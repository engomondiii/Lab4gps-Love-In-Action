{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidGeodesic from \"../Core/EllipsoidGeodesic.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport HeadingPitchRange from \"../Core/HeadingPitchRange.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraFlightPath from \"./CameraFlightPath.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * @typedef {object} DirectionUp\n *\n * An orientation given by a pair of unit vectors\n *\n * @property {Cartesian3} direction The unit \"direction\" vector\n * @property {Cartesian3} up The unit \"up\" vector\n **/\n/**\n * @typedef {object} HeadingPitchRollValues\n *\n * An orientation given by numeric heading, pitch, and roll\n *\n * @property {number} [heading=0.0] The heading in radians\n * @property {number} [pitch=-CesiumMath.PI_OVER_TWO] The pitch in radians\n * @property {number} [roll=0.0] The roll in radians\n **/\n\n/**\n * The camera is defined by a position, orientation, and view frustum.\n * <br /><br />\n * The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.\n * <br /><br />\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias Camera\n *\n * @constructor\n *\n * @param {Scene} scene The scene.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera.html|Cesium Sandcastle Camera Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera%20Tutorial.html|Cesium Sandcastle Camera Tutorial Example}\n * @demo {@link https://cesium.com/learn/cesiumjs-learn/cesiumjs-camera|Camera Tutorial}\n *\n * @example\n * // Create a camera looking down the negative z-axis, positioned at the origin,\n * // with a field of view of 60 degrees, and 1:1 aspect ratio.\n * const camera = new Cesium.Camera(scene);\n * camera.position = new Cesium.Cartesian3();\n * camera.direction = Cesium.Cartesian3.negate(Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());\n * camera.up = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Y);\n * camera.frustum.fov = Cesium.Math.PI_OVER_THREE;\n * camera.frustum.near = 1.0;\n * camera.frustum.far = 2.0;\n */\nfunction Camera(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n  this._scene = scene;\n  this._transform = Matrix4.clone(Matrix4.IDENTITY);\n  this._invTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._actualTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._actualInvTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._transformChanged = false;\n\n  /**\n   * The position of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.position = new Cartesian3();\n  this._position = new Cartesian3();\n  this._positionWC = new Cartesian3();\n  this._positionCartographic = new Cartographic();\n  this._oldPositionWC = undefined;\n\n  /**\n   * The position delta magnitude.\n   *\n   * @private\n   */\n  this.positionWCDeltaMagnitude = 0.0;\n\n  /**\n   * The position delta magnitude last frame.\n   *\n   * @private\n   */\n  this.positionWCDeltaMagnitudeLastFrame = 0.0;\n\n  /**\n   * How long in seconds since the camera has stopped moving\n   *\n   * @private\n   */\n  this.timeSinceMoved = 0.0;\n  this._lastMovedTimestamp = 0.0;\n\n  /**\n   * The view direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.direction = new Cartesian3();\n  this._direction = new Cartesian3();\n  this._directionWC = new Cartesian3();\n\n  /**\n   * The up direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.up = new Cartesian3();\n  this._up = new Cartesian3();\n  this._upWC = new Cartesian3();\n\n  /**\n   * The right direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.right = new Cartesian3();\n  this._right = new Cartesian3();\n  this._rightWC = new Cartesian3();\n\n  /**\n   * The region of space in view.\n   *\n   * @type {PerspectiveFrustum|PerspectiveOffCenterFrustum|OrthographicFrustum}\n   * @default PerspectiveFrustum()\n   *\n   * @see PerspectiveFrustum\n   * @see PerspectiveOffCenterFrustum\n   * @see OrthographicFrustum\n   */\n  this.frustum = new PerspectiveFrustum();\n  this.frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = CesiumMath.toRadians(60.0);\n\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the move methods.\n   * @type {number}\n   * @default 100000.0;\n   */\n  this.defaultMoveAmount = 100000.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the look methods.\n   * @type {number}\n   * @default Math.PI / 60.0\n   */\n  this.defaultLookAmount = Math.PI / 60.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the rotate methods.\n   * @type {number}\n   * @default Math.PI / 3600.0\n   */\n  this.defaultRotateAmount = Math.PI / 3600.0;\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the zoom methods.\n   * @type {number}\n   * @default 100000.0;\n   */\n  this.defaultZoomAmount = 100000.0;\n  /**\n   * If set, the camera will not be able to rotate past this axis in either direction.\n   * @type {Cartesian3 | undefined}\n   * @default undefined\n   */\n  this.constrainedAxis = undefined;\n  /**\n   * The factor multiplied by the the map size used to determine where to clamp the camera position\n   * when zooming out from the surface. The default is 1.5. Only valid for 2D and the map is rotatable.\n   * @type {number}\n   * @default 1.5\n   */\n  this.maximumZoomFactor = 1.5;\n  this._moveStart = new Event();\n  this._moveEnd = new Event();\n  this._changed = new Event();\n  this._changedPosition = undefined;\n  this._changedDirection = undefined;\n  this._changedFrustum = undefined;\n  this._changedHeading = undefined;\n  this._changedRoll = undefined;\n\n  /**\n   * The amount the camera has to change before the <code>changed</code> event is raised. The value is a percentage in the [0, 1] range.\n   * @type {number}\n   * @default 0.5\n   */\n  this.percentageChanged = 0.5;\n  this._viewMatrix = new Matrix4();\n  this._invViewMatrix = new Matrix4();\n  updateViewMatrix(this);\n  this._mode = SceneMode.SCENE3D;\n  this._modeChanged = true;\n  const projection = scene.mapProjection;\n  this._projection = projection;\n  this._maxCoord = projection.project(new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO));\n  this._max2Dfrustum = undefined;\n\n  // set default view\n  rectangleCameraPosition3D(this, Camera.DEFAULT_VIEW_RECTANGLE, this.position, true);\n  let mag = Cartesian3.magnitude(this.position);\n  mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n  Cartesian3.normalize(this.position, this.position);\n  Cartesian3.multiplyByScalar(this.position, mag, this.position);\n}\n\n/**\n * @private\n */\nCamera.TRANSFORM_2D = new Matrix4(0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n\n/**\n * @private\n */\nCamera.TRANSFORM_2D_INVERSE = Matrix4.inverseTransformation(Camera.TRANSFORM_2D, new Matrix4());\n\n/**\n * The default rectangle the camera will view on creation.\n * @type Rectangle\n */\nCamera.DEFAULT_VIEW_RECTANGLE = Rectangle.fromDegrees(-95.0, -20.0, -70.0, 90.0);\n\n/**\n * A scalar to multiply to the camera position and add it back after setting the camera to view the rectangle.\n * A value of zero means the camera will view the entire {@link Camera#DEFAULT_VIEW_RECTANGLE}, a value greater than zero\n * will move it further away from the extent, and a value less than zero will move it close to the extent.\n * @type {number}\n */\nCamera.DEFAULT_VIEW_FACTOR = 0.5;\n\n/**\n * The default heading/pitch/range that is used when the camera flies to a location that contains a bounding sphere.\n * @type HeadingPitchRange\n */\nCamera.DEFAULT_OFFSET = new HeadingPitchRange(0.0, -CesiumMath.PI_OVER_FOUR, 0.0);\nfunction updateViewMatrix(camera) {\n  Matrix4.computeView(camera._position, camera._direction, camera._up, camera._right, camera._viewMatrix);\n  Matrix4.multiply(camera._viewMatrix, camera._actualInvTransform, camera._viewMatrix);\n  Matrix4.inverseTransformation(camera._viewMatrix, camera._invViewMatrix);\n}\nfunction updateCameraDeltas(camera) {\n  if (!defined(camera._oldPositionWC)) {\n    camera._oldPositionWC = Cartesian3.clone(camera.positionWC, camera._oldPositionWC);\n  } else {\n    camera.positionWCDeltaMagnitudeLastFrame = camera.positionWCDeltaMagnitude;\n    const delta = Cartesian3.subtract(camera.positionWC, camera._oldPositionWC, camera._oldPositionWC);\n    camera.positionWCDeltaMagnitude = Cartesian3.magnitude(delta);\n    camera._oldPositionWC = Cartesian3.clone(camera.positionWC, camera._oldPositionWC);\n\n    // Update move timers\n    if (camera.positionWCDeltaMagnitude > 0.0) {\n      camera.timeSinceMoved = 0.0;\n      camera._lastMovedTimestamp = getTimestamp();\n    } else {\n      camera.timeSinceMoved = Math.max(getTimestamp() - camera._lastMovedTimestamp, 0.0) / 1000.0;\n    }\n  }\n}\n\n/**\n * Checks if there's a camera flight with preload for this camera.\n *\n * @returns {boolean} Whether or not this camera has a current flight with a valid preloadFlightCamera in scene.\n *\n * @private\n *\n */\nCamera.prototype.canPreloadFlight = function () {\n  return defined(this._currentFlight) && this._mode !== SceneMode.SCENE2D;\n};\nCamera.prototype._updateCameraChanged = function () {\n  const camera = this;\n  updateCameraDeltas(camera);\n  if (camera._changed.numberOfListeners === 0) {\n    return;\n  }\n  const percentageChanged = camera.percentageChanged;\n\n  // check heading\n  const currentHeading = camera.heading;\n  if (!defined(camera._changedHeading)) {\n    camera._changedHeading = currentHeading;\n  }\n  let headingDelta = Math.abs(camera._changedHeading - currentHeading) % CesiumMath.TWO_PI;\n  headingDelta = headingDelta > CesiumMath.PI ? CesiumMath.TWO_PI - headingDelta : headingDelta;\n\n  // Since delta is computed as the shortest distance between two angles\n  // the percentage is relative to the half circle.\n  const headingChangedPercentage = headingDelta / Math.PI;\n  if (headingChangedPercentage > percentageChanged) {\n    camera._changedHeading = currentHeading;\n  }\n\n  // check roll\n  const currentRoll = camera.roll;\n  if (!defined(camera._changedRoll)) {\n    camera._changedRoll = currentRoll;\n  }\n  let rollDelta = Math.abs(camera._changedRoll - currentRoll) % CesiumMath.TWO_PI;\n  rollDelta = rollDelta > CesiumMath.PI ? CesiumMath.TWO_PI - rollDelta : rollDelta;\n\n  // Since delta is computed as the shortest distance between two angles\n  // the percentage is relative to the half circle.\n  const rollChangedPercentage = rollDelta / Math.PI;\n  if (rollChangedPercentage > percentageChanged) {\n    camera._changedRoll = currentRoll;\n  }\n  if (rollChangedPercentage > percentageChanged || headingChangedPercentage > percentageChanged) {\n    camera._changed.raiseEvent(Math.max(rollChangedPercentage, headingChangedPercentage));\n  }\n  if (camera._mode === SceneMode.SCENE2D) {\n    if (!defined(camera._changedFrustum)) {\n      camera._changedPosition = Cartesian3.clone(camera.position, camera._changedPosition);\n      camera._changedFrustum = camera.frustum.clone();\n      return;\n    }\n    const position = camera.position;\n    const lastPosition = camera._changedPosition;\n    const frustum = camera.frustum;\n    const lastFrustum = camera._changedFrustum;\n    const x0 = position.x + frustum.left;\n    const x1 = position.x + frustum.right;\n    const x2 = lastPosition.x + lastFrustum.left;\n    const x3 = lastPosition.x + lastFrustum.right;\n    const y0 = position.y + frustum.bottom;\n    const y1 = position.y + frustum.top;\n    const y2 = lastPosition.y + lastFrustum.bottom;\n    const y3 = lastPosition.y + lastFrustum.top;\n    const leftX = Math.max(x0, x2);\n    const rightX = Math.min(x1, x3);\n    const bottomY = Math.max(y0, y2);\n    const topY = Math.min(y1, y3);\n    let areaPercentage;\n    if (leftX >= rightX || bottomY >= y1) {\n      areaPercentage = 1.0;\n    } else {\n      let areaRef = lastFrustum;\n      if (x0 < x2 && x1 > x3 && y0 < y2 && y1 > y3) {\n        areaRef = frustum;\n      }\n      areaPercentage = 1.0 - (rightX - leftX) * (topY - bottomY) / ((areaRef.right - areaRef.left) * (areaRef.top - areaRef.bottom));\n    }\n    if (areaPercentage > percentageChanged) {\n      camera._changed.raiseEvent(areaPercentage);\n      camera._changedPosition = Cartesian3.clone(camera.position, camera._changedPosition);\n      camera._changedFrustum = camera.frustum.clone(camera._changedFrustum);\n    }\n    return;\n  }\n  if (!defined(camera._changedDirection)) {\n    camera._changedPosition = Cartesian3.clone(camera.positionWC, camera._changedPosition);\n    camera._changedDirection = Cartesian3.clone(camera.directionWC, camera._changedDirection);\n    return;\n  }\n  const dirAngle = CesiumMath.acosClamped(Cartesian3.dot(camera.directionWC, camera._changedDirection));\n  let dirPercentage;\n  if (defined(camera.frustum.fovy)) {\n    dirPercentage = dirAngle / (camera.frustum.fovy * 0.5);\n  } else {\n    dirPercentage = dirAngle;\n  }\n  const distance = Cartesian3.distance(camera.positionWC, camera._changedPosition);\n  const heightPercentage = distance / camera.positionCartographic.height;\n  if (dirPercentage > percentageChanged || heightPercentage > percentageChanged) {\n    camera._changed.raiseEvent(Math.max(dirPercentage, heightPercentage));\n    camera._changedPosition = Cartesian3.clone(camera.positionWC, camera._changedPosition);\n    camera._changedDirection = Cartesian3.clone(camera.directionWC, camera._changedDirection);\n  }\n};\nfunction convertTransformForColumbusView(camera) {\n  Transforms.basisTo2D(camera._projection, camera._transform, camera._actualTransform);\n}\nconst scratchCartographic = new Cartographic();\nconst scratchCartesian3Projection = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4Origin = new Cartesian4();\nconst scratchCartesian4NewOrigin = new Cartesian4();\nconst scratchCartesian4NewXAxis = new Cartesian4();\nconst scratchCartesian4NewYAxis = new Cartesian4();\nconst scratchCartesian4NewZAxis = new Cartesian4();\nfunction convertTransformFor2D(camera) {\n  const projection = camera._projection;\n  const ellipsoid = projection.ellipsoid;\n  const origin = Matrix4.getColumn(camera._transform, 3, scratchCartesian4Origin);\n  const cartographic = ellipsoid.cartesianToCartographic(origin, scratchCartographic);\n  const projectedPosition = projection.project(cartographic, scratchCartesian3Projection);\n  const newOrigin = scratchCartesian4NewOrigin;\n  newOrigin.x = projectedPosition.z;\n  newOrigin.y = projectedPosition.x;\n  newOrigin.z = projectedPosition.y;\n  newOrigin.w = 1.0;\n  const newZAxis = Cartesian4.clone(Cartesian4.UNIT_X, scratchCartesian4NewZAxis);\n  const xAxis = Cartesian4.add(Matrix4.getColumn(camera._transform, 0, scratchCartesian3), origin, scratchCartesian3);\n  ellipsoid.cartesianToCartographic(xAxis, cartographic);\n  projection.project(cartographic, projectedPosition);\n  const newXAxis = scratchCartesian4NewXAxis;\n  newXAxis.x = projectedPosition.z;\n  newXAxis.y = projectedPosition.x;\n  newXAxis.z = projectedPosition.y;\n  newXAxis.w = 0.0;\n  Cartesian3.subtract(newXAxis, newOrigin, newXAxis);\n  newXAxis.x = 0.0;\n  const newYAxis = scratchCartesian4NewYAxis;\n  if (Cartesian3.magnitudeSquared(newXAxis) > CesiumMath.EPSILON10) {\n    Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  } else {\n    const yAxis = Cartesian4.add(Matrix4.getColumn(camera._transform, 1, scratchCartesian3), origin, scratchCartesian3);\n    ellipsoid.cartesianToCartographic(yAxis, cartographic);\n    projection.project(cartographic, projectedPosition);\n    newYAxis.x = projectedPosition.z;\n    newYAxis.y = projectedPosition.x;\n    newYAxis.z = projectedPosition.y;\n    newYAxis.w = 0.0;\n    Cartesian3.subtract(newYAxis, newOrigin, newYAxis);\n    newYAxis.x = 0.0;\n    if (Cartesian3.magnitudeSquared(newYAxis) < CesiumMath.EPSILON10) {\n      Cartesian4.clone(Cartesian4.UNIT_Y, newXAxis);\n      Cartesian4.clone(Cartesian4.UNIT_Z, newYAxis);\n    }\n  }\n  Cartesian3.cross(newYAxis, newZAxis, newXAxis);\n  Cartesian3.normalize(newXAxis, newXAxis);\n  Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  Cartesian3.normalize(newYAxis, newYAxis);\n  Matrix4.setColumn(camera._actualTransform, 0, newXAxis, camera._actualTransform);\n  Matrix4.setColumn(camera._actualTransform, 1, newYAxis, camera._actualTransform);\n  Matrix4.setColumn(camera._actualTransform, 2, newZAxis, camera._actualTransform);\n  Matrix4.setColumn(camera._actualTransform, 3, newOrigin, camera._actualTransform);\n}\nconst scratchCartesian = new Cartesian3();\nfunction updateMembers(camera) {\n  const mode = camera._mode;\n  let heightChanged = false;\n  let height = 0.0;\n  if (mode === SceneMode.SCENE2D) {\n    height = camera.frustum.right - camera.frustum.left;\n    heightChanged = height !== camera._positionCartographic.height;\n  }\n  let position = camera._position;\n  const positionChanged = !Cartesian3.equals(position, camera.position) || heightChanged;\n  if (positionChanged) {\n    position = Cartesian3.clone(camera.position, camera._position);\n  }\n  let direction = camera._direction;\n  const directionChanged = !Cartesian3.equals(direction, camera.direction);\n  if (directionChanged) {\n    Cartesian3.normalize(camera.direction, camera.direction);\n    direction = Cartesian3.clone(camera.direction, camera._direction);\n  }\n  let up = camera._up;\n  const upChanged = !Cartesian3.equals(up, camera.up);\n  if (upChanged) {\n    Cartesian3.normalize(camera.up, camera.up);\n    up = Cartesian3.clone(camera.up, camera._up);\n  }\n  let right = camera._right;\n  const rightChanged = !Cartesian3.equals(right, camera.right);\n  if (rightChanged) {\n    Cartesian3.normalize(camera.right, camera.right);\n    right = Cartesian3.clone(camera.right, camera._right);\n  }\n  const transformChanged = camera._transformChanged || camera._modeChanged;\n  camera._transformChanged = false;\n  if (transformChanged) {\n    Matrix4.inverseTransformation(camera._transform, camera._invTransform);\n    if (camera._mode === SceneMode.COLUMBUS_VIEW || camera._mode === SceneMode.SCENE2D) {\n      if (Matrix4.equals(Matrix4.IDENTITY, camera._transform)) {\n        Matrix4.clone(Camera.TRANSFORM_2D, camera._actualTransform);\n      } else if (camera._mode === SceneMode.COLUMBUS_VIEW) {\n        convertTransformForColumbusView(camera);\n      } else {\n        convertTransformFor2D(camera);\n      }\n    } else {\n      Matrix4.clone(camera._transform, camera._actualTransform);\n    }\n    Matrix4.inverseTransformation(camera._actualTransform, camera._actualInvTransform);\n    camera._modeChanged = false;\n  }\n  const transform = camera._actualTransform;\n  if (positionChanged || transformChanged) {\n    camera._positionWC = Matrix4.multiplyByPoint(transform, position, camera._positionWC);\n\n    // Compute the Cartographic position of the camera.\n    if (mode === SceneMode.SCENE3D || mode === SceneMode.MORPHING) {\n      camera._positionCartographic = camera._projection.ellipsoid.cartesianToCartographic(camera._positionWC, camera._positionCartographic);\n    } else {\n      // The camera position is expressed in the 2D coordinate system where the Y axis is to the East,\n      // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where\n      // X is to the East, Y is to the North, and Z is out of the local horizontal plane.\n      const positionENU = scratchCartesian;\n      positionENU.x = camera._positionWC.y;\n      positionENU.y = camera._positionWC.z;\n      positionENU.z = camera._positionWC.x;\n\n      // In 2D, the camera height is always 12.7 million meters.\n      // The apparent height is equal to half the frustum width.\n      if (mode === SceneMode.SCENE2D) {\n        positionENU.z = height;\n      }\n      camera._projection.unproject(positionENU, camera._positionCartographic);\n    }\n  }\n  if (directionChanged || upChanged || rightChanged) {\n    const det = Cartesian3.dot(direction, Cartesian3.cross(up, right, scratchCartesian));\n    if (Math.abs(1.0 - det) > CesiumMath.EPSILON2) {\n      //orthonormalize axes\n      const invUpMag = 1.0 / Cartesian3.magnitudeSquared(up);\n      const scalar = Cartesian3.dot(up, direction) * invUpMag;\n      const w0 = Cartesian3.multiplyByScalar(direction, scalar, scratchCartesian);\n      up = Cartesian3.normalize(Cartesian3.subtract(up, w0, camera._up), camera._up);\n      Cartesian3.clone(up, camera.up);\n      right = Cartesian3.cross(direction, up, camera._right);\n      Cartesian3.clone(right, camera.right);\n    }\n  }\n  if (directionChanged || transformChanged) {\n    camera._directionWC = Matrix4.multiplyByPointAsVector(transform, direction, camera._directionWC);\n    Cartesian3.normalize(camera._directionWC, camera._directionWC);\n  }\n  if (upChanged || transformChanged) {\n    camera._upWC = Matrix4.multiplyByPointAsVector(transform, up, camera._upWC);\n    Cartesian3.normalize(camera._upWC, camera._upWC);\n  }\n  if (rightChanged || transformChanged) {\n    camera._rightWC = Matrix4.multiplyByPointAsVector(transform, right, camera._rightWC);\n    Cartesian3.normalize(camera._rightWC, camera._rightWC);\n  }\n  if (positionChanged || directionChanged || upChanged || rightChanged || transformChanged) {\n    updateViewMatrix(camera);\n  }\n}\nfunction getHeading(direction, up) {\n  let heading;\n  if (!CesiumMath.equalsEpsilon(Math.abs(direction.z), 1.0, CesiumMath.EPSILON3)) {\n    heading = Math.atan2(direction.y, direction.x) - CesiumMath.PI_OVER_TWO;\n  } else {\n    heading = Math.atan2(up.y, up.x) - CesiumMath.PI_OVER_TWO;\n  }\n  return CesiumMath.TWO_PI - CesiumMath.zeroToTwoPi(heading);\n}\nfunction getPitch(direction) {\n  return CesiumMath.PI_OVER_TWO - CesiumMath.acosClamped(direction.z);\n}\nfunction getRoll(direction, up, right) {\n  let roll = 0.0;\n  if (!CesiumMath.equalsEpsilon(Math.abs(direction.z), 1.0, CesiumMath.EPSILON3)) {\n    roll = Math.atan2(-right.z, up.z);\n    roll = CesiumMath.zeroToTwoPi(roll + CesiumMath.TWO_PI);\n  }\n  return roll;\n}\nconst scratchHPRMatrix1 = new Matrix4();\nconst scratchHPRMatrix2 = new Matrix4();\nObject.defineProperties(Camera.prototype, {\n  /**\n   * Gets the camera's reference frame. The inverse of this transformation is appended to the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  transform: {\n    get: function () {\n      return this._transform;\n    }\n  },\n  /**\n   * Gets the inverse camera transform.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  inverseTransform: {\n    get: function () {\n      updateMembers(this);\n      return this._invTransform;\n    }\n  },\n  /**\n   * Gets the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#inverseViewMatrix\n   */\n  viewMatrix: {\n    get: function () {\n      updateMembers(this);\n      return this._viewMatrix;\n    }\n  },\n  /**\n   * Gets the inverse view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#viewMatrix\n   */\n  inverseViewMatrix: {\n    get: function () {\n      updateMembers(this);\n      return this._invViewMatrix;\n    }\n  },\n  /**\n   * Gets the {@link Cartographic} position of the camera, with longitude and latitude\n   * expressed in radians and height in meters.  In 2D and Columbus View, it is possible\n   * for the returned longitude and latitude to be outside the range of valid longitudes\n   * and latitudes when the camera is outside the map.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartographic}\n   * @readonly\n   */\n  positionCartographic: {\n    get: function () {\n      updateMembers(this);\n      return this._positionCartographic;\n    }\n  },\n  /**\n   * Gets the position of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  positionWC: {\n    get: function () {\n      updateMembers(this);\n      return this._positionWC;\n    }\n  },\n  /**\n   * Gets the view direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  directionWC: {\n    get: function () {\n      updateMembers(this);\n      return this._directionWC;\n    }\n  },\n  /**\n   * Gets the up direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  upWC: {\n    get: function () {\n      updateMembers(this);\n      return this._upWC;\n    }\n  },\n  /**\n   * Gets the right direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  rightWC: {\n    get: function () {\n      updateMembers(this);\n      return this._rightWC;\n    }\n  },\n  /**\n   * Gets the camera heading in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  heading: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        const ellipsoid = this._projection.ellipsoid;\n        const oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        const transform = Transforms.eastNorthUpToFixedFrame(this.positionWC, ellipsoid, scratchHPRMatrix2);\n        this._setTransform(transform);\n        const heading = getHeading(this.direction, this.up);\n        this._setTransform(oldTransform);\n        return heading;\n      }\n      return undefined;\n    }\n  },\n  /**\n   * Gets the camera pitch in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  pitch: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        const ellipsoid = this._projection.ellipsoid;\n        const oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        const transform = Transforms.eastNorthUpToFixedFrame(this.positionWC, ellipsoid, scratchHPRMatrix2);\n        this._setTransform(transform);\n        const pitch = getPitch(this.direction);\n        this._setTransform(oldTransform);\n        return pitch;\n      }\n      return undefined;\n    }\n  },\n  /**\n   * Gets the camera roll in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  roll: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        const ellipsoid = this._projection.ellipsoid;\n        const oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        const transform = Transforms.eastNorthUpToFixedFrame(this.positionWC, ellipsoid, scratchHPRMatrix2);\n        this._setTransform(transform);\n        const roll = getRoll(this.direction, this.up, this.right);\n        this._setTransform(oldTransform);\n        return roll;\n      }\n      return undefined;\n    }\n  },\n  /**\n   * Gets the event that will be raised at when the camera starts to move.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveStart: {\n    get: function () {\n      return this._moveStart;\n    }\n  },\n  /**\n   * Gets the event that will be raised when the camera has stopped moving.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveEnd: {\n    get: function () {\n      return this._moveEnd;\n    }\n  },\n  /**\n   * Gets the event that will be raised when the camera has changed by <code>percentageChanged</code>.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  changed: {\n    get: function () {\n      return this._changed;\n    }\n  }\n});\n\n/**\n * @private\n */\nCamera.prototype.update = function (mode) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(mode)) {\n    throw new DeveloperError(\"mode is required.\");\n  }\n  if (mode === SceneMode.SCENE2D && !(this.frustum instanceof OrthographicOffCenterFrustum)) {\n    throw new DeveloperError(\"An OrthographicOffCenterFrustum is required in 2D.\");\n  }\n  if ((mode === SceneMode.SCENE3D || mode === SceneMode.COLUMBUS_VIEW) && !(this.frustum instanceof PerspectiveFrustum) && !(this.frustum instanceof OrthographicFrustum)) {\n    throw new DeveloperError(\"A PerspectiveFrustum or OrthographicFrustum is required in 3D and Columbus view\");\n  }\n  //>>includeEnd('debug');\n\n  let updateFrustum = false;\n  if (mode !== this._mode) {\n    this._mode = mode;\n    this._modeChanged = mode !== SceneMode.MORPHING;\n    updateFrustum = this._mode === SceneMode.SCENE2D;\n  }\n  if (updateFrustum) {\n    const frustum = this._max2Dfrustum = this.frustum.clone();\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!(frustum instanceof OrthographicOffCenterFrustum)) {\n      throw new DeveloperError(\"The camera frustum is expected to be orthographic for 2D camera control.\");\n    }\n    //>>includeEnd('debug');\n\n    const maxZoomOut = 2.0;\n    const ratio = frustum.top / frustum.right;\n    frustum.right = this._maxCoord.x * maxZoomOut;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n  }\n  if (this._mode === SceneMode.SCENE2D) {\n    clampMove2D(this, this.position);\n  }\n};\nconst setTransformPosition = new Cartesian3();\nconst setTransformUp = new Cartesian3();\nconst setTransformDirection = new Cartesian3();\nCamera.prototype._setTransform = function (transform) {\n  const position = Cartesian3.clone(this.positionWC, setTransformPosition);\n  const up = Cartesian3.clone(this.upWC, setTransformUp);\n  const direction = Cartesian3.clone(this.directionWC, setTransformDirection);\n  Matrix4.clone(transform, this._transform);\n  this._transformChanged = true;\n  updateMembers(this);\n  const inverse = this._actualInvTransform;\n  Matrix4.multiplyByPoint(inverse, position, this.position);\n  Matrix4.multiplyByPointAsVector(inverse, direction, this.direction);\n  Matrix4.multiplyByPointAsVector(inverse, up, this.up);\n  Cartesian3.cross(this.direction, this.up, this.right);\n  updateMembers(this);\n};\nconst scratchAdjustOrthographicFrustumMousePosition = new Cartesian2();\nconst scratchPickRay = new Ray();\nconst scratchRayIntersection = new Cartesian3();\nconst scratchDepthIntersection = new Cartesian3();\nfunction calculateOrthographicFrustumWidth(camera) {\n  // Camera is fixed to an object, so keep frustum width constant.\n  if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {\n    return Cartesian3.magnitude(camera.position);\n  }\n  const scene = camera._scene;\n  const globe = scene.globe;\n  const mousePosition = scratchAdjustOrthographicFrustumMousePosition;\n  mousePosition.x = scene.drawingBufferWidth / 2.0;\n  mousePosition.y = scene.drawingBufferHeight / 2.0;\n  let rayIntersection;\n  if (defined(globe)) {\n    const ray = camera.getPickRay(mousePosition, scratchPickRay);\n    rayIntersection = globe.pickWorldCoordinates(ray, scene, true, scratchRayIntersection);\n  }\n  let depthIntersection;\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(mousePosition, scratchDepthIntersection);\n  }\n  let distance;\n  if (defined(rayIntersection) || defined(depthIntersection)) {\n    const depthDistance = defined(depthIntersection) ? Cartesian3.distance(depthIntersection, camera.positionWC) : Number.POSITIVE_INFINITY;\n    const rayDistance = defined(rayIntersection) ? Cartesian3.distance(rayIntersection, camera.positionWC) : Number.POSITIVE_INFINITY;\n    distance = Math.min(depthDistance, rayDistance);\n  } else {\n    distance = Math.max(camera.positionCartographic.height, 0.0);\n  }\n  return distance;\n}\nCamera.prototype._adjustOrthographicFrustum = function (zooming) {\n  if (!(this.frustum instanceof OrthographicFrustum)) {\n    return;\n  }\n  if (!zooming && this._positionCartographic.height < 150000.0) {\n    return;\n  }\n  this.frustum.width = calculateOrthographicFrustumWidth(this);\n};\nconst scratchSetViewCartesian = new Cartesian3();\nconst scratchSetViewTransform1 = new Matrix4();\nconst scratchSetViewTransform2 = new Matrix4();\nconst scratchSetViewQuaternion = new Quaternion();\nconst scratchSetViewMatrix3 = new Matrix3();\nconst scratchSetViewCartographic = new Cartographic();\nfunction setView3D(camera, position, hpr) {\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)) {\n    throw new DeveloperError(\"position has a NaN component\");\n  }\n  //>>includeEnd('debug');\n  const currentTransform = Matrix4.clone(camera.transform, scratchSetViewTransform1);\n  const localTransform = Transforms.eastNorthUpToFixedFrame(position, camera._projection.ellipsoid, scratchSetViewTransform2);\n  camera._setTransform(localTransform);\n  Cartesian3.clone(Cartesian3.ZERO, camera.position);\n  hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n  const rotQuat = Quaternion.fromHeadingPitchRoll(hpr, scratchSetViewQuaternion);\n  const rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n  Matrix3.getColumn(rotMat, 0, camera.direction);\n  Matrix3.getColumn(rotMat, 2, camera.up);\n  Cartesian3.cross(camera.direction, camera.up, camera.right);\n  camera._setTransform(currentTransform);\n  camera._adjustOrthographicFrustum(true);\n}\nfunction setViewCV(camera, position, hpr, convert) {\n  const currentTransform = Matrix4.clone(camera.transform, scratchSetViewTransform1);\n  camera._setTransform(Matrix4.IDENTITY);\n  if (!Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      const projection = camera._projection;\n      const cartographic = projection.ellipsoid.cartesianToCartographic(position, scratchSetViewCartographic);\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n    Cartesian3.clone(position, camera.position);\n  }\n  hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n  const rotQuat = Quaternion.fromHeadingPitchRoll(hpr, scratchSetViewQuaternion);\n  const rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n  Matrix3.getColumn(rotMat, 0, camera.direction);\n  Matrix3.getColumn(rotMat, 2, camera.up);\n  Cartesian3.cross(camera.direction, camera.up, camera.right);\n  camera._setTransform(currentTransform);\n  camera._adjustOrthographicFrustum(true);\n}\nfunction setView2D(camera, position, hpr, convert) {\n  const currentTransform = Matrix4.clone(camera.transform, scratchSetViewTransform1);\n  camera._setTransform(Matrix4.IDENTITY);\n  if (!Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      const projection = camera._projection;\n      const cartographic = projection.ellipsoid.cartesianToCartographic(position, scratchSetViewCartographic);\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n    Cartesian2.clone(position, camera.position);\n    const newLeft = -position.z * 0.5;\n    const newRight = -newLeft;\n    const frustum = camera.frustum;\n    if (newRight > newLeft) {\n      const ratio = frustum.top / frustum.right;\n      frustum.right = newRight;\n      frustum.left = newLeft;\n      frustum.top = frustum.right * ratio;\n      frustum.bottom = -frustum.top;\n    }\n  }\n  if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n    hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n    hpr.pitch = -CesiumMath.PI_OVER_TWO;\n    hpr.roll = 0.0;\n    const rotQuat = Quaternion.fromHeadingPitchRoll(hpr, scratchSetViewQuaternion);\n    const rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n    Matrix3.getColumn(rotMat, 2, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n  }\n  camera._setTransform(currentTransform);\n}\nconst scratchToHPRDirection = new Cartesian3();\nconst scratchToHPRUp = new Cartesian3();\nconst scratchToHPRRight = new Cartesian3();\nfunction directionUpToHeadingPitchRoll(camera, position, orientation, result) {\n  const direction = Cartesian3.clone(orientation.direction, scratchToHPRDirection);\n  const up = Cartesian3.clone(orientation.up, scratchToHPRUp);\n  if (camera._scene.mode === SceneMode.SCENE3D) {\n    const ellipsoid = camera._projection.ellipsoid;\n    const transform = Transforms.eastNorthUpToFixedFrame(position, ellipsoid, scratchHPRMatrix1);\n    const invTransform = Matrix4.inverseTransformation(transform, scratchHPRMatrix2);\n    Matrix4.multiplyByPointAsVector(invTransform, direction, direction);\n    Matrix4.multiplyByPointAsVector(invTransform, up, up);\n  }\n  const right = Cartesian3.cross(direction, up, scratchToHPRRight);\n  result.heading = getHeading(direction, up);\n  result.pitch = getPitch(direction);\n  result.roll = getRoll(direction, up, right);\n  return result;\n}\nconst scratchSetViewOptions = {\n  destination: undefined,\n  orientation: {\n    direction: undefined,\n    up: undefined,\n    heading: undefined,\n    pitch: undefined,\n    roll: undefined\n  },\n  convert: undefined,\n  endTransform: undefined\n};\nconst scratchHpr = new HeadingPitchRoll();\n/**\n * Sets the camera position, orientation and transform.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} [options.destination] The final position of the camera in world coordinates or a rectangle that would be visible from a top-down view.\n * @param {HeadingPitchRollValues|DirectionUp} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view. Orientation is not used in 2D when in infinite scrolling mode.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame of the camera.\n * @param {boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n *\n * @example\n * // 1. Set position with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2 Set view with heading, pitch and roll\n * viewer.camera.setView({\n *     destination : cartesianPosition,\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n * // 3. Change heading, pitch and roll with the camera position remaining the same.\n * viewer.camera.setView({\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n *\n * // 4. View rectangle with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 5. Set position with an orientation using unit vectors.\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n */\nCamera.prototype.setView = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  let orientation = defaultValue(options.orientation, defaultValue.EMPTY_OBJECT);\n  const mode = this._mode;\n  if (mode === SceneMode.MORPHING) {\n    return;\n  }\n  if (defined(options.endTransform)) {\n    this._setTransform(options.endTransform);\n  }\n  let convert = defaultValue(options.convert, true);\n  let destination = defaultValue(options.destination, Cartesian3.clone(this.positionWC, scratchSetViewCartesian));\n  if (defined(destination) && defined(destination.west)) {\n    destination = this.getRectangleCameraCoordinates(destination, scratchSetViewCartesian);\n    //>>includeStart('debug', pragmas.debug);\n    // destination.z may be null in 2D, but .x and .y should be numeric\n    if (isNaN(destination.x) || isNaN(destination.y)) {\n      throw new DeveloperError(`destination has a NaN component`);\n    }\n    //>>includeEnd('debug');\n    convert = false;\n  }\n  if (defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(this, destination, orientation, scratchSetViewOptions.orientation);\n  }\n  scratchHpr.heading = defaultValue(orientation.heading, 0.0);\n  scratchHpr.pitch = defaultValue(orientation.pitch, -CesiumMath.PI_OVER_TWO);\n  scratchHpr.roll = defaultValue(orientation.roll, 0.0);\n  if (mode === SceneMode.SCENE3D) {\n    setView3D(this, destination, scratchHpr);\n  } else if (mode === SceneMode.SCENE2D) {\n    setView2D(this, destination, scratchHpr, convert);\n  } else {\n    setViewCV(this, destination, scratchHpr, convert);\n  }\n};\nconst pitchScratch = new Cartesian3();\n/**\n * Fly the camera to the home view.  Use {@link Camera#.DEFAULT_VIEW_RECTANGLE} to set\n * the default view for the 3D scene.  The home view for 2D and columbus view shows the\n * entire map.\n *\n * @param {number} [duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight. See {@link Camera#flyTo}\n */\nCamera.prototype.flyHome = function (duration) {\n  const mode = this._mode;\n  if (mode === SceneMode.MORPHING) {\n    this._scene.completeMorph();\n  }\n  if (mode === SceneMode.SCENE2D) {\n    this.flyTo({\n      destination: Camera.DEFAULT_VIEW_RECTANGLE,\n      duration: duration,\n      endTransform: Matrix4.IDENTITY\n    });\n  } else if (mode === SceneMode.SCENE3D) {\n    const destination = this.getRectangleCameraCoordinates(Camera.DEFAULT_VIEW_RECTANGLE);\n    let mag = Cartesian3.magnitude(destination);\n    mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n    Cartesian3.normalize(destination, destination);\n    Cartesian3.multiplyByScalar(destination, mag, destination);\n    this.flyTo({\n      destination: destination,\n      duration: duration,\n      endTransform: Matrix4.IDENTITY\n    });\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    const maxRadii = this._projection.ellipsoid.maximumRadius;\n    let position = new Cartesian3(0.0, -1.0, 1.0);\n    position = Cartesian3.multiplyByScalar(Cartesian3.normalize(position, position), 5.0 * maxRadii, position);\n    this.flyTo({\n      destination: position,\n      duration: duration,\n      orientation: {\n        heading: 0.0,\n        pitch: -Math.acos(Cartesian3.normalize(position, pitchScratch).z),\n        roll: 0.0\n      },\n      endTransform: Matrix4.IDENTITY,\n      convert: false\n    });\n  }\n};\n\n/**\n * Transform a vector or point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\nCamera.prototype.worldToCameraCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByVector(this._actualInvTransform, cartesian, result);\n};\n\n/**\n * Transform a point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\nCamera.prototype.worldToCameraCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPoint(this._actualInvTransform, cartesian, result);\n};\n\n/**\n * Transform a vector from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\nCamera.prototype.worldToCameraCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPointAsVector(this._actualInvTransform, cartesian, result);\n};\n\n/**\n * Transform a vector or point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\nCamera.prototype.cameraToWorldCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByVector(this._actualTransform, cartesian, result);\n};\n\n/**\n * Transform a point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\nCamera.prototype.cameraToWorldCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPoint(this._actualTransform, cartesian, result);\n};\n\n/**\n * Transform a vector from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\nCamera.prototype.cameraToWorldCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPointAsVector(this._actualTransform, cartesian, result);\n};\nfunction clampMove2D(camera, position) {\n  const rotatable2D = camera._scene.mapMode2D === MapMode2D.ROTATE;\n  const maxProjectedX = camera._maxCoord.x;\n  const maxProjectedY = camera._maxCoord.y;\n  let minX;\n  let maxX;\n  if (rotatable2D) {\n    maxX = maxProjectedX;\n    minX = -maxX;\n  } else {\n    maxX = position.x - maxProjectedX * 2.0;\n    minX = position.x + maxProjectedX * 2.0;\n  }\n  if (position.x > maxProjectedX) {\n    position.x = maxX;\n  }\n  if (position.x < -maxProjectedX) {\n    position.x = minX;\n  }\n  if (position.y > maxProjectedY) {\n    position.y = maxProjectedY;\n  }\n  if (position.y < -maxProjectedY) {\n    position.y = -maxProjectedY;\n  }\n}\nconst moveScratch = new Cartesian3();\n/**\n * Translates the camera's position by <code>amount</code> along <code>direction</code>.\n *\n * @param {Cartesian3} direction The direction to move.\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n * @see Camera#moveForward\n * @see Camera#moveLeft\n * @see Camera#moveRight\n * @see Camera#moveUp\n * @see Camera#moveDown\n */\nCamera.prototype.move = function (direction, amount) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const cameraPosition = this.position;\n  Cartesian3.multiplyByScalar(direction, amount, moveScratch);\n  Cartesian3.add(cameraPosition, moveScratch, cameraPosition);\n  if (this._mode === SceneMode.SCENE2D) {\n    clampMove2D(this, cameraPosition);\n  }\n  this._adjustOrthographicFrustum(true);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's view vector.\n * When in 2D mode, this will zoom in the camera instead of translating the camera's position.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n */\nCamera.prototype.moveForward = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  if (this._mode === SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, amount);\n  }\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's view vector.\n * When in 2D mode, this will zoom out the camera instead of translating the camera's position.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveForward\n */\nCamera.prototype.moveBackward = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  if (this._mode === SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, -amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, -amount);\n  }\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's up vector.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveDown\n */\nCamera.prototype.moveUp = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.up, amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's up vector.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveUp\n */\nCamera.prototype.moveDown = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.up, -amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's right vector.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveLeft\n */\nCamera.prototype.moveRight = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.right, amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's right vector.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveRight\n */\nCamera.prototype.moveLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.right, -amount);\n};\n\n/**\n * Rotates the camera around its up vector by amount, in radians, in the opposite direction\n * of its right vector if not in 2D mode.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookRight\n */\nCamera.prototype.lookLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.up, -amount);\n  }\n};\n\n/**\n * Rotates the camera around its up vector by amount, in radians, in the direction\n * of its right vector if not in 2D mode.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookLeft\n */\nCamera.prototype.lookRight = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.up, amount);\n  }\n};\n\n/**\n * Rotates the camera around its right vector by amount, in radians, in the direction\n * of its up vector if not in 2D mode.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookDown\n */\nCamera.prototype.lookUp = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.right, -amount);\n  }\n};\n\n/**\n * Rotates the camera around its right vector by amount, in radians, in the opposite direction\n * of its up vector if not in 2D mode.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n */\nCamera.prototype.lookDown = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.right, amount);\n  }\n};\nconst lookScratchQuaternion = new Quaternion();\nconst lookScratchMatrix = new Matrix3();\n/**\n * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>\n *\n * @param {Cartesian3} axis The axis to rotate around.\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n * @see Camera#lookDown\n * @see Camera#lookLeft\n * @see Camera#lookRight\n */\nCamera.prototype.look = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(axis)) {\n    throw new DeveloperError(\"axis is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const turnAngle = defaultValue(angle, this.defaultLookAmount);\n  const quaternion = Quaternion.fromAxisAngle(axis, -turnAngle, lookScratchQuaternion);\n  const rotation = Matrix3.fromQuaternion(quaternion, lookScratchMatrix);\n  const direction = this.direction;\n  const up = this.up;\n  const right = this.right;\n  Matrix3.multiplyByVector(rotation, direction, direction);\n  Matrix3.multiplyByVector(rotation, up, up);\n  Matrix3.multiplyByVector(rotation, right, right);\n};\n\n/**\n * Rotate the camera counter-clockwise around its direction vector by amount, in radians.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistRight\n */\nCamera.prototype.twistLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n  this.look(this.direction, amount);\n};\n\n/**\n * Rotate the camera clockwise around its direction vector by amount, in radians.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistLeft\n */\nCamera.prototype.twistRight = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n  this.look(this.direction, -amount);\n};\nconst rotateScratchQuaternion = new Quaternion();\nconst rotateScratchMatrix = new Matrix3();\n/**\n * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance\n * of the camera's position to the center of the camera's reference frame remains the same.\n *\n * @param {Cartesian3} axis The axis to rotate around given in world coordinates.\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotateDown\n * @see Camera#rotateLeft\n * @see Camera#rotateRight\n */\nCamera.prototype.rotate = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(axis)) {\n    throw new DeveloperError(\"axis is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const turnAngle = defaultValue(angle, this.defaultRotateAmount);\n  const quaternion = Quaternion.fromAxisAngle(axis, -turnAngle, rotateScratchQuaternion);\n  const rotation = Matrix3.fromQuaternion(quaternion, rotateScratchMatrix);\n  Matrix3.multiplyByVector(rotation, this.position, this.position);\n  Matrix3.multiplyByVector(rotation, this.direction, this.direction);\n  Matrix3.multiplyByVector(rotation, this.up, this.up);\n  Cartesian3.cross(this.direction, this.up, this.right);\n  Cartesian3.cross(this.right, this.direction, this.up);\n  this._adjustOrthographicFrustum(false);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle downwards.\n *\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotate\n */\nCamera.prototype.rotateDown = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateVertical(this, angle);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle upwards.\n *\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateDown\n * @see Camera#rotate\n */\nCamera.prototype.rotateUp = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateVertical(this, -angle);\n};\nconst rotateVertScratchP = new Cartesian3();\nconst rotateVertScratchA = new Cartesian3();\nconst rotateVertScratchTan = new Cartesian3();\nconst rotateVertScratchNegate = new Cartesian3();\nfunction rotateVertical(camera, angle) {\n  const position = camera.position;\n  if (defined(camera.constrainedAxis) && !Cartesian3.equalsEpsilon(camera.position, Cartesian3.ZERO, CesiumMath.EPSILON2)) {\n    const p = Cartesian3.normalize(position, rotateVertScratchP);\n    const northParallel = Cartesian3.equalsEpsilon(p, camera.constrainedAxis, CesiumMath.EPSILON2);\n    const southParallel = Cartesian3.equalsEpsilon(p, Cartesian3.negate(camera.constrainedAxis, rotateVertScratchNegate), CesiumMath.EPSILON2);\n    if (!northParallel && !southParallel) {\n      const constrainedAxis = Cartesian3.normalize(camera.constrainedAxis, rotateVertScratchA);\n      let dot = Cartesian3.dot(p, constrainedAxis);\n      let angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n      dot = Cartesian3.dot(p, Cartesian3.negate(constrainedAxis, rotateVertScratchNegate));\n      angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n      const tangent = Cartesian3.cross(constrainedAxis, p, rotateVertScratchTan);\n      camera.rotate(tangent, angle);\n    } else if (northParallel && angle < 0 || southParallel && angle > 0) {\n      camera.rotate(camera.right, angle);\n    }\n  } else {\n    camera.rotate(camera.right, angle);\n  }\n}\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the right.\n *\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateLeft\n * @see Camera#rotate\n */\nCamera.prototype.rotateRight = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateHorizontal(this, -angle);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the left.\n *\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateRight\n * @see Camera#rotate\n */\nCamera.prototype.rotateLeft = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateHorizontal(this, angle);\n};\nfunction rotateHorizontal(camera, angle) {\n  if (defined(camera.constrainedAxis)) {\n    camera.rotate(camera.constrainedAxis, angle);\n  } else {\n    camera.rotate(camera.up, angle);\n  }\n}\nfunction zoom2D(camera, amount) {\n  const frustum = camera.frustum;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!(frustum instanceof OrthographicOffCenterFrustum) || !defined(frustum.left) || !defined(frustum.right) || !defined(frustum.bottom) || !defined(frustum.top)) {\n    throw new DeveloperError(\"The camera frustum is expected to be orthographic for 2D camera control.\");\n  }\n  //>>includeEnd('debug');\n\n  let ratio;\n  amount = amount * 0.5;\n  if (Math.abs(frustum.top) + Math.abs(frustum.bottom) > Math.abs(frustum.left) + Math.abs(frustum.right)) {\n    let newTop = frustum.top - amount;\n    let newBottom = frustum.bottom + amount;\n    let maxBottom = camera._maxCoord.y;\n    if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n      maxBottom *= camera.maximumZoomFactor;\n    }\n    if (newBottom > maxBottom) {\n      newBottom = maxBottom;\n      newTop = -maxBottom;\n    }\n    if (newTop <= newBottom) {\n      newTop = 1.0;\n      newBottom = -1.0;\n    }\n    ratio = frustum.right / frustum.top;\n    frustum.top = newTop;\n    frustum.bottom = newBottom;\n    frustum.right = frustum.top * ratio;\n    frustum.left = -frustum.right;\n  } else {\n    let newRight = frustum.right - amount;\n    let newLeft = frustum.left + amount;\n    let maxRight = camera._maxCoord.x;\n    if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n      maxRight *= camera.maximumZoomFactor;\n    }\n    if (newRight > maxRight) {\n      newRight = maxRight;\n      newLeft = -maxRight;\n    }\n    if (newRight <= newLeft) {\n      newRight = 1.0;\n      newLeft = -1.0;\n    }\n    ratio = frustum.top / frustum.right;\n    frustum.right = newRight;\n    frustum.left = newLeft;\n    frustum.top = frustum.right * ratio;\n    frustum.bottom = -frustum.top;\n  }\n}\nfunction zoom3D(camera, amount) {\n  camera.move(camera.direction, amount);\n}\n\n/**\n * Zooms <code>amount</code> along the camera's view vector.\n *\n * @param {number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomOut\n */\nCamera.prototype.zoomIn = function (amount) {\n  amount = defaultValue(amount, this.defaultZoomAmount);\n  if (this._mode === SceneMode.SCENE2D) {\n    zoom2D(this, amount);\n  } else {\n    zoom3D(this, amount);\n  }\n};\n\n/**\n * Zooms <code>amount</code> along the opposite direction of\n * the camera's view vector.\n *\n * @param {number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomIn\n */\nCamera.prototype.zoomOut = function (amount) {\n  amount = defaultValue(amount, this.defaultZoomAmount);\n  if (this._mode === SceneMode.SCENE2D) {\n    zoom2D(this, -amount);\n  } else {\n    zoom3D(this, -amount);\n  }\n};\n\n/**\n * Gets the magnitude of the camera position. In 3D, this is the vector magnitude. In 2D and\n * Columbus view, this is the distance to the map.\n *\n * @returns {number} The magnitude of the position.\n */\nCamera.prototype.getMagnitude = function () {\n  if (this._mode === SceneMode.SCENE3D) {\n    return Cartesian3.magnitude(this.position);\n  } else if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    return Math.abs(this.position.z);\n  } else if (this._mode === SceneMode.SCENE2D) {\n    return Math.max(this.frustum.right - this.frustum.left, this.frustum.top - this.frustum.bottom);\n  }\n};\nconst scratchLookAtMatrix4 = new Matrix4();\n\n/**\n * Sets the camera position and orientation using a target and offset. The target must be given in\n * world coordinates. The offset can be either a cartesian or heading/pitch/range in the local east-north-up reference frame centered at the target.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Cartesian3} target The target position in world coordinates.\n * @param {Cartesian3|HeadingPitchRange} offset The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAt is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * const center = Cesium.Cartesian3.fromDegrees(-98.0, 40.0);\n * viewer.camera.lookAt(center, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * const center = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * const heading = Cesium.Math.toRadians(50.0);\n * const pitch = Cesium.Math.toRadians(-20.0);\n * const range = 5000.0;\n * viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\nCamera.prototype.lookAt = function (target, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(target)) {\n    throw new DeveloperError(\"target is required\");\n  }\n  if (!defined(offset)) {\n    throw new DeveloperError(\"offset is required\");\n  }\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\"lookAt is not supported while morphing.\");\n  }\n  //>>includeEnd('debug');\n\n  const scene = this._scene;\n  const ellipsoid = defaultValue(scene.ellipsoid, Ellipsoid.default);\n  const transform = Transforms.eastNorthUpToFixedFrame(target, ellipsoid, scratchLookAtMatrix4);\n  this.lookAtTransform(transform, offset);\n};\nconst scratchLookAtHeadingPitchRangeOffset = new Cartesian3();\nconst scratchLookAtHeadingPitchRangeQuaternion1 = new Quaternion();\nconst scratchLookAtHeadingPitchRangeQuaternion2 = new Quaternion();\nconst scratchHeadingPitchRangeMatrix3 = new Matrix3();\nfunction offsetFromHeadingPitchRange(heading, pitch, range) {\n  pitch = CesiumMath.clamp(pitch, -CesiumMath.PI_OVER_TWO, CesiumMath.PI_OVER_TWO);\n  heading = CesiumMath.zeroToTwoPi(heading) - CesiumMath.PI_OVER_TWO;\n  const pitchQuat = Quaternion.fromAxisAngle(Cartesian3.UNIT_Y, -pitch, scratchLookAtHeadingPitchRangeQuaternion1);\n  const headingQuat = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, -heading, scratchLookAtHeadingPitchRangeQuaternion2);\n  const rotQuat = Quaternion.multiply(headingQuat, pitchQuat, headingQuat);\n  const rotMatrix = Matrix3.fromQuaternion(rotQuat, scratchHeadingPitchRangeMatrix3);\n  const offset = Cartesian3.clone(Cartesian3.UNIT_X, scratchLookAtHeadingPitchRangeOffset);\n  Matrix3.multiplyByVector(rotMatrix, offset, offset);\n  Cartesian3.negate(offset, offset);\n  Cartesian3.multiplyByScalar(offset, range, offset);\n  return offset;\n}\n\n/**\n * Sets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the center of the reference frame. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Matrix4} transform The transformation matrix defining the reference frame.\n * @param {Cartesian3|HeadingPitchRange} [offset] The offset from the target in a reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAtTransform is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-98.0, 40.0));\n * viewer.camera.lookAtTransform(transform, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-72.0, 40.0));\n * const heading = Cesium.Math.toRadians(50.0);\n * const pitch = Cesium.Math.toRadians(-20.0);\n * const range = 5000.0;\n * viewer.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\nCamera.prototype.lookAtTransform = function (transform, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(transform)) {\n    throw new DeveloperError(\"transform is required\");\n  }\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\"lookAtTransform is not supported while morphing.\");\n  }\n  //>>includeEnd('debug');\n\n  this._setTransform(transform);\n  if (!defined(offset)) {\n    return;\n  }\n  let cartesianOffset;\n  if (defined(offset.heading)) {\n    cartesianOffset = offsetFromHeadingPitchRange(offset.heading, offset.pitch, offset.range);\n  } else {\n    cartesianOffset = offset;\n  }\n  if (this._mode === SceneMode.SCENE2D) {\n    Cartesian2.clone(Cartesian2.ZERO, this.position);\n    Cartesian3.negate(cartesianOffset, this.up);\n    this.up.z = 0.0;\n    if (Cartesian3.magnitudeSquared(this.up) < CesiumMath.EPSILON10) {\n      Cartesian3.clone(Cartesian3.UNIT_Y, this.up);\n    }\n    Cartesian3.normalize(this.up, this.up);\n    this._setTransform(Matrix4.IDENTITY);\n    Cartesian3.negate(Cartesian3.UNIT_Z, this.direction);\n    Cartesian3.cross(this.direction, this.up, this.right);\n    Cartesian3.normalize(this.right, this.right);\n    const frustum = this.frustum;\n    const ratio = frustum.top / frustum.right;\n    frustum.right = Cartesian3.magnitude(cartesianOffset) * 0.5;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n    this._setTransform(transform);\n    return;\n  }\n  Cartesian3.clone(cartesianOffset, this.position);\n  Cartesian3.negate(this.position, this.direction);\n  Cartesian3.normalize(this.direction, this.direction);\n  Cartesian3.cross(this.direction, Cartesian3.UNIT_Z, this.right);\n  if (Cartesian3.magnitudeSquared(this.right) < CesiumMath.EPSILON10) {\n    Cartesian3.clone(Cartesian3.UNIT_X, this.right);\n  }\n  Cartesian3.normalize(this.right, this.right);\n  Cartesian3.cross(this.right, this.direction, this.up);\n  Cartesian3.normalize(this.up, this.up);\n  this._adjustOrthographicFrustum(true);\n};\nconst viewRectangle3DCartographic1 = new Cartographic();\nconst viewRectangle3DCartographic2 = new Cartographic();\nconst viewRectangle3DNorthEast = new Cartesian3();\nconst viewRectangle3DSouthWest = new Cartesian3();\nconst viewRectangle3DNorthWest = new Cartesian3();\nconst viewRectangle3DSouthEast = new Cartesian3();\nconst viewRectangle3DNorthCenter = new Cartesian3();\nconst viewRectangle3DSouthCenter = new Cartesian3();\nconst viewRectangle3DCenter = new Cartesian3();\nconst viewRectangle3DEquator = new Cartesian3();\nconst defaultRF = {\n  direction: new Cartesian3(),\n  right: new Cartesian3(),\n  up: new Cartesian3()\n};\nlet viewRectangle3DEllipsoidGeodesic;\nfunction computeD(direction, upOrRight, corner, tanThetaOrPhi) {\n  const opposite = Math.abs(Cartesian3.dot(upOrRight, corner));\n  return opposite / tanThetaOrPhi - Cartesian3.dot(direction, corner);\n}\nfunction rectangleCameraPosition3D(camera, rectangle, result, updateCamera) {\n  const ellipsoid = camera._projection.ellipsoid;\n  const cameraRF = updateCamera ? camera : defaultRF;\n  const {\n    north,\n    south,\n    west\n  } = rectangle;\n  let {\n    east\n  } = rectangle;\n\n  // If we go across the International Date Line\n  if (west > east) {\n    east += CesiumMath.TWO_PI;\n  }\n\n  // Find the midpoint latitude.\n  //\n  // EllipsoidGeodesic will fail if the north and south edges are very close to being on opposite sides of the ellipsoid.\n  // Ideally we'd just call EllipsoidGeodesic.setEndPoints and let it throw when it detects this case, but sadly it doesn't\n  // even look for this case in optimized builds, so we have to test for it here instead.\n  //\n  // Fortunately, this case can only happen (here) when north is very close to the north pole and south is very close to the south pole,\n  // so handle it just by using 0 latitude as the center.  It's certainliy possible to use a smaller tolerance\n  // than one degree here, but one degree is safe and putting the center at 0 latitude should be good enough for any\n  // rectangle that spans 178+ of the 180 degrees of latitude.\n  const longitude = (west + east) * 0.5;\n  let latitude;\n  if (south < -CesiumMath.PI_OVER_TWO + CesiumMath.RADIANS_PER_DEGREE && north > CesiumMath.PI_OVER_TWO - CesiumMath.RADIANS_PER_DEGREE) {\n    latitude = 0.0;\n  } else {\n    const northCartographic = viewRectangle3DCartographic1;\n    northCartographic.longitude = longitude;\n    northCartographic.latitude = north;\n    northCartographic.height = 0.0;\n    const southCartographic = viewRectangle3DCartographic2;\n    southCartographic.longitude = longitude;\n    southCartographic.latitude = south;\n    southCartographic.height = 0.0;\n    let ellipsoidGeodesic = viewRectangle3DEllipsoidGeodesic;\n    if (!defined(ellipsoidGeodesic) || ellipsoidGeodesic.ellipsoid !== ellipsoid) {\n      viewRectangle3DEllipsoidGeodesic = ellipsoidGeodesic = new EllipsoidGeodesic(undefined, undefined, ellipsoid);\n    }\n    ellipsoidGeodesic.setEndPoints(northCartographic, southCartographic);\n    latitude = ellipsoidGeodesic.interpolateUsingFraction(0.5, viewRectangle3DCartographic1).latitude;\n  }\n  const centerCartographic = viewRectangle3DCartographic1;\n  centerCartographic.longitude = longitude;\n  centerCartographic.latitude = latitude;\n  centerCartographic.height = 0.0;\n  const center = ellipsoid.cartographicToCartesian(centerCartographic, viewRectangle3DCenter);\n  const cart = viewRectangle3DCartographic1;\n  cart.longitude = east;\n  cart.latitude = north;\n  const northEast = ellipsoid.cartographicToCartesian(cart, viewRectangle3DNorthEast);\n  cart.longitude = west;\n  const northWest = ellipsoid.cartographicToCartesian(cart, viewRectangle3DNorthWest);\n  cart.longitude = longitude;\n  const northCenter = ellipsoid.cartographicToCartesian(cart, viewRectangle3DNorthCenter);\n  cart.latitude = south;\n  const southCenter = ellipsoid.cartographicToCartesian(cart, viewRectangle3DSouthCenter);\n  cart.longitude = east;\n  const southEast = ellipsoid.cartographicToCartesian(cart, viewRectangle3DSouthEast);\n  cart.longitude = west;\n  const southWest = ellipsoid.cartographicToCartesian(cart, viewRectangle3DSouthWest);\n  Cartesian3.subtract(northWest, center, northWest);\n  Cartesian3.subtract(southEast, center, southEast);\n  Cartesian3.subtract(northEast, center, northEast);\n  Cartesian3.subtract(southWest, center, southWest);\n  Cartesian3.subtract(northCenter, center, northCenter);\n  Cartesian3.subtract(southCenter, center, southCenter);\n  const direction = ellipsoid.geodeticSurfaceNormal(center, cameraRF.direction);\n  Cartesian3.negate(direction, direction);\n  const right = Cartesian3.cross(direction, Cartesian3.UNIT_Z, cameraRF.right);\n  Cartesian3.normalize(right, right);\n  const up = Cartesian3.cross(right, direction, cameraRF.up);\n  let d;\n  if (camera.frustum instanceof OrthographicFrustum) {\n    const width = Math.max(Cartesian3.distance(northEast, northWest), Cartesian3.distance(southEast, southWest));\n    const height = Math.max(Cartesian3.distance(northEast, southEast), Cartesian3.distance(northWest, southWest));\n    let rightScalar;\n    let topScalar;\n    const offCenterFrustum = camera.frustum._offCenterFrustum;\n    const ratio = offCenterFrustum.right / offCenterFrustum.top;\n    const heightRatio = height * ratio;\n    if (width > heightRatio) {\n      rightScalar = width;\n      topScalar = rightScalar / ratio;\n    } else {\n      topScalar = height;\n      rightScalar = heightRatio;\n    }\n    d = Math.max(rightScalar, topScalar);\n  } else {\n    const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    const tanTheta = camera.frustum.aspectRatio * tanPhi;\n    d = Math.max(computeD(direction, up, northWest, tanPhi), computeD(direction, up, southEast, tanPhi), computeD(direction, up, northEast, tanPhi), computeD(direction, up, southWest, tanPhi), computeD(direction, up, northCenter, tanPhi), computeD(direction, up, southCenter, tanPhi), computeD(direction, right, northWest, tanTheta), computeD(direction, right, southEast, tanTheta), computeD(direction, right, northEast, tanTheta), computeD(direction, right, southWest, tanTheta), computeD(direction, right, northCenter, tanTheta), computeD(direction, right, southCenter, tanTheta));\n\n    // If the rectangle crosses the equator, compute D at the equator, too, because that's the\n    // widest part of the rectangle when projected onto the globe.\n    if (south < 0 && north > 0) {\n      const equatorCartographic = viewRectangle3DCartographic1;\n      equatorCartographic.longitude = west;\n      equatorCartographic.latitude = 0.0;\n      equatorCartographic.height = 0.0;\n      let equatorPosition = ellipsoid.cartographicToCartesian(equatorCartographic, viewRectangle3DEquator);\n      Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(d, computeD(direction, up, equatorPosition, tanPhi), computeD(direction, right, equatorPosition, tanTheta));\n      equatorCartographic.longitude = east;\n      equatorPosition = ellipsoid.cartographicToCartesian(equatorCartographic, viewRectangle3DEquator);\n      Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(d, computeD(direction, up, equatorPosition, tanPhi), computeD(direction, right, equatorPosition, tanTheta));\n    }\n  }\n  return Cartesian3.add(center, Cartesian3.multiplyByScalar(direction, -d, viewRectangle3DEquator), result);\n}\nconst viewRectangleCVCartographic = new Cartographic();\nconst viewRectangleCVNorthEast = new Cartesian3();\nconst viewRectangleCVSouthWest = new Cartesian3();\nfunction rectangleCameraPositionColumbusView(camera, rectangle, result) {\n  const projection = camera._projection;\n  if (rectangle.west > rectangle.east) {\n    rectangle = Rectangle.MAX_VALUE;\n  }\n  const transform = camera._actualTransform;\n  const invTransform = camera._actualInvTransform;\n  const cart = viewRectangleCVCartographic;\n  cart.longitude = rectangle.east;\n  cart.latitude = rectangle.north;\n  const northEast = projection.project(cart, viewRectangleCVNorthEast);\n  Matrix4.multiplyByPoint(transform, northEast, northEast);\n  Matrix4.multiplyByPoint(invTransform, northEast, northEast);\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  const southWest = projection.project(cart, viewRectangleCVSouthWest);\n  Matrix4.multiplyByPoint(transform, southWest, southWest);\n  Matrix4.multiplyByPoint(invTransform, southWest, southWest);\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n  if (defined(camera.frustum.fovy)) {\n    const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    const tanTheta = camera.frustum.aspectRatio * tanPhi;\n    result.z = Math.max((northEast.x - southWest.x) / tanTheta, (northEast.y - southWest.y) / tanPhi) * 0.5;\n  } else {\n    const width = northEast.x - southWest.x;\n    const height = northEast.y - southWest.y;\n    result.z = Math.max(width, height);\n  }\n  return result;\n}\nconst viewRectangle2DCartographic = new Cartographic();\nconst viewRectangle2DNorthEast = new Cartesian3();\nconst viewRectangle2DSouthWest = new Cartesian3();\nfunction rectangleCameraPosition2D(camera, rectangle, result) {\n  const projection = camera._projection;\n\n  // Account for the rectangle crossing the International Date Line in 2D mode\n  let east = rectangle.east;\n  if (rectangle.west > rectangle.east) {\n    if (camera._scene.mapMode2D === MapMode2D.INFINITE_SCROLL) {\n      east += CesiumMath.TWO_PI;\n    } else {\n      rectangle = Rectangle.MAX_VALUE;\n      east = rectangle.east;\n    }\n  }\n  let cart = viewRectangle2DCartographic;\n  cart.longitude = east;\n  cart.latitude = rectangle.north;\n  const northEast = projection.project(cart, viewRectangle2DNorthEast);\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  const southWest = projection.project(cart, viewRectangle2DSouthWest);\n  const width = Math.abs(northEast.x - southWest.x) * 0.5;\n  let height = Math.abs(northEast.y - southWest.y) * 0.5;\n  let right, top;\n  const ratio = camera.frustum.right / camera.frustum.top;\n  const heightRatio = height * ratio;\n  if (width > heightRatio) {\n    right = width;\n    top = right / ratio;\n  } else {\n    top = height;\n    right = heightRatio;\n  }\n  height = Math.max(2.0 * right, 2.0 * top);\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n  cart = projection.unproject(result, cart);\n  cart.height = height;\n  result = projection.project(cart, result);\n  return result;\n}\n\n/**\n * Get the camera position needed to view a rectangle on an ellipsoid or map\n *\n * @param {Rectangle} rectangle The rectangle to view.\n * @param {Cartesian3} [result] The camera position needed to view the rectangle\n * @returns {Cartesian3} The camera position needed to view the rectangle\n */\nCamera.prototype.getRectangleCameraCoordinates = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  }\n  //>>includeEnd('debug');\n  const mode = this._mode;\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  if (mode === SceneMode.SCENE3D) {\n    return rectangleCameraPosition3D(this, rectangle, result);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    return rectangleCameraPositionColumbusView(this, rectangle, result);\n  } else if (mode === SceneMode.SCENE2D) {\n    return rectangleCameraPosition2D(this, rectangle, result);\n  }\n  return undefined;\n};\nconst pickEllipsoid3DRay = new Ray();\nfunction pickEllipsoid3D(camera, windowPosition, ellipsoid, result) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  const ray = camera.getPickRay(windowPosition, pickEllipsoid3DRay);\n  const intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n  if (!intersection) {\n    return undefined;\n  }\n  const t = intersection.start > 0.0 ? intersection.start : intersection.stop;\n  return Ray.getPoint(ray, t, result);\n}\nconst pickEllipsoid2DRay = new Ray();\nfunction pickMap2D(camera, windowPosition, projection, result) {\n  const ray = camera.getPickRay(windowPosition, pickEllipsoid2DRay);\n  let position = ray.origin;\n  position = Cartesian3.fromElements(position.y, position.z, 0.0, position);\n  const cart = projection.unproject(position);\n  if (cart.latitude < -CesiumMath.PI_OVER_TWO || cart.latitude > CesiumMath.PI_OVER_TWO) {\n    return undefined;\n  }\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\nconst pickEllipsoidCVRay = new Ray();\nfunction pickMapColumbusView(camera, windowPosition, projection, result) {\n  const ray = camera.getPickRay(windowPosition, pickEllipsoidCVRay);\n  const scalar = -ray.origin.x / ray.direction.x;\n  Ray.getPoint(ray, scalar, result);\n  const cart = projection.unproject(new Cartesian3(result.y, result.z, 0.0));\n  if (cart.latitude < -CesiumMath.PI_OVER_TWO || cart.latitude > CesiumMath.PI_OVER_TWO || cart.longitude < -Math.PI || cart.longitude > Math.PI) {\n    return undefined;\n  }\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n\n/**\n * Pick an ellipsoid or map.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to pick.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3 | undefined} If the ellipsoid or map was picked,\n * returns the point on the surface of the ellipsoid or map in world\n * coordinates. If the ellipsoid or map was not picked, returns undefined.\n *\n * @example\n * const canvas = viewer.scene.canvas;\n * const center = new Cesium.Cartesian2(canvas.clientWidth / 2.0, canvas.clientHeight / 2.0);\n * const ellipsoid = viewer.scene.ellipsoid;\n * const result = viewer.camera.pickEllipsoid(center, ellipsoid);\n */\nCamera.prototype.pickEllipsoid = function (windowPosition, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const canvas = this._scene.canvas;\n  if (canvas.clientWidth === 0 || canvas.clientHeight === 0) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  if (this._mode === SceneMode.SCENE3D) {\n    result = pickEllipsoid3D(this, windowPosition, ellipsoid, result);\n  } else if (this._mode === SceneMode.SCENE2D) {\n    result = pickMap2D(this, windowPosition, this._projection, result);\n  } else if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    result = pickMapColumbusView(this, windowPosition, this._projection, result);\n  } else {\n    return undefined;\n  }\n  return result;\n};\nconst pickPerspCenter = new Cartesian3();\nconst pickPerspXDir = new Cartesian3();\nconst pickPerspYDir = new Cartesian3();\nfunction getPickRayPerspective(camera, windowPosition, result) {\n  const canvas = camera._scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n  const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  const tanTheta = camera.frustum.aspectRatio * tanPhi;\n  const near = camera.frustum.near;\n  const x = 2.0 / width * windowPosition.x - 1.0;\n  const y = 2.0 / height * (height - windowPosition.y) - 1.0;\n  const position = camera.positionWC;\n  Cartesian3.clone(position, result.origin);\n  const nearCenter = Cartesian3.multiplyByScalar(camera.directionWC, near, pickPerspCenter);\n  Cartesian3.add(position, nearCenter, nearCenter);\n  const xDir = Cartesian3.multiplyByScalar(camera.rightWC, x * near * tanTheta, pickPerspXDir);\n  const yDir = Cartesian3.multiplyByScalar(camera.upWC, y * near * tanPhi, pickPerspYDir);\n  const direction = Cartesian3.add(nearCenter, xDir, result.direction);\n  Cartesian3.add(direction, yDir, direction);\n  Cartesian3.subtract(direction, position, direction);\n  Cartesian3.normalize(direction, direction);\n  return result;\n}\nconst scratchDirection = new Cartesian3();\nfunction getPickRayOrthographic(camera, windowPosition, result) {\n  const canvas = camera._scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n  let frustum = camera.frustum;\n  const offCenterFrustum = frustum.offCenterFrustum;\n  if (defined(offCenterFrustum)) {\n    frustum = offCenterFrustum;\n  }\n  let x = 2.0 / width * windowPosition.x - 1.0;\n  x *= (frustum.right - frustum.left) * 0.5;\n  let y = 2.0 / height * (height - windowPosition.y) - 1.0;\n  y *= (frustum.top - frustum.bottom) * 0.5;\n  const origin = result.origin;\n  Cartesian3.clone(camera.position, origin);\n  Cartesian3.multiplyByScalar(camera.right, x, scratchDirection);\n  Cartesian3.add(scratchDirection, origin, origin);\n  Cartesian3.multiplyByScalar(camera.up, y, scratchDirection);\n  Cartesian3.add(scratchDirection, origin, origin);\n  Cartesian3.clone(camera.directionWC, result.direction);\n  if (camera._mode === SceneMode.COLUMBUS_VIEW || camera._mode === SceneMode.SCENE2D) {\n    Cartesian3.fromElements(result.origin.z, result.origin.x, result.origin.y, result.origin);\n  }\n  return result;\n}\n\n/**\n * Create a ray from the camera position through the pixel at <code>windowPosition</code>\n * in world coordinates.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray|undefined} Returns the {@link Cartesian3} position and direction of the ray, or undefined if the pick ray cannot be determined.\n */\nCamera.prototype.getPickRay = function (windowPosition, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Ray();\n  }\n  const canvas = this._scene.canvas;\n  if (canvas.clientWidth <= 0 || canvas.clientHeight <= 0) {\n    return undefined;\n  }\n  const frustum = this.frustum;\n  if (defined(frustum.aspectRatio) && defined(frustum.fov) && defined(frustum.near)) {\n    return getPickRayPerspective(this, windowPosition, result);\n  }\n  return getPickRayOrthographic(this, windowPosition, result);\n};\nconst scratchToCenter = new Cartesian3();\nconst scratchProj = new Cartesian3();\n\n/**\n * Return the distance from the camera to the front of the bounding sphere.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @returns {number} The distance to the bounding sphere.\n */\nCamera.prototype.distanceToBoundingSphere = function (boundingSphere) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const toCenter = Cartesian3.subtract(this.positionWC, boundingSphere.center, scratchToCenter);\n  const proj = Cartesian3.multiplyByScalar(this.directionWC, Cartesian3.dot(toCenter, this.directionWC), scratchProj);\n  return Math.max(0.0, Cartesian3.magnitude(proj) - boundingSphere.radius);\n};\nconst scratchPixelSize = new Cartesian2();\n\n/**\n * Return the pixel size in meters.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @param {number} drawingBufferWidth The drawing buffer width.\n * @param {number} drawingBufferHeight The drawing buffer height.\n * @returns {number} The pixel size in meters.\n */\nCamera.prototype.getPixelSize = function (boundingSphere, drawingBufferWidth, drawingBufferHeight) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  if (!defined(drawingBufferWidth)) {\n    throw new DeveloperError(\"drawingBufferWidth is required.\");\n  }\n  if (!defined(drawingBufferHeight)) {\n    throw new DeveloperError(\"drawingBufferHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const distance = this.distanceToBoundingSphere(boundingSphere);\n  const pixelSize = this.frustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, this._scene.pixelRatio, scratchPixelSize);\n  return Math.max(pixelSize.x, pixelSize.y);\n};\nfunction createAnimationTemplateCV(camera, position, center, maxX, maxY, duration) {\n  const newPosition = Cartesian3.clone(position);\n  if (center.y > maxX) {\n    newPosition.y -= center.y - maxX;\n  } else if (center.y < -maxX) {\n    newPosition.y += -maxX - center.y;\n  }\n  if (center.z > maxY) {\n    newPosition.z -= center.z - maxY;\n  } else if (center.z < -maxY) {\n    newPosition.z += -maxY - center.z;\n  }\n  function updateCV(value) {\n    const interp = Cartesian3.lerp(position, newPosition, value.time, new Cartesian3());\n    camera.worldToCameraCoordinatesPoint(interp, camera.position);\n  }\n  return {\n    easingFunction: EasingFunction.EXPONENTIAL_OUT,\n    startObject: {\n      time: 0.0\n    },\n    stopObject: {\n      time: 1.0\n    },\n    duration: duration,\n    update: updateCV\n  };\n}\nconst normalScratch = new Cartesian3();\nconst centerScratch = new Cartesian3();\nconst posScratch = new Cartesian3();\nconst scratchCartesian3Subtract = new Cartesian3();\nfunction createAnimationCV(camera, duration) {\n  let position = camera.position;\n  const direction = camera.direction;\n  const normal = camera.worldToCameraCoordinatesVector(Cartesian3.UNIT_X, normalScratch);\n  const scalar = -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  const center = Cartesian3.add(position, Cartesian3.multiplyByScalar(direction, scalar, centerScratch), centerScratch);\n  camera.cameraToWorldCoordinatesPoint(center, center);\n  position = camera.cameraToWorldCoordinatesPoint(camera.position, posScratch);\n  const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  const tanTheta = camera.frustum.aspectRatio * tanPhi;\n  const distToC = Cartesian3.magnitude(Cartesian3.subtract(position, center, scratchCartesian3Subtract));\n  const dWidth = tanTheta * distToC;\n  const dHeight = tanPhi * distToC;\n  const mapWidth = camera._maxCoord.x;\n  const mapHeight = camera._maxCoord.y;\n  const maxX = Math.max(dWidth - mapWidth, mapWidth);\n  const maxY = Math.max(dHeight - mapHeight, mapHeight);\n  if (position.z < -maxX || position.z > maxX || position.y < -maxY || position.y > maxY) {\n    const translateX = center.y < -maxX || center.y > maxX;\n    const translateY = center.z < -maxY || center.z > maxY;\n    if (translateX || translateY) {\n      return createAnimationTemplateCV(camera, position, center, maxX, maxY, duration);\n    }\n  }\n  return undefined;\n}\n\n/**\n * Create an animation to move the map into view. This method is only valid for 2D and Columbus modes.\n *\n * @param {number} duration The duration, in seconds, of the animation.\n * @returns {object} The animation or undefined if the scene mode is 3D or the map is already ion view.\n *\n * @private\n */\nCamera.prototype.createCorrectPositionTween = function (duration) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(duration)) {\n    throw new DeveloperError(\"duration is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    return createAnimationCV(this, duration);\n  }\n  return undefined;\n};\nconst scratchFlyToDestination = new Cartesian3();\nconst newOptions = {\n  destination: undefined,\n  heading: undefined,\n  pitch: undefined,\n  roll: undefined,\n  duration: undefined,\n  complete: undefined,\n  cancel: undefined,\n  endTransform: undefined,\n  maximumHeight: undefined,\n  easingFunction: undefined\n};\n\n/**\n * Cancels the current camera flight and leaves the camera at its current location.\n * If no flight is in progress, this this function does nothing.\n */\nCamera.prototype.cancelFlight = function () {\n  if (defined(this._currentFlight)) {\n    this._currentFlight.cancelTween();\n    this._currentFlight = undefined;\n  }\n};\n\n/**\n * Completes the current camera flight and moves the camera immediately to its final destination.\n * If no flight is in progress, this this function does nothing.\n */\nCamera.prototype.completeFlight = function () {\n  if (defined(this._currentFlight)) {\n    this._currentFlight.cancelTween();\n    const options = {\n      destination: undefined,\n      orientation: {\n        heading: undefined,\n        pitch: undefined,\n        roll: undefined\n      }\n    };\n    options.destination = newOptions.destination;\n    options.orientation.heading = newOptions.heading;\n    options.orientation.pitch = newOptions.pitch;\n    options.orientation.roll = newOptions.roll;\n    this.setView(options);\n    if (defined(this._currentFlight.complete)) {\n      this._currentFlight.complete();\n    }\n    this._currentFlight = undefined;\n  }\n};\n\n/**\n * Flies the camera from its current position to a new position.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} options.destination The final position of the camera in world coordinates or a rectangle that would be visible from a top-down view.\n * @param {object} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view.  Orientation is not used in 2D when in infinite scrolling mode.\n * @param {number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {Camera.FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera.FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n * @param {EasingFunction.Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n *\n * @exception {DeveloperError} If either direction or up is given, then both are required.\n *\n * @example\n * // 1. Fly to a position with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2. Fly to a Rectangle with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 3. Fly to a position with an orientation using unit vectors.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n *\n * // 4. Fly to a position with an orientation using heading, pitch and roll.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         heading : Cesium.Math.toRadians(175.0),\n *         pitch : Cesium.Math.toRadians(-35.0),\n *         roll : 0.0\n *     }\n * });\n */\nCamera.prototype.flyTo = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  let destination = options.destination;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(destination)) {\n    throw new DeveloperError(\"destination is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const mode = this._mode;\n  if (mode === SceneMode.MORPHING) {\n    return;\n  }\n  this.cancelFlight();\n  const isRectangle = destination instanceof Rectangle;\n  if (isRectangle) {\n    destination = this.getRectangleCameraCoordinates(destination, scratchFlyToDestination);\n  }\n  let orientation = defaultValue(options.orientation, defaultValue.EMPTY_OBJECT);\n  if (defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(this, destination, orientation, scratchSetViewOptions.orientation);\n  }\n  if (defined(options.duration) && options.duration <= 0.0) {\n    const setViewOptions = scratchSetViewOptions;\n    setViewOptions.destination = options.destination;\n    setViewOptions.orientation.heading = orientation.heading;\n    setViewOptions.orientation.pitch = orientation.pitch;\n    setViewOptions.orientation.roll = orientation.roll;\n    setViewOptions.convert = options.convert;\n    setViewOptions.endTransform = options.endTransform;\n    this.setView(setViewOptions);\n    if (typeof options.complete === \"function\") {\n      options.complete();\n    }\n    return;\n  }\n  const that = this;\n  /* eslint-disable-next-line prefer-const */\n  let flightTween;\n  newOptions.destination = destination;\n  newOptions.heading = orientation.heading;\n  newOptions.pitch = orientation.pitch;\n  newOptions.roll = orientation.roll;\n  newOptions.duration = options.duration;\n  newOptions.complete = function () {\n    if (flightTween === that._currentFlight) {\n      that._currentFlight = undefined;\n    }\n    if (defined(options.complete)) {\n      options.complete();\n    }\n  };\n  newOptions.cancel = options.cancel;\n  newOptions.endTransform = options.endTransform;\n  newOptions.convert = isRectangle ? false : options.convert;\n  newOptions.maximumHeight = options.maximumHeight;\n  newOptions.pitchAdjustHeight = options.pitchAdjustHeight;\n  newOptions.flyOverLongitude = options.flyOverLongitude;\n  newOptions.flyOverLongitudeWeight = options.flyOverLongitudeWeight;\n  newOptions.easingFunction = options.easingFunction;\n  const scene = this._scene;\n  const tweenOptions = CameraFlightPath.createTween(scene, newOptions);\n  // If the camera doesn't actually need to go anywhere, duration\n  // will be 0 and we can just complete the current flight.\n  if (tweenOptions.duration === 0) {\n    if (typeof tweenOptions.complete === \"function\") {\n      tweenOptions.complete();\n    }\n    return;\n  }\n  flightTween = scene.tweens.add(tweenOptions);\n  this._currentFlight = flightTween;\n\n  // Save the final destination view information for the PRELOAD_FLIGHT pass.\n  let preloadFlightCamera = this._scene.preloadFlightCamera;\n  if (this._mode !== SceneMode.SCENE2D) {\n    if (!defined(preloadFlightCamera)) {\n      preloadFlightCamera = Camera.clone(this);\n    }\n    preloadFlightCamera.setView({\n      destination: destination,\n      orientation: orientation\n    });\n    this._scene.preloadFlightCullingVolume = preloadFlightCamera.frustum.computeCullingVolume(preloadFlightCamera.positionWC, preloadFlightCamera.directionWC, preloadFlightCamera.upWC);\n  }\n};\nfunction distanceToBoundingSphere3D(camera, radius) {\n  const frustum = camera.frustum;\n  const tanPhi = Math.tan(frustum.fovy * 0.5);\n  const tanTheta = frustum.aspectRatio * tanPhi;\n  return Math.max(radius / tanTheta, radius / tanPhi);\n}\nfunction distanceToBoundingSphere2D(camera, radius) {\n  let frustum = camera.frustum;\n  const offCenterFrustum = frustum.offCenterFrustum;\n  if (defined(offCenterFrustum)) {\n    frustum = offCenterFrustum;\n  }\n  let right, top;\n  const ratio = frustum.right / frustum.top;\n  const heightRatio = radius * ratio;\n  if (radius > heightRatio) {\n    right = radius;\n    top = right / ratio;\n  } else {\n    top = radius;\n    right = heightRatio;\n  }\n  return Math.max(right, top) * 1.5;\n}\nconst MINIMUM_ZOOM = 100.0;\nfunction adjustBoundingSphereOffset(camera, boundingSphere, offset) {\n  offset = HeadingPitchRange.clone(defined(offset) ? offset : Camera.DEFAULT_OFFSET);\n  const minimumZoom = camera._scene.screenSpaceCameraController.minimumZoomDistance;\n  const maximumZoom = camera._scene.screenSpaceCameraController.maximumZoomDistance;\n  const range = offset.range;\n  if (!defined(range) || range === 0.0) {\n    const radius = boundingSphere.radius;\n    if (radius === 0.0) {\n      offset.range = MINIMUM_ZOOM;\n    } else if (camera.frustum instanceof OrthographicFrustum || camera._mode === SceneMode.SCENE2D) {\n      offset.range = distanceToBoundingSphere2D(camera, radius);\n    } else {\n      offset.range = distanceToBoundingSphere3D(camera, radius);\n    }\n    offset.range = CesiumMath.clamp(offset.range, minimumZoom, maximumZoom);\n  }\n  return offset;\n}\n\n/**\n * Sets the camera so that the current view contains the provided bounding sphere.\n *\n * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {HeadingPitchRange} [offset] The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} viewBoundingSphere is not supported while morphing.\n */\nCamera.prototype.viewBoundingSphere = function (boundingSphere, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\"viewBoundingSphere is not supported while morphing.\");\n  }\n  //>>includeEnd('debug');\n\n  offset = adjustBoundingSphereOffset(this, boundingSphere, offset);\n  this.lookAt(boundingSphere.center, offset);\n};\nconst scratchflyToBoundingSphereTransform = new Matrix4();\nconst scratchflyToBoundingSphereDestination = new Cartesian3();\nconst scratchflyToBoundingSphereDirection = new Cartesian3();\nconst scratchflyToBoundingSphereUp = new Cartesian3();\nconst scratchflyToBoundingSphereRight = new Cartesian3();\nconst scratchFlyToBoundingSphereCart4 = new Cartesian4();\nconst scratchFlyToBoundingSphereQuaternion = new Quaternion();\nconst scratchFlyToBoundingSphereMatrix3 = new Matrix3();\n\n/**\n * Flies the camera to a location where the current view contains the provided bounding sphere.\n *\n * <p> The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D and Columbus View, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be aligned to local north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {object} [options] Object with the following properties:\n * @param {number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {HeadingPitchRange} [options.offset] The offset from the target in the local east-north-up reference frame centered at the target.\n * @param {Camera.FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera.FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {EasingFunction.Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n */\nCamera.prototype.flyToBoundingSphere = function (boundingSphere, options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const scene2D = this._mode === SceneMode.SCENE2D || this._mode === SceneMode.COLUMBUS_VIEW;\n  this._setTransform(Matrix4.IDENTITY);\n  const offset = adjustBoundingSphereOffset(this, boundingSphere, options.offset);\n  let position;\n  if (scene2D) {\n    position = Cartesian3.multiplyByScalar(Cartesian3.UNIT_Z, offset.range, scratchflyToBoundingSphereDestination);\n  } else {\n    position = offsetFromHeadingPitchRange(offset.heading, offset.pitch, offset.range);\n  }\n  const scene = this._scene;\n  const ellipsoid = defaultValue(scene.ellipsoid, Ellipsoid.default);\n  const transform = Transforms.eastNorthUpToFixedFrame(boundingSphere.center, ellipsoid, scratchflyToBoundingSphereTransform);\n  Matrix4.multiplyByPoint(transform, position, position);\n  let direction;\n  let up;\n  if (!scene2D) {\n    direction = Cartesian3.subtract(boundingSphere.center, position, scratchflyToBoundingSphereDirection);\n    Cartesian3.normalize(direction, direction);\n    up = Matrix4.multiplyByPointAsVector(transform, Cartesian3.UNIT_Z, scratchflyToBoundingSphereUp);\n    if (1.0 - Math.abs(Cartesian3.dot(direction, up)) < CesiumMath.EPSILON6) {\n      const rotateQuat = Quaternion.fromAxisAngle(direction, offset.heading, scratchFlyToBoundingSphereQuaternion);\n      const rotation = Matrix3.fromQuaternion(rotateQuat, scratchFlyToBoundingSphereMatrix3);\n      Cartesian3.fromCartesian4(Matrix4.getColumn(transform, 1, scratchFlyToBoundingSphereCart4), up);\n      Matrix3.multiplyByVector(rotation, up, up);\n    }\n    const right = Cartesian3.cross(direction, up, scratchflyToBoundingSphereRight);\n    Cartesian3.cross(right, direction, up);\n    Cartesian3.normalize(up, up);\n  }\n  this.flyTo({\n    destination: position,\n    orientation: {\n      direction: direction,\n      up: up\n    },\n    duration: options.duration,\n    complete: options.complete,\n    cancel: options.cancel,\n    endTransform: options.endTransform,\n    maximumHeight: options.maximumHeight,\n    easingFunction: options.easingFunction,\n    flyOverLongitude: options.flyOverLongitude,\n    flyOverLongitudeWeight: options.flyOverLongitudeWeight,\n    pitchAdjustHeight: options.pitchAdjustHeight\n  });\n};\nconst scratchCartesian3_1 = new Cartesian3();\nconst scratchCartesian3_2 = new Cartesian3();\nconst scratchCartesian3_3 = new Cartesian3();\nconst scratchCartesian3_4 = new Cartesian3();\nconst horizonPoints = [new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3()];\nfunction computeHorizonQuad(camera, ellipsoid) {\n  const radii = ellipsoid.radii;\n  const p = camera.positionWC;\n\n  // Find the corresponding position in the scaled space of the ellipsoid.\n  const q = Cartesian3.multiplyComponents(ellipsoid.oneOverRadii, p, scratchCartesian3_1);\n  const qMagnitude = Cartesian3.magnitude(q);\n  const qUnit = Cartesian3.normalize(q, scratchCartesian3_2);\n\n  // Determine the east and north directions at q.\n  let eUnit;\n  let nUnit;\n  if (Cartesian3.equalsEpsilon(qUnit, Cartesian3.UNIT_Z, CesiumMath.EPSILON10)) {\n    eUnit = new Cartesian3(0, 1, 0);\n    nUnit = new Cartesian3(0, 0, 1);\n  } else {\n    eUnit = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, qUnit, scratchCartesian3_3), scratchCartesian3_3);\n    nUnit = Cartesian3.normalize(Cartesian3.cross(qUnit, eUnit, scratchCartesian3_4), scratchCartesian3_4);\n  }\n\n  // Determine the radius of the 'limb' of the ellipsoid.\n  const wMagnitude = Math.sqrt(Cartesian3.magnitudeSquared(q) - 1.0);\n\n  // Compute the center and offsets.\n  const center = Cartesian3.multiplyByScalar(qUnit, 1.0 / qMagnitude, scratchCartesian3_1);\n  const scalar = wMagnitude / qMagnitude;\n  const eastOffset = Cartesian3.multiplyByScalar(eUnit, scalar, scratchCartesian3_2);\n  const northOffset = Cartesian3.multiplyByScalar(nUnit, scalar, scratchCartesian3_3);\n\n  // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.\n  const upperLeft = Cartesian3.add(center, northOffset, horizonPoints[0]);\n  Cartesian3.subtract(upperLeft, eastOffset, upperLeft);\n  Cartesian3.multiplyComponents(radii, upperLeft, upperLeft);\n  const lowerLeft = Cartesian3.subtract(center, northOffset, horizonPoints[1]);\n  Cartesian3.subtract(lowerLeft, eastOffset, lowerLeft);\n  Cartesian3.multiplyComponents(radii, lowerLeft, lowerLeft);\n  const lowerRight = Cartesian3.subtract(center, northOffset, horizonPoints[2]);\n  Cartesian3.add(lowerRight, eastOffset, lowerRight);\n  Cartesian3.multiplyComponents(radii, lowerRight, lowerRight);\n  const upperRight = Cartesian3.add(center, northOffset, horizonPoints[3]);\n  Cartesian3.add(upperRight, eastOffset, upperRight);\n  Cartesian3.multiplyComponents(radii, upperRight, upperRight);\n  return horizonPoints;\n}\nconst scratchPickCartesian2 = new Cartesian2();\nconst scratchRectCartesian = new Cartesian3();\nconst cartoArray = [new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic()];\nfunction addToResult(x, y, index, camera, ellipsoid, computedHorizonQuad) {\n  scratchPickCartesian2.x = x;\n  scratchPickCartesian2.y = y;\n  const r = camera.pickEllipsoid(scratchPickCartesian2, ellipsoid, scratchRectCartesian);\n  if (defined(r)) {\n    cartoArray[index] = ellipsoid.cartesianToCartographic(r, cartoArray[index]);\n    return 1;\n  }\n  cartoArray[index] = ellipsoid.cartesianToCartographic(computedHorizonQuad[index], cartoArray[index]);\n  return 0;\n}\n/**\n * Computes the approximate visible rectangle on the ellipsoid.\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid that you want to know the visible region.\n * @param {Rectangle} [result] The rectangle in which to store the result\n *\n * @returns {Rectangle|undefined} The visible rectangle or undefined if the ellipsoid isn't visible at all.\n */\nCamera.prototype.computeViewRectangle = function (ellipsoid, result) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  const cullingVolume = this.frustum.computeCullingVolume(this.positionWC, this.directionWC, this.upWC);\n  const boundingSphere = new BoundingSphere(Cartesian3.ZERO, ellipsoid.maximumRadius);\n  const visibility = cullingVolume.computeVisibility(boundingSphere);\n  if (visibility === Intersect.OUTSIDE) {\n    return undefined;\n  }\n  const canvas = this._scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n  let successfulPickCount = 0;\n  const computedHorizonQuad = computeHorizonQuad(this, ellipsoid);\n  successfulPickCount += addToResult(0, 0, 0, this, ellipsoid, computedHorizonQuad);\n  successfulPickCount += addToResult(0, height, 1, this, ellipsoid, computedHorizonQuad);\n  successfulPickCount += addToResult(width, height, 2, this, ellipsoid, computedHorizonQuad);\n  successfulPickCount += addToResult(width, 0, 3, this, ellipsoid, computedHorizonQuad);\n  if (successfulPickCount < 2) {\n    // If we have space non-globe in 3 or 4 corners then return the whole globe\n    return Rectangle.MAX_VALUE;\n  }\n  result = Rectangle.fromCartographicArray(cartoArray, result);\n\n  // Detect if we go over the poles\n  let distance = 0;\n  let lastLon = cartoArray[3].longitude;\n  for (let i = 0; i < 4; ++i) {\n    const lon = cartoArray[i].longitude;\n    const diff = Math.abs(lon - lastLon);\n    if (diff > CesiumMath.PI) {\n      // Crossed the dateline\n      distance += CesiumMath.TWO_PI - diff;\n    } else {\n      distance += diff;\n    }\n    lastLon = lon;\n  }\n\n  // We are over one of the poles so adjust the rectangle accordingly\n  if (CesiumMath.equalsEpsilon(Math.abs(distance), CesiumMath.TWO_PI, CesiumMath.EPSILON9)) {\n    result.west = -CesiumMath.PI;\n    result.east = CesiumMath.PI;\n    if (cartoArray[0].latitude >= 0.0) {\n      result.north = CesiumMath.PI_OVER_TWO;\n    } else {\n      result.south = -CesiumMath.PI_OVER_TWO;\n    }\n  }\n  return result;\n};\n\n/**\n * Switches the frustum/projection to perspective.\n *\n * This function is a no-op in 2D which must always be orthographic.\n */\nCamera.prototype.switchToPerspectiveFrustum = function () {\n  if (this._mode === SceneMode.SCENE2D || this.frustum instanceof PerspectiveFrustum) {\n    return;\n  }\n  const scene = this._scene;\n  this.frustum = new PerspectiveFrustum();\n  this.frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = CesiumMath.toRadians(60.0);\n};\n\n/**\n * Switches the frustum/projection to orthographic.\n *\n * This function is a no-op in 2D which will always be orthographic.\n */\nCamera.prototype.switchToOrthographicFrustum = function () {\n  if (this._mode === SceneMode.SCENE2D || this.frustum instanceof OrthographicFrustum) {\n    return;\n  }\n\n  // This must be called before changing the frustum because it uses the previous\n  // frustum to reconstruct the world space position from the depth buffer.\n  const frustumWidth = calculateOrthographicFrustumWidth(this);\n  const scene = this._scene;\n  this.frustum = new OrthographicFrustum();\n  this.frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.width = frustumWidth;\n};\n\n/**\n * @private\n */\nCamera.clone = function (camera, result) {\n  if (!defined(result)) {\n    result = new Camera(camera._scene);\n  }\n  Cartesian3.clone(camera.position, result.position);\n  Cartesian3.clone(camera.direction, result.direction);\n  Cartesian3.clone(camera.up, result.up);\n  Cartesian3.clone(camera.right, result.right);\n  Matrix4.clone(camera._transform, result.transform);\n  result._transformChanged = true;\n  result.frustum = camera.frustum.clone();\n  return result;\n};\n\n/**\n * A function that will execute when a flight completes.\n * @callback Camera.FlightCompleteCallback\n */\n\n/**\n * A function that will execute when a flight is cancelled.\n * @callback Camera.FlightCancelledCallback\n */\nexport default Camera;","map":{"version":3,"names":["BoundingSphere","Cartesian2","Cartesian3","Cartesian4","Cartographic","defaultValue","defined","DeveloperError","EasingFunction","Ellipsoid","EllipsoidGeodesic","Event","getTimestamp","HeadingPitchRange","HeadingPitchRoll","Intersect","IntersectionTests","CesiumMath","Matrix3","Matrix4","OrthographicFrustum","OrthographicOffCenterFrustum","PerspectiveFrustum","Quaternion","Ray","Rectangle","Transforms","CameraFlightPath","MapMode2D","SceneMode","Camera","scene","_scene","_transform","clone","IDENTITY","_invTransform","_actualTransform","_actualInvTransform","_transformChanged","position","_position","_positionWC","_positionCartographic","_oldPositionWC","undefined","positionWCDeltaMagnitude","positionWCDeltaMagnitudeLastFrame","timeSinceMoved","_lastMovedTimestamp","direction","_direction","_directionWC","up","_up","_upWC","right","_right","_rightWC","frustum","aspectRatio","drawingBufferWidth","drawingBufferHeight","fov","toRadians","defaultMoveAmount","defaultLookAmount","Math","PI","defaultRotateAmount","defaultZoomAmount","constrainedAxis","maximumZoomFactor","_moveStart","_moveEnd","_changed","_changedPosition","_changedDirection","_changedFrustum","_changedHeading","_changedRoll","percentageChanged","_viewMatrix","_invViewMatrix","updateViewMatrix","_mode","SCENE3D","_modeChanged","projection","mapProjection","_projection","_maxCoord","project","PI_OVER_TWO","_max2Dfrustum","rectangleCameraPosition3D","DEFAULT_VIEW_RECTANGLE","mag","magnitude","DEFAULT_VIEW_FACTOR","normalize","multiplyByScalar","TRANSFORM_2D","TRANSFORM_2D_INVERSE","inverseTransformation","fromDegrees","DEFAULT_OFFSET","PI_OVER_FOUR","camera","computeView","multiply","updateCameraDeltas","positionWC","delta","subtract","max","prototype","canPreloadFlight","_currentFlight","SCENE2D","_updateCameraChanged","numberOfListeners","currentHeading","heading","headingDelta","abs","TWO_PI","headingChangedPercentage","currentRoll","roll","rollDelta","rollChangedPercentage","raiseEvent","lastPosition","lastFrustum","x0","x","left","x1","x2","x3","y0","y","bottom","y1","top","y2","y3","leftX","rightX","min","bottomY","topY","areaPercentage","areaRef","directionWC","dirAngle","acosClamped","dot","dirPercentage","fovy","distance","heightPercentage","positionCartographic","height","convertTransformForColumbusView","basisTo2D","scratchCartographic","scratchCartesian3Projection","scratchCartesian3","scratchCartesian4Origin","scratchCartesian4NewOrigin","scratchCartesian4NewXAxis","scratchCartesian4NewYAxis","scratchCartesian4NewZAxis","convertTransformFor2D","ellipsoid","origin","getColumn","cartographic","cartesianToCartographic","projectedPosition","newOrigin","z","w","newZAxis","UNIT_X","xAxis","add","newXAxis","newYAxis","magnitudeSquared","EPSILON10","cross","yAxis","UNIT_Y","UNIT_Z","setColumn","scratchCartesian","updateMembers","mode","heightChanged","positionChanged","equals","directionChanged","upChanged","rightChanged","transformChanged","COLUMBUS_VIEW","transform","multiplyByPoint","MORPHING","positionENU","unproject","det","EPSILON2","invUpMag","scalar","w0","multiplyByPointAsVector","getHeading","equalsEpsilon","EPSILON3","atan2","zeroToTwoPi","getPitch","getRoll","scratchHPRMatrix1","scratchHPRMatrix2","Object","defineProperties","get","inverseTransform","viewMatrix","inverseViewMatrix","upWC","rightWC","oldTransform","eastNorthUpToFixedFrame","_setTransform","pitch","moveStart","moveEnd","changed","update","updateFrustum","maxZoomOut","ratio","clampMove2D","setTransformPosition","setTransformUp","setTransformDirection","inverse","scratchAdjustOrthographicFrustumMousePosition","scratchPickRay","scratchRayIntersection","scratchDepthIntersection","calculateOrthographicFrustumWidth","globe","mousePosition","rayIntersection","ray","getPickRay","pickWorldCoordinates","depthIntersection","pickPositionSupported","pickPositionWorldCoordinates","depthDistance","Number","POSITIVE_INFINITY","rayDistance","_adjustOrthographicFrustum","zooming","width","scratchSetViewCartesian","scratchSetViewTransform1","scratchSetViewTransform2","scratchSetViewQuaternion","scratchSetViewMatrix3","scratchSetViewCartographic","setView3D","hpr","isNaN","currentTransform","localTransform","ZERO","rotQuat","fromHeadingPitchRoll","rotMat","fromQuaternion","setViewCV","convert","setView2D","newLeft","newRight","mapMode2D","ROTATE","scratchToHPRDirection","scratchToHPRUp","scratchToHPRRight","directionUpToHeadingPitchRoll","orientation","result","invTransform","scratchSetViewOptions","destination","endTransform","scratchHpr","setView","options","EMPTY_OBJECT","west","getRectangleCameraCoordinates","pitchScratch","flyHome","duration","completeMorph","flyTo","maxRadii","maximumRadius","acos","worldToCameraCoordinates","cartesian","multiplyByVector","worldToCameraCoordinatesPoint","worldToCameraCoordinatesVector","cameraToWorldCoordinates","cameraToWorldCoordinatesPoint","cameraToWorldCoordinatesVector","rotatable2D","maxProjectedX","maxProjectedY","minX","maxX","moveScratch","move","amount","cameraPosition","moveForward","zoom2D","moveBackward","moveUp","moveDown","moveRight","moveLeft","lookLeft","look","lookRight","lookUp","lookDown","lookScratchQuaternion","lookScratchMatrix","axis","angle","turnAngle","quaternion","fromAxisAngle","rotation","twistLeft","twistRight","rotateScratchQuaternion","rotateScratchMatrix","rotate","rotateDown","rotateVertical","rotateUp","rotateVertScratchP","rotateVertScratchA","rotateVertScratchTan","rotateVertScratchNegate","p","northParallel","southParallel","negate","angleToAxis","EPSILON4","tangent","rotateRight","rotateHorizontal","rotateLeft","newTop","newBottom","maxBottom","maxRight","zoom3D","zoomIn","zoomOut","getMagnitude","scratchLookAtMatrix4","lookAt","target","offset","default","lookAtTransform","scratchLookAtHeadingPitchRangeOffset","scratchLookAtHeadingPitchRangeQuaternion1","scratchLookAtHeadingPitchRangeQuaternion2","scratchHeadingPitchRangeMatrix3","offsetFromHeadingPitchRange","range","clamp","pitchQuat","headingQuat","rotMatrix","cartesianOffset","viewRectangle3DCartographic1","viewRectangle3DCartographic2","viewRectangle3DNorthEast","viewRectangle3DSouthWest","viewRectangle3DNorthWest","viewRectangle3DSouthEast","viewRectangle3DNorthCenter","viewRectangle3DSouthCenter","viewRectangle3DCenter","viewRectangle3DEquator","defaultRF","viewRectangle3DEllipsoidGeodesic","computeD","upOrRight","corner","tanThetaOrPhi","opposite","rectangle","updateCamera","cameraRF","north","south","east","longitude","latitude","RADIANS_PER_DEGREE","northCartographic","southCartographic","ellipsoidGeodesic","setEndPoints","interpolateUsingFraction","centerCartographic","center","cartographicToCartesian","cart","northEast","northWest","northCenter","southCenter","southEast","southWest","geodeticSurfaceNormal","d","rightScalar","topScalar","offCenterFrustum","_offCenterFrustum","heightRatio","tanPhi","tan","tanTheta","equatorCartographic","equatorPosition","viewRectangleCVCartographic","viewRectangleCVNorthEast","viewRectangleCVSouthWest","rectangleCameraPositionColumbusView","MAX_VALUE","viewRectangle2DCartographic","viewRectangle2DNorthEast","viewRectangle2DSouthWest","rectangleCameraPosition2D","INFINITE_SCROLL","pickEllipsoid3DRay","pickEllipsoid3D","windowPosition","intersection","rayEllipsoid","t","start","stop","getPoint","pickEllipsoid2DRay","pickMap2D","fromElements","pickEllipsoidCVRay","pickMapColumbusView","pickEllipsoid","canvas","clientWidth","clientHeight","pickPerspCenter","pickPerspXDir","pickPerspYDir","getPickRayPerspective","near","nearCenter","xDir","yDir","scratchDirection","getPickRayOrthographic","scratchToCenter","scratchProj","distanceToBoundingSphere","boundingSphere","toCenter","proj","radius","scratchPixelSize","getPixelSize","pixelSize","getPixelDimensions","pixelRatio","createAnimationTemplateCV","maxY","newPosition","updateCV","value","interp","lerp","time","easingFunction","EXPONENTIAL_OUT","startObject","stopObject","normalScratch","centerScratch","posScratch","scratchCartesian3Subtract","createAnimationCV","normal","distToC","dWidth","dHeight","mapWidth","mapHeight","translateX","translateY","createCorrectPositionTween","scratchFlyToDestination","newOptions","complete","cancel","maximumHeight","cancelFlight","cancelTween","completeFlight","isRectangle","setViewOptions","that","flightTween","pitchAdjustHeight","flyOverLongitude","flyOverLongitudeWeight","tweenOptions","createTween","tweens","preloadFlightCamera","preloadFlightCullingVolume","computeCullingVolume","distanceToBoundingSphere3D","distanceToBoundingSphere2D","MINIMUM_ZOOM","adjustBoundingSphereOffset","minimumZoom","screenSpaceCameraController","minimumZoomDistance","maximumZoom","maximumZoomDistance","viewBoundingSphere","scratchflyToBoundingSphereTransform","scratchflyToBoundingSphereDestination","scratchflyToBoundingSphereDirection","scratchflyToBoundingSphereUp","scratchflyToBoundingSphereRight","scratchFlyToBoundingSphereCart4","scratchFlyToBoundingSphereQuaternion","scratchFlyToBoundingSphereMatrix3","flyToBoundingSphere","scene2D","EPSILON6","rotateQuat","fromCartesian4","scratchCartesian3_1","scratchCartesian3_2","scratchCartesian3_3","scratchCartesian3_4","horizonPoints","computeHorizonQuad","radii","q","multiplyComponents","oneOverRadii","qMagnitude","qUnit","eUnit","nUnit","wMagnitude","sqrt","eastOffset","northOffset","upperLeft","lowerLeft","lowerRight","upperRight","scratchPickCartesian2","scratchRectCartesian","cartoArray","addToResult","index","computedHorizonQuad","r","computeViewRectangle","cullingVolume","visibility","computeVisibility","OUTSIDE","successfulPickCount","fromCartographicArray","lastLon","i","lon","diff","EPSILON9","switchToPerspectiveFrustum","switchToOrthographicFrustum","frustumWidth"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Camera.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidGeodesic from \"../Core/EllipsoidGeodesic.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport HeadingPitchRange from \"../Core/HeadingPitchRange.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraFlightPath from \"./CameraFlightPath.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * @typedef {object} DirectionUp\n *\n * An orientation given by a pair of unit vectors\n *\n * @property {Cartesian3} direction The unit \"direction\" vector\n * @property {Cartesian3} up The unit \"up\" vector\n **/\n/**\n * @typedef {object} HeadingPitchRollValues\n *\n * An orientation given by numeric heading, pitch, and roll\n *\n * @property {number} [heading=0.0] The heading in radians\n * @property {number} [pitch=-CesiumMath.PI_OVER_TWO] The pitch in radians\n * @property {number} [roll=0.0] The roll in radians\n **/\n\n/**\n * The camera is defined by a position, orientation, and view frustum.\n * <br /><br />\n * The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.\n * <br /><br />\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias Camera\n *\n * @constructor\n *\n * @param {Scene} scene The scene.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera.html|Cesium Sandcastle Camera Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera%20Tutorial.html|Cesium Sandcastle Camera Tutorial Example}\n * @demo {@link https://cesium.com/learn/cesiumjs-learn/cesiumjs-camera|Camera Tutorial}\n *\n * @example\n * // Create a camera looking down the negative z-axis, positioned at the origin,\n * // with a field of view of 60 degrees, and 1:1 aspect ratio.\n * const camera = new Cesium.Camera(scene);\n * camera.position = new Cesium.Cartesian3();\n * camera.direction = Cesium.Cartesian3.negate(Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());\n * camera.up = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Y);\n * camera.frustum.fov = Cesium.Math.PI_OVER_THREE;\n * camera.frustum.near = 1.0;\n * camera.frustum.far = 2.0;\n */\nfunction Camera(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n  this._scene = scene;\n\n  this._transform = Matrix4.clone(Matrix4.IDENTITY);\n  this._invTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._actualTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._actualInvTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._transformChanged = false;\n\n  /**\n   * The position of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.position = new Cartesian3();\n  this._position = new Cartesian3();\n  this._positionWC = new Cartesian3();\n  this._positionCartographic = new Cartographic();\n  this._oldPositionWC = undefined;\n\n  /**\n   * The position delta magnitude.\n   *\n   * @private\n   */\n  this.positionWCDeltaMagnitude = 0.0;\n\n  /**\n   * The position delta magnitude last frame.\n   *\n   * @private\n   */\n  this.positionWCDeltaMagnitudeLastFrame = 0.0;\n\n  /**\n   * How long in seconds since the camera has stopped moving\n   *\n   * @private\n   */\n  this.timeSinceMoved = 0.0;\n  this._lastMovedTimestamp = 0.0;\n\n  /**\n   * The view direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.direction = new Cartesian3();\n  this._direction = new Cartesian3();\n  this._directionWC = new Cartesian3();\n\n  /**\n   * The up direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.up = new Cartesian3();\n  this._up = new Cartesian3();\n  this._upWC = new Cartesian3();\n\n  /**\n   * The right direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.right = new Cartesian3();\n  this._right = new Cartesian3();\n  this._rightWC = new Cartesian3();\n\n  /**\n   * The region of space in view.\n   *\n   * @type {PerspectiveFrustum|PerspectiveOffCenterFrustum|OrthographicFrustum}\n   * @default PerspectiveFrustum()\n   *\n   * @see PerspectiveFrustum\n   * @see PerspectiveOffCenterFrustum\n   * @see OrthographicFrustum\n   */\n  this.frustum = new PerspectiveFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = CesiumMath.toRadians(60.0);\n\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the move methods.\n   * @type {number}\n   * @default 100000.0;\n   */\n  this.defaultMoveAmount = 100000.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the look methods.\n   * @type {number}\n   * @default Math.PI / 60.0\n   */\n  this.defaultLookAmount = Math.PI / 60.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the rotate methods.\n   * @type {number}\n   * @default Math.PI / 3600.0\n   */\n  this.defaultRotateAmount = Math.PI / 3600.0;\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the zoom methods.\n   * @type {number}\n   * @default 100000.0;\n   */\n  this.defaultZoomAmount = 100000.0;\n  /**\n   * If set, the camera will not be able to rotate past this axis in either direction.\n   * @type {Cartesian3 | undefined}\n   * @default undefined\n   */\n  this.constrainedAxis = undefined;\n  /**\n   * The factor multiplied by the the map size used to determine where to clamp the camera position\n   * when zooming out from the surface. The default is 1.5. Only valid for 2D and the map is rotatable.\n   * @type {number}\n   * @default 1.5\n   */\n  this.maximumZoomFactor = 1.5;\n\n  this._moveStart = new Event();\n  this._moveEnd = new Event();\n\n  this._changed = new Event();\n  this._changedPosition = undefined;\n  this._changedDirection = undefined;\n  this._changedFrustum = undefined;\n  this._changedHeading = undefined;\n  this._changedRoll = undefined;\n\n  /**\n   * The amount the camera has to change before the <code>changed</code> event is raised. The value is a percentage in the [0, 1] range.\n   * @type {number}\n   * @default 0.5\n   */\n  this.percentageChanged = 0.5;\n\n  this._viewMatrix = new Matrix4();\n  this._invViewMatrix = new Matrix4();\n  updateViewMatrix(this);\n\n  this._mode = SceneMode.SCENE3D;\n  this._modeChanged = true;\n  const projection = scene.mapProjection;\n  this._projection = projection;\n  this._maxCoord = projection.project(\n    new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO),\n  );\n  this._max2Dfrustum = undefined;\n\n  // set default view\n  rectangleCameraPosition3D(\n    this,\n    Camera.DEFAULT_VIEW_RECTANGLE,\n    this.position,\n    true,\n  );\n\n  let mag = Cartesian3.magnitude(this.position);\n  mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n  Cartesian3.normalize(this.position, this.position);\n  Cartesian3.multiplyByScalar(this.position, mag, this.position);\n}\n\n/**\n * @private\n */\nCamera.TRANSFORM_2D = new Matrix4(\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0,\n);\n\n/**\n * @private\n */\nCamera.TRANSFORM_2D_INVERSE = Matrix4.inverseTransformation(\n  Camera.TRANSFORM_2D,\n  new Matrix4(),\n);\n\n/**\n * The default rectangle the camera will view on creation.\n * @type Rectangle\n */\nCamera.DEFAULT_VIEW_RECTANGLE = Rectangle.fromDegrees(\n  -95.0,\n  -20.0,\n  -70.0,\n  90.0,\n);\n\n/**\n * A scalar to multiply to the camera position and add it back after setting the camera to view the rectangle.\n * A value of zero means the camera will view the entire {@link Camera#DEFAULT_VIEW_RECTANGLE}, a value greater than zero\n * will move it further away from the extent, and a value less than zero will move it close to the extent.\n * @type {number}\n */\nCamera.DEFAULT_VIEW_FACTOR = 0.5;\n\n/**\n * The default heading/pitch/range that is used when the camera flies to a location that contains a bounding sphere.\n * @type HeadingPitchRange\n */\nCamera.DEFAULT_OFFSET = new HeadingPitchRange(\n  0.0,\n  -CesiumMath.PI_OVER_FOUR,\n  0.0,\n);\n\nfunction updateViewMatrix(camera) {\n  Matrix4.computeView(\n    camera._position,\n    camera._direction,\n    camera._up,\n    camera._right,\n    camera._viewMatrix,\n  );\n  Matrix4.multiply(\n    camera._viewMatrix,\n    camera._actualInvTransform,\n    camera._viewMatrix,\n  );\n  Matrix4.inverseTransformation(camera._viewMatrix, camera._invViewMatrix);\n}\n\nfunction updateCameraDeltas(camera) {\n  if (!defined(camera._oldPositionWC)) {\n    camera._oldPositionWC = Cartesian3.clone(\n      camera.positionWC,\n      camera._oldPositionWC,\n    );\n  } else {\n    camera.positionWCDeltaMagnitudeLastFrame = camera.positionWCDeltaMagnitude;\n    const delta = Cartesian3.subtract(\n      camera.positionWC,\n      camera._oldPositionWC,\n      camera._oldPositionWC,\n    );\n    camera.positionWCDeltaMagnitude = Cartesian3.magnitude(delta);\n    camera._oldPositionWC = Cartesian3.clone(\n      camera.positionWC,\n      camera._oldPositionWC,\n    );\n\n    // Update move timers\n    if (camera.positionWCDeltaMagnitude > 0.0) {\n      camera.timeSinceMoved = 0.0;\n      camera._lastMovedTimestamp = getTimestamp();\n    } else {\n      camera.timeSinceMoved =\n        Math.max(getTimestamp() - camera._lastMovedTimestamp, 0.0) / 1000.0;\n    }\n  }\n}\n\n/**\n * Checks if there's a camera flight with preload for this camera.\n *\n * @returns {boolean} Whether or not this camera has a current flight with a valid preloadFlightCamera in scene.\n *\n * @private\n *\n */\nCamera.prototype.canPreloadFlight = function () {\n  return defined(this._currentFlight) && this._mode !== SceneMode.SCENE2D;\n};\n\nCamera.prototype._updateCameraChanged = function () {\n  const camera = this;\n\n  updateCameraDeltas(camera);\n\n  if (camera._changed.numberOfListeners === 0) {\n    return;\n  }\n\n  const percentageChanged = camera.percentageChanged;\n\n  // check heading\n  const currentHeading = camera.heading;\n\n  if (!defined(camera._changedHeading)) {\n    camera._changedHeading = currentHeading;\n  }\n\n  let headingDelta =\n    Math.abs(camera._changedHeading - currentHeading) % CesiumMath.TWO_PI;\n  headingDelta =\n    headingDelta > CesiumMath.PI\n      ? CesiumMath.TWO_PI - headingDelta\n      : headingDelta;\n\n  // Since delta is computed as the shortest distance between two angles\n  // the percentage is relative to the half circle.\n  const headingChangedPercentage = headingDelta / Math.PI;\n\n  if (headingChangedPercentage > percentageChanged) {\n    camera._changedHeading = currentHeading;\n  }\n\n  // check roll\n  const currentRoll = camera.roll;\n\n  if (!defined(camera._changedRoll)) {\n    camera._changedRoll = currentRoll;\n  }\n\n  let rollDelta =\n    Math.abs(camera._changedRoll - currentRoll) % CesiumMath.TWO_PI;\n  rollDelta =\n    rollDelta > CesiumMath.PI ? CesiumMath.TWO_PI - rollDelta : rollDelta;\n\n  // Since delta is computed as the shortest distance between two angles\n  // the percentage is relative to the half circle.\n  const rollChangedPercentage = rollDelta / Math.PI;\n\n  if (rollChangedPercentage > percentageChanged) {\n    camera._changedRoll = currentRoll;\n  }\n  if (\n    rollChangedPercentage > percentageChanged ||\n    headingChangedPercentage > percentageChanged\n  ) {\n    camera._changed.raiseEvent(\n      Math.max(rollChangedPercentage, headingChangedPercentage),\n    );\n  }\n  if (camera._mode === SceneMode.SCENE2D) {\n    if (!defined(camera._changedFrustum)) {\n      camera._changedPosition = Cartesian3.clone(\n        camera.position,\n        camera._changedPosition,\n      );\n      camera._changedFrustum = camera.frustum.clone();\n      return;\n    }\n\n    const position = camera.position;\n    const lastPosition = camera._changedPosition;\n\n    const frustum = camera.frustum;\n    const lastFrustum = camera._changedFrustum;\n\n    const x0 = position.x + frustum.left;\n    const x1 = position.x + frustum.right;\n    const x2 = lastPosition.x + lastFrustum.left;\n    const x3 = lastPosition.x + lastFrustum.right;\n\n    const y0 = position.y + frustum.bottom;\n    const y1 = position.y + frustum.top;\n    const y2 = lastPosition.y + lastFrustum.bottom;\n    const y3 = lastPosition.y + lastFrustum.top;\n\n    const leftX = Math.max(x0, x2);\n    const rightX = Math.min(x1, x3);\n    const bottomY = Math.max(y0, y2);\n    const topY = Math.min(y1, y3);\n\n    let areaPercentage;\n    if (leftX >= rightX || bottomY >= y1) {\n      areaPercentage = 1.0;\n    } else {\n      let areaRef = lastFrustum;\n      if (x0 < x2 && x1 > x3 && y0 < y2 && y1 > y3) {\n        areaRef = frustum;\n      }\n      areaPercentage =\n        1.0 -\n        ((rightX - leftX) * (topY - bottomY)) /\n          ((areaRef.right - areaRef.left) * (areaRef.top - areaRef.bottom));\n    }\n\n    if (areaPercentage > percentageChanged) {\n      camera._changed.raiseEvent(areaPercentage);\n      camera._changedPosition = Cartesian3.clone(\n        camera.position,\n        camera._changedPosition,\n      );\n      camera._changedFrustum = camera.frustum.clone(camera._changedFrustum);\n    }\n    return;\n  }\n\n  if (!defined(camera._changedDirection)) {\n    camera._changedPosition = Cartesian3.clone(\n      camera.positionWC,\n      camera._changedPosition,\n    );\n    camera._changedDirection = Cartesian3.clone(\n      camera.directionWC,\n      camera._changedDirection,\n    );\n    return;\n  }\n\n  const dirAngle = CesiumMath.acosClamped(\n    Cartesian3.dot(camera.directionWC, camera._changedDirection),\n  );\n\n  let dirPercentage;\n  if (defined(camera.frustum.fovy)) {\n    dirPercentage = dirAngle / (camera.frustum.fovy * 0.5);\n  } else {\n    dirPercentage = dirAngle;\n  }\n\n  const distance = Cartesian3.distance(\n    camera.positionWC,\n    camera._changedPosition,\n  );\n  const heightPercentage = distance / camera.positionCartographic.height;\n\n  if (\n    dirPercentage > percentageChanged ||\n    heightPercentage > percentageChanged\n  ) {\n    camera._changed.raiseEvent(Math.max(dirPercentage, heightPercentage));\n    camera._changedPosition = Cartesian3.clone(\n      camera.positionWC,\n      camera._changedPosition,\n    );\n    camera._changedDirection = Cartesian3.clone(\n      camera.directionWC,\n      camera._changedDirection,\n    );\n  }\n};\n\nfunction convertTransformForColumbusView(camera) {\n  Transforms.basisTo2D(\n    camera._projection,\n    camera._transform,\n    camera._actualTransform,\n  );\n}\n\nconst scratchCartographic = new Cartographic();\nconst scratchCartesian3Projection = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4Origin = new Cartesian4();\nconst scratchCartesian4NewOrigin = new Cartesian4();\nconst scratchCartesian4NewXAxis = new Cartesian4();\nconst scratchCartesian4NewYAxis = new Cartesian4();\nconst scratchCartesian4NewZAxis = new Cartesian4();\n\nfunction convertTransformFor2D(camera) {\n  const projection = camera._projection;\n  const ellipsoid = projection.ellipsoid;\n\n  const origin = Matrix4.getColumn(\n    camera._transform,\n    3,\n    scratchCartesian4Origin,\n  );\n  const cartographic = ellipsoid.cartesianToCartographic(\n    origin,\n    scratchCartographic,\n  );\n\n  const projectedPosition = projection.project(\n    cartographic,\n    scratchCartesian3Projection,\n  );\n  const newOrigin = scratchCartesian4NewOrigin;\n  newOrigin.x = projectedPosition.z;\n  newOrigin.y = projectedPosition.x;\n  newOrigin.z = projectedPosition.y;\n  newOrigin.w = 1.0;\n\n  const newZAxis = Cartesian4.clone(\n    Cartesian4.UNIT_X,\n    scratchCartesian4NewZAxis,\n  );\n\n  const xAxis = Cartesian4.add(\n    Matrix4.getColumn(camera._transform, 0, scratchCartesian3),\n    origin,\n    scratchCartesian3,\n  );\n  ellipsoid.cartesianToCartographic(xAxis, cartographic);\n\n  projection.project(cartographic, projectedPosition);\n  const newXAxis = scratchCartesian4NewXAxis;\n  newXAxis.x = projectedPosition.z;\n  newXAxis.y = projectedPosition.x;\n  newXAxis.z = projectedPosition.y;\n  newXAxis.w = 0.0;\n\n  Cartesian3.subtract(newXAxis, newOrigin, newXAxis);\n  newXAxis.x = 0.0;\n\n  const newYAxis = scratchCartesian4NewYAxis;\n  if (Cartesian3.magnitudeSquared(newXAxis) > CesiumMath.EPSILON10) {\n    Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  } else {\n    const yAxis = Cartesian4.add(\n      Matrix4.getColumn(camera._transform, 1, scratchCartesian3),\n      origin,\n      scratchCartesian3,\n    );\n    ellipsoid.cartesianToCartographic(yAxis, cartographic);\n\n    projection.project(cartographic, projectedPosition);\n    newYAxis.x = projectedPosition.z;\n    newYAxis.y = projectedPosition.x;\n    newYAxis.z = projectedPosition.y;\n    newYAxis.w = 0.0;\n\n    Cartesian3.subtract(newYAxis, newOrigin, newYAxis);\n    newYAxis.x = 0.0;\n\n    if (Cartesian3.magnitudeSquared(newYAxis) < CesiumMath.EPSILON10) {\n      Cartesian4.clone(Cartesian4.UNIT_Y, newXAxis);\n      Cartesian4.clone(Cartesian4.UNIT_Z, newYAxis);\n    }\n  }\n\n  Cartesian3.cross(newYAxis, newZAxis, newXAxis);\n  Cartesian3.normalize(newXAxis, newXAxis);\n  Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  Cartesian3.normalize(newYAxis, newYAxis);\n\n  Matrix4.setColumn(\n    camera._actualTransform,\n    0,\n    newXAxis,\n    camera._actualTransform,\n  );\n  Matrix4.setColumn(\n    camera._actualTransform,\n    1,\n    newYAxis,\n    camera._actualTransform,\n  );\n  Matrix4.setColumn(\n    camera._actualTransform,\n    2,\n    newZAxis,\n    camera._actualTransform,\n  );\n  Matrix4.setColumn(\n    camera._actualTransform,\n    3,\n    newOrigin,\n    camera._actualTransform,\n  );\n}\n\nconst scratchCartesian = new Cartesian3();\n\nfunction updateMembers(camera) {\n  const mode = camera._mode;\n\n  let heightChanged = false;\n  let height = 0.0;\n  if (mode === SceneMode.SCENE2D) {\n    height = camera.frustum.right - camera.frustum.left;\n    heightChanged = height !== camera._positionCartographic.height;\n  }\n\n  let position = camera._position;\n  const positionChanged =\n    !Cartesian3.equals(position, camera.position) || heightChanged;\n  if (positionChanged) {\n    position = Cartesian3.clone(camera.position, camera._position);\n  }\n\n  let direction = camera._direction;\n  const directionChanged = !Cartesian3.equals(direction, camera.direction);\n  if (directionChanged) {\n    Cartesian3.normalize(camera.direction, camera.direction);\n    direction = Cartesian3.clone(camera.direction, camera._direction);\n  }\n\n  let up = camera._up;\n  const upChanged = !Cartesian3.equals(up, camera.up);\n  if (upChanged) {\n    Cartesian3.normalize(camera.up, camera.up);\n    up = Cartesian3.clone(camera.up, camera._up);\n  }\n\n  let right = camera._right;\n  const rightChanged = !Cartesian3.equals(right, camera.right);\n  if (rightChanged) {\n    Cartesian3.normalize(camera.right, camera.right);\n    right = Cartesian3.clone(camera.right, camera._right);\n  }\n\n  const transformChanged = camera._transformChanged || camera._modeChanged;\n  camera._transformChanged = false;\n\n  if (transformChanged) {\n    Matrix4.inverseTransformation(camera._transform, camera._invTransform);\n\n    if (\n      camera._mode === SceneMode.COLUMBUS_VIEW ||\n      camera._mode === SceneMode.SCENE2D\n    ) {\n      if (Matrix4.equals(Matrix4.IDENTITY, camera._transform)) {\n        Matrix4.clone(Camera.TRANSFORM_2D, camera._actualTransform);\n      } else if (camera._mode === SceneMode.COLUMBUS_VIEW) {\n        convertTransformForColumbusView(camera);\n      } else {\n        convertTransformFor2D(camera);\n      }\n    } else {\n      Matrix4.clone(camera._transform, camera._actualTransform);\n    }\n\n    Matrix4.inverseTransformation(\n      camera._actualTransform,\n      camera._actualInvTransform,\n    );\n\n    camera._modeChanged = false;\n  }\n\n  const transform = camera._actualTransform;\n\n  if (positionChanged || transformChanged) {\n    camera._positionWC = Matrix4.multiplyByPoint(\n      transform,\n      position,\n      camera._positionWC,\n    );\n\n    // Compute the Cartographic position of the camera.\n    if (mode === SceneMode.SCENE3D || mode === SceneMode.MORPHING) {\n      camera._positionCartographic =\n        camera._projection.ellipsoid.cartesianToCartographic(\n          camera._positionWC,\n          camera._positionCartographic,\n        );\n    } else {\n      // The camera position is expressed in the 2D coordinate system where the Y axis is to the East,\n      // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where\n      // X is to the East, Y is to the North, and Z is out of the local horizontal plane.\n      const positionENU = scratchCartesian;\n      positionENU.x = camera._positionWC.y;\n      positionENU.y = camera._positionWC.z;\n      positionENU.z = camera._positionWC.x;\n\n      // In 2D, the camera height is always 12.7 million meters.\n      // The apparent height is equal to half the frustum width.\n      if (mode === SceneMode.SCENE2D) {\n        positionENU.z = height;\n      }\n\n      camera._projection.unproject(positionENU, camera._positionCartographic);\n    }\n  }\n\n  if (directionChanged || upChanged || rightChanged) {\n    const det = Cartesian3.dot(\n      direction,\n      Cartesian3.cross(up, right, scratchCartesian),\n    );\n    if (Math.abs(1.0 - det) > CesiumMath.EPSILON2) {\n      //orthonormalize axes\n      const invUpMag = 1.0 / Cartesian3.magnitudeSquared(up);\n      const scalar = Cartesian3.dot(up, direction) * invUpMag;\n      const w0 = Cartesian3.multiplyByScalar(\n        direction,\n        scalar,\n        scratchCartesian,\n      );\n      up = Cartesian3.normalize(\n        Cartesian3.subtract(up, w0, camera._up),\n        camera._up,\n      );\n      Cartesian3.clone(up, camera.up);\n\n      right = Cartesian3.cross(direction, up, camera._right);\n      Cartesian3.clone(right, camera.right);\n    }\n  }\n\n  if (directionChanged || transformChanged) {\n    camera._directionWC = Matrix4.multiplyByPointAsVector(\n      transform,\n      direction,\n      camera._directionWC,\n    );\n    Cartesian3.normalize(camera._directionWC, camera._directionWC);\n  }\n\n  if (upChanged || transformChanged) {\n    camera._upWC = Matrix4.multiplyByPointAsVector(transform, up, camera._upWC);\n    Cartesian3.normalize(camera._upWC, camera._upWC);\n  }\n\n  if (rightChanged || transformChanged) {\n    camera._rightWC = Matrix4.multiplyByPointAsVector(\n      transform,\n      right,\n      camera._rightWC,\n    );\n    Cartesian3.normalize(camera._rightWC, camera._rightWC);\n  }\n\n  if (\n    positionChanged ||\n    directionChanged ||\n    upChanged ||\n    rightChanged ||\n    transformChanged\n  ) {\n    updateViewMatrix(camera);\n  }\n}\n\nfunction getHeading(direction, up) {\n  let heading;\n  if (\n    !CesiumMath.equalsEpsilon(Math.abs(direction.z), 1.0, CesiumMath.EPSILON3)\n  ) {\n    heading = Math.atan2(direction.y, direction.x) - CesiumMath.PI_OVER_TWO;\n  } else {\n    heading = Math.atan2(up.y, up.x) - CesiumMath.PI_OVER_TWO;\n  }\n\n  return CesiumMath.TWO_PI - CesiumMath.zeroToTwoPi(heading);\n}\n\nfunction getPitch(direction) {\n  return CesiumMath.PI_OVER_TWO - CesiumMath.acosClamped(direction.z);\n}\n\nfunction getRoll(direction, up, right) {\n  let roll = 0.0;\n  if (\n    !CesiumMath.equalsEpsilon(Math.abs(direction.z), 1.0, CesiumMath.EPSILON3)\n  ) {\n    roll = Math.atan2(-right.z, up.z);\n    roll = CesiumMath.zeroToTwoPi(roll + CesiumMath.TWO_PI);\n  }\n\n  return roll;\n}\n\nconst scratchHPRMatrix1 = new Matrix4();\nconst scratchHPRMatrix2 = new Matrix4();\n\nObject.defineProperties(Camera.prototype, {\n  /**\n   * Gets the camera's reference frame. The inverse of this transformation is appended to the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  transform: {\n    get: function () {\n      return this._transform;\n    },\n  },\n\n  /**\n   * Gets the inverse camera transform.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  inverseTransform: {\n    get: function () {\n      updateMembers(this);\n      return this._invTransform;\n    },\n  },\n\n  /**\n   * Gets the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#inverseViewMatrix\n   */\n  viewMatrix: {\n    get: function () {\n      updateMembers(this);\n      return this._viewMatrix;\n    },\n  },\n\n  /**\n   * Gets the inverse view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#viewMatrix\n   */\n  inverseViewMatrix: {\n    get: function () {\n      updateMembers(this);\n      return this._invViewMatrix;\n    },\n  },\n\n  /**\n   * Gets the {@link Cartographic} position of the camera, with longitude and latitude\n   * expressed in radians and height in meters.  In 2D and Columbus View, it is possible\n   * for the returned longitude and latitude to be outside the range of valid longitudes\n   * and latitudes when the camera is outside the map.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartographic}\n   * @readonly\n   */\n  positionCartographic: {\n    get: function () {\n      updateMembers(this);\n      return this._positionCartographic;\n    },\n  },\n\n  /**\n   * Gets the position of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  positionWC: {\n    get: function () {\n      updateMembers(this);\n      return this._positionWC;\n    },\n  },\n\n  /**\n   * Gets the view direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  directionWC: {\n    get: function () {\n      updateMembers(this);\n      return this._directionWC;\n    },\n  },\n\n  /**\n   * Gets the up direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  upWC: {\n    get: function () {\n      updateMembers(this);\n      return this._upWC;\n    },\n  },\n\n  /**\n   * Gets the right direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  rightWC: {\n    get: function () {\n      updateMembers(this);\n      return this._rightWC;\n    },\n  },\n\n  /**\n   * Gets the camera heading in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  heading: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        const ellipsoid = this._projection.ellipsoid;\n\n        const oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        const transform = Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2,\n        );\n        this._setTransform(transform);\n\n        const heading = getHeading(this.direction, this.up);\n\n        this._setTransform(oldTransform);\n\n        return heading;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the camera pitch in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  pitch: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        const ellipsoid = this._projection.ellipsoid;\n\n        const oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        const transform = Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2,\n        );\n        this._setTransform(transform);\n\n        const pitch = getPitch(this.direction);\n\n        this._setTransform(oldTransform);\n\n        return pitch;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the camera roll in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {number}\n   * @readonly\n   */\n  roll: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        const ellipsoid = this._projection.ellipsoid;\n\n        const oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        const transform = Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2,\n        );\n        this._setTransform(transform);\n\n        const roll = getRoll(this.direction, this.up, this.right);\n\n        this._setTransform(oldTransform);\n\n        return roll;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised at when the camera starts to move.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveStart: {\n    get: function () {\n      return this._moveStart;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised when the camera has stopped moving.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveEnd: {\n    get: function () {\n      return this._moveEnd;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised when the camera has changed by <code>percentageChanged</code>.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  changed: {\n    get: function () {\n      return this._changed;\n    },\n  },\n});\n\n/**\n * @private\n */\nCamera.prototype.update = function (mode) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(mode)) {\n    throw new DeveloperError(\"mode is required.\");\n  }\n  if (\n    mode === SceneMode.SCENE2D &&\n    !(this.frustum instanceof OrthographicOffCenterFrustum)\n  ) {\n    throw new DeveloperError(\n      \"An OrthographicOffCenterFrustum is required in 2D.\",\n    );\n  }\n  if (\n    (mode === SceneMode.SCENE3D || mode === SceneMode.COLUMBUS_VIEW) &&\n    !(this.frustum instanceof PerspectiveFrustum) &&\n    !(this.frustum instanceof OrthographicFrustum)\n  ) {\n    throw new DeveloperError(\n      \"A PerspectiveFrustum or OrthographicFrustum is required in 3D and Columbus view\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  let updateFrustum = false;\n  if (mode !== this._mode) {\n    this._mode = mode;\n    this._modeChanged = mode !== SceneMode.MORPHING;\n    updateFrustum = this._mode === SceneMode.SCENE2D;\n  }\n\n  if (updateFrustum) {\n    const frustum = (this._max2Dfrustum = this.frustum.clone());\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!(frustum instanceof OrthographicOffCenterFrustum)) {\n      throw new DeveloperError(\n        \"The camera frustum is expected to be orthographic for 2D camera control.\",\n      );\n    }\n    //>>includeEnd('debug');\n\n    const maxZoomOut = 2.0;\n    const ratio = frustum.top / frustum.right;\n    frustum.right = this._maxCoord.x * maxZoomOut;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n  }\n\n  if (this._mode === SceneMode.SCENE2D) {\n    clampMove2D(this, this.position);\n  }\n};\n\nconst setTransformPosition = new Cartesian3();\nconst setTransformUp = new Cartesian3();\nconst setTransformDirection = new Cartesian3();\n\nCamera.prototype._setTransform = function (transform) {\n  const position = Cartesian3.clone(this.positionWC, setTransformPosition);\n  const up = Cartesian3.clone(this.upWC, setTransformUp);\n  const direction = Cartesian3.clone(this.directionWC, setTransformDirection);\n\n  Matrix4.clone(transform, this._transform);\n  this._transformChanged = true;\n  updateMembers(this);\n  const inverse = this._actualInvTransform;\n\n  Matrix4.multiplyByPoint(inverse, position, this.position);\n  Matrix4.multiplyByPointAsVector(inverse, direction, this.direction);\n  Matrix4.multiplyByPointAsVector(inverse, up, this.up);\n  Cartesian3.cross(this.direction, this.up, this.right);\n\n  updateMembers(this);\n};\n\nconst scratchAdjustOrthographicFrustumMousePosition = new Cartesian2();\nconst scratchPickRay = new Ray();\nconst scratchRayIntersection = new Cartesian3();\nconst scratchDepthIntersection = new Cartesian3();\n\nfunction calculateOrthographicFrustumWidth(camera) {\n  // Camera is fixed to an object, so keep frustum width constant.\n  if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {\n    return Cartesian3.magnitude(camera.position);\n  }\n\n  const scene = camera._scene;\n  const globe = scene.globe;\n\n  const mousePosition = scratchAdjustOrthographicFrustumMousePosition;\n  mousePosition.x = scene.drawingBufferWidth / 2.0;\n  mousePosition.y = scene.drawingBufferHeight / 2.0;\n\n  let rayIntersection;\n  if (defined(globe)) {\n    const ray = camera.getPickRay(mousePosition, scratchPickRay);\n    rayIntersection = globe.pickWorldCoordinates(\n      ray,\n      scene,\n      true,\n      scratchRayIntersection,\n    );\n  }\n\n  let depthIntersection;\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(\n      mousePosition,\n      scratchDepthIntersection,\n    );\n  }\n\n  let distance;\n  if (defined(rayIntersection) || defined(depthIntersection)) {\n    const depthDistance = defined(depthIntersection)\n      ? Cartesian3.distance(depthIntersection, camera.positionWC)\n      : Number.POSITIVE_INFINITY;\n    const rayDistance = defined(rayIntersection)\n      ? Cartesian3.distance(rayIntersection, camera.positionWC)\n      : Number.POSITIVE_INFINITY;\n    distance = Math.min(depthDistance, rayDistance);\n  } else {\n    distance = Math.max(camera.positionCartographic.height, 0.0);\n  }\n  return distance;\n}\n\nCamera.prototype._adjustOrthographicFrustum = function (zooming) {\n  if (!(this.frustum instanceof OrthographicFrustum)) {\n    return;\n  }\n\n  if (!zooming && this._positionCartographic.height < 150000.0) {\n    return;\n  }\n\n  this.frustum.width = calculateOrthographicFrustumWidth(this);\n};\n\nconst scratchSetViewCartesian = new Cartesian3();\nconst scratchSetViewTransform1 = new Matrix4();\nconst scratchSetViewTransform2 = new Matrix4();\nconst scratchSetViewQuaternion = new Quaternion();\nconst scratchSetViewMatrix3 = new Matrix3();\nconst scratchSetViewCartographic = new Cartographic();\n\nfunction setView3D(camera, position, hpr) {\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(position.x) || isNaN(position.y) || isNaN(position.z)) {\n    throw new DeveloperError(\"position has a NaN component\");\n  }\n  //>>includeEnd('debug');\n  const currentTransform = Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1,\n  );\n  const localTransform = Transforms.eastNorthUpToFixedFrame(\n    position,\n    camera._projection.ellipsoid,\n    scratchSetViewTransform2,\n  );\n  camera._setTransform(localTransform);\n\n  Cartesian3.clone(Cartesian3.ZERO, camera.position);\n  hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n\n  const rotQuat = Quaternion.fromHeadingPitchRoll(\n    hpr,\n    scratchSetViewQuaternion,\n  );\n  const rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n  Matrix3.getColumn(rotMat, 0, camera.direction);\n  Matrix3.getColumn(rotMat, 2, camera.up);\n  Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n  camera._setTransform(currentTransform);\n\n  camera._adjustOrthographicFrustum(true);\n}\n\nfunction setViewCV(camera, position, hpr, convert) {\n  const currentTransform = Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1,\n  );\n  camera._setTransform(Matrix4.IDENTITY);\n\n  if (!Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      const projection = camera._projection;\n      const cartographic = projection.ellipsoid.cartesianToCartographic(\n        position,\n        scratchSetViewCartographic,\n      );\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n    Cartesian3.clone(position, camera.position);\n  }\n  hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n\n  const rotQuat = Quaternion.fromHeadingPitchRoll(\n    hpr,\n    scratchSetViewQuaternion,\n  );\n  const rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n  Matrix3.getColumn(rotMat, 0, camera.direction);\n  Matrix3.getColumn(rotMat, 2, camera.up);\n  Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n  camera._setTransform(currentTransform);\n\n  camera._adjustOrthographicFrustum(true);\n}\n\nfunction setView2D(camera, position, hpr, convert) {\n  const currentTransform = Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1,\n  );\n  camera._setTransform(Matrix4.IDENTITY);\n\n  if (!Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      const projection = camera._projection;\n      const cartographic = projection.ellipsoid.cartesianToCartographic(\n        position,\n        scratchSetViewCartographic,\n      );\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n\n    Cartesian2.clone(position, camera.position);\n\n    const newLeft = -position.z * 0.5;\n    const newRight = -newLeft;\n\n    const frustum = camera.frustum;\n    if (newRight > newLeft) {\n      const ratio = frustum.top / frustum.right;\n      frustum.right = newRight;\n      frustum.left = newLeft;\n      frustum.top = frustum.right * ratio;\n      frustum.bottom = -frustum.top;\n    }\n  }\n\n  if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n    hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n    hpr.pitch = -CesiumMath.PI_OVER_TWO;\n    hpr.roll = 0.0;\n    const rotQuat = Quaternion.fromHeadingPitchRoll(\n      hpr,\n      scratchSetViewQuaternion,\n    );\n    const rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n    Matrix3.getColumn(rotMat, 2, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n  }\n\n  camera._setTransform(currentTransform);\n}\n\nconst scratchToHPRDirection = new Cartesian3();\nconst scratchToHPRUp = new Cartesian3();\nconst scratchToHPRRight = new Cartesian3();\n\nfunction directionUpToHeadingPitchRoll(camera, position, orientation, result) {\n  const direction = Cartesian3.clone(\n    orientation.direction,\n    scratchToHPRDirection,\n  );\n  const up = Cartesian3.clone(orientation.up, scratchToHPRUp);\n\n  if (camera._scene.mode === SceneMode.SCENE3D) {\n    const ellipsoid = camera._projection.ellipsoid;\n    const transform = Transforms.eastNorthUpToFixedFrame(\n      position,\n      ellipsoid,\n      scratchHPRMatrix1,\n    );\n    const invTransform = Matrix4.inverseTransformation(\n      transform,\n      scratchHPRMatrix2,\n    );\n\n    Matrix4.multiplyByPointAsVector(invTransform, direction, direction);\n    Matrix4.multiplyByPointAsVector(invTransform, up, up);\n  }\n\n  const right = Cartesian3.cross(direction, up, scratchToHPRRight);\n\n  result.heading = getHeading(direction, up);\n  result.pitch = getPitch(direction);\n  result.roll = getRoll(direction, up, right);\n\n  return result;\n}\n\nconst scratchSetViewOptions = {\n  destination: undefined,\n  orientation: {\n    direction: undefined,\n    up: undefined,\n    heading: undefined,\n    pitch: undefined,\n    roll: undefined,\n  },\n  convert: undefined,\n  endTransform: undefined,\n};\n\nconst scratchHpr = new HeadingPitchRoll();\n/**\n * Sets the camera position, orientation and transform.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} [options.destination] The final position of the camera in world coordinates or a rectangle that would be visible from a top-down view.\n * @param {HeadingPitchRollValues|DirectionUp} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view. Orientation is not used in 2D when in infinite scrolling mode.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame of the camera.\n * @param {boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n *\n * @example\n * // 1. Set position with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2 Set view with heading, pitch and roll\n * viewer.camera.setView({\n *     destination : cartesianPosition,\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n * // 3. Change heading, pitch and roll with the camera position remaining the same.\n * viewer.camera.setView({\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n *\n * // 4. View rectangle with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 5. Set position with an orientation using unit vectors.\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n */\nCamera.prototype.setView = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  let orientation = defaultValue(\n    options.orientation,\n    defaultValue.EMPTY_OBJECT,\n  );\n\n  const mode = this._mode;\n  if (mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (defined(options.endTransform)) {\n    this._setTransform(options.endTransform);\n  }\n\n  let convert = defaultValue(options.convert, true);\n  let destination = defaultValue(\n    options.destination,\n    Cartesian3.clone(this.positionWC, scratchSetViewCartesian),\n  );\n  if (defined(destination) && defined(destination.west)) {\n    destination = this.getRectangleCameraCoordinates(\n      destination,\n      scratchSetViewCartesian,\n    );\n    //>>includeStart('debug', pragmas.debug);\n    // destination.z may be null in 2D, but .x and .y should be numeric\n    if (isNaN(destination.x) || isNaN(destination.y)) {\n      throw new DeveloperError(`destination has a NaN component`);\n    }\n    //>>includeEnd('debug');\n    convert = false;\n  }\n\n  if (defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(\n      this,\n      destination,\n      orientation,\n      scratchSetViewOptions.orientation,\n    );\n  }\n\n  scratchHpr.heading = defaultValue(orientation.heading, 0.0);\n  scratchHpr.pitch = defaultValue(orientation.pitch, -CesiumMath.PI_OVER_TWO);\n  scratchHpr.roll = defaultValue(orientation.roll, 0.0);\n\n  if (mode === SceneMode.SCENE3D) {\n    setView3D(this, destination, scratchHpr);\n  } else if (mode === SceneMode.SCENE2D) {\n    setView2D(this, destination, scratchHpr, convert);\n  } else {\n    setViewCV(this, destination, scratchHpr, convert);\n  }\n};\n\nconst pitchScratch = new Cartesian3();\n/**\n * Fly the camera to the home view.  Use {@link Camera#.DEFAULT_VIEW_RECTANGLE} to set\n * the default view for the 3D scene.  The home view for 2D and columbus view shows the\n * entire map.\n *\n * @param {number} [duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight. See {@link Camera#flyTo}\n */\nCamera.prototype.flyHome = function (duration) {\n  const mode = this._mode;\n\n  if (mode === SceneMode.MORPHING) {\n    this._scene.completeMorph();\n  }\n\n  if (mode === SceneMode.SCENE2D) {\n    this.flyTo({\n      destination: Camera.DEFAULT_VIEW_RECTANGLE,\n      duration: duration,\n      endTransform: Matrix4.IDENTITY,\n    });\n  } else if (mode === SceneMode.SCENE3D) {\n    const destination = this.getRectangleCameraCoordinates(\n      Camera.DEFAULT_VIEW_RECTANGLE,\n    );\n\n    let mag = Cartesian3.magnitude(destination);\n    mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n    Cartesian3.normalize(destination, destination);\n    Cartesian3.multiplyByScalar(destination, mag, destination);\n\n    this.flyTo({\n      destination: destination,\n      duration: duration,\n      endTransform: Matrix4.IDENTITY,\n    });\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    const maxRadii = this._projection.ellipsoid.maximumRadius;\n    let position = new Cartesian3(0.0, -1.0, 1.0);\n    position = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(position, position),\n      5.0 * maxRadii,\n      position,\n    );\n    this.flyTo({\n      destination: position,\n      duration: duration,\n      orientation: {\n        heading: 0.0,\n        pitch: -Math.acos(Cartesian3.normalize(position, pitchScratch).z),\n        roll: 0.0,\n      },\n      endTransform: Matrix4.IDENTITY,\n      convert: false,\n    });\n  }\n};\n\n/**\n * Transform a vector or point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\nCamera.prototype.worldToCameraCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByVector(this._actualInvTransform, cartesian, result);\n};\n\n/**\n * Transform a point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\nCamera.prototype.worldToCameraCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPoint(this._actualInvTransform, cartesian, result);\n};\n\n/**\n * Transform a vector from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\nCamera.prototype.worldToCameraCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPointAsVector(\n    this._actualInvTransform,\n    cartesian,\n    result,\n  );\n};\n\n/**\n * Transform a vector or point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\nCamera.prototype.cameraToWorldCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByVector(this._actualTransform, cartesian, result);\n};\n\n/**\n * Transform a point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\nCamera.prototype.cameraToWorldCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPoint(this._actualTransform, cartesian, result);\n};\n\n/**\n * Transform a vector from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\nCamera.prototype.cameraToWorldCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPointAsVector(\n    this._actualTransform,\n    cartesian,\n    result,\n  );\n};\n\nfunction clampMove2D(camera, position) {\n  const rotatable2D = camera._scene.mapMode2D === MapMode2D.ROTATE;\n  const maxProjectedX = camera._maxCoord.x;\n  const maxProjectedY = camera._maxCoord.y;\n\n  let minX;\n  let maxX;\n  if (rotatable2D) {\n    maxX = maxProjectedX;\n    minX = -maxX;\n  } else {\n    maxX = position.x - maxProjectedX * 2.0;\n    minX = position.x + maxProjectedX * 2.0;\n  }\n\n  if (position.x > maxProjectedX) {\n    position.x = maxX;\n  }\n  if (position.x < -maxProjectedX) {\n    position.x = minX;\n  }\n\n  if (position.y > maxProjectedY) {\n    position.y = maxProjectedY;\n  }\n  if (position.y < -maxProjectedY) {\n    position.y = -maxProjectedY;\n  }\n}\n\nconst moveScratch = new Cartesian3();\n/**\n * Translates the camera's position by <code>amount</code> along <code>direction</code>.\n *\n * @param {Cartesian3} direction The direction to move.\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n * @see Camera#moveForward\n * @see Camera#moveLeft\n * @see Camera#moveRight\n * @see Camera#moveUp\n * @see Camera#moveDown\n */\nCamera.prototype.move = function (direction, amount) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const cameraPosition = this.position;\n  Cartesian3.multiplyByScalar(direction, amount, moveScratch);\n  Cartesian3.add(cameraPosition, moveScratch, cameraPosition);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    clampMove2D(this, cameraPosition);\n  }\n  this._adjustOrthographicFrustum(true);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's view vector.\n * When in 2D mode, this will zoom in the camera instead of translating the camera's position.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n */\nCamera.prototype.moveForward = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, amount);\n  }\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's view vector.\n * When in 2D mode, this will zoom out the camera instead of translating the camera's position.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveForward\n */\nCamera.prototype.moveBackward = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, -amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, -amount);\n  }\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's up vector.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveDown\n */\nCamera.prototype.moveUp = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.up, amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's up vector.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveUp\n */\nCamera.prototype.moveDown = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.up, -amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's right vector.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveLeft\n */\nCamera.prototype.moveRight = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.right, amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's right vector.\n *\n * @param {number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveRight\n */\nCamera.prototype.moveLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.right, -amount);\n};\n\n/**\n * Rotates the camera around its up vector by amount, in radians, in the opposite direction\n * of its right vector if not in 2D mode.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookRight\n */\nCamera.prototype.lookLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.up, -amount);\n  }\n};\n\n/**\n * Rotates the camera around its up vector by amount, in radians, in the direction\n * of its right vector if not in 2D mode.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookLeft\n */\nCamera.prototype.lookRight = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.up, amount);\n  }\n};\n\n/**\n * Rotates the camera around its right vector by amount, in radians, in the direction\n * of its up vector if not in 2D mode.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookDown\n */\nCamera.prototype.lookUp = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.right, -amount);\n  }\n};\n\n/**\n * Rotates the camera around its right vector by amount, in radians, in the opposite direction\n * of its up vector if not in 2D mode.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n */\nCamera.prototype.lookDown = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.right, amount);\n  }\n};\n\nconst lookScratchQuaternion = new Quaternion();\nconst lookScratchMatrix = new Matrix3();\n/**\n * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>\n *\n * @param {Cartesian3} axis The axis to rotate around.\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n * @see Camera#lookDown\n * @see Camera#lookLeft\n * @see Camera#lookRight\n */\nCamera.prototype.look = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(axis)) {\n    throw new DeveloperError(\"axis is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const turnAngle = defaultValue(angle, this.defaultLookAmount);\n  const quaternion = Quaternion.fromAxisAngle(\n    axis,\n    -turnAngle,\n    lookScratchQuaternion,\n  );\n  const rotation = Matrix3.fromQuaternion(quaternion, lookScratchMatrix);\n\n  const direction = this.direction;\n  const up = this.up;\n  const right = this.right;\n\n  Matrix3.multiplyByVector(rotation, direction, direction);\n  Matrix3.multiplyByVector(rotation, up, up);\n  Matrix3.multiplyByVector(rotation, right, right);\n};\n\n/**\n * Rotate the camera counter-clockwise around its direction vector by amount, in radians.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistRight\n */\nCamera.prototype.twistLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n  this.look(this.direction, amount);\n};\n\n/**\n * Rotate the camera clockwise around its direction vector by amount, in radians.\n *\n * @param {number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistLeft\n */\nCamera.prototype.twistRight = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n  this.look(this.direction, -amount);\n};\n\nconst rotateScratchQuaternion = new Quaternion();\nconst rotateScratchMatrix = new Matrix3();\n/**\n * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance\n * of the camera's position to the center of the camera's reference frame remains the same.\n *\n * @param {Cartesian3} axis The axis to rotate around given in world coordinates.\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotateDown\n * @see Camera#rotateLeft\n * @see Camera#rotateRight\n */\nCamera.prototype.rotate = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(axis)) {\n    throw new DeveloperError(\"axis is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const turnAngle = defaultValue(angle, this.defaultRotateAmount);\n  const quaternion = Quaternion.fromAxisAngle(\n    axis,\n    -turnAngle,\n    rotateScratchQuaternion,\n  );\n  const rotation = Matrix3.fromQuaternion(quaternion, rotateScratchMatrix);\n  Matrix3.multiplyByVector(rotation, this.position, this.position);\n  Matrix3.multiplyByVector(rotation, this.direction, this.direction);\n  Matrix3.multiplyByVector(rotation, this.up, this.up);\n  Cartesian3.cross(this.direction, this.up, this.right);\n  Cartesian3.cross(this.right, this.direction, this.up);\n\n  this._adjustOrthographicFrustum(false);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle downwards.\n *\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotate\n */\nCamera.prototype.rotateDown = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateVertical(this, angle);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle upwards.\n *\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateDown\n * @see Camera#rotate\n */\nCamera.prototype.rotateUp = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateVertical(this, -angle);\n};\n\nconst rotateVertScratchP = new Cartesian3();\nconst rotateVertScratchA = new Cartesian3();\nconst rotateVertScratchTan = new Cartesian3();\nconst rotateVertScratchNegate = new Cartesian3();\nfunction rotateVertical(camera, angle) {\n  const position = camera.position;\n  if (\n    defined(camera.constrainedAxis) &&\n    !Cartesian3.equalsEpsilon(\n      camera.position,\n      Cartesian3.ZERO,\n      CesiumMath.EPSILON2,\n    )\n  ) {\n    const p = Cartesian3.normalize(position, rotateVertScratchP);\n    const northParallel = Cartesian3.equalsEpsilon(\n      p,\n      camera.constrainedAxis,\n      CesiumMath.EPSILON2,\n    );\n    const southParallel = Cartesian3.equalsEpsilon(\n      p,\n      Cartesian3.negate(camera.constrainedAxis, rotateVertScratchNegate),\n      CesiumMath.EPSILON2,\n    );\n    if (!northParallel && !southParallel) {\n      const constrainedAxis = Cartesian3.normalize(\n        camera.constrainedAxis,\n        rotateVertScratchA,\n      );\n\n      let dot = Cartesian3.dot(p, constrainedAxis);\n      let angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n\n      dot = Cartesian3.dot(\n        p,\n        Cartesian3.negate(constrainedAxis, rotateVertScratchNegate),\n      );\n      angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n\n      const tangent = Cartesian3.cross(\n        constrainedAxis,\n        p,\n        rotateVertScratchTan,\n      );\n      camera.rotate(tangent, angle);\n    } else if ((northParallel && angle < 0) || (southParallel && angle > 0)) {\n      camera.rotate(camera.right, angle);\n    }\n  } else {\n    camera.rotate(camera.right, angle);\n  }\n}\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the right.\n *\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateLeft\n * @see Camera#rotate\n */\nCamera.prototype.rotateRight = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateHorizontal(this, -angle);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the left.\n *\n * @param {number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateRight\n * @see Camera#rotate\n */\nCamera.prototype.rotateLeft = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateHorizontal(this, angle);\n};\n\nfunction rotateHorizontal(camera, angle) {\n  if (defined(camera.constrainedAxis)) {\n    camera.rotate(camera.constrainedAxis, angle);\n  } else {\n    camera.rotate(camera.up, angle);\n  }\n}\n\nfunction zoom2D(camera, amount) {\n  const frustum = camera.frustum;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !(frustum instanceof OrthographicOffCenterFrustum) ||\n    !defined(frustum.left) ||\n    !defined(frustum.right) ||\n    !defined(frustum.bottom) ||\n    !defined(frustum.top)\n  ) {\n    throw new DeveloperError(\n      \"The camera frustum is expected to be orthographic for 2D camera control.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  let ratio;\n  amount = amount * 0.5;\n\n  if (\n    Math.abs(frustum.top) + Math.abs(frustum.bottom) >\n    Math.abs(frustum.left) + Math.abs(frustum.right)\n  ) {\n    let newTop = frustum.top - amount;\n    let newBottom = frustum.bottom + amount;\n\n    let maxBottom = camera._maxCoord.y;\n    if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n      maxBottom *= camera.maximumZoomFactor;\n    }\n\n    if (newBottom > maxBottom) {\n      newBottom = maxBottom;\n      newTop = -maxBottom;\n    }\n\n    if (newTop <= newBottom) {\n      newTop = 1.0;\n      newBottom = -1.0;\n    }\n\n    ratio = frustum.right / frustum.top;\n    frustum.top = newTop;\n    frustum.bottom = newBottom;\n    frustum.right = frustum.top * ratio;\n    frustum.left = -frustum.right;\n  } else {\n    let newRight = frustum.right - amount;\n    let newLeft = frustum.left + amount;\n\n    let maxRight = camera._maxCoord.x;\n    if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n      maxRight *= camera.maximumZoomFactor;\n    }\n\n    if (newRight > maxRight) {\n      newRight = maxRight;\n      newLeft = -maxRight;\n    }\n\n    if (newRight <= newLeft) {\n      newRight = 1.0;\n      newLeft = -1.0;\n    }\n    ratio = frustum.top / frustum.right;\n    frustum.right = newRight;\n    frustum.left = newLeft;\n    frustum.top = frustum.right * ratio;\n    frustum.bottom = -frustum.top;\n  }\n}\n\nfunction zoom3D(camera, amount) {\n  camera.move(camera.direction, amount);\n}\n\n/**\n * Zooms <code>amount</code> along the camera's view vector.\n *\n * @param {number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomOut\n */\nCamera.prototype.zoomIn = function (amount) {\n  amount = defaultValue(amount, this.defaultZoomAmount);\n  if (this._mode === SceneMode.SCENE2D) {\n    zoom2D(this, amount);\n  } else {\n    zoom3D(this, amount);\n  }\n};\n\n/**\n * Zooms <code>amount</code> along the opposite direction of\n * the camera's view vector.\n *\n * @param {number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomIn\n */\nCamera.prototype.zoomOut = function (amount) {\n  amount = defaultValue(amount, this.defaultZoomAmount);\n  if (this._mode === SceneMode.SCENE2D) {\n    zoom2D(this, -amount);\n  } else {\n    zoom3D(this, -amount);\n  }\n};\n\n/**\n * Gets the magnitude of the camera position. In 3D, this is the vector magnitude. In 2D and\n * Columbus view, this is the distance to the map.\n *\n * @returns {number} The magnitude of the position.\n */\nCamera.prototype.getMagnitude = function () {\n  if (this._mode === SceneMode.SCENE3D) {\n    return Cartesian3.magnitude(this.position);\n  } else if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    return Math.abs(this.position.z);\n  } else if (this._mode === SceneMode.SCENE2D) {\n    return Math.max(\n      this.frustum.right - this.frustum.left,\n      this.frustum.top - this.frustum.bottom,\n    );\n  }\n};\n\nconst scratchLookAtMatrix4 = new Matrix4();\n\n/**\n * Sets the camera position and orientation using a target and offset. The target must be given in\n * world coordinates. The offset can be either a cartesian or heading/pitch/range in the local east-north-up reference frame centered at the target.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Cartesian3} target The target position in world coordinates.\n * @param {Cartesian3|HeadingPitchRange} offset The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAt is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * const center = Cesium.Cartesian3.fromDegrees(-98.0, 40.0);\n * viewer.camera.lookAt(center, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * const center = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * const heading = Cesium.Math.toRadians(50.0);\n * const pitch = Cesium.Math.toRadians(-20.0);\n * const range = 5000.0;\n * viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\nCamera.prototype.lookAt = function (target, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(target)) {\n    throw new DeveloperError(\"target is required\");\n  }\n  if (!defined(offset)) {\n    throw new DeveloperError(\"offset is required\");\n  }\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\"lookAt is not supported while morphing.\");\n  }\n  //>>includeEnd('debug');\n\n  const scene = this._scene;\n  const ellipsoid = defaultValue(scene.ellipsoid, Ellipsoid.default);\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    target,\n    ellipsoid,\n    scratchLookAtMatrix4,\n  );\n  this.lookAtTransform(transform, offset);\n};\n\nconst scratchLookAtHeadingPitchRangeOffset = new Cartesian3();\nconst scratchLookAtHeadingPitchRangeQuaternion1 = new Quaternion();\nconst scratchLookAtHeadingPitchRangeQuaternion2 = new Quaternion();\nconst scratchHeadingPitchRangeMatrix3 = new Matrix3();\n\nfunction offsetFromHeadingPitchRange(heading, pitch, range) {\n  pitch = CesiumMath.clamp(\n    pitch,\n    -CesiumMath.PI_OVER_TWO,\n    CesiumMath.PI_OVER_TWO,\n  );\n  heading = CesiumMath.zeroToTwoPi(heading) - CesiumMath.PI_OVER_TWO;\n\n  const pitchQuat = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Y,\n    -pitch,\n    scratchLookAtHeadingPitchRangeQuaternion1,\n  );\n  const headingQuat = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Z,\n    -heading,\n    scratchLookAtHeadingPitchRangeQuaternion2,\n  );\n  const rotQuat = Quaternion.multiply(headingQuat, pitchQuat, headingQuat);\n  const rotMatrix = Matrix3.fromQuaternion(\n    rotQuat,\n    scratchHeadingPitchRangeMatrix3,\n  );\n\n  const offset = Cartesian3.clone(\n    Cartesian3.UNIT_X,\n    scratchLookAtHeadingPitchRangeOffset,\n  );\n  Matrix3.multiplyByVector(rotMatrix, offset, offset);\n  Cartesian3.negate(offset, offset);\n  Cartesian3.multiplyByScalar(offset, range, offset);\n  return offset;\n}\n\n/**\n * Sets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the center of the reference frame. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Matrix4} transform The transformation matrix defining the reference frame.\n * @param {Cartesian3|HeadingPitchRange} [offset] The offset from the target in a reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAtTransform is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-98.0, 40.0));\n * viewer.camera.lookAtTransform(transform, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-72.0, 40.0));\n * const heading = Cesium.Math.toRadians(50.0);\n * const pitch = Cesium.Math.toRadians(-20.0);\n * const range = 5000.0;\n * viewer.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\nCamera.prototype.lookAtTransform = function (transform, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(transform)) {\n    throw new DeveloperError(\"transform is required\");\n  }\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\n      \"lookAtTransform is not supported while morphing.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._setTransform(transform);\n  if (!defined(offset)) {\n    return;\n  }\n\n  let cartesianOffset;\n  if (defined(offset.heading)) {\n    cartesianOffset = offsetFromHeadingPitchRange(\n      offset.heading,\n      offset.pitch,\n      offset.range,\n    );\n  } else {\n    cartesianOffset = offset;\n  }\n\n  if (this._mode === SceneMode.SCENE2D) {\n    Cartesian2.clone(Cartesian2.ZERO, this.position);\n\n    Cartesian3.negate(cartesianOffset, this.up);\n    this.up.z = 0.0;\n\n    if (Cartesian3.magnitudeSquared(this.up) < CesiumMath.EPSILON10) {\n      Cartesian3.clone(Cartesian3.UNIT_Y, this.up);\n    }\n\n    Cartesian3.normalize(this.up, this.up);\n\n    this._setTransform(Matrix4.IDENTITY);\n\n    Cartesian3.negate(Cartesian3.UNIT_Z, this.direction);\n    Cartesian3.cross(this.direction, this.up, this.right);\n    Cartesian3.normalize(this.right, this.right);\n\n    const frustum = this.frustum;\n    const ratio = frustum.top / frustum.right;\n    frustum.right = Cartesian3.magnitude(cartesianOffset) * 0.5;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n\n    this._setTransform(transform);\n\n    return;\n  }\n\n  Cartesian3.clone(cartesianOffset, this.position);\n  Cartesian3.negate(this.position, this.direction);\n  Cartesian3.normalize(this.direction, this.direction);\n  Cartesian3.cross(this.direction, Cartesian3.UNIT_Z, this.right);\n\n  if (Cartesian3.magnitudeSquared(this.right) < CesiumMath.EPSILON10) {\n    Cartesian3.clone(Cartesian3.UNIT_X, this.right);\n  }\n\n  Cartesian3.normalize(this.right, this.right);\n  Cartesian3.cross(this.right, this.direction, this.up);\n  Cartesian3.normalize(this.up, this.up);\n\n  this._adjustOrthographicFrustum(true);\n};\n\nconst viewRectangle3DCartographic1 = new Cartographic();\nconst viewRectangle3DCartographic2 = new Cartographic();\nconst viewRectangle3DNorthEast = new Cartesian3();\nconst viewRectangle3DSouthWest = new Cartesian3();\nconst viewRectangle3DNorthWest = new Cartesian3();\nconst viewRectangle3DSouthEast = new Cartesian3();\nconst viewRectangle3DNorthCenter = new Cartesian3();\nconst viewRectangle3DSouthCenter = new Cartesian3();\nconst viewRectangle3DCenter = new Cartesian3();\nconst viewRectangle3DEquator = new Cartesian3();\nconst defaultRF = {\n  direction: new Cartesian3(),\n  right: new Cartesian3(),\n  up: new Cartesian3(),\n};\nlet viewRectangle3DEllipsoidGeodesic;\n\nfunction computeD(direction, upOrRight, corner, tanThetaOrPhi) {\n  const opposite = Math.abs(Cartesian3.dot(upOrRight, corner));\n  return opposite / tanThetaOrPhi - Cartesian3.dot(direction, corner);\n}\n\nfunction rectangleCameraPosition3D(camera, rectangle, result, updateCamera) {\n  const ellipsoid = camera._projection.ellipsoid;\n  const cameraRF = updateCamera ? camera : defaultRF;\n\n  const { north, south, west } = rectangle;\n  let { east } = rectangle;\n\n  // If we go across the International Date Line\n  if (west > east) {\n    east += CesiumMath.TWO_PI;\n  }\n\n  // Find the midpoint latitude.\n  //\n  // EllipsoidGeodesic will fail if the north and south edges are very close to being on opposite sides of the ellipsoid.\n  // Ideally we'd just call EllipsoidGeodesic.setEndPoints and let it throw when it detects this case, but sadly it doesn't\n  // even look for this case in optimized builds, so we have to test for it here instead.\n  //\n  // Fortunately, this case can only happen (here) when north is very close to the north pole and south is very close to the south pole,\n  // so handle it just by using 0 latitude as the center.  It's certainliy possible to use a smaller tolerance\n  // than one degree here, but one degree is safe and putting the center at 0 latitude should be good enough for any\n  // rectangle that spans 178+ of the 180 degrees of latitude.\n  const longitude = (west + east) * 0.5;\n  let latitude;\n  if (\n    south < -CesiumMath.PI_OVER_TWO + CesiumMath.RADIANS_PER_DEGREE &&\n    north > CesiumMath.PI_OVER_TWO - CesiumMath.RADIANS_PER_DEGREE\n  ) {\n    latitude = 0.0;\n  } else {\n    const northCartographic = viewRectangle3DCartographic1;\n    northCartographic.longitude = longitude;\n    northCartographic.latitude = north;\n    northCartographic.height = 0.0;\n\n    const southCartographic = viewRectangle3DCartographic2;\n    southCartographic.longitude = longitude;\n    southCartographic.latitude = south;\n    southCartographic.height = 0.0;\n\n    let ellipsoidGeodesic = viewRectangle3DEllipsoidGeodesic;\n    if (\n      !defined(ellipsoidGeodesic) ||\n      ellipsoidGeodesic.ellipsoid !== ellipsoid\n    ) {\n      viewRectangle3DEllipsoidGeodesic = ellipsoidGeodesic =\n        new EllipsoidGeodesic(undefined, undefined, ellipsoid);\n    }\n\n    ellipsoidGeodesic.setEndPoints(northCartographic, southCartographic);\n    latitude = ellipsoidGeodesic.interpolateUsingFraction(\n      0.5,\n      viewRectangle3DCartographic1,\n    ).latitude;\n  }\n\n  const centerCartographic = viewRectangle3DCartographic1;\n  centerCartographic.longitude = longitude;\n  centerCartographic.latitude = latitude;\n  centerCartographic.height = 0.0;\n\n  const center = ellipsoid.cartographicToCartesian(\n    centerCartographic,\n    viewRectangle3DCenter,\n  );\n\n  const cart = viewRectangle3DCartographic1;\n  cart.longitude = east;\n  cart.latitude = north;\n  const northEast = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthEast,\n  );\n  cart.longitude = west;\n  const northWest = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthWest,\n  );\n  cart.longitude = longitude;\n  const northCenter = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthCenter,\n  );\n  cart.latitude = south;\n  const southCenter = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthCenter,\n  );\n  cart.longitude = east;\n  const southEast = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthEast,\n  );\n  cart.longitude = west;\n  const southWest = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthWest,\n  );\n\n  Cartesian3.subtract(northWest, center, northWest);\n  Cartesian3.subtract(southEast, center, southEast);\n  Cartesian3.subtract(northEast, center, northEast);\n  Cartesian3.subtract(southWest, center, southWest);\n  Cartesian3.subtract(northCenter, center, northCenter);\n  Cartesian3.subtract(southCenter, center, southCenter);\n\n  const direction = ellipsoid.geodeticSurfaceNormal(center, cameraRF.direction);\n  Cartesian3.negate(direction, direction);\n  const right = Cartesian3.cross(direction, Cartesian3.UNIT_Z, cameraRF.right);\n  Cartesian3.normalize(right, right);\n  const up = Cartesian3.cross(right, direction, cameraRF.up);\n\n  let d;\n  if (camera.frustum instanceof OrthographicFrustum) {\n    const width = Math.max(\n      Cartesian3.distance(northEast, northWest),\n      Cartesian3.distance(southEast, southWest),\n    );\n    const height = Math.max(\n      Cartesian3.distance(northEast, southEast),\n      Cartesian3.distance(northWest, southWest),\n    );\n\n    let rightScalar;\n    let topScalar;\n    const offCenterFrustum = camera.frustum._offCenterFrustum;\n    const ratio = offCenterFrustum.right / offCenterFrustum.top;\n    const heightRatio = height * ratio;\n    if (width > heightRatio) {\n      rightScalar = width;\n      topScalar = rightScalar / ratio;\n    } else {\n      topScalar = height;\n      rightScalar = heightRatio;\n    }\n\n    d = Math.max(rightScalar, topScalar);\n  } else {\n    const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    const tanTheta = camera.frustum.aspectRatio * tanPhi;\n\n    d = Math.max(\n      computeD(direction, up, northWest, tanPhi),\n      computeD(direction, up, southEast, tanPhi),\n      computeD(direction, up, northEast, tanPhi),\n      computeD(direction, up, southWest, tanPhi),\n      computeD(direction, up, northCenter, tanPhi),\n      computeD(direction, up, southCenter, tanPhi),\n      computeD(direction, right, northWest, tanTheta),\n      computeD(direction, right, southEast, tanTheta),\n      computeD(direction, right, northEast, tanTheta),\n      computeD(direction, right, southWest, tanTheta),\n      computeD(direction, right, northCenter, tanTheta),\n      computeD(direction, right, southCenter, tanTheta),\n    );\n\n    // If the rectangle crosses the equator, compute D at the equator, too, because that's the\n    // widest part of the rectangle when projected onto the globe.\n    if (south < 0 && north > 0) {\n      const equatorCartographic = viewRectangle3DCartographic1;\n      equatorCartographic.longitude = west;\n      equatorCartographic.latitude = 0.0;\n      equatorCartographic.height = 0.0;\n      let equatorPosition = ellipsoid.cartographicToCartesian(\n        equatorCartographic,\n        viewRectangle3DEquator,\n      );\n      Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(\n        d,\n        computeD(direction, up, equatorPosition, tanPhi),\n        computeD(direction, right, equatorPosition, tanTheta),\n      );\n\n      equatorCartographic.longitude = east;\n      equatorPosition = ellipsoid.cartographicToCartesian(\n        equatorCartographic,\n        viewRectangle3DEquator,\n      );\n      Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(\n        d,\n        computeD(direction, up, equatorPosition, tanPhi),\n        computeD(direction, right, equatorPosition, tanTheta),\n      );\n    }\n  }\n\n  return Cartesian3.add(\n    center,\n    Cartesian3.multiplyByScalar(direction, -d, viewRectangle3DEquator),\n    result,\n  );\n}\n\nconst viewRectangleCVCartographic = new Cartographic();\nconst viewRectangleCVNorthEast = new Cartesian3();\nconst viewRectangleCVSouthWest = new Cartesian3();\nfunction rectangleCameraPositionColumbusView(camera, rectangle, result) {\n  const projection = camera._projection;\n  if (rectangle.west > rectangle.east) {\n    rectangle = Rectangle.MAX_VALUE;\n  }\n  const transform = camera._actualTransform;\n  const invTransform = camera._actualInvTransform;\n\n  const cart = viewRectangleCVCartographic;\n  cart.longitude = rectangle.east;\n  cart.latitude = rectangle.north;\n  const northEast = projection.project(cart, viewRectangleCVNorthEast);\n  Matrix4.multiplyByPoint(transform, northEast, northEast);\n  Matrix4.multiplyByPoint(invTransform, northEast, northEast);\n\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  const southWest = projection.project(cart, viewRectangleCVSouthWest);\n  Matrix4.multiplyByPoint(transform, southWest, southWest);\n  Matrix4.multiplyByPoint(invTransform, southWest, southWest);\n\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n\n  if (defined(camera.frustum.fovy)) {\n    const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    const tanTheta = camera.frustum.aspectRatio * tanPhi;\n    result.z =\n      Math.max(\n        (northEast.x - southWest.x) / tanTheta,\n        (northEast.y - southWest.y) / tanPhi,\n      ) * 0.5;\n  } else {\n    const width = northEast.x - southWest.x;\n    const height = northEast.y - southWest.y;\n    result.z = Math.max(width, height);\n  }\n\n  return result;\n}\n\nconst viewRectangle2DCartographic = new Cartographic();\nconst viewRectangle2DNorthEast = new Cartesian3();\nconst viewRectangle2DSouthWest = new Cartesian3();\nfunction rectangleCameraPosition2D(camera, rectangle, result) {\n  const projection = camera._projection;\n\n  // Account for the rectangle crossing the International Date Line in 2D mode\n  let east = rectangle.east;\n  if (rectangle.west > rectangle.east) {\n    if (camera._scene.mapMode2D === MapMode2D.INFINITE_SCROLL) {\n      east += CesiumMath.TWO_PI;\n    } else {\n      rectangle = Rectangle.MAX_VALUE;\n      east = rectangle.east;\n    }\n  }\n\n  let cart = viewRectangle2DCartographic;\n  cart.longitude = east;\n  cart.latitude = rectangle.north;\n  const northEast = projection.project(cart, viewRectangle2DNorthEast);\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  const southWest = projection.project(cart, viewRectangle2DSouthWest);\n\n  const width = Math.abs(northEast.x - southWest.x) * 0.5;\n  let height = Math.abs(northEast.y - southWest.y) * 0.5;\n\n  let right, top;\n  const ratio = camera.frustum.right / camera.frustum.top;\n  const heightRatio = height * ratio;\n  if (width > heightRatio) {\n    right = width;\n    top = right / ratio;\n  } else {\n    top = height;\n    right = heightRatio;\n  }\n\n  height = Math.max(2.0 * right, 2.0 * top);\n\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n\n  cart = projection.unproject(result, cart);\n  cart.height = height;\n  result = projection.project(cart, result);\n\n  return result;\n}\n\n/**\n * Get the camera position needed to view a rectangle on an ellipsoid or map\n *\n * @param {Rectangle} rectangle The rectangle to view.\n * @param {Cartesian3} [result] The camera position needed to view the rectangle\n * @returns {Cartesian3} The camera position needed to view the rectangle\n */\nCamera.prototype.getRectangleCameraCoordinates = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  }\n  //>>includeEnd('debug');\n  const mode = this._mode;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  if (mode === SceneMode.SCENE3D) {\n    return rectangleCameraPosition3D(this, rectangle, result);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    return rectangleCameraPositionColumbusView(this, rectangle, result);\n  } else if (mode === SceneMode.SCENE2D) {\n    return rectangleCameraPosition2D(this, rectangle, result);\n  }\n\n  return undefined;\n};\n\nconst pickEllipsoid3DRay = new Ray();\nfunction pickEllipsoid3D(camera, windowPosition, ellipsoid, result) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  const ray = camera.getPickRay(windowPosition, pickEllipsoid3DRay);\n  const intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n  if (!intersection) {\n    return undefined;\n  }\n\n  const t = intersection.start > 0.0 ? intersection.start : intersection.stop;\n  return Ray.getPoint(ray, t, result);\n}\n\nconst pickEllipsoid2DRay = new Ray();\nfunction pickMap2D(camera, windowPosition, projection, result) {\n  const ray = camera.getPickRay(windowPosition, pickEllipsoid2DRay);\n  let position = ray.origin;\n  position = Cartesian3.fromElements(position.y, position.z, 0.0, position);\n  const cart = projection.unproject(position);\n\n  if (\n    cart.latitude < -CesiumMath.PI_OVER_TWO ||\n    cart.latitude > CesiumMath.PI_OVER_TWO\n  ) {\n    return undefined;\n  }\n\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n\nconst pickEllipsoidCVRay = new Ray();\nfunction pickMapColumbusView(camera, windowPosition, projection, result) {\n  const ray = camera.getPickRay(windowPosition, pickEllipsoidCVRay);\n  const scalar = -ray.origin.x / ray.direction.x;\n  Ray.getPoint(ray, scalar, result);\n\n  const cart = projection.unproject(new Cartesian3(result.y, result.z, 0.0));\n\n  if (\n    cart.latitude < -CesiumMath.PI_OVER_TWO ||\n    cart.latitude > CesiumMath.PI_OVER_TWO ||\n    cart.longitude < -Math.PI ||\n    cart.longitude > Math.PI\n  ) {\n    return undefined;\n  }\n\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n\n/**\n * Pick an ellipsoid or map.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to pick.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3 | undefined} If the ellipsoid or map was picked,\n * returns the point on the surface of the ellipsoid or map in world\n * coordinates. If the ellipsoid or map was not picked, returns undefined.\n *\n * @example\n * const canvas = viewer.scene.canvas;\n * const center = new Cesium.Cartesian2(canvas.clientWidth / 2.0, canvas.clientHeight / 2.0);\n * const ellipsoid = viewer.scene.ellipsoid;\n * const result = viewer.camera.pickEllipsoid(center, ellipsoid);\n */\nCamera.prototype.pickEllipsoid = function (windowPosition, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const canvas = this._scene.canvas;\n  if (canvas.clientWidth === 0 || canvas.clientHeight === 0) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n\n  if (this._mode === SceneMode.SCENE3D) {\n    result = pickEllipsoid3D(this, windowPosition, ellipsoid, result);\n  } else if (this._mode === SceneMode.SCENE2D) {\n    result = pickMap2D(this, windowPosition, this._projection, result);\n  } else if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    result = pickMapColumbusView(\n      this,\n      windowPosition,\n      this._projection,\n      result,\n    );\n  } else {\n    return undefined;\n  }\n\n  return result;\n};\n\nconst pickPerspCenter = new Cartesian3();\nconst pickPerspXDir = new Cartesian3();\nconst pickPerspYDir = new Cartesian3();\nfunction getPickRayPerspective(camera, windowPosition, result) {\n  const canvas = camera._scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n\n  const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  const tanTheta = camera.frustum.aspectRatio * tanPhi;\n  const near = camera.frustum.near;\n\n  const x = (2.0 / width) * windowPosition.x - 1.0;\n  const y = (2.0 / height) * (height - windowPosition.y) - 1.0;\n\n  const position = camera.positionWC;\n  Cartesian3.clone(position, result.origin);\n\n  const nearCenter = Cartesian3.multiplyByScalar(\n    camera.directionWC,\n    near,\n    pickPerspCenter,\n  );\n  Cartesian3.add(position, nearCenter, nearCenter);\n  const xDir = Cartesian3.multiplyByScalar(\n    camera.rightWC,\n    x * near * tanTheta,\n    pickPerspXDir,\n  );\n  const yDir = Cartesian3.multiplyByScalar(\n    camera.upWC,\n    y * near * tanPhi,\n    pickPerspYDir,\n  );\n  const direction = Cartesian3.add(nearCenter, xDir, result.direction);\n  Cartesian3.add(direction, yDir, direction);\n  Cartesian3.subtract(direction, position, direction);\n  Cartesian3.normalize(direction, direction);\n\n  return result;\n}\n\nconst scratchDirection = new Cartesian3();\n\nfunction getPickRayOrthographic(camera, windowPosition, result) {\n  const canvas = camera._scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n\n  let frustum = camera.frustum;\n  const offCenterFrustum = frustum.offCenterFrustum;\n  if (defined(offCenterFrustum)) {\n    frustum = offCenterFrustum;\n  }\n  let x = (2.0 / width) * windowPosition.x - 1.0;\n  x *= (frustum.right - frustum.left) * 0.5;\n  let y = (2.0 / height) * (height - windowPosition.y) - 1.0;\n  y *= (frustum.top - frustum.bottom) * 0.5;\n\n  const origin = result.origin;\n  Cartesian3.clone(camera.position, origin);\n\n  Cartesian3.multiplyByScalar(camera.right, x, scratchDirection);\n  Cartesian3.add(scratchDirection, origin, origin);\n  Cartesian3.multiplyByScalar(camera.up, y, scratchDirection);\n  Cartesian3.add(scratchDirection, origin, origin);\n\n  Cartesian3.clone(camera.directionWC, result.direction);\n\n  if (\n    camera._mode === SceneMode.COLUMBUS_VIEW ||\n    camera._mode === SceneMode.SCENE2D\n  ) {\n    Cartesian3.fromElements(\n      result.origin.z,\n      result.origin.x,\n      result.origin.y,\n      result.origin,\n    );\n  }\n\n  return result;\n}\n\n/**\n * Create a ray from the camera position through the pixel at <code>windowPosition</code>\n * in world coordinates.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray|undefined} Returns the {@link Cartesian3} position and direction of the ray, or undefined if the pick ray cannot be determined.\n */\nCamera.prototype.getPickRay = function (windowPosition, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Ray();\n  }\n\n  const canvas = this._scene.canvas;\n  if (canvas.clientWidth <= 0 || canvas.clientHeight <= 0) {\n    return undefined;\n  }\n\n  const frustum = this.frustum;\n  if (\n    defined(frustum.aspectRatio) &&\n    defined(frustum.fov) &&\n    defined(frustum.near)\n  ) {\n    return getPickRayPerspective(this, windowPosition, result);\n  }\n\n  return getPickRayOrthographic(this, windowPosition, result);\n};\n\nconst scratchToCenter = new Cartesian3();\nconst scratchProj = new Cartesian3();\n\n/**\n * Return the distance from the camera to the front of the bounding sphere.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @returns {number} The distance to the bounding sphere.\n */\nCamera.prototype.distanceToBoundingSphere = function (boundingSphere) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const toCenter = Cartesian3.subtract(\n    this.positionWC,\n    boundingSphere.center,\n    scratchToCenter,\n  );\n  const proj = Cartesian3.multiplyByScalar(\n    this.directionWC,\n    Cartesian3.dot(toCenter, this.directionWC),\n    scratchProj,\n  );\n  return Math.max(0.0, Cartesian3.magnitude(proj) - boundingSphere.radius);\n};\n\nconst scratchPixelSize = new Cartesian2();\n\n/**\n * Return the pixel size in meters.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @param {number} drawingBufferWidth The drawing buffer width.\n * @param {number} drawingBufferHeight The drawing buffer height.\n * @returns {number} The pixel size in meters.\n */\nCamera.prototype.getPixelSize = function (\n  boundingSphere,\n  drawingBufferWidth,\n  drawingBufferHeight,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  if (!defined(drawingBufferWidth)) {\n    throw new DeveloperError(\"drawingBufferWidth is required.\");\n  }\n  if (!defined(drawingBufferHeight)) {\n    throw new DeveloperError(\"drawingBufferHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const distance = this.distanceToBoundingSphere(boundingSphere);\n  const pixelSize = this.frustum.getPixelDimensions(\n    drawingBufferWidth,\n    drawingBufferHeight,\n    distance,\n    this._scene.pixelRatio,\n    scratchPixelSize,\n  );\n  return Math.max(pixelSize.x, pixelSize.y);\n};\n\nfunction createAnimationTemplateCV(\n  camera,\n  position,\n  center,\n  maxX,\n  maxY,\n  duration,\n) {\n  const newPosition = Cartesian3.clone(position);\n\n  if (center.y > maxX) {\n    newPosition.y -= center.y - maxX;\n  } else if (center.y < -maxX) {\n    newPosition.y += -maxX - center.y;\n  }\n\n  if (center.z > maxY) {\n    newPosition.z -= center.z - maxY;\n  } else if (center.z < -maxY) {\n    newPosition.z += -maxY - center.z;\n  }\n\n  function updateCV(value) {\n    const interp = Cartesian3.lerp(\n      position,\n      newPosition,\n      value.time,\n      new Cartesian3(),\n    );\n    camera.worldToCameraCoordinatesPoint(interp, camera.position);\n  }\n  return {\n    easingFunction: EasingFunction.EXPONENTIAL_OUT,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: 1.0,\n    },\n    duration: duration,\n    update: updateCV,\n  };\n}\n\nconst normalScratch = new Cartesian3();\nconst centerScratch = new Cartesian3();\nconst posScratch = new Cartesian3();\nconst scratchCartesian3Subtract = new Cartesian3();\n\nfunction createAnimationCV(camera, duration) {\n  let position = camera.position;\n  const direction = camera.direction;\n\n  const normal = camera.worldToCameraCoordinatesVector(\n    Cartesian3.UNIT_X,\n    normalScratch,\n  );\n  const scalar =\n    -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  const center = Cartesian3.add(\n    position,\n    Cartesian3.multiplyByScalar(direction, scalar, centerScratch),\n    centerScratch,\n  );\n  camera.cameraToWorldCoordinatesPoint(center, center);\n\n  position = camera.cameraToWorldCoordinatesPoint(camera.position, posScratch);\n\n  const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  const tanTheta = camera.frustum.aspectRatio * tanPhi;\n  const distToC = Cartesian3.magnitude(\n    Cartesian3.subtract(position, center, scratchCartesian3Subtract),\n  );\n  const dWidth = tanTheta * distToC;\n  const dHeight = tanPhi * distToC;\n\n  const mapWidth = camera._maxCoord.x;\n  const mapHeight = camera._maxCoord.y;\n\n  const maxX = Math.max(dWidth - mapWidth, mapWidth);\n  const maxY = Math.max(dHeight - mapHeight, mapHeight);\n\n  if (\n    position.z < -maxX ||\n    position.z > maxX ||\n    position.y < -maxY ||\n    position.y > maxY\n  ) {\n    const translateX = center.y < -maxX || center.y > maxX;\n    const translateY = center.z < -maxY || center.z > maxY;\n    if (translateX || translateY) {\n      return createAnimationTemplateCV(\n        camera,\n        position,\n        center,\n        maxX,\n        maxY,\n        duration,\n      );\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Create an animation to move the map into view. This method is only valid for 2D and Columbus modes.\n *\n * @param {number} duration The duration, in seconds, of the animation.\n * @returns {object} The animation or undefined if the scene mode is 3D or the map is already ion view.\n *\n * @private\n */\nCamera.prototype.createCorrectPositionTween = function (duration) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(duration)) {\n    throw new DeveloperError(\"duration is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    return createAnimationCV(this, duration);\n  }\n\n  return undefined;\n};\n\nconst scratchFlyToDestination = new Cartesian3();\nconst newOptions = {\n  destination: undefined,\n  heading: undefined,\n  pitch: undefined,\n  roll: undefined,\n  duration: undefined,\n  complete: undefined,\n  cancel: undefined,\n  endTransform: undefined,\n  maximumHeight: undefined,\n  easingFunction: undefined,\n};\n\n/**\n * Cancels the current camera flight and leaves the camera at its current location.\n * If no flight is in progress, this this function does nothing.\n */\nCamera.prototype.cancelFlight = function () {\n  if (defined(this._currentFlight)) {\n    this._currentFlight.cancelTween();\n    this._currentFlight = undefined;\n  }\n};\n\n/**\n * Completes the current camera flight and moves the camera immediately to its final destination.\n * If no flight is in progress, this this function does nothing.\n */\nCamera.prototype.completeFlight = function () {\n  if (defined(this._currentFlight)) {\n    this._currentFlight.cancelTween();\n\n    const options = {\n      destination: undefined,\n      orientation: {\n        heading: undefined,\n        pitch: undefined,\n        roll: undefined,\n      },\n    };\n\n    options.destination = newOptions.destination;\n    options.orientation.heading = newOptions.heading;\n    options.orientation.pitch = newOptions.pitch;\n    options.orientation.roll = newOptions.roll;\n\n    this.setView(options);\n\n    if (defined(this._currentFlight.complete)) {\n      this._currentFlight.complete();\n    }\n\n    this._currentFlight = undefined;\n  }\n};\n\n/**\n * Flies the camera from its current position to a new position.\n *\n * @param {object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} options.destination The final position of the camera in world coordinates or a rectangle that would be visible from a top-down view.\n * @param {object} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view.  Orientation is not used in 2D when in infinite scrolling mode.\n * @param {number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {Camera.FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera.FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n * @param {EasingFunction.Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n *\n * @exception {DeveloperError} If either direction or up is given, then both are required.\n *\n * @example\n * // 1. Fly to a position with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2. Fly to a Rectangle with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 3. Fly to a position with an orientation using unit vectors.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n *\n * // 4. Fly to a position with an orientation using heading, pitch and roll.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         heading : Cesium.Math.toRadians(175.0),\n *         pitch : Cesium.Math.toRadians(-35.0),\n *         roll : 0.0\n *     }\n * });\n */\nCamera.prototype.flyTo = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  let destination = options.destination;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(destination)) {\n    throw new DeveloperError(\"destination is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const mode = this._mode;\n  if (mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  this.cancelFlight();\n\n  const isRectangle = destination instanceof Rectangle;\n  if (isRectangle) {\n    destination = this.getRectangleCameraCoordinates(\n      destination,\n      scratchFlyToDestination,\n    );\n  }\n\n  let orientation = defaultValue(\n    options.orientation,\n    defaultValue.EMPTY_OBJECT,\n  );\n  if (defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(\n      this,\n      destination,\n      orientation,\n      scratchSetViewOptions.orientation,\n    );\n  }\n\n  if (defined(options.duration) && options.duration <= 0.0) {\n    const setViewOptions = scratchSetViewOptions;\n    setViewOptions.destination = options.destination;\n    setViewOptions.orientation.heading = orientation.heading;\n    setViewOptions.orientation.pitch = orientation.pitch;\n    setViewOptions.orientation.roll = orientation.roll;\n    setViewOptions.convert = options.convert;\n    setViewOptions.endTransform = options.endTransform;\n    this.setView(setViewOptions);\n    if (typeof options.complete === \"function\") {\n      options.complete();\n    }\n    return;\n  }\n\n  const that = this;\n  /* eslint-disable-next-line prefer-const */\n  let flightTween;\n\n  newOptions.destination = destination;\n  newOptions.heading = orientation.heading;\n  newOptions.pitch = orientation.pitch;\n  newOptions.roll = orientation.roll;\n  newOptions.duration = options.duration;\n  newOptions.complete = function () {\n    if (flightTween === that._currentFlight) {\n      that._currentFlight = undefined;\n    }\n    if (defined(options.complete)) {\n      options.complete();\n    }\n  };\n  newOptions.cancel = options.cancel;\n  newOptions.endTransform = options.endTransform;\n  newOptions.convert = isRectangle ? false : options.convert;\n  newOptions.maximumHeight = options.maximumHeight;\n  newOptions.pitchAdjustHeight = options.pitchAdjustHeight;\n  newOptions.flyOverLongitude = options.flyOverLongitude;\n  newOptions.flyOverLongitudeWeight = options.flyOverLongitudeWeight;\n  newOptions.easingFunction = options.easingFunction;\n\n  const scene = this._scene;\n  const tweenOptions = CameraFlightPath.createTween(scene, newOptions);\n  // If the camera doesn't actually need to go anywhere, duration\n  // will be 0 and we can just complete the current flight.\n  if (tweenOptions.duration === 0) {\n    if (typeof tweenOptions.complete === \"function\") {\n      tweenOptions.complete();\n    }\n    return;\n  }\n  flightTween = scene.tweens.add(tweenOptions);\n  this._currentFlight = flightTween;\n\n  // Save the final destination view information for the PRELOAD_FLIGHT pass.\n  let preloadFlightCamera = this._scene.preloadFlightCamera;\n  if (this._mode !== SceneMode.SCENE2D) {\n    if (!defined(preloadFlightCamera)) {\n      preloadFlightCamera = Camera.clone(this);\n    }\n    preloadFlightCamera.setView({\n      destination: destination,\n      orientation: orientation,\n    });\n\n    this._scene.preloadFlightCullingVolume =\n      preloadFlightCamera.frustum.computeCullingVolume(\n        preloadFlightCamera.positionWC,\n        preloadFlightCamera.directionWC,\n        preloadFlightCamera.upWC,\n      );\n  }\n};\n\nfunction distanceToBoundingSphere3D(camera, radius) {\n  const frustum = camera.frustum;\n  const tanPhi = Math.tan(frustum.fovy * 0.5);\n  const tanTheta = frustum.aspectRatio * tanPhi;\n  return Math.max(radius / tanTheta, radius / tanPhi);\n}\n\nfunction distanceToBoundingSphere2D(camera, radius) {\n  let frustum = camera.frustum;\n  const offCenterFrustum = frustum.offCenterFrustum;\n  if (defined(offCenterFrustum)) {\n    frustum = offCenterFrustum;\n  }\n\n  let right, top;\n  const ratio = frustum.right / frustum.top;\n  const heightRatio = radius * ratio;\n  if (radius > heightRatio) {\n    right = radius;\n    top = right / ratio;\n  } else {\n    top = radius;\n    right = heightRatio;\n  }\n\n  return Math.max(right, top) * 1.5;\n}\n\nconst MINIMUM_ZOOM = 100.0;\n\nfunction adjustBoundingSphereOffset(camera, boundingSphere, offset) {\n  offset = HeadingPitchRange.clone(\n    defined(offset) ? offset : Camera.DEFAULT_OFFSET,\n  );\n\n  const minimumZoom =\n    camera._scene.screenSpaceCameraController.minimumZoomDistance;\n  const maximumZoom =\n    camera._scene.screenSpaceCameraController.maximumZoomDistance;\n  const range = offset.range;\n  if (!defined(range) || range === 0.0) {\n    const radius = boundingSphere.radius;\n    if (radius === 0.0) {\n      offset.range = MINIMUM_ZOOM;\n    } else if (\n      camera.frustum instanceof OrthographicFrustum ||\n      camera._mode === SceneMode.SCENE2D\n    ) {\n      offset.range = distanceToBoundingSphere2D(camera, radius);\n    } else {\n      offset.range = distanceToBoundingSphere3D(camera, radius);\n    }\n    offset.range = CesiumMath.clamp(offset.range, minimumZoom, maximumZoom);\n  }\n\n  return offset;\n}\n\n/**\n * Sets the camera so that the current view contains the provided bounding sphere.\n *\n * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {HeadingPitchRange} [offset] The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} viewBoundingSphere is not supported while morphing.\n */\nCamera.prototype.viewBoundingSphere = function (boundingSphere, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\n      \"viewBoundingSphere is not supported while morphing.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  offset = adjustBoundingSphereOffset(this, boundingSphere, offset);\n  this.lookAt(boundingSphere.center, offset);\n};\n\nconst scratchflyToBoundingSphereTransform = new Matrix4();\nconst scratchflyToBoundingSphereDestination = new Cartesian3();\nconst scratchflyToBoundingSphereDirection = new Cartesian3();\nconst scratchflyToBoundingSphereUp = new Cartesian3();\nconst scratchflyToBoundingSphereRight = new Cartesian3();\nconst scratchFlyToBoundingSphereCart4 = new Cartesian4();\nconst scratchFlyToBoundingSphereQuaternion = new Quaternion();\nconst scratchFlyToBoundingSphereMatrix3 = new Matrix3();\n\n/**\n * Flies the camera to a location where the current view contains the provided bounding sphere.\n *\n * <p> The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D and Columbus View, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be aligned to local north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {object} [options] Object with the following properties:\n * @param {number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {HeadingPitchRange} [options.offset] The offset from the target in the local east-north-up reference frame centered at the target.\n * @param {Camera.FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera.FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {EasingFunction.Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n */\nCamera.prototype.flyToBoundingSphere = function (boundingSphere, options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const scene2D =\n    this._mode === SceneMode.SCENE2D || this._mode === SceneMode.COLUMBUS_VIEW;\n  this._setTransform(Matrix4.IDENTITY);\n  const offset = adjustBoundingSphereOffset(\n    this,\n    boundingSphere,\n    options.offset,\n  );\n\n  let position;\n  if (scene2D) {\n    position = Cartesian3.multiplyByScalar(\n      Cartesian3.UNIT_Z,\n      offset.range,\n      scratchflyToBoundingSphereDestination,\n    );\n  } else {\n    position = offsetFromHeadingPitchRange(\n      offset.heading,\n      offset.pitch,\n      offset.range,\n    );\n  }\n\n  const scene = this._scene;\n  const ellipsoid = defaultValue(scene.ellipsoid, Ellipsoid.default);\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    boundingSphere.center,\n    ellipsoid,\n    scratchflyToBoundingSphereTransform,\n  );\n  Matrix4.multiplyByPoint(transform, position, position);\n\n  let direction;\n  let up;\n\n  if (!scene2D) {\n    direction = Cartesian3.subtract(\n      boundingSphere.center,\n      position,\n      scratchflyToBoundingSphereDirection,\n    );\n    Cartesian3.normalize(direction, direction);\n\n    up = Matrix4.multiplyByPointAsVector(\n      transform,\n      Cartesian3.UNIT_Z,\n      scratchflyToBoundingSphereUp,\n    );\n    if (1.0 - Math.abs(Cartesian3.dot(direction, up)) < CesiumMath.EPSILON6) {\n      const rotateQuat = Quaternion.fromAxisAngle(\n        direction,\n        offset.heading,\n        scratchFlyToBoundingSphereQuaternion,\n      );\n      const rotation = Matrix3.fromQuaternion(\n        rotateQuat,\n        scratchFlyToBoundingSphereMatrix3,\n      );\n\n      Cartesian3.fromCartesian4(\n        Matrix4.getColumn(transform, 1, scratchFlyToBoundingSphereCart4),\n        up,\n      );\n      Matrix3.multiplyByVector(rotation, up, up);\n    }\n\n    const right = Cartesian3.cross(\n      direction,\n      up,\n      scratchflyToBoundingSphereRight,\n    );\n    Cartesian3.cross(right, direction, up);\n    Cartesian3.normalize(up, up);\n  }\n\n  this.flyTo({\n    destination: position,\n    orientation: {\n      direction: direction,\n      up: up,\n    },\n    duration: options.duration,\n    complete: options.complete,\n    cancel: options.cancel,\n    endTransform: options.endTransform,\n    maximumHeight: options.maximumHeight,\n    easingFunction: options.easingFunction,\n    flyOverLongitude: options.flyOverLongitude,\n    flyOverLongitudeWeight: options.flyOverLongitudeWeight,\n    pitchAdjustHeight: options.pitchAdjustHeight,\n  });\n};\n\nconst scratchCartesian3_1 = new Cartesian3();\nconst scratchCartesian3_2 = new Cartesian3();\nconst scratchCartesian3_3 = new Cartesian3();\nconst scratchCartesian3_4 = new Cartesian3();\nconst horizonPoints = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\n\nfunction computeHorizonQuad(camera, ellipsoid) {\n  const radii = ellipsoid.radii;\n  const p = camera.positionWC;\n\n  // Find the corresponding position in the scaled space of the ellipsoid.\n  const q = Cartesian3.multiplyComponents(\n    ellipsoid.oneOverRadii,\n    p,\n    scratchCartesian3_1,\n  );\n\n  const qMagnitude = Cartesian3.magnitude(q);\n  const qUnit = Cartesian3.normalize(q, scratchCartesian3_2);\n\n  // Determine the east and north directions at q.\n  let eUnit;\n  let nUnit;\n  if (\n    Cartesian3.equalsEpsilon(qUnit, Cartesian3.UNIT_Z, CesiumMath.EPSILON10)\n  ) {\n    eUnit = new Cartesian3(0, 1, 0);\n    nUnit = new Cartesian3(0, 0, 1);\n  } else {\n    eUnit = Cartesian3.normalize(\n      Cartesian3.cross(Cartesian3.UNIT_Z, qUnit, scratchCartesian3_3),\n      scratchCartesian3_3,\n    );\n    nUnit = Cartesian3.normalize(\n      Cartesian3.cross(qUnit, eUnit, scratchCartesian3_4),\n      scratchCartesian3_4,\n    );\n  }\n\n  // Determine the radius of the 'limb' of the ellipsoid.\n  const wMagnitude = Math.sqrt(Cartesian3.magnitudeSquared(q) - 1.0);\n\n  // Compute the center and offsets.\n  const center = Cartesian3.multiplyByScalar(\n    qUnit,\n    1.0 / qMagnitude,\n    scratchCartesian3_1,\n  );\n  const scalar = wMagnitude / qMagnitude;\n  const eastOffset = Cartesian3.multiplyByScalar(\n    eUnit,\n    scalar,\n    scratchCartesian3_2,\n  );\n  const northOffset = Cartesian3.multiplyByScalar(\n    nUnit,\n    scalar,\n    scratchCartesian3_3,\n  );\n\n  // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.\n  const upperLeft = Cartesian3.add(center, northOffset, horizonPoints[0]);\n  Cartesian3.subtract(upperLeft, eastOffset, upperLeft);\n  Cartesian3.multiplyComponents(radii, upperLeft, upperLeft);\n\n  const lowerLeft = Cartesian3.subtract(center, northOffset, horizonPoints[1]);\n  Cartesian3.subtract(lowerLeft, eastOffset, lowerLeft);\n  Cartesian3.multiplyComponents(radii, lowerLeft, lowerLeft);\n\n  const lowerRight = Cartesian3.subtract(center, northOffset, horizonPoints[2]);\n  Cartesian3.add(lowerRight, eastOffset, lowerRight);\n  Cartesian3.multiplyComponents(radii, lowerRight, lowerRight);\n\n  const upperRight = Cartesian3.add(center, northOffset, horizonPoints[3]);\n  Cartesian3.add(upperRight, eastOffset, upperRight);\n  Cartesian3.multiplyComponents(radii, upperRight, upperRight);\n\n  return horizonPoints;\n}\n\nconst scratchPickCartesian2 = new Cartesian2();\nconst scratchRectCartesian = new Cartesian3();\nconst cartoArray = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\nfunction addToResult(x, y, index, camera, ellipsoid, computedHorizonQuad) {\n  scratchPickCartesian2.x = x;\n  scratchPickCartesian2.y = y;\n  const r = camera.pickEllipsoid(\n    scratchPickCartesian2,\n    ellipsoid,\n    scratchRectCartesian,\n  );\n  if (defined(r)) {\n    cartoArray[index] = ellipsoid.cartesianToCartographic(r, cartoArray[index]);\n    return 1;\n  }\n  cartoArray[index] = ellipsoid.cartesianToCartographic(\n    computedHorizonQuad[index],\n    cartoArray[index],\n  );\n  return 0;\n}\n/**\n * Computes the approximate visible rectangle on the ellipsoid.\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid that you want to know the visible region.\n * @param {Rectangle} [result] The rectangle in which to store the result\n *\n * @returns {Rectangle|undefined} The visible rectangle or undefined if the ellipsoid isn't visible at all.\n */\nCamera.prototype.computeViewRectangle = function (ellipsoid, result) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  const cullingVolume = this.frustum.computeCullingVolume(\n    this.positionWC,\n    this.directionWC,\n    this.upWC,\n  );\n  const boundingSphere = new BoundingSphere(\n    Cartesian3.ZERO,\n    ellipsoid.maximumRadius,\n  );\n  const visibility = cullingVolume.computeVisibility(boundingSphere);\n  if (visibility === Intersect.OUTSIDE) {\n    return undefined;\n  }\n\n  const canvas = this._scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n\n  let successfulPickCount = 0;\n\n  const computedHorizonQuad = computeHorizonQuad(this, ellipsoid);\n\n  successfulPickCount += addToResult(\n    0,\n    0,\n    0,\n    this,\n    ellipsoid,\n    computedHorizonQuad,\n  );\n  successfulPickCount += addToResult(\n    0,\n    height,\n    1,\n    this,\n    ellipsoid,\n    computedHorizonQuad,\n  );\n  successfulPickCount += addToResult(\n    width,\n    height,\n    2,\n    this,\n    ellipsoid,\n    computedHorizonQuad,\n  );\n  successfulPickCount += addToResult(\n    width,\n    0,\n    3,\n    this,\n    ellipsoid,\n    computedHorizonQuad,\n  );\n\n  if (successfulPickCount < 2) {\n    // If we have space non-globe in 3 or 4 corners then return the whole globe\n    return Rectangle.MAX_VALUE;\n  }\n\n  result = Rectangle.fromCartographicArray(cartoArray, result);\n\n  // Detect if we go over the poles\n  let distance = 0;\n  let lastLon = cartoArray[3].longitude;\n  for (let i = 0; i < 4; ++i) {\n    const lon = cartoArray[i].longitude;\n    const diff = Math.abs(lon - lastLon);\n    if (diff > CesiumMath.PI) {\n      // Crossed the dateline\n      distance += CesiumMath.TWO_PI - diff;\n    } else {\n      distance += diff;\n    }\n\n    lastLon = lon;\n  }\n\n  // We are over one of the poles so adjust the rectangle accordingly\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(distance),\n      CesiumMath.TWO_PI,\n      CesiumMath.EPSILON9,\n    )\n  ) {\n    result.west = -CesiumMath.PI;\n    result.east = CesiumMath.PI;\n    if (cartoArray[0].latitude >= 0.0) {\n      result.north = CesiumMath.PI_OVER_TWO;\n    } else {\n      result.south = -CesiumMath.PI_OVER_TWO;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Switches the frustum/projection to perspective.\n *\n * This function is a no-op in 2D which must always be orthographic.\n */\nCamera.prototype.switchToPerspectiveFrustum = function () {\n  if (\n    this._mode === SceneMode.SCENE2D ||\n    this.frustum instanceof PerspectiveFrustum\n  ) {\n    return;\n  }\n\n  const scene = this._scene;\n  this.frustum = new PerspectiveFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = CesiumMath.toRadians(60.0);\n};\n\n/**\n * Switches the frustum/projection to orthographic.\n *\n * This function is a no-op in 2D which will always be orthographic.\n */\nCamera.prototype.switchToOrthographicFrustum = function () {\n  if (\n    this._mode === SceneMode.SCENE2D ||\n    this.frustum instanceof OrthographicFrustum\n  ) {\n    return;\n  }\n\n  // This must be called before changing the frustum because it uses the previous\n  // frustum to reconstruct the world space position from the depth buffer.\n  const frustumWidth = calculateOrthographicFrustumWidth(this);\n\n  const scene = this._scene;\n  this.frustum = new OrthographicFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.width = frustumWidth;\n};\n\n/**\n * @private\n */\nCamera.clone = function (camera, result) {\n  if (!defined(result)) {\n    result = new Camera(camera._scene);\n  }\n\n  Cartesian3.clone(camera.position, result.position);\n  Cartesian3.clone(camera.direction, result.direction);\n  Cartesian3.clone(camera.up, result.up);\n  Cartesian3.clone(camera.right, result.right);\n  Matrix4.clone(camera._transform, result.transform);\n  result._transformChanged = true;\n  result.frustum = camera.frustum.clone();\n\n  return result;\n};\n\n/**\n * A function that will execute when a flight completes.\n * @callback Camera.FlightCompleteCallback\n */\n\n/**\n * A function that will execute when a flight is cancelled.\n * @callback Camera.FlightCancelledCallback\n */\nexport default Camera;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}