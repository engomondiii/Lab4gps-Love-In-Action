{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Cesium3DTileOptimizationHint from \"./Cesium3DTileOptimizationHint.js\";\nimport TileBoundingRegion from \"./TileBoundingRegion.js\";\nimport TileOrientedBoundingBox from \"./TileOrientedBoundingBox.js\";\n\n/**\n * Utility functions for computing optimization hints for a {@link Cesium3DTileset}.\n *\n * @namespace Cesium3DTileOptimizations\n *\n * @private\n */\nconst Cesium3DTileOptimizations = {};\nconst scratchAxis = new Cartesian3();\n\n/**\n * Evaluates support for the childrenWithinParent optimization. This is used to more tightly cull tilesets if\n * children bounds are fully contained within the parent. Currently, support for the optimization only works for\n * oriented bounding boxes, so both the child and parent tile must be either a {@link TileOrientedBoundingBox} or\n * {@link TileBoundingRegion}. The purpose of this check is to prevent use of a culling optimization when the child\n * bounds exceed those of the parent. If the child bounds are greater, it is more likely that the optimization will\n * waste CPU cycles. Bounding spheres are not supported for the reason that the child bounds can very often be\n * partially outside of the parent bounds.\n *\n * @param {Cesium3DTile} tile The tile to check.\n * @returns {boolean} Whether the childrenWithinParent optimization is supported.\n */\nCesium3DTileOptimizations.checkChildrenWithinParent = function (tile) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"tile\", tile);\n  //>>includeEnd('debug');\n\n  const children = tile.children;\n  const length = children.length;\n\n  // Check if the parent has an oriented bounding box.\n  const boundingVolume = tile.boundingVolume;\n  if (boundingVolume instanceof TileOrientedBoundingBox || boundingVolume instanceof TileBoundingRegion) {\n    const orientedBoundingBox = boundingVolume._orientedBoundingBox;\n    tile._optimChildrenWithinParent = Cesium3DTileOptimizationHint.USE_OPTIMIZATION;\n    for (let i = 0; i < length; ++i) {\n      const child = children[i];\n\n      // Check if the child has an oriented bounding box.\n      const childBoundingVolume = child.boundingVolume;\n      if (!(childBoundingVolume instanceof TileOrientedBoundingBox || childBoundingVolume instanceof TileBoundingRegion)) {\n        // Do not support if the parent and child both do not have oriented bounding boxes.\n        tile._optimChildrenWithinParent = Cesium3DTileOptimizationHint.SKIP_OPTIMIZATION;\n        break;\n      }\n      const childOrientedBoundingBox = childBoundingVolume._orientedBoundingBox;\n\n      // Compute the axis from the parent to the child.\n      const axis = Cartesian3.subtract(childOrientedBoundingBox.center, orientedBoundingBox.center, scratchAxis);\n      const axisLength = Cartesian3.magnitude(axis);\n      Cartesian3.divideByScalar(axis, axisLength, axis);\n\n      // Project the bounding box of the parent onto the axis. Because the axis is a ray from the parent\n      // to the child, the projection parameterized along the ray will be (+/- proj1).\n      const proj1 = Math.abs(orientedBoundingBox.halfAxes[0] * axis.x) + Math.abs(orientedBoundingBox.halfAxes[1] * axis.y) + Math.abs(orientedBoundingBox.halfAxes[2] * axis.z) + Math.abs(orientedBoundingBox.halfAxes[3] * axis.x) + Math.abs(orientedBoundingBox.halfAxes[4] * axis.y) + Math.abs(orientedBoundingBox.halfAxes[5] * axis.z) + Math.abs(orientedBoundingBox.halfAxes[6] * axis.x) + Math.abs(orientedBoundingBox.halfAxes[7] * axis.y) + Math.abs(orientedBoundingBox.halfAxes[8] * axis.z);\n\n      // Project the bounding box of the child onto the axis. Because the axis is a ray from the parent\n      // to the child, the projection parameterized along the ray will be (+/- proj2) + axis.length.\n      const proj2 = Math.abs(childOrientedBoundingBox.halfAxes[0] * axis.x) + Math.abs(childOrientedBoundingBox.halfAxes[1] * axis.y) + Math.abs(childOrientedBoundingBox.halfAxes[2] * axis.z) + Math.abs(childOrientedBoundingBox.halfAxes[3] * axis.x) + Math.abs(childOrientedBoundingBox.halfAxes[4] * axis.y) + Math.abs(childOrientedBoundingBox.halfAxes[5] * axis.z) + Math.abs(childOrientedBoundingBox.halfAxes[6] * axis.x) + Math.abs(childOrientedBoundingBox.halfAxes[7] * axis.y) + Math.abs(childOrientedBoundingBox.halfAxes[8] * axis.z);\n\n      // If the child extends the parent's bounds, the optimization is not valid and we skip it.\n      if (proj1 <= proj2 + axisLength) {\n        tile._optimChildrenWithinParent = Cesium3DTileOptimizationHint.SKIP_OPTIMIZATION;\n        break;\n      }\n    }\n  }\n  return tile._optimChildrenWithinParent === Cesium3DTileOptimizationHint.USE_OPTIMIZATION;\n};\nexport default Cesium3DTileOptimizations;","map":{"version":3,"names":["Cartesian3","Check","Cesium3DTileOptimizationHint","TileBoundingRegion","TileOrientedBoundingBox","Cesium3DTileOptimizations","scratchAxis","checkChildrenWithinParent","tile","typeOf","object","children","length","boundingVolume","orientedBoundingBox","_orientedBoundingBox","_optimChildrenWithinParent","USE_OPTIMIZATION","i","child","childBoundingVolume","SKIP_OPTIMIZATION","childOrientedBoundingBox","axis","subtract","center","axisLength","magnitude","divideByScalar","proj1","Math","abs","halfAxes","x","y","z","proj2"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Cesium3DTileOptimizations.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Cesium3DTileOptimizationHint from \"./Cesium3DTileOptimizationHint.js\";\nimport TileBoundingRegion from \"./TileBoundingRegion.js\";\nimport TileOrientedBoundingBox from \"./TileOrientedBoundingBox.js\";\n\n/**\n * Utility functions for computing optimization hints for a {@link Cesium3DTileset}.\n *\n * @namespace Cesium3DTileOptimizations\n *\n * @private\n */\nconst Cesium3DTileOptimizations = {};\n\nconst scratchAxis = new Cartesian3();\n\n/**\n * Evaluates support for the childrenWithinParent optimization. This is used to more tightly cull tilesets if\n * children bounds are fully contained within the parent. Currently, support for the optimization only works for\n * oriented bounding boxes, so both the child and parent tile must be either a {@link TileOrientedBoundingBox} or\n * {@link TileBoundingRegion}. The purpose of this check is to prevent use of a culling optimization when the child\n * bounds exceed those of the parent. If the child bounds are greater, it is more likely that the optimization will\n * waste CPU cycles. Bounding spheres are not supported for the reason that the child bounds can very often be\n * partially outside of the parent bounds.\n *\n * @param {Cesium3DTile} tile The tile to check.\n * @returns {boolean} Whether the childrenWithinParent optimization is supported.\n */\nCesium3DTileOptimizations.checkChildrenWithinParent = function (tile) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"tile\", tile);\n  //>>includeEnd('debug');\n\n  const children = tile.children;\n  const length = children.length;\n\n  // Check if the parent has an oriented bounding box.\n  const boundingVolume = tile.boundingVolume;\n  if (\n    boundingVolume instanceof TileOrientedBoundingBox ||\n    boundingVolume instanceof TileBoundingRegion\n  ) {\n    const orientedBoundingBox = boundingVolume._orientedBoundingBox;\n    tile._optimChildrenWithinParent =\n      Cesium3DTileOptimizationHint.USE_OPTIMIZATION;\n    for (let i = 0; i < length; ++i) {\n      const child = children[i];\n\n      // Check if the child has an oriented bounding box.\n      const childBoundingVolume = child.boundingVolume;\n      if (\n        !(\n          childBoundingVolume instanceof TileOrientedBoundingBox ||\n          childBoundingVolume instanceof TileBoundingRegion\n        )\n      ) {\n        // Do not support if the parent and child both do not have oriented bounding boxes.\n        tile._optimChildrenWithinParent =\n          Cesium3DTileOptimizationHint.SKIP_OPTIMIZATION;\n        break;\n      }\n\n      const childOrientedBoundingBox = childBoundingVolume._orientedBoundingBox;\n\n      // Compute the axis from the parent to the child.\n      const axis = Cartesian3.subtract(\n        childOrientedBoundingBox.center,\n        orientedBoundingBox.center,\n        scratchAxis,\n      );\n      const axisLength = Cartesian3.magnitude(axis);\n      Cartesian3.divideByScalar(axis, axisLength, axis);\n\n      // Project the bounding box of the parent onto the axis. Because the axis is a ray from the parent\n      // to the child, the projection parameterized along the ray will be (+/- proj1).\n      const proj1 =\n        Math.abs(orientedBoundingBox.halfAxes[0] * axis.x) +\n        Math.abs(orientedBoundingBox.halfAxes[1] * axis.y) +\n        Math.abs(orientedBoundingBox.halfAxes[2] * axis.z) +\n        Math.abs(orientedBoundingBox.halfAxes[3] * axis.x) +\n        Math.abs(orientedBoundingBox.halfAxes[4] * axis.y) +\n        Math.abs(orientedBoundingBox.halfAxes[5] * axis.z) +\n        Math.abs(orientedBoundingBox.halfAxes[6] * axis.x) +\n        Math.abs(orientedBoundingBox.halfAxes[7] * axis.y) +\n        Math.abs(orientedBoundingBox.halfAxes[8] * axis.z);\n\n      // Project the bounding box of the child onto the axis. Because the axis is a ray from the parent\n      // to the child, the projection parameterized along the ray will be (+/- proj2) + axis.length.\n      const proj2 =\n        Math.abs(childOrientedBoundingBox.halfAxes[0] * axis.x) +\n        Math.abs(childOrientedBoundingBox.halfAxes[1] * axis.y) +\n        Math.abs(childOrientedBoundingBox.halfAxes[2] * axis.z) +\n        Math.abs(childOrientedBoundingBox.halfAxes[3] * axis.x) +\n        Math.abs(childOrientedBoundingBox.halfAxes[4] * axis.y) +\n        Math.abs(childOrientedBoundingBox.halfAxes[5] * axis.z) +\n        Math.abs(childOrientedBoundingBox.halfAxes[6] * axis.x) +\n        Math.abs(childOrientedBoundingBox.halfAxes[7] * axis.y) +\n        Math.abs(childOrientedBoundingBox.halfAxes[8] * axis.z);\n\n      // If the child extends the parent's bounds, the optimization is not valid and we skip it.\n      if (proj1 <= proj2 + axisLength) {\n        tile._optimChildrenWithinParent =\n          Cesium3DTileOptimizationHint.SKIP_OPTIMIZATION;\n        break;\n      }\n    }\n  }\n\n  return (\n    tile._optimChildrenWithinParent ===\n    Cesium3DTileOptimizationHint.USE_OPTIMIZATION\n  );\n};\nexport default Cesium3DTileOptimizations;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}