{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Plane from \"../Core/Plane.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport PolylineCommon from \"../Shaders/PolylineCommon.js\";\nimport PolylineFS from \"../Shaders/PolylineFS.js\";\nimport PolylineVS from \"../Shaders/PolylineVS.js\";\nimport BatchTable from \"./BatchTable.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Material from \"./Material.js\";\nimport Polyline from \"./Polyline.js\";\nimport SceneMode from \"./SceneMode.js\";\nconst SHOW_INDEX = Polyline.SHOW_INDEX;\nconst WIDTH_INDEX = Polyline.WIDTH_INDEX;\nconst POSITION_INDEX = Polyline.POSITION_INDEX;\nconst MATERIAL_INDEX = Polyline.MATERIAL_INDEX;\n//POSITION_SIZE_INDEX is needed for when the polyline's position array changes size.\n//When it does, we need to recreate the indicesBuffer.\nconst POSITION_SIZE_INDEX = Polyline.POSITION_SIZE_INDEX;\nconst DISTANCE_DISPLAY_CONDITION = Polyline.DISTANCE_DISPLAY_CONDITION;\nconst NUMBER_OF_PROPERTIES = Polyline.NUMBER_OF_PROPERTIES;\nconst attributeLocations = {\n  texCoordExpandAndBatchIndex: 0,\n  position3DHigh: 1,\n  position3DLow: 2,\n  position2DHigh: 3,\n  position2DLow: 4,\n  prevPosition3DHigh: 5,\n  prevPosition3DLow: 6,\n  prevPosition2DHigh: 7,\n  prevPosition2DLow: 8,\n  nextPosition3DHigh: 9,\n  nextPosition3DLow: 10,\n  nextPosition2DHigh: 11,\n  nextPosition2DLow: 12\n};\n\n/**\n * A renderable collection of polylines.\n * <br /><br />\n * <div align=\"center\">\n * <img src=\"Images/Polyline.png\" width=\"400\" height=\"300\" /><br />\n * Example polylines\n * </div>\n * <br /><br />\n * Polylines are added and removed from the collection using {@link PolylineCollection#add}\n * and {@link PolylineCollection#remove}.\n *\n * @alias PolylineCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each polyline from model to world coordinates.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {boolean} [options.show=true] Determines if the polylines in the collection will be shown.\n *\n * @performance For best performance, prefer a few collections, each with many polylines, to\n * many collections with only a few polylines each.  Organize collections so that polylines\n * with the same update frequency are in the same collection, i.e., polylines that do not\n * change should be in one collection; polylines that change every frame should be in another\n * collection; and so on.\n *\n * @see PolylineCollection#add\n * @see PolylineCollection#remove\n * @see Polyline\n * @see LabelCollection\n *\n * @example\n * // Create a polyline collection with two polylines\n * const polylines = new Cesium.PolylineCollection();\n * polylines.add({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -75.10, 39.57,\n *     -77.02, 38.53,\n *     -80.50, 35.14,\n *     -80.12, 25.46]),\n *   width : 2\n * });\n *\n * polylines.add({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -73.10, 37.57,\n *     -75.02, 36.53,\n *     -78.50, 33.14,\n *     -78.12, 23.46]),\n *   width : 4\n * });\n */\nfunction PolylineCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * Determines if polylines in this collection will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * The 4x4 transformation matrix that transforms each polyline in this collection from model to world coordinates.\n   * When this is the identity matrix, the polylines are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   */\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n  this._opaqueRS = undefined;\n  this._translucentRS = undefined;\n  this._colorCommands = [];\n  this._polylinesUpdated = false;\n  this._polylinesRemoved = false;\n  this._createVertexArray = false;\n  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n  this._polylines = [];\n  this._polylineBuckets = {};\n\n  // The buffer usage is determined based on the usage of the attribute over time.\n  this._positionBufferUsage = {\n    bufferUsage: BufferUsage.STATIC_DRAW,\n    frameCount: 0\n  };\n  this._mode = undefined;\n  this._polylinesToUpdate = [];\n  this._vertexArrays = [];\n  this._positionBuffer = undefined;\n  this._texCoordExpandAndBatchIndexBuffer = undefined;\n  this._batchTable = undefined;\n  this._createBatchTable = false;\n\n  // Only used by Vector3DTilePoints\n  this._useHighlightColor = false;\n  this._highlightColor = Color.clone(Color.WHITE);\n  const that = this;\n  this._uniformMap = {\n    u_highlightColor: function () {\n      return that._highlightColor;\n    }\n  };\n}\nObject.defineProperties(PolylineCollection.prototype, {\n  /**\n   * Returns the number of polylines in this collection.  This is commonly used with\n   * {@link PolylineCollection#get} to iterate over all the polylines\n   * in the collection.\n   * @memberof PolylineCollection.prototype\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      removePolylines(this);\n      return this._polylines.length;\n    }\n  }\n});\n\n/**\n     * Creates and adds a polyline with the specified initial properties to the collection.\n     * The added polyline is returned so it can be modified or removed from the collection later.\n     *\n     * @param {object}[options] A template describing the polyline's properties as shown in Example 1.\n     * @returns {Polyline} The polyline that was added to the collection.\n     *\n     * @performance After calling <code>add</code>, {@link PolylineCollection#update} is called and\n     * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.\n     * For best performance, add as many polylines as possible before calling <code>update</code>.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * // Example 1:  Add a polyline, specifying all the default values.\n     * const p = polylines.add({\n     *   show : true,\n     *   positions : ellipsoid.cartographicArrayToCartesianArray([\n           Cesium.Cartographic.fromDegrees(-75.10, 39.57),\n           Cesium.Cartographic.fromDegrees(-77.02, 38.53)]),\n     *   width : 1\n     * });\n     *\n     * @see PolylineCollection#remove\n     * @see PolylineCollection#removeAll\n     * @see PolylineCollection#update\n     */\nPolylineCollection.prototype.add = function (options) {\n  const p = new Polyline(options, this);\n  p._index = this._polylines.length;\n  this._polylines.push(p);\n  this._createVertexArray = true;\n  this._createBatchTable = true;\n  return p;\n};\n\n/**\n * Removes a polyline from the collection.\n *\n * @param {Polyline} polyline The polyline to remove.\n * @returns {boolean} <code>true</code> if the polyline was removed; <code>false</code> if the polyline was not found in the collection.\n *\n * @performance After calling <code>remove</code>, {@link PolylineCollection#update} is called and\n * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.\n * For best performance, remove as many polylines as possible before calling <code>update</code>.\n * If you intend to temporarily hide a polyline, it is usually more efficient to call\n * {@link Polyline#show} instead of removing and re-adding the polyline.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const p = polylines.add(...);\n * polylines.remove(p);  // Returns true\n *\n * @see PolylineCollection#add\n * @see PolylineCollection#removeAll\n * @see PolylineCollection#update\n * @see Polyline#show\n */\nPolylineCollection.prototype.remove = function (polyline) {\n  if (this.contains(polyline)) {\n    this._polylinesRemoved = true;\n    this._createVertexArray = true;\n    this._createBatchTable = true;\n    if (defined(polyline._bucket)) {\n      const bucket = polyline._bucket;\n      bucket.shaderProgram = bucket.shaderProgram && bucket.shaderProgram.destroy();\n    }\n    polyline._destroy();\n    return true;\n  }\n  return false;\n};\n\n/**\n * Removes all polylines from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the polylines\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * polylines.add(...);\n * polylines.add(...);\n * polylines.removeAll();\n *\n * @see PolylineCollection#add\n * @see PolylineCollection#remove\n * @see PolylineCollection#update\n */\nPolylineCollection.prototype.removeAll = function () {\n  releaseShaders(this);\n  destroyPolylines(this);\n  this._polylineBuckets = {};\n  this._polylinesRemoved = false;\n  this._polylines.length = 0;\n  this._polylinesToUpdate.length = 0;\n  this._createVertexArray = true;\n};\n\n/**\n * Determines if this collection contains the specified polyline.\n *\n * @param {Polyline} polyline The polyline to check for.\n * @returns {boolean} true if this collection contains the polyline, false otherwise.\n *\n * @see PolylineCollection#get\n */\nPolylineCollection.prototype.contains = function (polyline) {\n  return defined(polyline) && polyline._polylineCollection === this;\n};\n\n/**\n * Returns the polyline in the collection at the specified index.  Indices are zero-based\n * and increase as polylines are added.  Removing a polyline shifts all polylines after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link PolylineCollection#length} to iterate over all the polylines\n * in the collection.\n *\n * @param {number} index The zero-based index of the polyline.\n * @returns {Polyline} The polyline at the specified index.\n *\n * @performance If polylines were removed from the collection and\n * {@link PolylineCollection#update} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Toggle the show property of every polyline in the collection\n * const len = polylines.length;\n * for (let i = 0; i < len; ++i) {\n *   const p = polylines.get(i);\n *   p.show = !p.show;\n * }\n *\n * @see PolylineCollection#length\n */\nPolylineCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  removePolylines(this);\n  return this._polylines[index];\n};\nfunction createBatchTable(collection, context) {\n  if (defined(collection._batchTable)) {\n    collection._batchTable.destroy();\n  }\n  const attributes = [{\n    functionName: \"batchTable_getWidthAndShow\",\n    componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n    componentsPerAttribute: 2\n  }, {\n    functionName: \"batchTable_getPickColor\",\n    componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n    componentsPerAttribute: 4,\n    normalize: true\n  }, {\n    functionName: \"batchTable_getCenterHigh\",\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3\n  }, {\n    functionName: \"batchTable_getCenterLowAndRadius\",\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4\n  }, {\n    functionName: \"batchTable_getDistanceDisplayCondition\",\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 2\n  }];\n  collection._batchTable = new BatchTable(context, attributes, collection._polylines.length);\n}\nconst scratchUpdatePolylineEncodedCartesian = new EncodedCartesian3();\nconst scratchUpdatePolylineCartesian4 = new Cartesian4();\nconst scratchNearFarCartesian2 = new Cartesian2();\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {RuntimeError} Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\n */\nPolylineCollection.prototype.update = function (frameState) {\n  removePolylines(this);\n  if (this._polylines.length === 0 || !this.show) {\n    return;\n  }\n  updateMode(this, frameState);\n  const context = frameState.context;\n  const projection = frameState.mapProjection;\n  let polyline;\n  let properties = this._propertiesChanged;\n  if (this._createBatchTable) {\n    if (ContextLimits.maximumVertexTextureImageUnits === 0) {\n      throw new RuntimeError(\"Vertex texture fetch support is required to render polylines. The maximum number of vertex texture image units must be greater than zero.\");\n    }\n    createBatchTable(this, context);\n    this._createBatchTable = false;\n  }\n  if (this._createVertexArray || computeNewBuffersUsage(this)) {\n    createVertexArrays(this, context, projection);\n  } else if (this._polylinesUpdated) {\n    // Polylines were modified, but no polylines were added or removed.\n    const polylinesToUpdate = this._polylinesToUpdate;\n    if (this._mode !== SceneMode.SCENE3D) {\n      const updateLength = polylinesToUpdate.length;\n      for (let i = 0; i < updateLength; ++i) {\n        polyline = polylinesToUpdate[i];\n        polyline.update();\n      }\n    }\n\n    // if a polyline's positions size changes, we need to recreate the vertex arrays and vertex buffers because the indices will be different.\n    // if a polyline's material changes, we need to recreate the VAOs and VBOs because they will be batched differently.\n    if (properties[POSITION_SIZE_INDEX] || properties[MATERIAL_INDEX]) {\n      createVertexArrays(this, context, projection);\n    } else {\n      const length = polylinesToUpdate.length;\n      const polylineBuckets = this._polylineBuckets;\n      for (let ii = 0; ii < length; ++ii) {\n        polyline = polylinesToUpdate[ii];\n        properties = polyline._propertiesChanged;\n        const bucket = polyline._bucket;\n        let index = 0;\n        for (const x in polylineBuckets) {\n          if (polylineBuckets.hasOwnProperty(x)) {\n            if (polylineBuckets[x] === bucket) {\n              if (properties[POSITION_INDEX]) {\n                bucket.writeUpdate(index, polyline, this._positionBuffer, projection);\n              }\n              break;\n            }\n            index += polylineBuckets[x].lengthOfPositions;\n          }\n        }\n        if (properties[SHOW_INDEX] || properties[WIDTH_INDEX]) {\n          this._batchTable.setBatchedAttribute(polyline._index, 0, new Cartesian2(polyline._width, polyline._show));\n        }\n        if (this._batchTable.attributes.length > 2) {\n          if (properties[POSITION_INDEX] || properties[POSITION_SIZE_INDEX]) {\n            const boundingSphere = frameState.mode === SceneMode.SCENE2D ? polyline._boundingVolume2D : polyline._boundingVolumeWC;\n            const encodedCenter = EncodedCartesian3.fromCartesian(boundingSphere.center, scratchUpdatePolylineEncodedCartesian);\n            const low = Cartesian4.fromElements(encodedCenter.low.x, encodedCenter.low.y, encodedCenter.low.z, boundingSphere.radius, scratchUpdatePolylineCartesian4);\n            this._batchTable.setBatchedAttribute(polyline._index, 2, encodedCenter.high);\n            this._batchTable.setBatchedAttribute(polyline._index, 3, low);\n          }\n          if (properties[DISTANCE_DISPLAY_CONDITION]) {\n            const nearFarCartesian = scratchNearFarCartesian2;\n            nearFarCartesian.x = 0.0;\n            nearFarCartesian.y = Number.MAX_VALUE;\n            const distanceDisplayCondition = polyline.distanceDisplayCondition;\n            if (defined(distanceDisplayCondition)) {\n              nearFarCartesian.x = distanceDisplayCondition.near;\n              nearFarCartesian.y = distanceDisplayCondition.far;\n            }\n            this._batchTable.setBatchedAttribute(polyline._index, 4, nearFarCartesian);\n          }\n        }\n        polyline._clean();\n      }\n    }\n    polylinesToUpdate.length = 0;\n    this._polylinesUpdated = false;\n  }\n  properties = this._propertiesChanged;\n  for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n    properties[k] = 0;\n  }\n  let modelMatrix = Matrix4.IDENTITY;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    modelMatrix = this.modelMatrix;\n  }\n  const pass = frameState.passes;\n  const useDepthTest = frameState.morphTime !== 0.0;\n  if (!defined(this._opaqueRS) || this._opaqueRS.depthTest.enabled !== useDepthTest) {\n    this._opaqueRS = RenderState.fromCache({\n      depthMask: useDepthTest,\n      depthTest: {\n        enabled: useDepthTest\n      }\n    });\n  }\n  if (!defined(this._translucentRS) || this._translucentRS.depthTest.enabled !== useDepthTest) {\n    this._translucentRS = RenderState.fromCache({\n      blending: BlendingState.ALPHA_BLEND,\n      depthMask: !useDepthTest,\n      depthTest: {\n        enabled: useDepthTest\n      }\n    });\n  }\n  this._batchTable.update(frameState);\n  if (pass.render || pass.pick) {\n    const colorList = this._colorCommands;\n    createCommandLists(this, frameState, colorList, modelMatrix);\n  }\n};\nconst boundingSphereScratch = new BoundingSphere();\nconst boundingSphereScratch2 = new BoundingSphere();\nfunction createCommandLists(polylineCollection, frameState, commands, modelMatrix) {\n  const context = frameState.context;\n  const commandList = frameState.commandList;\n  const commandsLength = commands.length;\n  let commandIndex = 0;\n  let cloneBoundingSphere = true;\n  const vertexArrays = polylineCollection._vertexArrays;\n  const debugShowBoundingVolume = polylineCollection.debugShowBoundingVolume;\n  const batchTable = polylineCollection._batchTable;\n  const uniformCallback = batchTable.getUniformMapCallback();\n  const length = vertexArrays.length;\n  for (let m = 0; m < length; ++m) {\n    const va = vertexArrays[m];\n    const buckets = va.buckets;\n    const bucketLength = buckets.length;\n    for (let n = 0; n < bucketLength; ++n) {\n      const bucketLocator = buckets[n];\n      let offset = bucketLocator.offset;\n      const sp = bucketLocator.bucket.shaderProgram;\n      const polylines = bucketLocator.bucket.polylines;\n      const polylineLength = polylines.length;\n      let currentId;\n      let currentMaterial;\n      let count = 0;\n      let command;\n      let uniformMap;\n      for (let s = 0; s < polylineLength; ++s) {\n        const polyline = polylines[s];\n        const mId = createMaterialId(polyline._material);\n        if (mId !== currentId) {\n          if (defined(currentId) && count > 0) {\n            const translucent = currentMaterial.isTranslucent();\n            if (commandIndex >= commandsLength) {\n              command = new DrawCommand({\n                owner: polylineCollection\n              });\n              commands.push(command);\n            } else {\n              command = commands[commandIndex];\n            }\n            ++commandIndex;\n            uniformMap = combine(uniformCallback(currentMaterial._uniforms), polylineCollection._uniformMap);\n            command.boundingVolume = BoundingSphere.clone(boundingSphereScratch, command.boundingVolume);\n            command.modelMatrix = modelMatrix;\n            command.shaderProgram = sp;\n            command.vertexArray = va.va;\n            command.renderState = translucent ? polylineCollection._translucentRS : polylineCollection._opaqueRS;\n            command.pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n            command.debugShowBoundingVolume = debugShowBoundingVolume;\n            command.pickId = \"v_pickColor\";\n            command.uniformMap = uniformMap;\n            command.count = count;\n            command.offset = offset;\n            offset += count;\n            count = 0;\n            cloneBoundingSphere = true;\n            commandList.push(command);\n          }\n          currentMaterial = polyline._material;\n          currentMaterial.update(context);\n          currentId = mId;\n        }\n        const locators = polyline._locatorBuckets;\n        const locatorLength = locators.length;\n        for (let t = 0; t < locatorLength; ++t) {\n          const locator = locators[t];\n          if (locator.locator === bucketLocator) {\n            count += locator.count;\n          }\n        }\n        let boundingVolume;\n        if (frameState.mode === SceneMode.SCENE3D) {\n          boundingVolume = polyline._boundingVolumeWC;\n        } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n          boundingVolume = polyline._boundingVolume2D;\n        } else if (frameState.mode === SceneMode.SCENE2D) {\n          if (defined(polyline._boundingVolume2D)) {\n            boundingVolume = BoundingSphere.clone(polyline._boundingVolume2D, boundingSphereScratch2);\n            boundingVolume.center.x = 0.0;\n          }\n        } else if (defined(polyline._boundingVolumeWC) && defined(polyline._boundingVolume2D)) {\n          boundingVolume = BoundingSphere.union(polyline._boundingVolumeWC, polyline._boundingVolume2D, boundingSphereScratch2);\n        }\n        if (cloneBoundingSphere) {\n          cloneBoundingSphere = false;\n          BoundingSphere.clone(boundingVolume, boundingSphereScratch);\n        } else {\n          BoundingSphere.union(boundingVolume, boundingSphereScratch, boundingSphereScratch);\n        }\n      }\n      if (defined(currentId) && count > 0) {\n        if (commandIndex >= commandsLength) {\n          command = new DrawCommand({\n            owner: polylineCollection\n          });\n          commands.push(command);\n        } else {\n          command = commands[commandIndex];\n        }\n        ++commandIndex;\n        uniformMap = combine(uniformCallback(currentMaterial._uniforms), polylineCollection._uniformMap);\n        command.boundingVolume = BoundingSphere.clone(boundingSphereScratch, command.boundingVolume);\n        command.modelMatrix = modelMatrix;\n        command.shaderProgram = sp;\n        command.vertexArray = va.va;\n        command.renderState = currentMaterial.isTranslucent() ? polylineCollection._translucentRS : polylineCollection._opaqueRS;\n        command.pass = currentMaterial.isTranslucent() ? Pass.TRANSLUCENT : Pass.OPAQUE;\n        command.debugShowBoundingVolume = debugShowBoundingVolume;\n        command.pickId = \"v_pickColor\";\n        command.uniformMap = uniformMap;\n        command.count = count;\n        command.offset = offset;\n        cloneBoundingSphere = true;\n        commandList.push(command);\n      }\n      currentId = undefined;\n    }\n  }\n  commands.length = commandIndex;\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PolylineCollection#destroy\n */\nPolylineCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * polylines = polylines && polylines.destroy();\n *\n * @see PolylineCollection#isDestroyed\n */\nPolylineCollection.prototype.destroy = function () {\n  destroyVertexArrays(this);\n  releaseShaders(this);\n  destroyPolylines(this);\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n  return destroyObject(this);\n};\nfunction computeNewBuffersUsage(collection) {\n  let usageChanged = false;\n  const properties = collection._propertiesChanged;\n  const bufferUsage = collection._positionBufferUsage;\n  if (properties[POSITION_INDEX]) {\n    if (bufferUsage.bufferUsage !== BufferUsage.STREAM_DRAW) {\n      usageChanged = true;\n      bufferUsage.bufferUsage = BufferUsage.STREAM_DRAW;\n      bufferUsage.frameCount = 100;\n    } else {\n      bufferUsage.frameCount = 100;\n    }\n  } else if (bufferUsage.bufferUsage !== BufferUsage.STATIC_DRAW) {\n    if (bufferUsage.frameCount === 0) {\n      usageChanged = true;\n      bufferUsage.bufferUsage = BufferUsage.STATIC_DRAW;\n    } else {\n      bufferUsage.frameCount--;\n    }\n  }\n  return usageChanged;\n}\nconst emptyVertexBuffer = [0.0, 0.0, 0.0];\nfunction createVertexArrays(collection, context, projection) {\n  collection._createVertexArray = false;\n  releaseShaders(collection);\n  destroyVertexArrays(collection);\n  sortPolylinesIntoBuckets(collection);\n\n  //stores all of the individual indices arrays.\n  const totalIndices = [[]];\n  let indices = totalIndices[0];\n  const batchTable = collection._batchTable;\n  const useHighlightColor = collection._useHighlightColor;\n\n  //used to determine the vertexBuffer offset if the indicesArray goes over 64k.\n  //if it's the same polyline while it goes over 64k, the offset needs to backtrack componentsPerAttribute * componentDatatype bytes\n  //so that the polyline looks contiguous.\n  //if the polyline ends at the 64k mark, then the offset is just 64k * componentsPerAttribute * componentDatatype\n  const vertexBufferOffset = [0];\n  let offset = 0;\n  const vertexArrayBuckets = [[]];\n  let totalLength = 0;\n  const polylineBuckets = collection._polylineBuckets;\n  let x;\n  let bucket;\n  for (x in polylineBuckets) {\n    if (polylineBuckets.hasOwnProperty(x)) {\n      bucket = polylineBuckets[x];\n      bucket.updateShader(context, batchTable, useHighlightColor);\n      totalLength += bucket.lengthOfPositions;\n    }\n  }\n  if (totalLength > 0) {\n    const mode = collection._mode;\n    const positionArray = new Float32Array(6 * totalLength * 3);\n    const texCoordExpandAndBatchIndexArray = new Float32Array(totalLength * 4);\n    let position3DArray;\n    let positionIndex = 0;\n    let colorIndex = 0;\n    let texCoordExpandAndBatchIndexIndex = 0;\n    for (x in polylineBuckets) {\n      if (polylineBuckets.hasOwnProperty(x)) {\n        bucket = polylineBuckets[x];\n        bucket.write(positionArray, texCoordExpandAndBatchIndexArray, positionIndex, colorIndex, texCoordExpandAndBatchIndexIndex, batchTable, context, projection);\n        if (mode === SceneMode.MORPHING) {\n          if (!defined(position3DArray)) {\n            position3DArray = new Float32Array(6 * totalLength * 3);\n          }\n          bucket.writeForMorph(position3DArray, positionIndex);\n        }\n        const bucketLength = bucket.lengthOfPositions;\n        positionIndex += 6 * bucketLength * 3;\n        colorIndex += bucketLength * 4;\n        texCoordExpandAndBatchIndexIndex += bucketLength * 4;\n        offset = bucket.updateIndices(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset);\n      }\n    }\n    const positionBufferUsage = collection._positionBufferUsage.bufferUsage;\n    const texCoordExpandAndBatchIndexBufferUsage = BufferUsage.STATIC_DRAW;\n    collection._positionBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: positionArray,\n      usage: positionBufferUsage\n    });\n    let position3DBuffer;\n    if (defined(position3DArray)) {\n      position3DBuffer = Buffer.createVertexBuffer({\n        context: context,\n        typedArray: position3DArray,\n        usage: positionBufferUsage\n      });\n    }\n    collection._texCoordExpandAndBatchIndexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: texCoordExpandAndBatchIndexArray,\n      usage: texCoordExpandAndBatchIndexBufferUsage\n    });\n    const positionSizeInBytes = 3 * Float32Array.BYTES_PER_ELEMENT;\n    const texCoordExpandAndBatchIndexSizeInBytes = 4 * Float32Array.BYTES_PER_ELEMENT;\n    let vbo = 0;\n    const numberOfIndicesArrays = totalIndices.length;\n    for (let k = 0; k < numberOfIndicesArrays; ++k) {\n      indices = totalIndices[k];\n      if (indices.length > 0) {\n        const indicesArray = new Uint16Array(indices);\n        const indexBuffer = Buffer.createIndexBuffer({\n          context: context,\n          typedArray: indicesArray,\n          usage: BufferUsage.STATIC_DRAW,\n          indexDatatype: IndexDatatype.UNSIGNED_SHORT\n        });\n        vbo += vertexBufferOffset[k];\n        const positionHighOffset = 6 * (k * (positionSizeInBytes * CesiumMath.SIXTY_FOUR_KILOBYTES) - vbo * positionSizeInBytes); //componentsPerAttribute(3) * componentDatatype(4)\n        const positionLowOffset = positionSizeInBytes + positionHighOffset;\n        const prevPositionHighOffset = positionSizeInBytes + positionLowOffset;\n        const prevPositionLowOffset = positionSizeInBytes + prevPositionHighOffset;\n        const nextPositionHighOffset = positionSizeInBytes + prevPositionLowOffset;\n        const nextPositionLowOffset = positionSizeInBytes + nextPositionHighOffset;\n        const vertexTexCoordExpandAndBatchIndexBufferOffset = k * (texCoordExpandAndBatchIndexSizeInBytes * CesiumMath.SIXTY_FOUR_KILOBYTES) - vbo * texCoordExpandAndBatchIndexSizeInBytes;\n        const attributes = [{\n          index: attributeLocations.position3DHigh,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: positionHighOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.position3DLow,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: positionLowOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.position2DHigh,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: positionHighOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.position2DLow,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: positionLowOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.prevPosition3DHigh,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: prevPositionHighOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.prevPosition3DLow,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: prevPositionLowOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.prevPosition2DHigh,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: prevPositionHighOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.prevPosition2DLow,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: prevPositionLowOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.nextPosition3DHigh,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: nextPositionHighOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.nextPosition3DLow,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: nextPositionLowOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.nextPosition2DHigh,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: nextPositionHighOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.nextPosition2DLow,\n          componentsPerAttribute: 3,\n          componentDatatype: ComponentDatatype.FLOAT,\n          offsetInBytes: nextPositionLowOffset,\n          strideInBytes: 6 * positionSizeInBytes\n        }, {\n          index: attributeLocations.texCoordExpandAndBatchIndex,\n          componentsPerAttribute: 4,\n          componentDatatype: ComponentDatatype.FLOAT,\n          vertexBuffer: collection._texCoordExpandAndBatchIndexBuffer,\n          offsetInBytes: vertexTexCoordExpandAndBatchIndexBufferOffset\n        }];\n        let bufferProperty3D;\n        let buffer3D;\n        let buffer2D;\n        let bufferProperty2D;\n        if (mode === SceneMode.SCENE3D) {\n          buffer3D = collection._positionBuffer;\n          bufferProperty3D = \"vertexBuffer\";\n          buffer2D = emptyVertexBuffer;\n          bufferProperty2D = \"value\";\n        } else if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n          buffer3D = emptyVertexBuffer;\n          bufferProperty3D = \"value\";\n          buffer2D = collection._positionBuffer;\n          bufferProperty2D = \"vertexBuffer\";\n        } else {\n          buffer3D = position3DBuffer;\n          bufferProperty3D = \"vertexBuffer\";\n          buffer2D = collection._positionBuffer;\n          bufferProperty2D = \"vertexBuffer\";\n        }\n        attributes[0][bufferProperty3D] = buffer3D;\n        attributes[1][bufferProperty3D] = buffer3D;\n        attributes[2][bufferProperty2D] = buffer2D;\n        attributes[3][bufferProperty2D] = buffer2D;\n        attributes[4][bufferProperty3D] = buffer3D;\n        attributes[5][bufferProperty3D] = buffer3D;\n        attributes[6][bufferProperty2D] = buffer2D;\n        attributes[7][bufferProperty2D] = buffer2D;\n        attributes[8][bufferProperty3D] = buffer3D;\n        attributes[9][bufferProperty3D] = buffer3D;\n        attributes[10][bufferProperty2D] = buffer2D;\n        attributes[11][bufferProperty2D] = buffer2D;\n        const va = new VertexArray({\n          context: context,\n          attributes: attributes,\n          indexBuffer: indexBuffer\n        });\n        collection._vertexArrays.push({\n          va: va,\n          buckets: vertexArrayBuckets[k]\n        });\n      }\n    }\n  }\n}\nfunction replacer(key, value) {\n  if (value instanceof Texture) {\n    return value.id;\n  }\n  return value;\n}\nconst scratchUniformArray = [];\nfunction createMaterialId(material) {\n  const uniforms = Material._uniformList[material.type];\n  const length = uniforms.length;\n  scratchUniformArray.length = 2.0 * length;\n  let index = 0;\n  for (let i = 0; i < length; ++i) {\n    const uniform = uniforms[i];\n    scratchUniformArray[index] = uniform;\n    scratchUniformArray[index + 1] = material._uniforms[uniform]();\n    index += 2;\n  }\n  return `${material.type}:${JSON.stringify(scratchUniformArray, replacer)}`;\n}\nfunction sortPolylinesIntoBuckets(collection) {\n  const mode = collection._mode;\n  const modelMatrix = collection._modelMatrix;\n  const polylineBuckets = collection._polylineBuckets = {};\n  const polylines = collection._polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    const p = polylines[i];\n    if (p._actualPositions.length > 1) {\n      p.update();\n      const material = p.material;\n      let value = polylineBuckets[material.type];\n      if (!defined(value)) {\n        value = polylineBuckets[material.type] = new PolylineBucket(material, mode, modelMatrix);\n      }\n      value.addPolyline(p);\n    }\n  }\n}\nfunction updateMode(collection, frameState) {\n  const mode = frameState.mode;\n  if (collection._mode !== mode || !Matrix4.equals(collection._modelMatrix, collection.modelMatrix)) {\n    collection._mode = mode;\n    collection._modelMatrix = Matrix4.clone(collection.modelMatrix);\n    collection._createVertexArray = true;\n  }\n}\nfunction removePolylines(collection) {\n  if (collection._polylinesRemoved) {\n    collection._polylinesRemoved = false;\n    const definedPolylines = [];\n    const definedPolylinesToUpdate = [];\n    let polyIndex = 0;\n    let polyline;\n    const length = collection._polylines.length;\n    for (let i = 0; i < length; ++i) {\n      polyline = collection._polylines[i];\n      if (!polyline.isDestroyed) {\n        polyline._index = polyIndex++;\n        definedPolylinesToUpdate.push(polyline);\n        definedPolylines.push(polyline);\n      }\n    }\n    collection._polylines = definedPolylines;\n    collection._polylinesToUpdate = definedPolylinesToUpdate;\n  }\n}\nfunction releaseShaders(collection) {\n  const polylines = collection._polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    if (!polylines[i].isDestroyed) {\n      const bucket = polylines[i]._bucket;\n      if (defined(bucket)) {\n        bucket.shaderProgram = bucket.shaderProgram && bucket.shaderProgram.destroy();\n      }\n    }\n  }\n}\nfunction destroyVertexArrays(collection) {\n  const length = collection._vertexArrays.length;\n  for (let t = 0; t < length; ++t) {\n    collection._vertexArrays[t].va.destroy();\n  }\n  collection._vertexArrays.length = 0;\n}\nPolylineCollection.prototype._updatePolyline = function (polyline, propertyChanged) {\n  this._polylinesUpdated = true;\n  if (!polyline._dirty) {\n    this._polylinesToUpdate.push(polyline);\n  }\n  ++this._propertiesChanged[propertyChanged];\n};\nfunction destroyPolylines(collection) {\n  const polylines = collection._polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    if (!polylines[i].isDestroyed) {\n      polylines[i]._destroy();\n    }\n  }\n}\nfunction VertexArrayBucketLocator(count, offset, bucket) {\n  this.count = count;\n  this.offset = offset;\n  this.bucket = bucket;\n}\nfunction PolylineBucket(material, mode, modelMatrix) {\n  this.polylines = [];\n  this.lengthOfPositions = 0;\n  this.material = material;\n  this.shaderProgram = undefined;\n  this.mode = mode;\n  this.modelMatrix = modelMatrix;\n}\nPolylineBucket.prototype.addPolyline = function (p) {\n  const polylines = this.polylines;\n  polylines.push(p);\n  p._actualLength = this.getPolylinePositionsLength(p);\n  this.lengthOfPositions += p._actualLength;\n  p._bucket = this;\n};\nPolylineBucket.prototype.updateShader = function (context, batchTable, useHighlightColor) {\n  if (defined(this.shaderProgram)) {\n    return;\n  }\n  const defines = [\"DISTANCE_DISPLAY_CONDITION\"];\n  if (useHighlightColor) {\n    defines.push(\"VECTOR_TILE\");\n  }\n\n  // Check for use of v_polylineAngle in material shader\n  if (this.material.shaderSource.search(/in\\s+float\\s+v_polylineAngle;/g) !== -1) {\n    defines.push(\"POLYLINE_DASH\");\n  }\n  if (!FeatureDetection.isInternetExplorer()) {\n    defines.push(\"CLIP_POLYLINE\");\n  }\n  const fs = new ShaderSource({\n    defines: defines,\n    sources: [\"in vec4 v_pickColor;\\n\", this.material.shaderSource, PolylineFS]\n  });\n  const vsSource = batchTable.getVertexShaderCallback()(PolylineVS);\n  const vs = new ShaderSource({\n    defines: defines,\n    sources: [PolylineCommon, vsSource]\n  });\n  this.shaderProgram = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n};\nfunction intersectsIDL(polyline) {\n  return Cartesian3.dot(Cartesian3.UNIT_X, polyline._boundingVolume.center) < 0 || polyline._boundingVolume.intersectPlane(Plane.ORIGIN_ZX_PLANE) === Intersect.INTERSECTING;\n}\nPolylineBucket.prototype.getPolylinePositionsLength = function (polyline) {\n  let length;\n  if (this.mode === SceneMode.SCENE3D || !intersectsIDL(polyline)) {\n    length = polyline._actualPositions.length;\n    return length * 4.0 - 4.0;\n  }\n  let count = 0;\n  const segmentLengths = polyline._segments.lengths;\n  length = segmentLengths.length;\n  for (let i = 0; i < length; ++i) {\n    count += segmentLengths[i] * 4.0 - 4.0;\n  }\n  return count;\n};\nconst scratchWritePosition = new Cartesian3();\nconst scratchWritePrevPosition = new Cartesian3();\nconst scratchWriteNextPosition = new Cartesian3();\nconst scratchWriteVector = new Cartesian3();\nconst scratchPickColorCartesian = new Cartesian4();\nconst scratchWidthShowCartesian = new Cartesian2();\nPolylineBucket.prototype.write = function (positionArray, texCoordExpandAndBatchIndexArray, positionIndex, colorIndex, texCoordExpandAndBatchIndexIndex, batchTable, context, projection) {\n  const mode = this.mode;\n  const maxLon = projection.ellipsoid.maximumRadius * CesiumMath.PI;\n  const polylines = this.polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    const polyline = polylines[i];\n    const width = polyline.width;\n    const show = polyline.show && width > 0.0;\n    const polylineBatchIndex = polyline._index;\n    const segments = this.getSegments(polyline, projection);\n    const positions = segments.positions;\n    const lengths = segments.lengths;\n    const positionsLength = positions.length;\n    const pickColor = polyline.getPickId(context).color;\n    let segmentIndex = 0;\n    let count = 0;\n    let position;\n    for (let j = 0; j < positionsLength; ++j) {\n      if (j === 0) {\n        if (polyline._loop) {\n          position = positions[positionsLength - 2];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(positions[0], positions[1], position);\n          Cartesian3.add(positions[0], position, position);\n        }\n      } else {\n        position = positions[j - 1];\n      }\n      Cartesian3.clone(position, scratchWritePrevPosition);\n      Cartesian3.clone(positions[j], scratchWritePosition);\n      if (j === positionsLength - 1) {\n        if (polyline._loop) {\n          position = positions[1];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], position);\n          Cartesian3.add(positions[positionsLength - 1], position, position);\n        }\n      } else {\n        position = positions[j + 1];\n      }\n      Cartesian3.clone(position, scratchWriteNextPosition);\n      const segmentLength = lengths[segmentIndex];\n      if (j === count + segmentLength) {\n        count += segmentLength;\n        ++segmentIndex;\n      }\n      const segmentStart = j - count === 0;\n      const segmentEnd = j === count + lengths[segmentIndex] - 1;\n      if (mode === SceneMode.SCENE2D) {\n        scratchWritePrevPosition.z = 0.0;\n        scratchWritePosition.z = 0.0;\n        scratchWriteNextPosition.z = 0.0;\n      }\n      if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n        if ((segmentStart || segmentEnd) && maxLon - Math.abs(scratchWritePosition.x) < 1.0) {\n          if (scratchWritePosition.x < 0.0 && scratchWritePrevPosition.x > 0.0 || scratchWritePosition.x > 0.0 && scratchWritePrevPosition.x < 0.0) {\n            Cartesian3.clone(scratchWritePosition, scratchWritePrevPosition);\n          }\n          if (scratchWritePosition.x < 0.0 && scratchWriteNextPosition.x > 0.0 || scratchWritePosition.x > 0.0 && scratchWriteNextPosition.x < 0.0) {\n            Cartesian3.clone(scratchWritePosition, scratchWriteNextPosition);\n          }\n        }\n      }\n      const startK = segmentStart ? 2 : 0;\n      const endK = segmentEnd ? 2 : 4;\n      for (let k = startK; k < endK; ++k) {\n        EncodedCartesian3.writeElements(scratchWritePosition, positionArray, positionIndex);\n        EncodedCartesian3.writeElements(scratchWritePrevPosition, positionArray, positionIndex + 6);\n        EncodedCartesian3.writeElements(scratchWriteNextPosition, positionArray, positionIndex + 12);\n        const direction = k - 2 < 0 ? -1.0 : 1.0;\n        texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex] = j / (positionsLength - 1); // s tex coord\n        texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex + 1] = 2 * (k % 2) - 1; // expand direction\n        texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex + 2] = direction;\n        texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex + 3] = polylineBatchIndex;\n        positionIndex += 6 * 3;\n        texCoordExpandAndBatchIndexIndex += 4;\n      }\n    }\n    const colorCartesian = scratchPickColorCartesian;\n    colorCartesian.x = Color.floatToByte(pickColor.red);\n    colorCartesian.y = Color.floatToByte(pickColor.green);\n    colorCartesian.z = Color.floatToByte(pickColor.blue);\n    colorCartesian.w = Color.floatToByte(pickColor.alpha);\n    const widthShowCartesian = scratchWidthShowCartesian;\n    widthShowCartesian.x = width;\n    widthShowCartesian.y = show ? 1.0 : 0.0;\n    const boundingSphere = mode === SceneMode.SCENE2D ? polyline._boundingVolume2D : polyline._boundingVolumeWC;\n    const encodedCenter = EncodedCartesian3.fromCartesian(boundingSphere.center, scratchUpdatePolylineEncodedCartesian);\n    const high = encodedCenter.high;\n    const low = Cartesian4.fromElements(encodedCenter.low.x, encodedCenter.low.y, encodedCenter.low.z, boundingSphere.radius, scratchUpdatePolylineCartesian4);\n    const nearFarCartesian = scratchNearFarCartesian2;\n    nearFarCartesian.x = 0.0;\n    nearFarCartesian.y = Number.MAX_VALUE;\n    const distanceDisplayCondition = polyline.distanceDisplayCondition;\n    if (defined(distanceDisplayCondition)) {\n      nearFarCartesian.x = distanceDisplayCondition.near;\n      nearFarCartesian.y = distanceDisplayCondition.far;\n    }\n    batchTable.setBatchedAttribute(polylineBatchIndex, 0, widthShowCartesian);\n    batchTable.setBatchedAttribute(polylineBatchIndex, 1, colorCartesian);\n    if (batchTable.attributes.length > 2) {\n      batchTable.setBatchedAttribute(polylineBatchIndex, 2, high);\n      batchTable.setBatchedAttribute(polylineBatchIndex, 3, low);\n      batchTable.setBatchedAttribute(polylineBatchIndex, 4, nearFarCartesian);\n    }\n  }\n};\nconst morphPositionScratch = new Cartesian3();\nconst morphPrevPositionScratch = new Cartesian3();\nconst morphNextPositionScratch = new Cartesian3();\nconst morphVectorScratch = new Cartesian3();\nPolylineBucket.prototype.writeForMorph = function (positionArray, positionIndex) {\n  const modelMatrix = this.modelMatrix;\n  const polylines = this.polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    const polyline = polylines[i];\n    const positions = polyline._segments.positions;\n    const lengths = polyline._segments.lengths;\n    const positionsLength = positions.length;\n    let segmentIndex = 0;\n    let count = 0;\n    for (let j = 0; j < positionsLength; ++j) {\n      let prevPosition;\n      if (j === 0) {\n        if (polyline._loop) {\n          prevPosition = positions[positionsLength - 2];\n        } else {\n          prevPosition = morphVectorScratch;\n          Cartesian3.subtract(positions[0], positions[1], prevPosition);\n          Cartesian3.add(positions[0], prevPosition, prevPosition);\n        }\n      } else {\n        prevPosition = positions[j - 1];\n      }\n      prevPosition = Matrix4.multiplyByPoint(modelMatrix, prevPosition, morphPrevPositionScratch);\n      const position = Matrix4.multiplyByPoint(modelMatrix, positions[j], morphPositionScratch);\n      let nextPosition;\n      if (j === positionsLength - 1) {\n        if (polyline._loop) {\n          nextPosition = positions[1];\n        } else {\n          nextPosition = morphVectorScratch;\n          Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], nextPosition);\n          Cartesian3.add(positions[positionsLength - 1], nextPosition, nextPosition);\n        }\n      } else {\n        nextPosition = positions[j + 1];\n      }\n      nextPosition = Matrix4.multiplyByPoint(modelMatrix, nextPosition, morphNextPositionScratch);\n      const segmentLength = lengths[segmentIndex];\n      if (j === count + segmentLength) {\n        count += segmentLength;\n        ++segmentIndex;\n      }\n      const segmentStart = j - count === 0;\n      const segmentEnd = j === count + lengths[segmentIndex] - 1;\n      const startK = segmentStart ? 2 : 0;\n      const endK = segmentEnd ? 2 : 4;\n      for (let k = startK; k < endK; ++k) {\n        EncodedCartesian3.writeElements(position, positionArray, positionIndex);\n        EncodedCartesian3.writeElements(prevPosition, positionArray, positionIndex + 6);\n        EncodedCartesian3.writeElements(nextPosition, positionArray, positionIndex + 12);\n        positionIndex += 6 * 3;\n      }\n    }\n  }\n};\nconst scratchSegmentLengths = new Array(1);\nPolylineBucket.prototype.updateIndices = function (totalIndices, vertexBufferOffset, vertexArrayBuckets, offset) {\n  let vaCount = vertexArrayBuckets.length - 1;\n  let bucketLocator = new VertexArrayBucketLocator(0, offset, this);\n  vertexArrayBuckets[vaCount].push(bucketLocator);\n  let count = 0;\n  let indices = totalIndices[totalIndices.length - 1];\n  let indicesCount = 0;\n  if (indices.length > 0) {\n    indicesCount = indices[indices.length - 1] + 1;\n  }\n  const polylines = this.polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    const polyline = polylines[i];\n    polyline._locatorBuckets = [];\n    let segments;\n    if (this.mode === SceneMode.SCENE3D) {\n      segments = scratchSegmentLengths;\n      const positionsLength = polyline._actualPositions.length;\n      if (positionsLength > 0) {\n        segments[0] = positionsLength;\n      } else {\n        continue;\n      }\n    } else {\n      segments = polyline._segments.lengths;\n    }\n    const numberOfSegments = segments.length;\n    if (numberOfSegments > 0) {\n      let segmentIndexCount = 0;\n      for (let j = 0; j < numberOfSegments; ++j) {\n        const segmentLength = segments[j] - 1.0;\n        for (let k = 0; k < segmentLength; ++k) {\n          if (indicesCount + 4 > CesiumMath.SIXTY_FOUR_KILOBYTES) {\n            polyline._locatorBuckets.push({\n              locator: bucketLocator,\n              count: segmentIndexCount\n            });\n            segmentIndexCount = 0;\n            vertexBufferOffset.push(4);\n            indices = [];\n            totalIndices.push(indices);\n            indicesCount = 0;\n            bucketLocator.count = count;\n            count = 0;\n            offset = 0;\n            bucketLocator = new VertexArrayBucketLocator(0, 0, this);\n            vertexArrayBuckets[++vaCount] = [bucketLocator];\n          }\n          indices.push(indicesCount, indicesCount + 2, indicesCount + 1);\n          indices.push(indicesCount + 1, indicesCount + 2, indicesCount + 3);\n          segmentIndexCount += 6;\n          count += 6;\n          offset += 6;\n          indicesCount += 4;\n        }\n      }\n      polyline._locatorBuckets.push({\n        locator: bucketLocator,\n        count: segmentIndexCount\n      });\n      if (indicesCount + 4 > CesiumMath.SIXTY_FOUR_KILOBYTES) {\n        vertexBufferOffset.push(0);\n        indices = [];\n        totalIndices.push(indices);\n        indicesCount = 0;\n        bucketLocator.count = count;\n        offset = 0;\n        count = 0;\n        bucketLocator = new VertexArrayBucketLocator(0, 0, this);\n        vertexArrayBuckets[++vaCount] = [bucketLocator];\n      }\n    }\n    polyline._clean();\n  }\n  bucketLocator.count = count;\n  return offset;\n};\nPolylineBucket.prototype.getPolylineStartIndex = function (polyline) {\n  const polylines = this.polylines;\n  let positionIndex = 0;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    const p = polylines[i];\n    if (p === polyline) {\n      break;\n    }\n    positionIndex += p._actualLength;\n  }\n  return positionIndex;\n};\nconst scratchSegments = {\n  positions: undefined,\n  lengths: undefined\n};\nconst scratchLengths = new Array(1);\nconst pscratch = new Cartesian3();\nconst scratchCartographic = new Cartographic();\nPolylineBucket.prototype.getSegments = function (polyline, projection) {\n  let positions = polyline._actualPositions;\n  if (this.mode === SceneMode.SCENE3D) {\n    scratchLengths[0] = positions.length;\n    scratchSegments.positions = positions;\n    scratchSegments.lengths = scratchLengths;\n    return scratchSegments;\n  }\n  if (intersectsIDL(polyline)) {\n    positions = polyline._segments.positions;\n  }\n  const ellipsoid = projection.ellipsoid;\n  const newPositions = [];\n  const modelMatrix = this.modelMatrix;\n  const length = positions.length;\n  let position;\n  let p = pscratch;\n  for (let n = 0; n < length; ++n) {\n    position = positions[n];\n    p = Matrix4.multiplyByPoint(modelMatrix, position, p);\n    newPositions.push(projection.project(ellipsoid.cartesianToCartographic(p, scratchCartographic)));\n  }\n  if (newPositions.length > 0) {\n    polyline._boundingVolume2D = BoundingSphere.fromPoints(newPositions, polyline._boundingVolume2D);\n    const center2D = polyline._boundingVolume2D.center;\n    polyline._boundingVolume2D.center = new Cartesian3(center2D.z, center2D.x, center2D.y);\n  }\n  scratchSegments.positions = newPositions;\n  scratchSegments.lengths = polyline._segments.lengths;\n  return scratchSegments;\n};\nlet scratchPositionsArray;\nPolylineBucket.prototype.writeUpdate = function (index, polyline, positionBuffer, projection) {\n  const mode = this.mode;\n  const maxLon = projection.ellipsoid.maximumRadius * CesiumMath.PI;\n  let positionsLength = polyline._actualLength;\n  if (positionsLength) {\n    index += this.getPolylineStartIndex(polyline);\n    let positionArray = scratchPositionsArray;\n    const positionsArrayLength = 6 * positionsLength * 3;\n    if (!defined(positionArray) || positionArray.length < positionsArrayLength) {\n      positionArray = scratchPositionsArray = new Float32Array(positionsArrayLength);\n    } else if (positionArray.length > positionsArrayLength) {\n      positionArray = new Float32Array(positionArray.buffer, 0, positionsArrayLength);\n    }\n    const segments = this.getSegments(polyline, projection);\n    const positions = segments.positions;\n    const lengths = segments.lengths;\n    let positionIndex = 0;\n    let segmentIndex = 0;\n    let count = 0;\n    let position;\n    positionsLength = positions.length;\n    for (let i = 0; i < positionsLength; ++i) {\n      if (i === 0) {\n        if (polyline._loop) {\n          position = positions[positionsLength - 2];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(positions[0], positions[1], position);\n          Cartesian3.add(positions[0], position, position);\n        }\n      } else {\n        position = positions[i - 1];\n      }\n      Cartesian3.clone(position, scratchWritePrevPosition);\n      Cartesian3.clone(positions[i], scratchWritePosition);\n      if (i === positionsLength - 1) {\n        if (polyline._loop) {\n          position = positions[1];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], position);\n          Cartesian3.add(positions[positionsLength - 1], position, position);\n        }\n      } else {\n        position = positions[i + 1];\n      }\n      Cartesian3.clone(position, scratchWriteNextPosition);\n      const segmentLength = lengths[segmentIndex];\n      if (i === count + segmentLength) {\n        count += segmentLength;\n        ++segmentIndex;\n      }\n      const segmentStart = i - count === 0;\n      const segmentEnd = i === count + lengths[segmentIndex] - 1;\n      if (mode === SceneMode.SCENE2D) {\n        scratchWritePrevPosition.z = 0.0;\n        scratchWritePosition.z = 0.0;\n        scratchWriteNextPosition.z = 0.0;\n      }\n      if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n        if ((segmentStart || segmentEnd) && maxLon - Math.abs(scratchWritePosition.x) < 1.0) {\n          if (scratchWritePosition.x < 0.0 && scratchWritePrevPosition.x > 0.0 || scratchWritePosition.x > 0.0 && scratchWritePrevPosition.x < 0.0) {\n            Cartesian3.clone(scratchWritePosition, scratchWritePrevPosition);\n          }\n          if (scratchWritePosition.x < 0.0 && scratchWriteNextPosition.x > 0.0 || scratchWritePosition.x > 0.0 && scratchWriteNextPosition.x < 0.0) {\n            Cartesian3.clone(scratchWritePosition, scratchWriteNextPosition);\n          }\n        }\n      }\n      const startJ = segmentStart ? 2 : 0;\n      const endJ = segmentEnd ? 2 : 4;\n      for (let j = startJ; j < endJ; ++j) {\n        EncodedCartesian3.writeElements(scratchWritePosition, positionArray, positionIndex);\n        EncodedCartesian3.writeElements(scratchWritePrevPosition, positionArray, positionIndex + 6);\n        EncodedCartesian3.writeElements(scratchWriteNextPosition, positionArray, positionIndex + 12);\n        positionIndex += 6 * 3;\n      }\n    }\n    positionBuffer.copyFromArrayView(positionArray, 6 * 3 * Float32Array.BYTES_PER_ELEMENT * index);\n  }\n};\nexport default PolylineCollection;","map":{"version":3,"names":["BoundingSphere","Cartesian2","Cartesian3","Cartesian4","Cartographic","Color","combine","ComponentDatatype","defaultValue","defined","destroyObject","DeveloperError","EncodedCartesian3","FeatureDetection","IndexDatatype","Intersect","CesiumMath","Matrix4","Plane","RuntimeError","Buffer","BufferUsage","ContextLimits","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","Texture","VertexArray","PolylineCommon","PolylineFS","PolylineVS","BatchTable","BlendingState","Material","Polyline","SceneMode","SHOW_INDEX","WIDTH_INDEX","POSITION_INDEX","MATERIAL_INDEX","POSITION_SIZE_INDEX","DISTANCE_DISPLAY_CONDITION","NUMBER_OF_PROPERTIES","attributeLocations","texCoordExpandAndBatchIndex","position3DHigh","position3DLow","position2DHigh","position2DLow","prevPosition3DHigh","prevPosition3DLow","prevPosition2DHigh","prevPosition2DLow","nextPosition3DHigh","nextPosition3DLow","nextPosition2DHigh","nextPosition2DLow","PolylineCollection","options","EMPTY_OBJECT","show","modelMatrix","clone","IDENTITY","_modelMatrix","debugShowBoundingVolume","_opaqueRS","undefined","_translucentRS","_colorCommands","_polylinesUpdated","_polylinesRemoved","_createVertexArray","_propertiesChanged","Uint32Array","_polylines","_polylineBuckets","_positionBufferUsage","bufferUsage","STATIC_DRAW","frameCount","_mode","_polylinesToUpdate","_vertexArrays","_positionBuffer","_texCoordExpandAndBatchIndexBuffer","_batchTable","_createBatchTable","_useHighlightColor","_highlightColor","WHITE","that","_uniformMap","u_highlightColor","Object","defineProperties","prototype","length","get","removePolylines","add","p","_index","push","remove","polyline","contains","_bucket","bucket","shaderProgram","destroy","_destroy","removeAll","releaseShaders","destroyPolylines","_polylineCollection","index","createBatchTable","collection","context","attributes","functionName","componentDatatype","UNSIGNED_BYTE","componentsPerAttribute","normalize","FLOAT","scratchUpdatePolylineEncodedCartesian","scratchUpdatePolylineCartesian4","scratchNearFarCartesian2","update","frameState","updateMode","projection","mapProjection","properties","maximumVertexTextureImageUnits","computeNewBuffersUsage","createVertexArrays","polylinesToUpdate","SCENE3D","updateLength","i","polylineBuckets","ii","x","hasOwnProperty","writeUpdate","lengthOfPositions","setBatchedAttribute","_width","_show","boundingSphere","mode","SCENE2D","_boundingVolume2D","_boundingVolumeWC","encodedCenter","fromCartesian","center","low","fromElements","y","z","radius","high","nearFarCartesian","Number","MAX_VALUE","distanceDisplayCondition","near","far","_clean","k","pass","passes","useDepthTest","morphTime","depthTest","enabled","fromCache","depthMask","blending","ALPHA_BLEND","render","pick","colorList","createCommandLists","boundingSphereScratch","boundingSphereScratch2","polylineCollection","commands","commandList","commandsLength","commandIndex","cloneBoundingSphere","vertexArrays","batchTable","uniformCallback","getUniformMapCallback","m","va","buckets","bucketLength","n","bucketLocator","offset","sp","polylines","polylineLength","currentId","currentMaterial","count","command","uniformMap","s","mId","createMaterialId","_material","translucent","isTranslucent","owner","_uniforms","boundingVolume","vertexArray","renderState","TRANSLUCENT","OPAQUE","pickId","locators","_locatorBuckets","locatorLength","t","locator","COLUMBUS_VIEW","union","isDestroyed","destroyVertexArrays","usageChanged","STREAM_DRAW","emptyVertexBuffer","sortPolylinesIntoBuckets","totalIndices","indices","useHighlightColor","vertexBufferOffset","vertexArrayBuckets","totalLength","updateShader","positionArray","Float32Array","texCoordExpandAndBatchIndexArray","position3DArray","positionIndex","colorIndex","texCoordExpandAndBatchIndexIndex","write","MORPHING","writeForMorph","updateIndices","positionBufferUsage","texCoordExpandAndBatchIndexBufferUsage","createVertexBuffer","typedArray","usage","position3DBuffer","positionSizeInBytes","BYTES_PER_ELEMENT","texCoordExpandAndBatchIndexSizeInBytes","vbo","numberOfIndicesArrays","indicesArray","Uint16Array","indexBuffer","createIndexBuffer","indexDatatype","UNSIGNED_SHORT","positionHighOffset","SIXTY_FOUR_KILOBYTES","positionLowOffset","prevPositionHighOffset","prevPositionLowOffset","nextPositionHighOffset","nextPositionLowOffset","vertexTexCoordExpandAndBatchIndexBufferOffset","offsetInBytes","strideInBytes","vertexBuffer","bufferProperty3D","buffer3D","buffer2D","bufferProperty2D","replacer","key","value","id","scratchUniformArray","material","uniforms","_uniformList","type","uniform","JSON","stringify","_actualPositions","PolylineBucket","addPolyline","equals","definedPolylines","definedPolylinesToUpdate","polyIndex","_updatePolyline","propertyChanged","_dirty","VertexArrayBucketLocator","_actualLength","getPolylinePositionsLength","defines","shaderSource","search","isInternetExplorer","fs","sources","vsSource","getVertexShaderCallback","vs","vertexShaderSource","fragmentShaderSource","intersectsIDL","dot","UNIT_X","_boundingVolume","intersectPlane","ORIGIN_ZX_PLANE","INTERSECTING","segmentLengths","_segments","lengths","scratchWritePosition","scratchWritePrevPosition","scratchWriteNextPosition","scratchWriteVector","scratchPickColorCartesian","scratchWidthShowCartesian","maxLon","ellipsoid","maximumRadius","PI","width","polylineBatchIndex","segments","getSegments","positions","positionsLength","pickColor","getPickId","color","segmentIndex","position","j","_loop","subtract","segmentLength","segmentStart","segmentEnd","Math","abs","startK","endK","writeElements","direction","colorCartesian","floatToByte","red","green","blue","w","alpha","widthShowCartesian","morphPositionScratch","morphPrevPositionScratch","morphNextPositionScratch","morphVectorScratch","prevPosition","multiplyByPoint","nextPosition","scratchSegmentLengths","Array","vaCount","indicesCount","numberOfSegments","segmentIndexCount","getPolylineStartIndex","scratchSegments","scratchLengths","pscratch","scratchCartographic","newPositions","project","cartesianToCartographic","fromPoints","center2D","scratchPositionsArray","positionBuffer","positionsArrayLength","buffer","startJ","endJ","copyFromArrayView"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/PolylineCollection.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Plane from \"../Core/Plane.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport PolylineCommon from \"../Shaders/PolylineCommon.js\";\nimport PolylineFS from \"../Shaders/PolylineFS.js\";\nimport PolylineVS from \"../Shaders/PolylineVS.js\";\nimport BatchTable from \"./BatchTable.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Material from \"./Material.js\";\nimport Polyline from \"./Polyline.js\";\nimport SceneMode from \"./SceneMode.js\";\n\nconst SHOW_INDEX = Polyline.SHOW_INDEX;\nconst WIDTH_INDEX = Polyline.WIDTH_INDEX;\nconst POSITION_INDEX = Polyline.POSITION_INDEX;\nconst MATERIAL_INDEX = Polyline.MATERIAL_INDEX;\n//POSITION_SIZE_INDEX is needed for when the polyline's position array changes size.\n//When it does, we need to recreate the indicesBuffer.\nconst POSITION_SIZE_INDEX = Polyline.POSITION_SIZE_INDEX;\nconst DISTANCE_DISPLAY_CONDITION = Polyline.DISTANCE_DISPLAY_CONDITION;\nconst NUMBER_OF_PROPERTIES = Polyline.NUMBER_OF_PROPERTIES;\n\nconst attributeLocations = {\n  texCoordExpandAndBatchIndex: 0,\n  position3DHigh: 1,\n  position3DLow: 2,\n  position2DHigh: 3,\n  position2DLow: 4,\n  prevPosition3DHigh: 5,\n  prevPosition3DLow: 6,\n  prevPosition2DHigh: 7,\n  prevPosition2DLow: 8,\n  nextPosition3DHigh: 9,\n  nextPosition3DLow: 10,\n  nextPosition2DHigh: 11,\n  nextPosition2DLow: 12,\n};\n\n/**\n * A renderable collection of polylines.\n * <br /><br />\n * <div align=\"center\">\n * <img src=\"Images/Polyline.png\" width=\"400\" height=\"300\" /><br />\n * Example polylines\n * </div>\n * <br /><br />\n * Polylines are added and removed from the collection using {@link PolylineCollection#add}\n * and {@link PolylineCollection#remove}.\n *\n * @alias PolylineCollection\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each polyline from model to world coordinates.\n * @param {boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {boolean} [options.show=true] Determines if the polylines in the collection will be shown.\n *\n * @performance For best performance, prefer a few collections, each with many polylines, to\n * many collections with only a few polylines each.  Organize collections so that polylines\n * with the same update frequency are in the same collection, i.e., polylines that do not\n * change should be in one collection; polylines that change every frame should be in another\n * collection; and so on.\n *\n * @see PolylineCollection#add\n * @see PolylineCollection#remove\n * @see Polyline\n * @see LabelCollection\n *\n * @example\n * // Create a polyline collection with two polylines\n * const polylines = new Cesium.PolylineCollection();\n * polylines.add({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -75.10, 39.57,\n *     -77.02, 38.53,\n *     -80.50, 35.14,\n *     -80.12, 25.46]),\n *   width : 2\n * });\n *\n * polylines.add({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -73.10, 37.57,\n *     -75.02, 36.53,\n *     -78.50, 33.14,\n *     -78.12, 23.46]),\n *   width : 4\n * });\n */\nfunction PolylineCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * Determines if polylines in this collection will be shown.\n   *\n   * @type {boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * The 4x4 transformation matrix that transforms each polyline in this collection from model to world coordinates.\n   * When this is the identity matrix, the polylines are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY),\n  );\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false,\n  );\n\n  this._opaqueRS = undefined;\n  this._translucentRS = undefined;\n\n  this._colorCommands = [];\n\n  this._polylinesUpdated = false;\n  this._polylinesRemoved = false;\n  this._createVertexArray = false;\n  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n  this._polylines = [];\n  this._polylineBuckets = {};\n\n  // The buffer usage is determined based on the usage of the attribute over time.\n  this._positionBufferUsage = {\n    bufferUsage: BufferUsage.STATIC_DRAW,\n    frameCount: 0,\n  };\n\n  this._mode = undefined;\n\n  this._polylinesToUpdate = [];\n  this._vertexArrays = [];\n  this._positionBuffer = undefined;\n  this._texCoordExpandAndBatchIndexBuffer = undefined;\n\n  this._batchTable = undefined;\n  this._createBatchTable = false;\n\n  // Only used by Vector3DTilePoints\n  this._useHighlightColor = false;\n  this._highlightColor = Color.clone(Color.WHITE);\n\n  const that = this;\n  this._uniformMap = {\n    u_highlightColor: function () {\n      return that._highlightColor;\n    },\n  };\n}\n\nObject.defineProperties(PolylineCollection.prototype, {\n  /**\n   * Returns the number of polylines in this collection.  This is commonly used with\n   * {@link PolylineCollection#get} to iterate over all the polylines\n   * in the collection.\n   * @memberof PolylineCollection.prototype\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      removePolylines(this);\n      return this._polylines.length;\n    },\n  },\n});\n\n/**\n     * Creates and adds a polyline with the specified initial properties to the collection.\n     * The added polyline is returned so it can be modified or removed from the collection later.\n     *\n     * @param {object}[options] A template describing the polyline's properties as shown in Example 1.\n     * @returns {Polyline} The polyline that was added to the collection.\n     *\n     * @performance After calling <code>add</code>, {@link PolylineCollection#update} is called and\n     * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.\n     * For best performance, add as many polylines as possible before calling <code>update</code>.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * // Example 1:  Add a polyline, specifying all the default values.\n     * const p = polylines.add({\n     *   show : true,\n     *   positions : ellipsoid.cartographicArrayToCartesianArray([\n           Cesium.Cartographic.fromDegrees(-75.10, 39.57),\n           Cesium.Cartographic.fromDegrees(-77.02, 38.53)]),\n     *   width : 1\n     * });\n     *\n     * @see PolylineCollection#remove\n     * @see PolylineCollection#removeAll\n     * @see PolylineCollection#update\n     */\nPolylineCollection.prototype.add = function (options) {\n  const p = new Polyline(options, this);\n  p._index = this._polylines.length;\n  this._polylines.push(p);\n  this._createVertexArray = true;\n  this._createBatchTable = true;\n  return p;\n};\n\n/**\n * Removes a polyline from the collection.\n *\n * @param {Polyline} polyline The polyline to remove.\n * @returns {boolean} <code>true</code> if the polyline was removed; <code>false</code> if the polyline was not found in the collection.\n *\n * @performance After calling <code>remove</code>, {@link PolylineCollection#update} is called and\n * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.\n * For best performance, remove as many polylines as possible before calling <code>update</code>.\n * If you intend to temporarily hide a polyline, it is usually more efficient to call\n * {@link Polyline#show} instead of removing and re-adding the polyline.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const p = polylines.add(...);\n * polylines.remove(p);  // Returns true\n *\n * @see PolylineCollection#add\n * @see PolylineCollection#removeAll\n * @see PolylineCollection#update\n * @see Polyline#show\n */\nPolylineCollection.prototype.remove = function (polyline) {\n  if (this.contains(polyline)) {\n    this._polylinesRemoved = true;\n    this._createVertexArray = true;\n    this._createBatchTable = true;\n    if (defined(polyline._bucket)) {\n      const bucket = polyline._bucket;\n      bucket.shaderProgram =\n        bucket.shaderProgram && bucket.shaderProgram.destroy();\n    }\n    polyline._destroy();\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Removes all polylines from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the polylines\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * polylines.add(...);\n * polylines.add(...);\n * polylines.removeAll();\n *\n * @see PolylineCollection#add\n * @see PolylineCollection#remove\n * @see PolylineCollection#update\n */\nPolylineCollection.prototype.removeAll = function () {\n  releaseShaders(this);\n  destroyPolylines(this);\n  this._polylineBuckets = {};\n  this._polylinesRemoved = false;\n  this._polylines.length = 0;\n  this._polylinesToUpdate.length = 0;\n  this._createVertexArray = true;\n};\n\n/**\n * Determines if this collection contains the specified polyline.\n *\n * @param {Polyline} polyline The polyline to check for.\n * @returns {boolean} true if this collection contains the polyline, false otherwise.\n *\n * @see PolylineCollection#get\n */\nPolylineCollection.prototype.contains = function (polyline) {\n  return defined(polyline) && polyline._polylineCollection === this;\n};\n\n/**\n * Returns the polyline in the collection at the specified index.  Indices are zero-based\n * and increase as polylines are added.  Removing a polyline shifts all polylines after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link PolylineCollection#length} to iterate over all the polylines\n * in the collection.\n *\n * @param {number} index The zero-based index of the polyline.\n * @returns {Polyline} The polyline at the specified index.\n *\n * @performance If polylines were removed from the collection and\n * {@link PolylineCollection#update} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Toggle the show property of every polyline in the collection\n * const len = polylines.length;\n * for (let i = 0; i < len; ++i) {\n *   const p = polylines.get(i);\n *   p.show = !p.show;\n * }\n *\n * @see PolylineCollection#length\n */\nPolylineCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  removePolylines(this);\n  return this._polylines[index];\n};\n\nfunction createBatchTable(collection, context) {\n  if (defined(collection._batchTable)) {\n    collection._batchTable.destroy();\n  }\n\n  const attributes = [\n    {\n      functionName: \"batchTable_getWidthAndShow\",\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 2,\n    },\n    {\n      functionName: \"batchTable_getPickColor\",\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 4,\n      normalize: true,\n    },\n    {\n      functionName: \"batchTable_getCenterHigh\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n    },\n    {\n      functionName: \"batchTable_getCenterLowAndRadius\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 4,\n    },\n    {\n      functionName: \"batchTable_getDistanceDisplayCondition\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n    },\n  ];\n\n  collection._batchTable = new BatchTable(\n    context,\n    attributes,\n    collection._polylines.length,\n  );\n}\n\nconst scratchUpdatePolylineEncodedCartesian = new EncodedCartesian3();\nconst scratchUpdatePolylineCartesian4 = new Cartesian4();\nconst scratchNearFarCartesian2 = new Cartesian2();\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {RuntimeError} Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\n */\nPolylineCollection.prototype.update = function (frameState) {\n  removePolylines(this);\n\n  if (this._polylines.length === 0 || !this.show) {\n    return;\n  }\n\n  updateMode(this, frameState);\n\n  const context = frameState.context;\n  const projection = frameState.mapProjection;\n  let polyline;\n  let properties = this._propertiesChanged;\n\n  if (this._createBatchTable) {\n    if (ContextLimits.maximumVertexTextureImageUnits === 0) {\n      throw new RuntimeError(\n        \"Vertex texture fetch support is required to render polylines. The maximum number of vertex texture image units must be greater than zero.\",\n      );\n    }\n    createBatchTable(this, context);\n    this._createBatchTable = false;\n  }\n\n  if (this._createVertexArray || computeNewBuffersUsage(this)) {\n    createVertexArrays(this, context, projection);\n  } else if (this._polylinesUpdated) {\n    // Polylines were modified, but no polylines were added or removed.\n    const polylinesToUpdate = this._polylinesToUpdate;\n    if (this._mode !== SceneMode.SCENE3D) {\n      const updateLength = polylinesToUpdate.length;\n      for (let i = 0; i < updateLength; ++i) {\n        polyline = polylinesToUpdate[i];\n        polyline.update();\n      }\n    }\n\n    // if a polyline's positions size changes, we need to recreate the vertex arrays and vertex buffers because the indices will be different.\n    // if a polyline's material changes, we need to recreate the VAOs and VBOs because they will be batched differently.\n    if (properties[POSITION_SIZE_INDEX] || properties[MATERIAL_INDEX]) {\n      createVertexArrays(this, context, projection);\n    } else {\n      const length = polylinesToUpdate.length;\n      const polylineBuckets = this._polylineBuckets;\n      for (let ii = 0; ii < length; ++ii) {\n        polyline = polylinesToUpdate[ii];\n        properties = polyline._propertiesChanged;\n        const bucket = polyline._bucket;\n        let index = 0;\n        for (const x in polylineBuckets) {\n          if (polylineBuckets.hasOwnProperty(x)) {\n            if (polylineBuckets[x] === bucket) {\n              if (properties[POSITION_INDEX]) {\n                bucket.writeUpdate(\n                  index,\n                  polyline,\n                  this._positionBuffer,\n                  projection,\n                );\n              }\n              break;\n            }\n            index += polylineBuckets[x].lengthOfPositions;\n          }\n        }\n\n        if (properties[SHOW_INDEX] || properties[WIDTH_INDEX]) {\n          this._batchTable.setBatchedAttribute(\n            polyline._index,\n            0,\n            new Cartesian2(polyline._width, polyline._show),\n          );\n        }\n\n        if (this._batchTable.attributes.length > 2) {\n          if (properties[POSITION_INDEX] || properties[POSITION_SIZE_INDEX]) {\n            const boundingSphere =\n              frameState.mode === SceneMode.SCENE2D\n                ? polyline._boundingVolume2D\n                : polyline._boundingVolumeWC;\n            const encodedCenter = EncodedCartesian3.fromCartesian(\n              boundingSphere.center,\n              scratchUpdatePolylineEncodedCartesian,\n            );\n            const low = Cartesian4.fromElements(\n              encodedCenter.low.x,\n              encodedCenter.low.y,\n              encodedCenter.low.z,\n              boundingSphere.radius,\n              scratchUpdatePolylineCartesian4,\n            );\n            this._batchTable.setBatchedAttribute(\n              polyline._index,\n              2,\n              encodedCenter.high,\n            );\n            this._batchTable.setBatchedAttribute(polyline._index, 3, low);\n          }\n\n          if (properties[DISTANCE_DISPLAY_CONDITION]) {\n            const nearFarCartesian = scratchNearFarCartesian2;\n            nearFarCartesian.x = 0.0;\n            nearFarCartesian.y = Number.MAX_VALUE;\n\n            const distanceDisplayCondition = polyline.distanceDisplayCondition;\n            if (defined(distanceDisplayCondition)) {\n              nearFarCartesian.x = distanceDisplayCondition.near;\n              nearFarCartesian.y = distanceDisplayCondition.far;\n            }\n\n            this._batchTable.setBatchedAttribute(\n              polyline._index,\n              4,\n              nearFarCartesian,\n            );\n          }\n        }\n\n        polyline._clean();\n      }\n    }\n    polylinesToUpdate.length = 0;\n    this._polylinesUpdated = false;\n  }\n\n  properties = this._propertiesChanged;\n  for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n    properties[k] = 0;\n  }\n\n  let modelMatrix = Matrix4.IDENTITY;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    modelMatrix = this.modelMatrix;\n  }\n\n  const pass = frameState.passes;\n  const useDepthTest = frameState.morphTime !== 0.0;\n\n  if (\n    !defined(this._opaqueRS) ||\n    this._opaqueRS.depthTest.enabled !== useDepthTest\n  ) {\n    this._opaqueRS = RenderState.fromCache({\n      depthMask: useDepthTest,\n      depthTest: {\n        enabled: useDepthTest,\n      },\n    });\n  }\n\n  if (\n    !defined(this._translucentRS) ||\n    this._translucentRS.depthTest.enabled !== useDepthTest\n  ) {\n    this._translucentRS = RenderState.fromCache({\n      blending: BlendingState.ALPHA_BLEND,\n      depthMask: !useDepthTest,\n      depthTest: {\n        enabled: useDepthTest,\n      },\n    });\n  }\n\n  this._batchTable.update(frameState);\n\n  if (pass.render || pass.pick) {\n    const colorList = this._colorCommands;\n    createCommandLists(this, frameState, colorList, modelMatrix);\n  }\n};\n\nconst boundingSphereScratch = new BoundingSphere();\nconst boundingSphereScratch2 = new BoundingSphere();\n\nfunction createCommandLists(\n  polylineCollection,\n  frameState,\n  commands,\n  modelMatrix,\n) {\n  const context = frameState.context;\n  const commandList = frameState.commandList;\n\n  const commandsLength = commands.length;\n  let commandIndex = 0;\n  let cloneBoundingSphere = true;\n\n  const vertexArrays = polylineCollection._vertexArrays;\n  const debugShowBoundingVolume = polylineCollection.debugShowBoundingVolume;\n\n  const batchTable = polylineCollection._batchTable;\n  const uniformCallback = batchTable.getUniformMapCallback();\n\n  const length = vertexArrays.length;\n  for (let m = 0; m < length; ++m) {\n    const va = vertexArrays[m];\n    const buckets = va.buckets;\n    const bucketLength = buckets.length;\n\n    for (let n = 0; n < bucketLength; ++n) {\n      const bucketLocator = buckets[n];\n\n      let offset = bucketLocator.offset;\n      const sp = bucketLocator.bucket.shaderProgram;\n\n      const polylines = bucketLocator.bucket.polylines;\n      const polylineLength = polylines.length;\n      let currentId;\n      let currentMaterial;\n      let count = 0;\n      let command;\n      let uniformMap;\n\n      for (let s = 0; s < polylineLength; ++s) {\n        const polyline = polylines[s];\n        const mId = createMaterialId(polyline._material);\n        if (mId !== currentId) {\n          if (defined(currentId) && count > 0) {\n            const translucent = currentMaterial.isTranslucent();\n\n            if (commandIndex >= commandsLength) {\n              command = new DrawCommand({\n                owner: polylineCollection,\n              });\n              commands.push(command);\n            } else {\n              command = commands[commandIndex];\n            }\n\n            ++commandIndex;\n\n            uniformMap = combine(\n              uniformCallback(currentMaterial._uniforms),\n              polylineCollection._uniformMap,\n            );\n\n            command.boundingVolume = BoundingSphere.clone(\n              boundingSphereScratch,\n              command.boundingVolume,\n            );\n            command.modelMatrix = modelMatrix;\n            command.shaderProgram = sp;\n            command.vertexArray = va.va;\n            command.renderState = translucent\n              ? polylineCollection._translucentRS\n              : polylineCollection._opaqueRS;\n            command.pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n            command.debugShowBoundingVolume = debugShowBoundingVolume;\n            command.pickId = \"v_pickColor\";\n\n            command.uniformMap = uniformMap;\n            command.count = count;\n            command.offset = offset;\n\n            offset += count;\n            count = 0;\n            cloneBoundingSphere = true;\n\n            commandList.push(command);\n          }\n\n          currentMaterial = polyline._material;\n          currentMaterial.update(context);\n          currentId = mId;\n        }\n\n        const locators = polyline._locatorBuckets;\n        const locatorLength = locators.length;\n        for (let t = 0; t < locatorLength; ++t) {\n          const locator = locators[t];\n          if (locator.locator === bucketLocator) {\n            count += locator.count;\n          }\n        }\n\n        let boundingVolume;\n        if (frameState.mode === SceneMode.SCENE3D) {\n          boundingVolume = polyline._boundingVolumeWC;\n        } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n          boundingVolume = polyline._boundingVolume2D;\n        } else if (frameState.mode === SceneMode.SCENE2D) {\n          if (defined(polyline._boundingVolume2D)) {\n            boundingVolume = BoundingSphere.clone(\n              polyline._boundingVolume2D,\n              boundingSphereScratch2,\n            );\n            boundingVolume.center.x = 0.0;\n          }\n        } else if (\n          defined(polyline._boundingVolumeWC) &&\n          defined(polyline._boundingVolume2D)\n        ) {\n          boundingVolume = BoundingSphere.union(\n            polyline._boundingVolumeWC,\n            polyline._boundingVolume2D,\n            boundingSphereScratch2,\n          );\n        }\n\n        if (cloneBoundingSphere) {\n          cloneBoundingSphere = false;\n          BoundingSphere.clone(boundingVolume, boundingSphereScratch);\n        } else {\n          BoundingSphere.union(\n            boundingVolume,\n            boundingSphereScratch,\n            boundingSphereScratch,\n          );\n        }\n      }\n\n      if (defined(currentId) && count > 0) {\n        if (commandIndex >= commandsLength) {\n          command = new DrawCommand({\n            owner: polylineCollection,\n          });\n          commands.push(command);\n        } else {\n          command = commands[commandIndex];\n        }\n\n        ++commandIndex;\n\n        uniformMap = combine(\n          uniformCallback(currentMaterial._uniforms),\n          polylineCollection._uniformMap,\n        );\n\n        command.boundingVolume = BoundingSphere.clone(\n          boundingSphereScratch,\n          command.boundingVolume,\n        );\n        command.modelMatrix = modelMatrix;\n        command.shaderProgram = sp;\n        command.vertexArray = va.va;\n        command.renderState = currentMaterial.isTranslucent()\n          ? polylineCollection._translucentRS\n          : polylineCollection._opaqueRS;\n        command.pass = currentMaterial.isTranslucent()\n          ? Pass.TRANSLUCENT\n          : Pass.OPAQUE;\n        command.debugShowBoundingVolume = debugShowBoundingVolume;\n        command.pickId = \"v_pickColor\";\n\n        command.uniformMap = uniformMap;\n        command.count = count;\n        command.offset = offset;\n\n        cloneBoundingSphere = true;\n\n        commandList.push(command);\n      }\n\n      currentId = undefined;\n    }\n  }\n\n  commands.length = commandIndex;\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PolylineCollection#destroy\n */\nPolylineCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * polylines = polylines && polylines.destroy();\n *\n * @see PolylineCollection#isDestroyed\n */\nPolylineCollection.prototype.destroy = function () {\n  destroyVertexArrays(this);\n  releaseShaders(this);\n  destroyPolylines(this);\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n  return destroyObject(this);\n};\n\nfunction computeNewBuffersUsage(collection) {\n  let usageChanged = false;\n  const properties = collection._propertiesChanged;\n  const bufferUsage = collection._positionBufferUsage;\n  if (properties[POSITION_INDEX]) {\n    if (bufferUsage.bufferUsage !== BufferUsage.STREAM_DRAW) {\n      usageChanged = true;\n      bufferUsage.bufferUsage = BufferUsage.STREAM_DRAW;\n      bufferUsage.frameCount = 100;\n    } else {\n      bufferUsage.frameCount = 100;\n    }\n  } else if (bufferUsage.bufferUsage !== BufferUsage.STATIC_DRAW) {\n    if (bufferUsage.frameCount === 0) {\n      usageChanged = true;\n      bufferUsage.bufferUsage = BufferUsage.STATIC_DRAW;\n    } else {\n      bufferUsage.frameCount--;\n    }\n  }\n\n  return usageChanged;\n}\n\nconst emptyVertexBuffer = [0.0, 0.0, 0.0];\n\nfunction createVertexArrays(collection, context, projection) {\n  collection._createVertexArray = false;\n  releaseShaders(collection);\n  destroyVertexArrays(collection);\n  sortPolylinesIntoBuckets(collection);\n\n  //stores all of the individual indices arrays.\n  const totalIndices = [[]];\n  let indices = totalIndices[0];\n\n  const batchTable = collection._batchTable;\n  const useHighlightColor = collection._useHighlightColor;\n\n  //used to determine the vertexBuffer offset if the indicesArray goes over 64k.\n  //if it's the same polyline while it goes over 64k, the offset needs to backtrack componentsPerAttribute * componentDatatype bytes\n  //so that the polyline looks contiguous.\n  //if the polyline ends at the 64k mark, then the offset is just 64k * componentsPerAttribute * componentDatatype\n  const vertexBufferOffset = [0];\n  let offset = 0;\n  const vertexArrayBuckets = [[]];\n  let totalLength = 0;\n  const polylineBuckets = collection._polylineBuckets;\n  let x;\n  let bucket;\n  for (x in polylineBuckets) {\n    if (polylineBuckets.hasOwnProperty(x)) {\n      bucket = polylineBuckets[x];\n      bucket.updateShader(context, batchTable, useHighlightColor);\n      totalLength += bucket.lengthOfPositions;\n    }\n  }\n\n  if (totalLength > 0) {\n    const mode = collection._mode;\n\n    const positionArray = new Float32Array(6 * totalLength * 3);\n    const texCoordExpandAndBatchIndexArray = new Float32Array(totalLength * 4);\n    let position3DArray;\n\n    let positionIndex = 0;\n    let colorIndex = 0;\n    let texCoordExpandAndBatchIndexIndex = 0;\n    for (x in polylineBuckets) {\n      if (polylineBuckets.hasOwnProperty(x)) {\n        bucket = polylineBuckets[x];\n        bucket.write(\n          positionArray,\n          texCoordExpandAndBatchIndexArray,\n          positionIndex,\n          colorIndex,\n          texCoordExpandAndBatchIndexIndex,\n          batchTable,\n          context,\n          projection,\n        );\n\n        if (mode === SceneMode.MORPHING) {\n          if (!defined(position3DArray)) {\n            position3DArray = new Float32Array(6 * totalLength * 3);\n          }\n          bucket.writeForMorph(position3DArray, positionIndex);\n        }\n\n        const bucketLength = bucket.lengthOfPositions;\n        positionIndex += 6 * bucketLength * 3;\n        colorIndex += bucketLength * 4;\n        texCoordExpandAndBatchIndexIndex += bucketLength * 4;\n        offset = bucket.updateIndices(\n          totalIndices,\n          vertexBufferOffset,\n          vertexArrayBuckets,\n          offset,\n        );\n      }\n    }\n\n    const positionBufferUsage = collection._positionBufferUsage.bufferUsage;\n    const texCoordExpandAndBatchIndexBufferUsage = BufferUsage.STATIC_DRAW;\n\n    collection._positionBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: positionArray,\n      usage: positionBufferUsage,\n    });\n    let position3DBuffer;\n    if (defined(position3DArray)) {\n      position3DBuffer = Buffer.createVertexBuffer({\n        context: context,\n        typedArray: position3DArray,\n        usage: positionBufferUsage,\n      });\n    }\n    collection._texCoordExpandAndBatchIndexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: texCoordExpandAndBatchIndexArray,\n      usage: texCoordExpandAndBatchIndexBufferUsage,\n    });\n\n    const positionSizeInBytes = 3 * Float32Array.BYTES_PER_ELEMENT;\n    const texCoordExpandAndBatchIndexSizeInBytes =\n      4 * Float32Array.BYTES_PER_ELEMENT;\n\n    let vbo = 0;\n    const numberOfIndicesArrays = totalIndices.length;\n    for (let k = 0; k < numberOfIndicesArrays; ++k) {\n      indices = totalIndices[k];\n\n      if (indices.length > 0) {\n        const indicesArray = new Uint16Array(indices);\n        const indexBuffer = Buffer.createIndexBuffer({\n          context: context,\n          typedArray: indicesArray,\n          usage: BufferUsage.STATIC_DRAW,\n          indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n        });\n\n        vbo += vertexBufferOffset[k];\n\n        const positionHighOffset =\n          6 *\n          (k * (positionSizeInBytes * CesiumMath.SIXTY_FOUR_KILOBYTES) -\n            vbo * positionSizeInBytes); //componentsPerAttribute(3) * componentDatatype(4)\n        const positionLowOffset = positionSizeInBytes + positionHighOffset;\n        const prevPositionHighOffset = positionSizeInBytes + positionLowOffset;\n        const prevPositionLowOffset =\n          positionSizeInBytes + prevPositionHighOffset;\n        const nextPositionHighOffset =\n          positionSizeInBytes + prevPositionLowOffset;\n        const nextPositionLowOffset =\n          positionSizeInBytes + nextPositionHighOffset;\n        const vertexTexCoordExpandAndBatchIndexBufferOffset =\n          k *\n            (texCoordExpandAndBatchIndexSizeInBytes *\n              CesiumMath.SIXTY_FOUR_KILOBYTES) -\n          vbo * texCoordExpandAndBatchIndexSizeInBytes;\n\n        const attributes = [\n          {\n            index: attributeLocations.position3DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: positionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.position3DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: positionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.position2DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: positionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.position2DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: positionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.prevPosition3DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: prevPositionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.prevPosition3DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: prevPositionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.prevPosition2DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: prevPositionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.prevPosition2DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: prevPositionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.nextPosition3DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: nextPositionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.nextPosition3DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: nextPositionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.nextPosition2DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: nextPositionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.nextPosition2DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: nextPositionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.texCoordExpandAndBatchIndex,\n            componentsPerAttribute: 4,\n            componentDatatype: ComponentDatatype.FLOAT,\n            vertexBuffer: collection._texCoordExpandAndBatchIndexBuffer,\n            offsetInBytes: vertexTexCoordExpandAndBatchIndexBufferOffset,\n          },\n        ];\n\n        let bufferProperty3D;\n        let buffer3D;\n        let buffer2D;\n        let bufferProperty2D;\n\n        if (mode === SceneMode.SCENE3D) {\n          buffer3D = collection._positionBuffer;\n          bufferProperty3D = \"vertexBuffer\";\n          buffer2D = emptyVertexBuffer;\n          bufferProperty2D = \"value\";\n        } else if (\n          mode === SceneMode.SCENE2D ||\n          mode === SceneMode.COLUMBUS_VIEW\n        ) {\n          buffer3D = emptyVertexBuffer;\n          bufferProperty3D = \"value\";\n          buffer2D = collection._positionBuffer;\n          bufferProperty2D = \"vertexBuffer\";\n        } else {\n          buffer3D = position3DBuffer;\n          bufferProperty3D = \"vertexBuffer\";\n          buffer2D = collection._positionBuffer;\n          bufferProperty2D = \"vertexBuffer\";\n        }\n\n        attributes[0][bufferProperty3D] = buffer3D;\n        attributes[1][bufferProperty3D] = buffer3D;\n        attributes[2][bufferProperty2D] = buffer2D;\n        attributes[3][bufferProperty2D] = buffer2D;\n        attributes[4][bufferProperty3D] = buffer3D;\n        attributes[5][bufferProperty3D] = buffer3D;\n        attributes[6][bufferProperty2D] = buffer2D;\n        attributes[7][bufferProperty2D] = buffer2D;\n        attributes[8][bufferProperty3D] = buffer3D;\n        attributes[9][bufferProperty3D] = buffer3D;\n        attributes[10][bufferProperty2D] = buffer2D;\n        attributes[11][bufferProperty2D] = buffer2D;\n\n        const va = new VertexArray({\n          context: context,\n          attributes: attributes,\n          indexBuffer: indexBuffer,\n        });\n        collection._vertexArrays.push({\n          va: va,\n          buckets: vertexArrayBuckets[k],\n        });\n      }\n    }\n  }\n}\n\nfunction replacer(key, value) {\n  if (value instanceof Texture) {\n    return value.id;\n  }\n\n  return value;\n}\n\nconst scratchUniformArray = [];\nfunction createMaterialId(material) {\n  const uniforms = Material._uniformList[material.type];\n  const length = uniforms.length;\n  scratchUniformArray.length = 2.0 * length;\n\n  let index = 0;\n  for (let i = 0; i < length; ++i) {\n    const uniform = uniforms[i];\n    scratchUniformArray[index] = uniform;\n    scratchUniformArray[index + 1] = material._uniforms[uniform]();\n    index += 2;\n  }\n\n  return `${material.type}:${JSON.stringify(scratchUniformArray, replacer)}`;\n}\n\nfunction sortPolylinesIntoBuckets(collection) {\n  const mode = collection._mode;\n  const modelMatrix = collection._modelMatrix;\n\n  const polylineBuckets = (collection._polylineBuckets = {});\n  const polylines = collection._polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    const p = polylines[i];\n    if (p._actualPositions.length > 1) {\n      p.update();\n      const material = p.material;\n      let value = polylineBuckets[material.type];\n      if (!defined(value)) {\n        value = polylineBuckets[material.type] = new PolylineBucket(\n          material,\n          mode,\n          modelMatrix,\n        );\n      }\n      value.addPolyline(p);\n    }\n  }\n}\n\nfunction updateMode(collection, frameState) {\n  const mode = frameState.mode;\n\n  if (\n    collection._mode !== mode ||\n    !Matrix4.equals(collection._modelMatrix, collection.modelMatrix)\n  ) {\n    collection._mode = mode;\n    collection._modelMatrix = Matrix4.clone(collection.modelMatrix);\n    collection._createVertexArray = true;\n  }\n}\n\nfunction removePolylines(collection) {\n  if (collection._polylinesRemoved) {\n    collection._polylinesRemoved = false;\n    const definedPolylines = [];\n    const definedPolylinesToUpdate = [];\n    let polyIndex = 0;\n    let polyline;\n\n    const length = collection._polylines.length;\n    for (let i = 0; i < length; ++i) {\n      polyline = collection._polylines[i];\n      if (!polyline.isDestroyed) {\n        polyline._index = polyIndex++;\n        definedPolylinesToUpdate.push(polyline);\n        definedPolylines.push(polyline);\n      }\n    }\n\n    collection._polylines = definedPolylines;\n    collection._polylinesToUpdate = definedPolylinesToUpdate;\n  }\n}\n\nfunction releaseShaders(collection) {\n  const polylines = collection._polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    if (!polylines[i].isDestroyed) {\n      const bucket = polylines[i]._bucket;\n      if (defined(bucket)) {\n        bucket.shaderProgram =\n          bucket.shaderProgram && bucket.shaderProgram.destroy();\n      }\n    }\n  }\n}\n\nfunction destroyVertexArrays(collection) {\n  const length = collection._vertexArrays.length;\n  for (let t = 0; t < length; ++t) {\n    collection._vertexArrays[t].va.destroy();\n  }\n  collection._vertexArrays.length = 0;\n}\n\nPolylineCollection.prototype._updatePolyline = function (\n  polyline,\n  propertyChanged,\n) {\n  this._polylinesUpdated = true;\n  if (!polyline._dirty) {\n    this._polylinesToUpdate.push(polyline);\n  }\n  ++this._propertiesChanged[propertyChanged];\n};\n\nfunction destroyPolylines(collection) {\n  const polylines = collection._polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    if (!polylines[i].isDestroyed) {\n      polylines[i]._destroy();\n    }\n  }\n}\n\nfunction VertexArrayBucketLocator(count, offset, bucket) {\n  this.count = count;\n  this.offset = offset;\n  this.bucket = bucket;\n}\n\nfunction PolylineBucket(material, mode, modelMatrix) {\n  this.polylines = [];\n  this.lengthOfPositions = 0;\n  this.material = material;\n  this.shaderProgram = undefined;\n  this.mode = mode;\n  this.modelMatrix = modelMatrix;\n}\n\nPolylineBucket.prototype.addPolyline = function (p) {\n  const polylines = this.polylines;\n  polylines.push(p);\n  p._actualLength = this.getPolylinePositionsLength(p);\n  this.lengthOfPositions += p._actualLength;\n  p._bucket = this;\n};\n\nPolylineBucket.prototype.updateShader = function (\n  context,\n  batchTable,\n  useHighlightColor,\n) {\n  if (defined(this.shaderProgram)) {\n    return;\n  }\n\n  const defines = [\"DISTANCE_DISPLAY_CONDITION\"];\n  if (useHighlightColor) {\n    defines.push(\"VECTOR_TILE\");\n  }\n\n  // Check for use of v_polylineAngle in material shader\n  if (\n    this.material.shaderSource.search(/in\\s+float\\s+v_polylineAngle;/g) !== -1\n  ) {\n    defines.push(\"POLYLINE_DASH\");\n  }\n\n  if (!FeatureDetection.isInternetExplorer()) {\n    defines.push(\"CLIP_POLYLINE\");\n  }\n\n  const fs = new ShaderSource({\n    defines: defines,\n    sources: [\"in vec4 v_pickColor;\\n\", this.material.shaderSource, PolylineFS],\n  });\n\n  const vsSource = batchTable.getVertexShaderCallback()(PolylineVS);\n  const vs = new ShaderSource({\n    defines: defines,\n    sources: [PolylineCommon, vsSource],\n  });\n\n  this.shaderProgram = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n};\n\nfunction intersectsIDL(polyline) {\n  return (\n    Cartesian3.dot(Cartesian3.UNIT_X, polyline._boundingVolume.center) < 0 ||\n    polyline._boundingVolume.intersectPlane(Plane.ORIGIN_ZX_PLANE) ===\n      Intersect.INTERSECTING\n  );\n}\n\nPolylineBucket.prototype.getPolylinePositionsLength = function (polyline) {\n  let length;\n  if (this.mode === SceneMode.SCENE3D || !intersectsIDL(polyline)) {\n    length = polyline._actualPositions.length;\n    return length * 4.0 - 4.0;\n  }\n\n  let count = 0;\n  const segmentLengths = polyline._segments.lengths;\n  length = segmentLengths.length;\n  for (let i = 0; i < length; ++i) {\n    count += segmentLengths[i] * 4.0 - 4.0;\n  }\n\n  return count;\n};\n\nconst scratchWritePosition = new Cartesian3();\nconst scratchWritePrevPosition = new Cartesian3();\nconst scratchWriteNextPosition = new Cartesian3();\nconst scratchWriteVector = new Cartesian3();\nconst scratchPickColorCartesian = new Cartesian4();\nconst scratchWidthShowCartesian = new Cartesian2();\n\nPolylineBucket.prototype.write = function (\n  positionArray,\n  texCoordExpandAndBatchIndexArray,\n  positionIndex,\n  colorIndex,\n  texCoordExpandAndBatchIndexIndex,\n  batchTable,\n  context,\n  projection,\n) {\n  const mode = this.mode;\n  const maxLon = projection.ellipsoid.maximumRadius * CesiumMath.PI;\n\n  const polylines = this.polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    const polyline = polylines[i];\n    const width = polyline.width;\n    const show = polyline.show && width > 0.0;\n    const polylineBatchIndex = polyline._index;\n    const segments = this.getSegments(polyline, projection);\n    const positions = segments.positions;\n    const lengths = segments.lengths;\n    const positionsLength = positions.length;\n\n    const pickColor = polyline.getPickId(context).color;\n\n    let segmentIndex = 0;\n    let count = 0;\n    let position;\n\n    for (let j = 0; j < positionsLength; ++j) {\n      if (j === 0) {\n        if (polyline._loop) {\n          position = positions[positionsLength - 2];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(positions[0], positions[1], position);\n          Cartesian3.add(positions[0], position, position);\n        }\n      } else {\n        position = positions[j - 1];\n      }\n\n      Cartesian3.clone(position, scratchWritePrevPosition);\n      Cartesian3.clone(positions[j], scratchWritePosition);\n\n      if (j === positionsLength - 1) {\n        if (polyline._loop) {\n          position = positions[1];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(\n            positions[positionsLength - 1],\n            positions[positionsLength - 2],\n            position,\n          );\n          Cartesian3.add(positions[positionsLength - 1], position, position);\n        }\n      } else {\n        position = positions[j + 1];\n      }\n\n      Cartesian3.clone(position, scratchWriteNextPosition);\n\n      const segmentLength = lengths[segmentIndex];\n      if (j === count + segmentLength) {\n        count += segmentLength;\n        ++segmentIndex;\n      }\n\n      const segmentStart = j - count === 0;\n      const segmentEnd = j === count + lengths[segmentIndex] - 1;\n\n      if (mode === SceneMode.SCENE2D) {\n        scratchWritePrevPosition.z = 0.0;\n        scratchWritePosition.z = 0.0;\n        scratchWriteNextPosition.z = 0.0;\n      }\n\n      if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n        if (\n          (segmentStart || segmentEnd) &&\n          maxLon - Math.abs(scratchWritePosition.x) < 1.0\n        ) {\n          if (\n            (scratchWritePosition.x < 0.0 &&\n              scratchWritePrevPosition.x > 0.0) ||\n            (scratchWritePosition.x > 0.0 && scratchWritePrevPosition.x < 0.0)\n          ) {\n            Cartesian3.clone(scratchWritePosition, scratchWritePrevPosition);\n          }\n\n          if (\n            (scratchWritePosition.x < 0.0 &&\n              scratchWriteNextPosition.x > 0.0) ||\n            (scratchWritePosition.x > 0.0 && scratchWriteNextPosition.x < 0.0)\n          ) {\n            Cartesian3.clone(scratchWritePosition, scratchWriteNextPosition);\n          }\n        }\n      }\n\n      const startK = segmentStart ? 2 : 0;\n      const endK = segmentEnd ? 2 : 4;\n\n      for (let k = startK; k < endK; ++k) {\n        EncodedCartesian3.writeElements(\n          scratchWritePosition,\n          positionArray,\n          positionIndex,\n        );\n        EncodedCartesian3.writeElements(\n          scratchWritePrevPosition,\n          positionArray,\n          positionIndex + 6,\n        );\n        EncodedCartesian3.writeElements(\n          scratchWriteNextPosition,\n          positionArray,\n          positionIndex + 12,\n        );\n\n        const direction = k - 2 < 0 ? -1.0 : 1.0;\n        texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex] =\n          j / (positionsLength - 1); // s tex coord\n        texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex + 1] =\n          2 * (k % 2) - 1; // expand direction\n        texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex + 2] =\n          direction;\n        texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex + 3] =\n          polylineBatchIndex;\n\n        positionIndex += 6 * 3;\n        texCoordExpandAndBatchIndexIndex += 4;\n      }\n    }\n\n    const colorCartesian = scratchPickColorCartesian;\n    colorCartesian.x = Color.floatToByte(pickColor.red);\n    colorCartesian.y = Color.floatToByte(pickColor.green);\n    colorCartesian.z = Color.floatToByte(pickColor.blue);\n    colorCartesian.w = Color.floatToByte(pickColor.alpha);\n\n    const widthShowCartesian = scratchWidthShowCartesian;\n    widthShowCartesian.x = width;\n    widthShowCartesian.y = show ? 1.0 : 0.0;\n\n    const boundingSphere =\n      mode === SceneMode.SCENE2D\n        ? polyline._boundingVolume2D\n        : polyline._boundingVolumeWC;\n    const encodedCenter = EncodedCartesian3.fromCartesian(\n      boundingSphere.center,\n      scratchUpdatePolylineEncodedCartesian,\n    );\n    const high = encodedCenter.high;\n    const low = Cartesian4.fromElements(\n      encodedCenter.low.x,\n      encodedCenter.low.y,\n      encodedCenter.low.z,\n      boundingSphere.radius,\n      scratchUpdatePolylineCartesian4,\n    );\n\n    const nearFarCartesian = scratchNearFarCartesian2;\n    nearFarCartesian.x = 0.0;\n    nearFarCartesian.y = Number.MAX_VALUE;\n\n    const distanceDisplayCondition = polyline.distanceDisplayCondition;\n    if (defined(distanceDisplayCondition)) {\n      nearFarCartesian.x = distanceDisplayCondition.near;\n      nearFarCartesian.y = distanceDisplayCondition.far;\n    }\n\n    batchTable.setBatchedAttribute(polylineBatchIndex, 0, widthShowCartesian);\n    batchTable.setBatchedAttribute(polylineBatchIndex, 1, colorCartesian);\n\n    if (batchTable.attributes.length > 2) {\n      batchTable.setBatchedAttribute(polylineBatchIndex, 2, high);\n      batchTable.setBatchedAttribute(polylineBatchIndex, 3, low);\n      batchTable.setBatchedAttribute(polylineBatchIndex, 4, nearFarCartesian);\n    }\n  }\n};\n\nconst morphPositionScratch = new Cartesian3();\nconst morphPrevPositionScratch = new Cartesian3();\nconst morphNextPositionScratch = new Cartesian3();\nconst morphVectorScratch = new Cartesian3();\n\nPolylineBucket.prototype.writeForMorph = function (\n  positionArray,\n  positionIndex,\n) {\n  const modelMatrix = this.modelMatrix;\n  const polylines = this.polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    const polyline = polylines[i];\n    const positions = polyline._segments.positions;\n    const lengths = polyline._segments.lengths;\n    const positionsLength = positions.length;\n\n    let segmentIndex = 0;\n    let count = 0;\n\n    for (let j = 0; j < positionsLength; ++j) {\n      let prevPosition;\n      if (j === 0) {\n        if (polyline._loop) {\n          prevPosition = positions[positionsLength - 2];\n        } else {\n          prevPosition = morphVectorScratch;\n          Cartesian3.subtract(positions[0], positions[1], prevPosition);\n          Cartesian3.add(positions[0], prevPosition, prevPosition);\n        }\n      } else {\n        prevPosition = positions[j - 1];\n      }\n\n      prevPosition = Matrix4.multiplyByPoint(\n        modelMatrix,\n        prevPosition,\n        morphPrevPositionScratch,\n      );\n\n      const position = Matrix4.multiplyByPoint(\n        modelMatrix,\n        positions[j],\n        morphPositionScratch,\n      );\n\n      let nextPosition;\n      if (j === positionsLength - 1) {\n        if (polyline._loop) {\n          nextPosition = positions[1];\n        } else {\n          nextPosition = morphVectorScratch;\n          Cartesian3.subtract(\n            positions[positionsLength - 1],\n            positions[positionsLength - 2],\n            nextPosition,\n          );\n          Cartesian3.add(\n            positions[positionsLength - 1],\n            nextPosition,\n            nextPosition,\n          );\n        }\n      } else {\n        nextPosition = positions[j + 1];\n      }\n\n      nextPosition = Matrix4.multiplyByPoint(\n        modelMatrix,\n        nextPosition,\n        morphNextPositionScratch,\n      );\n\n      const segmentLength = lengths[segmentIndex];\n      if (j === count + segmentLength) {\n        count += segmentLength;\n        ++segmentIndex;\n      }\n\n      const segmentStart = j - count === 0;\n      const segmentEnd = j === count + lengths[segmentIndex] - 1;\n\n      const startK = segmentStart ? 2 : 0;\n      const endK = segmentEnd ? 2 : 4;\n\n      for (let k = startK; k < endK; ++k) {\n        EncodedCartesian3.writeElements(position, positionArray, positionIndex);\n        EncodedCartesian3.writeElements(\n          prevPosition,\n          positionArray,\n          positionIndex + 6,\n        );\n        EncodedCartesian3.writeElements(\n          nextPosition,\n          positionArray,\n          positionIndex + 12,\n        );\n\n        positionIndex += 6 * 3;\n      }\n    }\n  }\n};\n\nconst scratchSegmentLengths = new Array(1);\n\nPolylineBucket.prototype.updateIndices = function (\n  totalIndices,\n  vertexBufferOffset,\n  vertexArrayBuckets,\n  offset,\n) {\n  let vaCount = vertexArrayBuckets.length - 1;\n  let bucketLocator = new VertexArrayBucketLocator(0, offset, this);\n  vertexArrayBuckets[vaCount].push(bucketLocator);\n  let count = 0;\n  let indices = totalIndices[totalIndices.length - 1];\n  let indicesCount = 0;\n  if (indices.length > 0) {\n    indicesCount = indices[indices.length - 1] + 1;\n  }\n  const polylines = this.polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    const polyline = polylines[i];\n    polyline._locatorBuckets = [];\n\n    let segments;\n    if (this.mode === SceneMode.SCENE3D) {\n      segments = scratchSegmentLengths;\n      const positionsLength = polyline._actualPositions.length;\n      if (positionsLength > 0) {\n        segments[0] = positionsLength;\n      } else {\n        continue;\n      }\n    } else {\n      segments = polyline._segments.lengths;\n    }\n\n    const numberOfSegments = segments.length;\n    if (numberOfSegments > 0) {\n      let segmentIndexCount = 0;\n      for (let j = 0; j < numberOfSegments; ++j) {\n        const segmentLength = segments[j] - 1.0;\n        for (let k = 0; k < segmentLength; ++k) {\n          if (indicesCount + 4 > CesiumMath.SIXTY_FOUR_KILOBYTES) {\n            polyline._locatorBuckets.push({\n              locator: bucketLocator,\n              count: segmentIndexCount,\n            });\n            segmentIndexCount = 0;\n            vertexBufferOffset.push(4);\n            indices = [];\n            totalIndices.push(indices);\n            indicesCount = 0;\n            bucketLocator.count = count;\n            count = 0;\n            offset = 0;\n            bucketLocator = new VertexArrayBucketLocator(0, 0, this);\n            vertexArrayBuckets[++vaCount] = [bucketLocator];\n          }\n\n          indices.push(indicesCount, indicesCount + 2, indicesCount + 1);\n          indices.push(indicesCount + 1, indicesCount + 2, indicesCount + 3);\n\n          segmentIndexCount += 6;\n          count += 6;\n          offset += 6;\n          indicesCount += 4;\n        }\n      }\n\n      polyline._locatorBuckets.push({\n        locator: bucketLocator,\n        count: segmentIndexCount,\n      });\n\n      if (indicesCount + 4 > CesiumMath.SIXTY_FOUR_KILOBYTES) {\n        vertexBufferOffset.push(0);\n        indices = [];\n        totalIndices.push(indices);\n        indicesCount = 0;\n        bucketLocator.count = count;\n        offset = 0;\n        count = 0;\n        bucketLocator = new VertexArrayBucketLocator(0, 0, this);\n        vertexArrayBuckets[++vaCount] = [bucketLocator];\n      }\n    }\n    polyline._clean();\n  }\n  bucketLocator.count = count;\n  return offset;\n};\n\nPolylineBucket.prototype.getPolylineStartIndex = function (polyline) {\n  const polylines = this.polylines;\n  let positionIndex = 0;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    const p = polylines[i];\n    if (p === polyline) {\n      break;\n    }\n    positionIndex += p._actualLength;\n  }\n  return positionIndex;\n};\n\nconst scratchSegments = {\n  positions: undefined,\n  lengths: undefined,\n};\nconst scratchLengths = new Array(1);\nconst pscratch = new Cartesian3();\nconst scratchCartographic = new Cartographic();\n\nPolylineBucket.prototype.getSegments = function (polyline, projection) {\n  let positions = polyline._actualPositions;\n\n  if (this.mode === SceneMode.SCENE3D) {\n    scratchLengths[0] = positions.length;\n    scratchSegments.positions = positions;\n    scratchSegments.lengths = scratchLengths;\n    return scratchSegments;\n  }\n\n  if (intersectsIDL(polyline)) {\n    positions = polyline._segments.positions;\n  }\n\n  const ellipsoid = projection.ellipsoid;\n  const newPositions = [];\n  const modelMatrix = this.modelMatrix;\n  const length = positions.length;\n  let position;\n  let p = pscratch;\n\n  for (let n = 0; n < length; ++n) {\n    position = positions[n];\n    p = Matrix4.multiplyByPoint(modelMatrix, position, p);\n    newPositions.push(\n      projection.project(\n        ellipsoid.cartesianToCartographic(p, scratchCartographic),\n      ),\n    );\n  }\n\n  if (newPositions.length > 0) {\n    polyline._boundingVolume2D = BoundingSphere.fromPoints(\n      newPositions,\n      polyline._boundingVolume2D,\n    );\n    const center2D = polyline._boundingVolume2D.center;\n    polyline._boundingVolume2D.center = new Cartesian3(\n      center2D.z,\n      center2D.x,\n      center2D.y,\n    );\n  }\n\n  scratchSegments.positions = newPositions;\n  scratchSegments.lengths = polyline._segments.lengths;\n  return scratchSegments;\n};\n\nlet scratchPositionsArray;\n\nPolylineBucket.prototype.writeUpdate = function (\n  index,\n  polyline,\n  positionBuffer,\n  projection,\n) {\n  const mode = this.mode;\n  const maxLon = projection.ellipsoid.maximumRadius * CesiumMath.PI;\n\n  let positionsLength = polyline._actualLength;\n  if (positionsLength) {\n    index += this.getPolylineStartIndex(polyline);\n\n    let positionArray = scratchPositionsArray;\n    const positionsArrayLength = 6 * positionsLength * 3;\n\n    if (\n      !defined(positionArray) ||\n      positionArray.length < positionsArrayLength\n    ) {\n      positionArray = scratchPositionsArray = new Float32Array(\n        positionsArrayLength,\n      );\n    } else if (positionArray.length > positionsArrayLength) {\n      positionArray = new Float32Array(\n        positionArray.buffer,\n        0,\n        positionsArrayLength,\n      );\n    }\n\n    const segments = this.getSegments(polyline, projection);\n    const positions = segments.positions;\n    const lengths = segments.lengths;\n\n    let positionIndex = 0;\n    let segmentIndex = 0;\n    let count = 0;\n    let position;\n\n    positionsLength = positions.length;\n    for (let i = 0; i < positionsLength; ++i) {\n      if (i === 0) {\n        if (polyline._loop) {\n          position = positions[positionsLength - 2];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(positions[0], positions[1], position);\n          Cartesian3.add(positions[0], position, position);\n        }\n      } else {\n        position = positions[i - 1];\n      }\n\n      Cartesian3.clone(position, scratchWritePrevPosition);\n      Cartesian3.clone(positions[i], scratchWritePosition);\n\n      if (i === positionsLength - 1) {\n        if (polyline._loop) {\n          position = positions[1];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(\n            positions[positionsLength - 1],\n            positions[positionsLength - 2],\n            position,\n          );\n          Cartesian3.add(positions[positionsLength - 1], position, position);\n        }\n      } else {\n        position = positions[i + 1];\n      }\n\n      Cartesian3.clone(position, scratchWriteNextPosition);\n\n      const segmentLength = lengths[segmentIndex];\n      if (i === count + segmentLength) {\n        count += segmentLength;\n        ++segmentIndex;\n      }\n\n      const segmentStart = i - count === 0;\n      const segmentEnd = i === count + lengths[segmentIndex] - 1;\n\n      if (mode === SceneMode.SCENE2D) {\n        scratchWritePrevPosition.z = 0.0;\n        scratchWritePosition.z = 0.0;\n        scratchWriteNextPosition.z = 0.0;\n      }\n\n      if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n        if (\n          (segmentStart || segmentEnd) &&\n          maxLon - Math.abs(scratchWritePosition.x) < 1.0\n        ) {\n          if (\n            (scratchWritePosition.x < 0.0 &&\n              scratchWritePrevPosition.x > 0.0) ||\n            (scratchWritePosition.x > 0.0 && scratchWritePrevPosition.x < 0.0)\n          ) {\n            Cartesian3.clone(scratchWritePosition, scratchWritePrevPosition);\n          }\n\n          if (\n            (scratchWritePosition.x < 0.0 &&\n              scratchWriteNextPosition.x > 0.0) ||\n            (scratchWritePosition.x > 0.0 && scratchWriteNextPosition.x < 0.0)\n          ) {\n            Cartesian3.clone(scratchWritePosition, scratchWriteNextPosition);\n          }\n        }\n      }\n\n      const startJ = segmentStart ? 2 : 0;\n      const endJ = segmentEnd ? 2 : 4;\n\n      for (let j = startJ; j < endJ; ++j) {\n        EncodedCartesian3.writeElements(\n          scratchWritePosition,\n          positionArray,\n          positionIndex,\n        );\n        EncodedCartesian3.writeElements(\n          scratchWritePrevPosition,\n          positionArray,\n          positionIndex + 6,\n        );\n        EncodedCartesian3.writeElements(\n          scratchWriteNextPosition,\n          positionArray,\n          positionIndex + 12,\n        );\n        positionIndex += 6 * 3;\n      }\n    }\n\n    positionBuffer.copyFromArrayView(\n      positionArray,\n      6 * 3 * Float32Array.BYTES_PER_ELEMENT * index,\n    );\n  }\n};\nexport default PolylineCollection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}