{"ast":null,"code":"import binarySearch from \"../Core/binarySearch.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport ExtrapolationType from \"../Core/ExtrapolationType.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport LinearApproximation from \"../Core/LinearApproximation.js\";\nconst PackableNumber = {\n  packedLength: 1,\n  pack: function (value, array, startingIndex) {\n    startingIndex = defaultValue(startingIndex, 0);\n    array[startingIndex] = value;\n  },\n  unpack: function (array, startingIndex, result) {\n    startingIndex = defaultValue(startingIndex, 0);\n    return array[startingIndex];\n  }\n};\n\n//We can't use splice for inserting new elements because function apply can't handle\n//a huge number of arguments.  See https://code.google.com/p/chromium/issues/detail?id=56588\nfunction arrayInsert(array, startIndex, items) {\n  let i;\n  const arrayLength = array.length;\n  const itemsLength = items.length;\n  const newLength = arrayLength + itemsLength;\n  array.length = newLength;\n  if (arrayLength !== startIndex) {\n    let q = arrayLength - 1;\n    for (i = newLength - 1; i >= startIndex; i--) {\n      array[i] = array[q--];\n    }\n  }\n  for (i = 0; i < itemsLength; i++) {\n    array[startIndex++] = items[i];\n  }\n}\nfunction convertDate(date, epoch) {\n  if (date instanceof JulianDate) {\n    return date;\n  }\n  if (typeof date === \"string\") {\n    return JulianDate.fromIso8601(date);\n  }\n  return JulianDate.addSeconds(epoch, date, new JulianDate());\n}\nconst timesSpliceArgs = [];\nconst valuesSpliceArgs = [];\nfunction mergeNewSamples(epoch, times, values, newData, packedLength) {\n  let newDataIndex = 0;\n  let i;\n  let prevItem;\n  let timesInsertionPoint;\n  let valuesInsertionPoint;\n  let currentTime;\n  let nextTime;\n  while (newDataIndex < newData.length) {\n    currentTime = convertDate(newData[newDataIndex], epoch);\n    timesInsertionPoint = binarySearch(times, currentTime, JulianDate.compare);\n    let timesSpliceArgsCount = 0;\n    let valuesSpliceArgsCount = 0;\n    if (timesInsertionPoint < 0) {\n      //Doesn't exist, insert as many additional values as we can.\n      timesInsertionPoint = ~timesInsertionPoint;\n      valuesInsertionPoint = timesInsertionPoint * packedLength;\n      prevItem = undefined;\n      nextTime = times[timesInsertionPoint];\n      while (newDataIndex < newData.length) {\n        currentTime = convertDate(newData[newDataIndex], epoch);\n        if (defined(prevItem) && JulianDate.compare(prevItem, currentTime) >= 0 || defined(nextTime) && JulianDate.compare(currentTime, nextTime) >= 0) {\n          break;\n        }\n        timesSpliceArgs[timesSpliceArgsCount++] = currentTime;\n        newDataIndex = newDataIndex + 1;\n        for (i = 0; i < packedLength; i++) {\n          valuesSpliceArgs[valuesSpliceArgsCount++] = newData[newDataIndex];\n          newDataIndex = newDataIndex + 1;\n        }\n        prevItem = currentTime;\n      }\n      if (timesSpliceArgsCount > 0) {\n        valuesSpliceArgs.length = valuesSpliceArgsCount;\n        arrayInsert(values, valuesInsertionPoint, valuesSpliceArgs);\n        timesSpliceArgs.length = timesSpliceArgsCount;\n        arrayInsert(times, timesInsertionPoint, timesSpliceArgs);\n      }\n    } else {\n      //Found an exact match\n      for (i = 0; i < packedLength; i++) {\n        newDataIndex++;\n        values[timesInsertionPoint * packedLength + i] = newData[newDataIndex];\n      }\n      newDataIndex++;\n    }\n  }\n}\n\n/**\n * A {@link Property} whose value is interpolated for a given time from the\n * provided set of samples and specified interpolation algorithm and degree.\n * @alias SampledProperty\n * @constructor\n *\n * @param {number|Packable} type The type of property.\n * @param {Packable[]} [derivativeTypes] When supplied, indicates that samples will contain derivative information of the specified types.\n *\n *\n * @example\n * //Create a linearly interpolated Cartesian2\n * const property = new Cesium.SampledProperty(Cesium.Cartesian2);\n *\n * //Populate it with data\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:00.00Z'), new Cesium.Cartesian2(0, 0));\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-02T00:00:00.00Z'), new Cesium.Cartesian2(4, 7));\n *\n * //Retrieve an interpolated value\n * const result = property.getValue(Cesium.JulianDate.fromIso8601('2012-08-01T12:00:00.00Z'));\n *\n * @example\n * //Create a simple numeric SampledProperty that uses third degree Hermite Polynomial Approximation\n * const property = new Cesium.SampledProperty(Number);\n * property.setInterpolationOptions({\n *     interpolationDegree : 3,\n *     interpolationAlgorithm : Cesium.HermitePolynomialApproximation\n * });\n *\n * //Populate it with data\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:00.00Z'), 1.0);\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:01:00.00Z'), 6.0);\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:02:00.00Z'), 12.0);\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:03:30.00Z'), 5.0);\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:06:30.00Z'), 2.0);\n *\n * //Samples can be added in any order.\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:30.00Z'), 6.2);\n *\n * //Retrieve an interpolated value\n * const result = property.getValue(Cesium.JulianDate.fromIso8601('2012-08-01T00:02:34.00Z'));\n *\n * @see SampledPositionProperty\n */\nfunction SampledProperty(type, derivativeTypes) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"type\", type);\n  //>>includeEnd('debug');\n\n  let innerType = type;\n  if (innerType === Number) {\n    innerType = PackableNumber;\n  }\n  let packedLength = innerType.packedLength;\n  let packedInterpolationLength = defaultValue(innerType.packedInterpolationLength, packedLength);\n  let inputOrder = 0;\n  let innerDerivativeTypes;\n  if (defined(derivativeTypes)) {\n    const length = derivativeTypes.length;\n    innerDerivativeTypes = new Array(length);\n    for (let i = 0; i < length; i++) {\n      let derivativeType = derivativeTypes[i];\n      if (derivativeType === Number) {\n        derivativeType = PackableNumber;\n      }\n      const derivativePackedLength = derivativeType.packedLength;\n      packedLength += derivativePackedLength;\n      packedInterpolationLength += defaultValue(derivativeType.packedInterpolationLength, derivativePackedLength);\n      innerDerivativeTypes[i] = derivativeType;\n    }\n    inputOrder = length;\n  }\n  this._type = type;\n  this._innerType = innerType;\n  this._interpolationDegree = 1;\n  this._interpolationAlgorithm = LinearApproximation;\n  this._numberOfPoints = 0;\n  this._times = [];\n  this._values = [];\n  this._xTable = [];\n  this._yTable = [];\n  this._packedLength = packedLength;\n  this._packedInterpolationLength = packedInterpolationLength;\n  this._updateTableLength = true;\n  this._interpolationResult = new Array(packedInterpolationLength);\n  this._definitionChanged = new Event();\n  this._derivativeTypes = derivativeTypes;\n  this._innerDerivativeTypes = innerDerivativeTypes;\n  this._inputOrder = inputOrder;\n  this._forwardExtrapolationType = ExtrapolationType.NONE;\n  this._forwardExtrapolationDuration = 0;\n  this._backwardExtrapolationType = ExtrapolationType.NONE;\n  this._backwardExtrapolationDuration = 0;\n}\nObject.defineProperties(SampledProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.  A property is considered\n   * constant if getValue always returns the same result for the current definition.\n   * @memberof SampledProperty.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return this._values.length === 0;\n    }\n  },\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * The definition is considered to have changed if a call to getValue would return\n   * a different result for the same time.\n   * @memberof SampledProperty.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    }\n  },\n  /**\n   * Gets the type of property.\n   * @memberof SampledProperty.prototype\n   * @type {*}\n   */\n  type: {\n    get: function () {\n      return this._type;\n    }\n  },\n  /**\n   * Gets the derivative types used by this property.\n   * @memberof SampledProperty.prototype\n   * @type {Packable[]}\n   */\n  derivativeTypes: {\n    get: function () {\n      return this._derivativeTypes;\n    }\n  },\n  /**\n   * Gets the degree of interpolation to perform when retrieving a value.\n   * @memberof SampledProperty.prototype\n   * @type {number}\n   * @default 1\n   */\n  interpolationDegree: {\n    get: function () {\n      return this._interpolationDegree;\n    }\n  },\n  /**\n   * Gets the interpolation algorithm to use when retrieving a value.\n   * @memberof SampledProperty.prototype\n   * @type {InterpolationAlgorithm}\n   * @default LinearApproximation\n   */\n  interpolationAlgorithm: {\n    get: function () {\n      return this._interpolationAlgorithm;\n    }\n  },\n  /**\n   * Gets or sets the type of extrapolation to perform when a value\n   * is requested at a time after any available samples.\n   * @memberof SampledProperty.prototype\n   * @type {ExtrapolationType}\n   * @default ExtrapolationType.NONE\n   */\n  forwardExtrapolationType: {\n    get: function () {\n      return this._forwardExtrapolationType;\n    },\n    set: function (value) {\n      if (this._forwardExtrapolationType !== value) {\n        this._forwardExtrapolationType = value;\n        this._definitionChanged.raiseEvent(this);\n      }\n    }\n  },\n  /**\n   * Gets or sets the amount of time to extrapolate forward before\n   * the property becomes undefined.  A value of 0 will extrapolate forever.\n   * @memberof SampledProperty.prototype\n   * @type {number}\n   * @default 0\n   */\n  forwardExtrapolationDuration: {\n    get: function () {\n      return this._forwardExtrapolationDuration;\n    },\n    set: function (value) {\n      if (this._forwardExtrapolationDuration !== value) {\n        this._forwardExtrapolationDuration = value;\n        this._definitionChanged.raiseEvent(this);\n      }\n    }\n  },\n  /**\n   * Gets or sets the type of extrapolation to perform when a value\n   * is requested at a time before any available samples.\n   * @memberof SampledProperty.prototype\n   * @type {ExtrapolationType}\n   * @default ExtrapolationType.NONE\n   */\n  backwardExtrapolationType: {\n    get: function () {\n      return this._backwardExtrapolationType;\n    },\n    set: function (value) {\n      if (this._backwardExtrapolationType !== value) {\n        this._backwardExtrapolationType = value;\n        this._definitionChanged.raiseEvent(this);\n      }\n    }\n  },\n  /**\n   * Gets or sets the amount of time to extrapolate backward\n   * before the property becomes undefined.  A value of 0 will extrapolate forever.\n   * @memberof SampledProperty.prototype\n   * @type {number}\n   * @default 0\n   */\n  backwardExtrapolationDuration: {\n    get: function () {\n      return this._backwardExtrapolationDuration;\n    },\n    set: function (value) {\n      if (this._backwardExtrapolationDuration !== value) {\n        this._backwardExtrapolationDuration = value;\n        this._definitionChanged.raiseEvent(this);\n      }\n    }\n  }\n});\nconst timeScratch = new JulianDate();\n\n/**\n * Gets the value of the property at the provided time.\n *\n * @param {JulianDate} [time=JulianDate.now()] The time for which to retrieve the value. If omitted, the current system time is used.\n * @param {object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {object} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nSampledProperty.prototype.getValue = function (time, result) {\n  if (!defined(time)) {\n    time = JulianDate.now(timeScratch);\n  }\n  const times = this._times;\n  const timesLength = times.length;\n  if (timesLength === 0) {\n    return undefined;\n  }\n  let timeout;\n  const innerType = this._innerType;\n  const values = this._values;\n  let index = binarySearch(times, time, JulianDate.compare);\n  if (index < 0) {\n    index = ~index;\n    if (index === 0) {\n      const startTime = times[index];\n      timeout = this._backwardExtrapolationDuration;\n      if (this._backwardExtrapolationType === ExtrapolationType.NONE || timeout !== 0 && JulianDate.secondsDifference(startTime, time) > timeout) {\n        return undefined;\n      }\n      if (this._backwardExtrapolationType === ExtrapolationType.HOLD) {\n        return innerType.unpack(values, 0, result);\n      }\n    }\n    if (index >= timesLength) {\n      index = timesLength - 1;\n      const endTime = times[index];\n      timeout = this._forwardExtrapolationDuration;\n      if (this._forwardExtrapolationType === ExtrapolationType.NONE || timeout !== 0 && JulianDate.secondsDifference(time, endTime) > timeout) {\n        return undefined;\n      }\n      if (this._forwardExtrapolationType === ExtrapolationType.HOLD) {\n        index = timesLength - 1;\n        return innerType.unpack(values, index * innerType.packedLength, result);\n      }\n    }\n    const xTable = this._xTable;\n    const yTable = this._yTable;\n    const interpolationAlgorithm = this._interpolationAlgorithm;\n    const packedInterpolationLength = this._packedInterpolationLength;\n    const inputOrder = this._inputOrder;\n    if (this._updateTableLength) {\n      this._updateTableLength = false;\n      const numberOfPoints = Math.min(interpolationAlgorithm.getRequiredDataPoints(this._interpolationDegree, inputOrder), timesLength);\n      if (numberOfPoints !== this._numberOfPoints) {\n        this._numberOfPoints = numberOfPoints;\n        xTable.length = numberOfPoints;\n        yTable.length = numberOfPoints * packedInterpolationLength;\n      }\n    }\n    const degree = this._numberOfPoints - 1;\n    if (degree < 1) {\n      return undefined;\n    }\n    let firstIndex = 0;\n    let lastIndex = timesLength - 1;\n    const pointsInCollection = lastIndex - firstIndex + 1;\n    if (pointsInCollection >= degree + 1) {\n      let computedFirstIndex = index - (degree / 2 | 0) - 1;\n      if (computedFirstIndex < firstIndex) {\n        computedFirstIndex = firstIndex;\n      }\n      let computedLastIndex = computedFirstIndex + degree;\n      if (computedLastIndex > lastIndex) {\n        computedLastIndex = lastIndex;\n        computedFirstIndex = computedLastIndex - degree;\n        if (computedFirstIndex < firstIndex) {\n          computedFirstIndex = firstIndex;\n        }\n      }\n      firstIndex = computedFirstIndex;\n      lastIndex = computedLastIndex;\n    }\n    const length = lastIndex - firstIndex + 1;\n\n    // Build the tables\n    for (let i = 0; i < length; ++i) {\n      xTable[i] = JulianDate.secondsDifference(times[firstIndex + i], times[lastIndex]);\n    }\n    if (!defined(innerType.convertPackedArrayForInterpolation)) {\n      let destinationIndex = 0;\n      const packedLength = this._packedLength;\n      let sourceIndex = firstIndex * packedLength;\n      const stop = (lastIndex + 1) * packedLength;\n      while (sourceIndex < stop) {\n        yTable[destinationIndex] = values[sourceIndex];\n        sourceIndex++;\n        destinationIndex++;\n      }\n    } else {\n      innerType.convertPackedArrayForInterpolation(values, firstIndex, lastIndex, yTable);\n    }\n\n    // Interpolate!\n    const x = JulianDate.secondsDifference(time, times[lastIndex]);\n    let interpolationResult;\n    if (inputOrder === 0 || !defined(interpolationAlgorithm.interpolate)) {\n      interpolationResult = interpolationAlgorithm.interpolateOrderZero(x, xTable, yTable, packedInterpolationLength, this._interpolationResult);\n    } else {\n      const yStride = Math.floor(packedInterpolationLength / (inputOrder + 1));\n      interpolationResult = interpolationAlgorithm.interpolate(x, xTable, yTable, yStride, inputOrder, inputOrder, this._interpolationResult);\n    }\n    if (!defined(innerType.unpackInterpolationResult)) {\n      return innerType.unpack(interpolationResult, 0, result);\n    }\n    return innerType.unpackInterpolationResult(interpolationResult, values, firstIndex, lastIndex, result);\n  }\n  return innerType.unpack(values, index * this._packedLength, result);\n};\n\n/**\n * Sets the algorithm and degree to use when interpolating a value.\n *\n * @param {object} [options] Object with the following properties:\n * @param {InterpolationAlgorithm} [options.interpolationAlgorithm] The new interpolation algorithm.  If undefined, the existing property will be unchanged.\n * @param {number} [options.interpolationDegree] The new interpolation degree.  If undefined, the existing property will be unchanged.\n */\nSampledProperty.prototype.setInterpolationOptions = function (options) {\n  if (!defined(options)) {\n    return;\n  }\n  let valuesChanged = false;\n  const interpolationAlgorithm = options.interpolationAlgorithm;\n  const interpolationDegree = options.interpolationDegree;\n  if (defined(interpolationAlgorithm) && this._interpolationAlgorithm !== interpolationAlgorithm) {\n    this._interpolationAlgorithm = interpolationAlgorithm;\n    valuesChanged = true;\n  }\n  if (defined(interpolationDegree) && this._interpolationDegree !== interpolationDegree) {\n    this._interpolationDegree = interpolationDegree;\n    valuesChanged = true;\n  }\n  if (valuesChanged) {\n    this._updateTableLength = true;\n    this._definitionChanged.raiseEvent(this);\n  }\n};\n\n/**\n * Adds a new sample.\n *\n * @param {JulianDate} time The sample time.\n * @param {Packable} value The value at the provided time.\n * @param {Packable[]} [derivatives] The array of derivatives at the provided time.\n */\nSampledProperty.prototype.addSample = function (time, value, derivatives) {\n  const innerDerivativeTypes = this._innerDerivativeTypes;\n  const hasDerivatives = defined(innerDerivativeTypes);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  Check.defined(\"value\", value);\n  if (hasDerivatives) {\n    Check.defined(\"derivatives\", derivatives);\n  }\n  //>>includeEnd('debug');\n\n  const innerType = this._innerType;\n  const data = [];\n  data.push(time);\n  innerType.pack(value, data, data.length);\n  if (hasDerivatives) {\n    const derivativesLength = innerDerivativeTypes.length;\n    for (let x = 0; x < derivativesLength; x++) {\n      innerDerivativeTypes[x].pack(derivatives[x], data, data.length);\n    }\n  }\n  mergeNewSamples(undefined, this._times, this._values, data, this._packedLength);\n  this._updateTableLength = true;\n  this._definitionChanged.raiseEvent(this);\n};\n\n/**\n * Adds an array of samples.\n *\n * @param {JulianDate[]} times An array of JulianDate instances where each index is a sample time.\n * @param {Packable[]} values The array of values, where each value corresponds to the provided times index.\n * @param {Array[]} [derivativeValues] An array where each item is the array of derivatives at the equivalent time index.\n *\n * @exception {DeveloperError} times and values must be the same length.\n * @exception {DeveloperError} times and derivativeValues must be the same length.\n */\nSampledProperty.prototype.addSamples = function (times, values, derivativeValues) {\n  const innerDerivativeTypes = this._innerDerivativeTypes;\n  const hasDerivatives = defined(innerDerivativeTypes);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"times\", times);\n  Check.defined(\"values\", values);\n  if (times.length !== values.length) {\n    throw new DeveloperError(\"times and values must be the same length.\");\n  }\n  if (hasDerivatives && (!defined(derivativeValues) || derivativeValues.length !== times.length)) {\n    throw new DeveloperError(\"times and derivativeValues must be the same length.\");\n  }\n  //>>includeEnd('debug');\n\n  const innerType = this._innerType;\n  const length = times.length;\n  const data = [];\n  for (let i = 0; i < length; i++) {\n    data.push(times[i]);\n    innerType.pack(values[i], data, data.length);\n    if (hasDerivatives) {\n      const derivatives = derivativeValues[i];\n      const derivativesLength = innerDerivativeTypes.length;\n      for (let x = 0; x < derivativesLength; x++) {\n        innerDerivativeTypes[x].pack(derivatives[x], data, data.length);\n      }\n    }\n  }\n  mergeNewSamples(undefined, this._times, this._values, data, this._packedLength);\n  this._updateTableLength = true;\n  this._definitionChanged.raiseEvent(this);\n};\n\n/**\n * Retrieves the time of the provided sample associated with the index. A negative index accesses the list of samples in reverse order.\n *\n * @param {number} index The index of samples list.\n * @returns {JulianDate | undefined} The JulianDate time of the sample, or undefined if failed.\n */\nSampledProperty.prototype.getSample = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  const times = this._times;\n  const len = times.length;\n  if (!defined(len)) {\n    return undefined;\n  }\n  if (index < 0) {\n    index += len;\n  }\n  return times[index];\n};\n\n/**\n * Adds samples as a single packed array where each new sample is represented as a date,\n * followed by the packed representation of the corresponding value and derivatives.\n *\n * @param {number[]} packedSamples The array of packed samples.\n * @param {JulianDate} [epoch] If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.\n */\nSampledProperty.prototype.addSamplesPackedArray = function (packedSamples, epoch) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"packedSamples\", packedSamples);\n  //>>includeEnd('debug');\n\n  mergeNewSamples(epoch, this._times, this._values, packedSamples, this._packedLength);\n  this._updateTableLength = true;\n  this._definitionChanged.raiseEvent(this);\n};\n\n/**\n * Removes a sample at the given time, if present.\n *\n * @param {JulianDate} time The sample time.\n * @returns {boolean} <code>true</code> if a sample at time was removed, <code>false</code> otherwise.\n */\nSampledProperty.prototype.removeSample = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  const index = binarySearch(this._times, time, JulianDate.compare);\n  if (index < 0) {\n    return false;\n  }\n  removeSamples(this, index, 1);\n  return true;\n};\nfunction removeSamples(property, startIndex, numberToRemove) {\n  const packedLength = property._packedLength;\n  property._times.splice(startIndex, numberToRemove);\n  property._values.splice(startIndex * packedLength, numberToRemove * packedLength);\n  property._updateTableLength = true;\n  property._definitionChanged.raiseEvent(property);\n}\n\n/**\n * Removes all samples for the given time interval.\n *\n * @param {TimeInterval} time The time interval for which to remove all samples.\n */\nSampledProperty.prototype.removeSamples = function (timeInterval) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"timeInterval\", timeInterval);\n  //>>includeEnd('debug');\n\n  const times = this._times;\n  let startIndex = binarySearch(times, timeInterval.start, JulianDate.compare);\n  if (startIndex < 0) {\n    startIndex = ~startIndex;\n  } else if (!timeInterval.isStartIncluded) {\n    ++startIndex;\n  }\n  let stopIndex = binarySearch(times, timeInterval.stop, JulianDate.compare);\n  if (stopIndex < 0) {\n    stopIndex = ~stopIndex;\n  } else if (timeInterval.isStopIncluded) {\n    ++stopIndex;\n  }\n  removeSamples(this, startIndex, stopIndex - startIndex);\n};\n\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nSampledProperty.prototype.equals = function (other) {\n  if (this === other) {\n    return true;\n  }\n  if (!defined(other)) {\n    return false;\n  }\n  if (this._type !== other._type ||\n  //\n  this._interpolationDegree !== other._interpolationDegree ||\n  //\n  this._interpolationAlgorithm !== other._interpolationAlgorithm) {\n    return false;\n  }\n  const derivativeTypes = this._derivativeTypes;\n  const hasDerivatives = defined(derivativeTypes);\n  const otherDerivativeTypes = other._derivativeTypes;\n  const otherHasDerivatives = defined(otherDerivativeTypes);\n  if (hasDerivatives !== otherHasDerivatives) {\n    return false;\n  }\n  let i;\n  let length;\n  if (hasDerivatives) {\n    length = derivativeTypes.length;\n    if (length !== otherDerivativeTypes.length) {\n      return false;\n    }\n    for (i = 0; i < length; i++) {\n      if (derivativeTypes[i] !== otherDerivativeTypes[i]) {\n        return false;\n      }\n    }\n  }\n  const times = this._times;\n  const otherTimes = other._times;\n  length = times.length;\n  if (length !== otherTimes.length) {\n    return false;\n  }\n  for (i = 0; i < length; i++) {\n    if (!JulianDate.equals(times[i], otherTimes[i])) {\n      return false;\n    }\n  }\n  const values = this._values;\n  const otherValues = other._values;\n  length = values.length;\n\n  //Since time lengths are equal, values length and other length are guaranteed to be equal.\n  for (i = 0; i < length; i++) {\n    if (values[i] !== otherValues[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n//Exposed for testing.\nSampledProperty._mergeNewSamples = mergeNewSamples;\nexport default SampledProperty;","map":{"version":3,"names":["binarySearch","Check","defaultValue","defined","DeveloperError","Event","ExtrapolationType","JulianDate","LinearApproximation","PackableNumber","packedLength","pack","value","array","startingIndex","unpack","result","arrayInsert","startIndex","items","i","arrayLength","length","itemsLength","newLength","q","convertDate","date","epoch","fromIso8601","addSeconds","timesSpliceArgs","valuesSpliceArgs","mergeNewSamples","times","values","newData","newDataIndex","prevItem","timesInsertionPoint","valuesInsertionPoint","currentTime","nextTime","compare","timesSpliceArgsCount","valuesSpliceArgsCount","undefined","SampledProperty","type","derivativeTypes","innerType","Number","packedInterpolationLength","inputOrder","innerDerivativeTypes","Array","derivativeType","derivativePackedLength","_type","_innerType","_interpolationDegree","_interpolationAlgorithm","_numberOfPoints","_times","_values","_xTable","_yTable","_packedLength","_packedInterpolationLength","_updateTableLength","_interpolationResult","_definitionChanged","_derivativeTypes","_innerDerivativeTypes","_inputOrder","_forwardExtrapolationType","NONE","_forwardExtrapolationDuration","_backwardExtrapolationType","_backwardExtrapolationDuration","Object","defineProperties","prototype","isConstant","get","definitionChanged","interpolationDegree","interpolationAlgorithm","forwardExtrapolationType","set","raiseEvent","forwardExtrapolationDuration","backwardExtrapolationType","backwardExtrapolationDuration","timeScratch","getValue","time","now","timesLength","timeout","index","startTime","secondsDifference","HOLD","endTime","xTable","yTable","numberOfPoints","Math","min","getRequiredDataPoints","degree","firstIndex","lastIndex","pointsInCollection","computedFirstIndex","computedLastIndex","convertPackedArrayForInterpolation","destinationIndex","sourceIndex","stop","x","interpolationResult","interpolate","interpolateOrderZero","yStride","floor","unpackInterpolationResult","setInterpolationOptions","options","valuesChanged","addSample","derivatives","hasDerivatives","data","push","derivativesLength","addSamples","derivativeValues","getSample","typeOf","number","len","addSamplesPackedArray","packedSamples","removeSample","removeSamples","property","numberToRemove","splice","timeInterval","start","isStartIncluded","stopIndex","isStopIncluded","equals","other","otherDerivativeTypes","otherHasDerivatives","otherTimes","otherValues","_mergeNewSamples"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/SampledProperty.js"],"sourcesContent":["import binarySearch from \"../Core/binarySearch.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport ExtrapolationType from \"../Core/ExtrapolationType.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport LinearApproximation from \"../Core/LinearApproximation.js\";\n\nconst PackableNumber = {\n  packedLength: 1,\n  pack: function (value, array, startingIndex) {\n    startingIndex = defaultValue(startingIndex, 0);\n    array[startingIndex] = value;\n  },\n  unpack: function (array, startingIndex, result) {\n    startingIndex = defaultValue(startingIndex, 0);\n    return array[startingIndex];\n  },\n};\n\n//We can't use splice for inserting new elements because function apply can't handle\n//a huge number of arguments.  See https://code.google.com/p/chromium/issues/detail?id=56588\nfunction arrayInsert(array, startIndex, items) {\n  let i;\n  const arrayLength = array.length;\n  const itemsLength = items.length;\n  const newLength = arrayLength + itemsLength;\n\n  array.length = newLength;\n  if (arrayLength !== startIndex) {\n    let q = arrayLength - 1;\n    for (i = newLength - 1; i >= startIndex; i--) {\n      array[i] = array[q--];\n    }\n  }\n\n  for (i = 0; i < itemsLength; i++) {\n    array[startIndex++] = items[i];\n  }\n}\n\nfunction convertDate(date, epoch) {\n  if (date instanceof JulianDate) {\n    return date;\n  }\n  if (typeof date === \"string\") {\n    return JulianDate.fromIso8601(date);\n  }\n  return JulianDate.addSeconds(epoch, date, new JulianDate());\n}\n\nconst timesSpliceArgs = [];\nconst valuesSpliceArgs = [];\n\nfunction mergeNewSamples(epoch, times, values, newData, packedLength) {\n  let newDataIndex = 0;\n  let i;\n  let prevItem;\n  let timesInsertionPoint;\n  let valuesInsertionPoint;\n  let currentTime;\n  let nextTime;\n\n  while (newDataIndex < newData.length) {\n    currentTime = convertDate(newData[newDataIndex], epoch);\n    timesInsertionPoint = binarySearch(times, currentTime, JulianDate.compare);\n    let timesSpliceArgsCount = 0;\n    let valuesSpliceArgsCount = 0;\n\n    if (timesInsertionPoint < 0) {\n      //Doesn't exist, insert as many additional values as we can.\n      timesInsertionPoint = ~timesInsertionPoint;\n\n      valuesInsertionPoint = timesInsertionPoint * packedLength;\n      prevItem = undefined;\n      nextTime = times[timesInsertionPoint];\n      while (newDataIndex < newData.length) {\n        currentTime = convertDate(newData[newDataIndex], epoch);\n        if (\n          (defined(prevItem) &&\n            JulianDate.compare(prevItem, currentTime) >= 0) ||\n          (defined(nextTime) && JulianDate.compare(currentTime, nextTime) >= 0)\n        ) {\n          break;\n        }\n        timesSpliceArgs[timesSpliceArgsCount++] = currentTime;\n        newDataIndex = newDataIndex + 1;\n        for (i = 0; i < packedLength; i++) {\n          valuesSpliceArgs[valuesSpliceArgsCount++] = newData[newDataIndex];\n          newDataIndex = newDataIndex + 1;\n        }\n        prevItem = currentTime;\n      }\n\n      if (timesSpliceArgsCount > 0) {\n        valuesSpliceArgs.length = valuesSpliceArgsCount;\n        arrayInsert(values, valuesInsertionPoint, valuesSpliceArgs);\n\n        timesSpliceArgs.length = timesSpliceArgsCount;\n        arrayInsert(times, timesInsertionPoint, timesSpliceArgs);\n      }\n    } else {\n      //Found an exact match\n      for (i = 0; i < packedLength; i++) {\n        newDataIndex++;\n        values[timesInsertionPoint * packedLength + i] = newData[newDataIndex];\n      }\n      newDataIndex++;\n    }\n  }\n}\n\n/**\n * A {@link Property} whose value is interpolated for a given time from the\n * provided set of samples and specified interpolation algorithm and degree.\n * @alias SampledProperty\n * @constructor\n *\n * @param {number|Packable} type The type of property.\n * @param {Packable[]} [derivativeTypes] When supplied, indicates that samples will contain derivative information of the specified types.\n *\n *\n * @example\n * //Create a linearly interpolated Cartesian2\n * const property = new Cesium.SampledProperty(Cesium.Cartesian2);\n *\n * //Populate it with data\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:00.00Z'), new Cesium.Cartesian2(0, 0));\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-02T00:00:00.00Z'), new Cesium.Cartesian2(4, 7));\n *\n * //Retrieve an interpolated value\n * const result = property.getValue(Cesium.JulianDate.fromIso8601('2012-08-01T12:00:00.00Z'));\n *\n * @example\n * //Create a simple numeric SampledProperty that uses third degree Hermite Polynomial Approximation\n * const property = new Cesium.SampledProperty(Number);\n * property.setInterpolationOptions({\n *     interpolationDegree : 3,\n *     interpolationAlgorithm : Cesium.HermitePolynomialApproximation\n * });\n *\n * //Populate it with data\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:00.00Z'), 1.0);\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:01:00.00Z'), 6.0);\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:02:00.00Z'), 12.0);\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:03:30.00Z'), 5.0);\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:06:30.00Z'), 2.0);\n *\n * //Samples can be added in any order.\n * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:30.00Z'), 6.2);\n *\n * //Retrieve an interpolated value\n * const result = property.getValue(Cesium.JulianDate.fromIso8601('2012-08-01T00:02:34.00Z'));\n *\n * @see SampledPositionProperty\n */\nfunction SampledProperty(type, derivativeTypes) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"type\", type);\n  //>>includeEnd('debug');\n\n  let innerType = type;\n  if (innerType === Number) {\n    innerType = PackableNumber;\n  }\n  let packedLength = innerType.packedLength;\n  let packedInterpolationLength = defaultValue(\n    innerType.packedInterpolationLength,\n    packedLength,\n  );\n\n  let inputOrder = 0;\n  let innerDerivativeTypes;\n  if (defined(derivativeTypes)) {\n    const length = derivativeTypes.length;\n    innerDerivativeTypes = new Array(length);\n    for (let i = 0; i < length; i++) {\n      let derivativeType = derivativeTypes[i];\n      if (derivativeType === Number) {\n        derivativeType = PackableNumber;\n      }\n      const derivativePackedLength = derivativeType.packedLength;\n      packedLength += derivativePackedLength;\n      packedInterpolationLength += defaultValue(\n        derivativeType.packedInterpolationLength,\n        derivativePackedLength,\n      );\n      innerDerivativeTypes[i] = derivativeType;\n    }\n    inputOrder = length;\n  }\n\n  this._type = type;\n  this._innerType = innerType;\n  this._interpolationDegree = 1;\n  this._interpolationAlgorithm = LinearApproximation;\n  this._numberOfPoints = 0;\n  this._times = [];\n  this._values = [];\n  this._xTable = [];\n  this._yTable = [];\n  this._packedLength = packedLength;\n  this._packedInterpolationLength = packedInterpolationLength;\n  this._updateTableLength = true;\n  this._interpolationResult = new Array(packedInterpolationLength);\n  this._definitionChanged = new Event();\n  this._derivativeTypes = derivativeTypes;\n  this._innerDerivativeTypes = innerDerivativeTypes;\n  this._inputOrder = inputOrder;\n  this._forwardExtrapolationType = ExtrapolationType.NONE;\n  this._forwardExtrapolationDuration = 0;\n  this._backwardExtrapolationType = ExtrapolationType.NONE;\n  this._backwardExtrapolationDuration = 0;\n}\n\nObject.defineProperties(SampledProperty.prototype, {\n  /**\n   * Gets a value indicating if this property is constant.  A property is considered\n   * constant if getValue always returns the same result for the current definition.\n   * @memberof SampledProperty.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  isConstant: {\n    get: function () {\n      return this._values.length === 0;\n    },\n  },\n  /**\n   * Gets the event that is raised whenever the definition of this property changes.\n   * The definition is considered to have changed if a call to getValue would return\n   * a different result for the same time.\n   * @memberof SampledProperty.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  definitionChanged: {\n    get: function () {\n      return this._definitionChanged;\n    },\n  },\n  /**\n   * Gets the type of property.\n   * @memberof SampledProperty.prototype\n   * @type {*}\n   */\n  type: {\n    get: function () {\n      return this._type;\n    },\n  },\n  /**\n   * Gets the derivative types used by this property.\n   * @memberof SampledProperty.prototype\n   * @type {Packable[]}\n   */\n  derivativeTypes: {\n    get: function () {\n      return this._derivativeTypes;\n    },\n  },\n  /**\n   * Gets the degree of interpolation to perform when retrieving a value.\n   * @memberof SampledProperty.prototype\n   * @type {number}\n   * @default 1\n   */\n  interpolationDegree: {\n    get: function () {\n      return this._interpolationDegree;\n    },\n  },\n  /**\n   * Gets the interpolation algorithm to use when retrieving a value.\n   * @memberof SampledProperty.prototype\n   * @type {InterpolationAlgorithm}\n   * @default LinearApproximation\n   */\n  interpolationAlgorithm: {\n    get: function () {\n      return this._interpolationAlgorithm;\n    },\n  },\n  /**\n   * Gets or sets the type of extrapolation to perform when a value\n   * is requested at a time after any available samples.\n   * @memberof SampledProperty.prototype\n   * @type {ExtrapolationType}\n   * @default ExtrapolationType.NONE\n   */\n  forwardExtrapolationType: {\n    get: function () {\n      return this._forwardExtrapolationType;\n    },\n    set: function (value) {\n      if (this._forwardExtrapolationType !== value) {\n        this._forwardExtrapolationType = value;\n        this._definitionChanged.raiseEvent(this);\n      }\n    },\n  },\n  /**\n   * Gets or sets the amount of time to extrapolate forward before\n   * the property becomes undefined.  A value of 0 will extrapolate forever.\n   * @memberof SampledProperty.prototype\n   * @type {number}\n   * @default 0\n   */\n  forwardExtrapolationDuration: {\n    get: function () {\n      return this._forwardExtrapolationDuration;\n    },\n    set: function (value) {\n      if (this._forwardExtrapolationDuration !== value) {\n        this._forwardExtrapolationDuration = value;\n        this._definitionChanged.raiseEvent(this);\n      }\n    },\n  },\n  /**\n   * Gets or sets the type of extrapolation to perform when a value\n   * is requested at a time before any available samples.\n   * @memberof SampledProperty.prototype\n   * @type {ExtrapolationType}\n   * @default ExtrapolationType.NONE\n   */\n  backwardExtrapolationType: {\n    get: function () {\n      return this._backwardExtrapolationType;\n    },\n    set: function (value) {\n      if (this._backwardExtrapolationType !== value) {\n        this._backwardExtrapolationType = value;\n        this._definitionChanged.raiseEvent(this);\n      }\n    },\n  },\n  /**\n   * Gets or sets the amount of time to extrapolate backward\n   * before the property becomes undefined.  A value of 0 will extrapolate forever.\n   * @memberof SampledProperty.prototype\n   * @type {number}\n   * @default 0\n   */\n  backwardExtrapolationDuration: {\n    get: function () {\n      return this._backwardExtrapolationDuration;\n    },\n    set: function (value) {\n      if (this._backwardExtrapolationDuration !== value) {\n        this._backwardExtrapolationDuration = value;\n        this._definitionChanged.raiseEvent(this);\n      }\n    },\n  },\n});\n\nconst timeScratch = new JulianDate();\n\n/**\n * Gets the value of the property at the provided time.\n *\n * @param {JulianDate} [time=JulianDate.now()] The time for which to retrieve the value. If omitted, the current system time is used.\n * @param {object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n * @returns {object} The modified result parameter or a new instance if the result parameter was not supplied.\n */\nSampledProperty.prototype.getValue = function (time, result) {\n  if (!defined(time)) {\n    time = JulianDate.now(timeScratch);\n  }\n\n  const times = this._times;\n  const timesLength = times.length;\n  if (timesLength === 0) {\n    return undefined;\n  }\n\n  let timeout;\n  const innerType = this._innerType;\n  const values = this._values;\n  let index = binarySearch(times, time, JulianDate.compare);\n\n  if (index < 0) {\n    index = ~index;\n\n    if (index === 0) {\n      const startTime = times[index];\n      timeout = this._backwardExtrapolationDuration;\n      if (\n        this._backwardExtrapolationType === ExtrapolationType.NONE ||\n        (timeout !== 0 &&\n          JulianDate.secondsDifference(startTime, time) > timeout)\n      ) {\n        return undefined;\n      }\n      if (this._backwardExtrapolationType === ExtrapolationType.HOLD) {\n        return innerType.unpack(values, 0, result);\n      }\n    }\n\n    if (index >= timesLength) {\n      index = timesLength - 1;\n      const endTime = times[index];\n      timeout = this._forwardExtrapolationDuration;\n      if (\n        this._forwardExtrapolationType === ExtrapolationType.NONE ||\n        (timeout !== 0 && JulianDate.secondsDifference(time, endTime) > timeout)\n      ) {\n        return undefined;\n      }\n      if (this._forwardExtrapolationType === ExtrapolationType.HOLD) {\n        index = timesLength - 1;\n        return innerType.unpack(values, index * innerType.packedLength, result);\n      }\n    }\n\n    const xTable = this._xTable;\n    const yTable = this._yTable;\n    const interpolationAlgorithm = this._interpolationAlgorithm;\n    const packedInterpolationLength = this._packedInterpolationLength;\n    const inputOrder = this._inputOrder;\n\n    if (this._updateTableLength) {\n      this._updateTableLength = false;\n      const numberOfPoints = Math.min(\n        interpolationAlgorithm.getRequiredDataPoints(\n          this._interpolationDegree,\n          inputOrder,\n        ),\n        timesLength,\n      );\n      if (numberOfPoints !== this._numberOfPoints) {\n        this._numberOfPoints = numberOfPoints;\n        xTable.length = numberOfPoints;\n        yTable.length = numberOfPoints * packedInterpolationLength;\n      }\n    }\n\n    const degree = this._numberOfPoints - 1;\n    if (degree < 1) {\n      return undefined;\n    }\n\n    let firstIndex = 0;\n    let lastIndex = timesLength - 1;\n    const pointsInCollection = lastIndex - firstIndex + 1;\n\n    if (pointsInCollection >= degree + 1) {\n      let computedFirstIndex = index - ((degree / 2) | 0) - 1;\n      if (computedFirstIndex < firstIndex) {\n        computedFirstIndex = firstIndex;\n      }\n      let computedLastIndex = computedFirstIndex + degree;\n      if (computedLastIndex > lastIndex) {\n        computedLastIndex = lastIndex;\n        computedFirstIndex = computedLastIndex - degree;\n        if (computedFirstIndex < firstIndex) {\n          computedFirstIndex = firstIndex;\n        }\n      }\n\n      firstIndex = computedFirstIndex;\n      lastIndex = computedLastIndex;\n    }\n    const length = lastIndex - firstIndex + 1;\n\n    // Build the tables\n    for (let i = 0; i < length; ++i) {\n      xTable[i] = JulianDate.secondsDifference(\n        times[firstIndex + i],\n        times[lastIndex],\n      );\n    }\n\n    if (!defined(innerType.convertPackedArrayForInterpolation)) {\n      let destinationIndex = 0;\n      const packedLength = this._packedLength;\n      let sourceIndex = firstIndex * packedLength;\n      const stop = (lastIndex + 1) * packedLength;\n\n      while (sourceIndex < stop) {\n        yTable[destinationIndex] = values[sourceIndex];\n        sourceIndex++;\n        destinationIndex++;\n      }\n    } else {\n      innerType.convertPackedArrayForInterpolation(\n        values,\n        firstIndex,\n        lastIndex,\n        yTable,\n      );\n    }\n\n    // Interpolate!\n    const x = JulianDate.secondsDifference(time, times[lastIndex]);\n    let interpolationResult;\n    if (inputOrder === 0 || !defined(interpolationAlgorithm.interpolate)) {\n      interpolationResult = interpolationAlgorithm.interpolateOrderZero(\n        x,\n        xTable,\n        yTable,\n        packedInterpolationLength,\n        this._interpolationResult,\n      );\n    } else {\n      const yStride = Math.floor(packedInterpolationLength / (inputOrder + 1));\n      interpolationResult = interpolationAlgorithm.interpolate(\n        x,\n        xTable,\n        yTable,\n        yStride,\n        inputOrder,\n        inputOrder,\n        this._interpolationResult,\n      );\n    }\n\n    if (!defined(innerType.unpackInterpolationResult)) {\n      return innerType.unpack(interpolationResult, 0, result);\n    }\n    return innerType.unpackInterpolationResult(\n      interpolationResult,\n      values,\n      firstIndex,\n      lastIndex,\n      result,\n    );\n  }\n  return innerType.unpack(values, index * this._packedLength, result);\n};\n\n/**\n * Sets the algorithm and degree to use when interpolating a value.\n *\n * @param {object} [options] Object with the following properties:\n * @param {InterpolationAlgorithm} [options.interpolationAlgorithm] The new interpolation algorithm.  If undefined, the existing property will be unchanged.\n * @param {number} [options.interpolationDegree] The new interpolation degree.  If undefined, the existing property will be unchanged.\n */\nSampledProperty.prototype.setInterpolationOptions = function (options) {\n  if (!defined(options)) {\n    return;\n  }\n\n  let valuesChanged = false;\n\n  const interpolationAlgorithm = options.interpolationAlgorithm;\n  const interpolationDegree = options.interpolationDegree;\n\n  if (\n    defined(interpolationAlgorithm) &&\n    this._interpolationAlgorithm !== interpolationAlgorithm\n  ) {\n    this._interpolationAlgorithm = interpolationAlgorithm;\n    valuesChanged = true;\n  }\n\n  if (\n    defined(interpolationDegree) &&\n    this._interpolationDegree !== interpolationDegree\n  ) {\n    this._interpolationDegree = interpolationDegree;\n    valuesChanged = true;\n  }\n\n  if (valuesChanged) {\n    this._updateTableLength = true;\n    this._definitionChanged.raiseEvent(this);\n  }\n};\n\n/**\n * Adds a new sample.\n *\n * @param {JulianDate} time The sample time.\n * @param {Packable} value The value at the provided time.\n * @param {Packable[]} [derivatives] The array of derivatives at the provided time.\n */\nSampledProperty.prototype.addSample = function (time, value, derivatives) {\n  const innerDerivativeTypes = this._innerDerivativeTypes;\n  const hasDerivatives = defined(innerDerivativeTypes);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  Check.defined(\"value\", value);\n  if (hasDerivatives) {\n    Check.defined(\"derivatives\", derivatives);\n  }\n  //>>includeEnd('debug');\n\n  const innerType = this._innerType;\n  const data = [];\n  data.push(time);\n  innerType.pack(value, data, data.length);\n\n  if (hasDerivatives) {\n    const derivativesLength = innerDerivativeTypes.length;\n    for (let x = 0; x < derivativesLength; x++) {\n      innerDerivativeTypes[x].pack(derivatives[x], data, data.length);\n    }\n  }\n  mergeNewSamples(\n    undefined,\n    this._times,\n    this._values,\n    data,\n    this._packedLength,\n  );\n  this._updateTableLength = true;\n  this._definitionChanged.raiseEvent(this);\n};\n\n/**\n * Adds an array of samples.\n *\n * @param {JulianDate[]} times An array of JulianDate instances where each index is a sample time.\n * @param {Packable[]} values The array of values, where each value corresponds to the provided times index.\n * @param {Array[]} [derivativeValues] An array where each item is the array of derivatives at the equivalent time index.\n *\n * @exception {DeveloperError} times and values must be the same length.\n * @exception {DeveloperError} times and derivativeValues must be the same length.\n */\nSampledProperty.prototype.addSamples = function (\n  times,\n  values,\n  derivativeValues,\n) {\n  const innerDerivativeTypes = this._innerDerivativeTypes;\n  const hasDerivatives = defined(innerDerivativeTypes);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"times\", times);\n  Check.defined(\"values\", values);\n  if (times.length !== values.length) {\n    throw new DeveloperError(\"times and values must be the same length.\");\n  }\n  if (\n    hasDerivatives &&\n    (!defined(derivativeValues) || derivativeValues.length !== times.length)\n  ) {\n    throw new DeveloperError(\n      \"times and derivativeValues must be the same length.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const innerType = this._innerType;\n  const length = times.length;\n  const data = [];\n  for (let i = 0; i < length; i++) {\n    data.push(times[i]);\n    innerType.pack(values[i], data, data.length);\n\n    if (hasDerivatives) {\n      const derivatives = derivativeValues[i];\n      const derivativesLength = innerDerivativeTypes.length;\n      for (let x = 0; x < derivativesLength; x++) {\n        innerDerivativeTypes[x].pack(derivatives[x], data, data.length);\n      }\n    }\n  }\n  mergeNewSamples(\n    undefined,\n    this._times,\n    this._values,\n    data,\n    this._packedLength,\n  );\n  this._updateTableLength = true;\n  this._definitionChanged.raiseEvent(this);\n};\n\n/**\n * Retrieves the time of the provided sample associated with the index. A negative index accesses the list of samples in reverse order.\n *\n * @param {number} index The index of samples list.\n * @returns {JulianDate | undefined} The JulianDate time of the sample, or undefined if failed.\n */\nSampledProperty.prototype.getSample = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  const times = this._times;\n  const len = times.length;\n  if (!defined(len)) {\n    return undefined;\n  }\n\n  if (index < 0) {\n    index += len;\n  }\n\n  return times[index];\n};\n\n/**\n * Adds samples as a single packed array where each new sample is represented as a date,\n * followed by the packed representation of the corresponding value and derivatives.\n *\n * @param {number[]} packedSamples The array of packed samples.\n * @param {JulianDate} [epoch] If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.\n */\nSampledProperty.prototype.addSamplesPackedArray = function (\n  packedSamples,\n  epoch,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"packedSamples\", packedSamples);\n  //>>includeEnd('debug');\n\n  mergeNewSamples(\n    epoch,\n    this._times,\n    this._values,\n    packedSamples,\n    this._packedLength,\n  );\n  this._updateTableLength = true;\n  this._definitionChanged.raiseEvent(this);\n};\n\n/**\n * Removes a sample at the given time, if present.\n *\n * @param {JulianDate} time The sample time.\n * @returns {boolean} <code>true</code> if a sample at time was removed, <code>false</code> otherwise.\n */\nSampledProperty.prototype.removeSample = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  const index = binarySearch(this._times, time, JulianDate.compare);\n  if (index < 0) {\n    return false;\n  }\n  removeSamples(this, index, 1);\n  return true;\n};\n\nfunction removeSamples(property, startIndex, numberToRemove) {\n  const packedLength = property._packedLength;\n  property._times.splice(startIndex, numberToRemove);\n  property._values.splice(\n    startIndex * packedLength,\n    numberToRemove * packedLength,\n  );\n  property._updateTableLength = true;\n  property._definitionChanged.raiseEvent(property);\n}\n\n/**\n * Removes all samples for the given time interval.\n *\n * @param {TimeInterval} time The time interval for which to remove all samples.\n */\nSampledProperty.prototype.removeSamples = function (timeInterval) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"timeInterval\", timeInterval);\n  //>>includeEnd('debug');\n\n  const times = this._times;\n  let startIndex = binarySearch(times, timeInterval.start, JulianDate.compare);\n  if (startIndex < 0) {\n    startIndex = ~startIndex;\n  } else if (!timeInterval.isStartIncluded) {\n    ++startIndex;\n  }\n  let stopIndex = binarySearch(times, timeInterval.stop, JulianDate.compare);\n  if (stopIndex < 0) {\n    stopIndex = ~stopIndex;\n  } else if (timeInterval.isStopIncluded) {\n    ++stopIndex;\n  }\n\n  removeSamples(this, startIndex, stopIndex - startIndex);\n};\n\n/**\n * Compares this property to the provided property and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Property} [other] The other property.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nSampledProperty.prototype.equals = function (other) {\n  if (this === other) {\n    return true;\n  }\n  if (!defined(other)) {\n    return false;\n  }\n\n  if (\n    this._type !== other._type || //\n    this._interpolationDegree !== other._interpolationDegree || //\n    this._interpolationAlgorithm !== other._interpolationAlgorithm\n  ) {\n    return false;\n  }\n\n  const derivativeTypes = this._derivativeTypes;\n  const hasDerivatives = defined(derivativeTypes);\n  const otherDerivativeTypes = other._derivativeTypes;\n  const otherHasDerivatives = defined(otherDerivativeTypes);\n  if (hasDerivatives !== otherHasDerivatives) {\n    return false;\n  }\n\n  let i;\n  let length;\n  if (hasDerivatives) {\n    length = derivativeTypes.length;\n    if (length !== otherDerivativeTypes.length) {\n      return false;\n    }\n\n    for (i = 0; i < length; i++) {\n      if (derivativeTypes[i] !== otherDerivativeTypes[i]) {\n        return false;\n      }\n    }\n  }\n\n  const times = this._times;\n  const otherTimes = other._times;\n  length = times.length;\n\n  if (length !== otherTimes.length) {\n    return false;\n  }\n\n  for (i = 0; i < length; i++) {\n    if (!JulianDate.equals(times[i], otherTimes[i])) {\n      return false;\n    }\n  }\n\n  const values = this._values;\n  const otherValues = other._values;\n  length = values.length;\n\n  //Since time lengths are equal, values length and other length are guaranteed to be equal.\n  for (i = 0; i < length; i++) {\n    if (values[i] !== otherValues[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n//Exposed for testing.\nSampledProperty._mergeNewSamples = mergeNewSamples;\nexport default SampledProperty;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}