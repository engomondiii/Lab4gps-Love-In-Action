{"ast":null,"code":"import Color from \"../Core/Color.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport defined from \"../Core/defined.js\";\n\n/**\n * @private\n */\nfunction DebugInspector() {\n  this._cachedShowFrustumsShaders = {};\n}\nfunction getAttributeLocations(shaderProgram) {\n  const attributeLocations = {};\n  const attributes = shaderProgram.vertexAttributes;\n  for (const a in attributes) {\n    if (attributes.hasOwnProperty(a)) {\n      attributeLocations[a] = attributes[a].index;\n    }\n  }\n  return attributeLocations;\n}\nfunction createDebugShowFrustumsShaderProgram(scene, shaderProgram) {\n  const context = scene.context;\n  const sp = shaderProgram;\n  const fs = sp.fragmentShaderSource.clone();\n  const targets = [];\n  fs.sources = fs.sources.map(function (source) {\n    source = ShaderSource.replaceMain(source, \"czm_Debug_main\");\n    const re = /out_FragData_(\\d+)/g;\n    let match;\n    while ((match = re.exec(source)) !== null) {\n      if (targets.indexOf(match[1]) === -1) {\n        targets.push(match[1]);\n      }\n    }\n    return source;\n  });\n  const length = targets.length;\n  let newMain = \"\";\n  newMain += \"uniform vec3 debugShowCommandsColor;\\n\";\n  newMain += \"uniform vec3 debugShowFrustumsColor;\\n\";\n  newMain += \"void main() \\n\" + \"{ \\n\" + \"    czm_Debug_main(); \\n\";\n\n  // set debugShowCommandsColor to Color(1.0, 1.0, 1.0, 1.0) to stop rendering scene.debugShowCommands\n  // set debugShowFrustumsColor to Color(1.0, 1.0, 1.0, 1.0) to stop rendering scene.debugShowFrustums\n  let i;\n  if (length > 0) {\n    for (i = 0; i < length; ++i) {\n      newMain += `    out_FragData_${targets[i]}.rgb *= debugShowCommandsColor;\\n`;\n      newMain += `    out_FragData_${targets[i]}.rgb *= debugShowFrustumsColor;\\n`;\n    }\n  } else {\n    newMain += \"    out_FragColor.rgb *= debugShowCommandsColor;\\n\";\n    newMain += \"    out_FragColor.rgb *= debugShowFrustumsColor;\\n\";\n  }\n  newMain += \"}\";\n  fs.sources.push(newMain);\n  const attributeLocations = getAttributeLocations(sp);\n  return ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: sp.vertexShaderSource,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n}\nconst scratchFrustumColor = new Color();\nfunction createDebugShowFrustumsUniformMap(scene, command) {\n  // setup uniform for the shader\n  let debugUniformMap;\n  if (!defined(command.uniformMap)) {\n    debugUniformMap = {};\n  } else {\n    debugUniformMap = command.uniformMap;\n  }\n  if (defined(debugUniformMap.debugShowCommandsColor) || defined(debugUniformMap.debugShowFrustumsColor)) {\n    return debugUniformMap;\n  }\n  debugUniformMap.debugShowCommandsColor = function () {\n    if (!scene.debugShowCommands) {\n      return Color.WHITE;\n    }\n    if (!defined(command._debugColor)) {\n      command._debugColor = Color.fromRandom();\n    }\n    return command._debugColor;\n  };\n  debugUniformMap.debugShowFrustumsColor = function () {\n    if (!scene.debugShowFrustums) {\n      return Color.WHITE;\n    }\n\n    // Support up to three frustums.  If a command overlaps all\n    // three, it's code is not changed.\n    scratchFrustumColor.red = command.debugOverlappingFrustums & 1 << 0 ? 1.0 : 0.0;\n    scratchFrustumColor.green = command.debugOverlappingFrustums & 1 << 1 ? 1.0 : 0.0;\n    scratchFrustumColor.blue = command.debugOverlappingFrustums & 1 << 2 ? 1.0 : 0.0;\n    scratchFrustumColor.alpha = 1.0;\n    return scratchFrustumColor;\n  };\n  return debugUniformMap;\n}\nconst scratchShowFrustumCommand = new DrawCommand();\nDebugInspector.prototype.executeDebugShowFrustumsCommand = function (scene, command, passState) {\n  // create debug command\n  const shaderProgramId = command.shaderProgram.id;\n  let debugShaderProgram = this._cachedShowFrustumsShaders[shaderProgramId];\n  if (!defined(debugShaderProgram)) {\n    debugShaderProgram = createDebugShowFrustumsShaderProgram(scene, command.shaderProgram);\n    this._cachedShowFrustumsShaders[shaderProgramId] = debugShaderProgram;\n  }\n  const debugCommand = DrawCommand.shallowClone(command, scratchShowFrustumCommand);\n  debugCommand.shaderProgram = debugShaderProgram;\n  debugCommand.uniformMap = createDebugShowFrustumsUniformMap(scene, command);\n  debugCommand.execute(scene.context, passState);\n};\nexport default DebugInspector;","map":{"version":3,"names":["Color","DrawCommand","ShaderSource","ShaderProgram","defined","DebugInspector","_cachedShowFrustumsShaders","getAttributeLocations","shaderProgram","attributeLocations","attributes","vertexAttributes","a","hasOwnProperty","index","createDebugShowFrustumsShaderProgram","scene","context","sp","fs","fragmentShaderSource","clone","targets","sources","map","source","replaceMain","re","match","exec","indexOf","push","length","newMain","i","fromCache","vertexShaderSource","scratchFrustumColor","createDebugShowFrustumsUniformMap","command","debugUniformMap","uniformMap","debugShowCommandsColor","debugShowFrustumsColor","debugShowCommands","WHITE","_debugColor","fromRandom","debugShowFrustums","red","debugOverlappingFrustums","green","blue","alpha","scratchShowFrustumCommand","prototype","executeDebugShowFrustumsCommand","passState","shaderProgramId","id","debugShaderProgram","debugCommand","shallowClone","execute"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/DebugInspector.js"],"sourcesContent":["import Color from \"../Core/Color.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport defined from \"../Core/defined.js\";\n\n/**\n * @private\n */\nfunction DebugInspector() {\n  this._cachedShowFrustumsShaders = {};\n}\n\nfunction getAttributeLocations(shaderProgram) {\n  const attributeLocations = {};\n  const attributes = shaderProgram.vertexAttributes;\n  for (const a in attributes) {\n    if (attributes.hasOwnProperty(a)) {\n      attributeLocations[a] = attributes[a].index;\n    }\n  }\n\n  return attributeLocations;\n}\n\nfunction createDebugShowFrustumsShaderProgram(scene, shaderProgram) {\n  const context = scene.context;\n  const sp = shaderProgram;\n  const fs = sp.fragmentShaderSource.clone();\n\n  const targets = [];\n  fs.sources = fs.sources.map(function (source) {\n    source = ShaderSource.replaceMain(source, \"czm_Debug_main\");\n    const re = /out_FragData_(\\d+)/g;\n    let match;\n    while ((match = re.exec(source)) !== null) {\n      if (targets.indexOf(match[1]) === -1) {\n        targets.push(match[1]);\n      }\n    }\n    return source;\n  });\n  const length = targets.length;\n\n  let newMain = \"\";\n  newMain += \"uniform vec3 debugShowCommandsColor;\\n\";\n  newMain += \"uniform vec3 debugShowFrustumsColor;\\n\";\n  newMain += \"void main() \\n\" + \"{ \\n\" + \"    czm_Debug_main(); \\n\";\n\n  // set debugShowCommandsColor to Color(1.0, 1.0, 1.0, 1.0) to stop rendering scene.debugShowCommands\n  // set debugShowFrustumsColor to Color(1.0, 1.0, 1.0, 1.0) to stop rendering scene.debugShowFrustums\n  let i;\n  if (length > 0) {\n    for (i = 0; i < length; ++i) {\n      newMain += `    out_FragData_${targets[i]}.rgb *= debugShowCommandsColor;\\n`;\n      newMain += `    out_FragData_${targets[i]}.rgb *= debugShowFrustumsColor;\\n`;\n    }\n  } else {\n    newMain += \"    out_FragColor.rgb *= debugShowCommandsColor;\\n\";\n    newMain += \"    out_FragColor.rgb *= debugShowFrustumsColor;\\n\";\n  }\n  newMain += \"}\";\n\n  fs.sources.push(newMain);\n\n  const attributeLocations = getAttributeLocations(sp);\n\n  return ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: sp.vertexShaderSource,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n}\n\nconst scratchFrustumColor = new Color();\nfunction createDebugShowFrustumsUniformMap(scene, command) {\n  // setup uniform for the shader\n  let debugUniformMap;\n  if (!defined(command.uniformMap)) {\n    debugUniformMap = {};\n  } else {\n    debugUniformMap = command.uniformMap;\n  }\n\n  if (\n    defined(debugUniformMap.debugShowCommandsColor) ||\n    defined(debugUniformMap.debugShowFrustumsColor)\n  ) {\n    return debugUniformMap;\n  }\n\n  debugUniformMap.debugShowCommandsColor = function () {\n    if (!scene.debugShowCommands) {\n      return Color.WHITE;\n    }\n\n    if (!defined(command._debugColor)) {\n      command._debugColor = Color.fromRandom();\n    }\n\n    return command._debugColor;\n  };\n\n  debugUniformMap.debugShowFrustumsColor = function () {\n    if (!scene.debugShowFrustums) {\n      return Color.WHITE;\n    }\n\n    // Support up to three frustums.  If a command overlaps all\n    // three, it's code is not changed.\n    scratchFrustumColor.red =\n      command.debugOverlappingFrustums & (1 << 0) ? 1.0 : 0.0;\n    scratchFrustumColor.green =\n      command.debugOverlappingFrustums & (1 << 1) ? 1.0 : 0.0;\n    scratchFrustumColor.blue =\n      command.debugOverlappingFrustums & (1 << 2) ? 1.0 : 0.0;\n    scratchFrustumColor.alpha = 1.0;\n    return scratchFrustumColor;\n  };\n\n  return debugUniformMap;\n}\n\nconst scratchShowFrustumCommand = new DrawCommand();\nDebugInspector.prototype.executeDebugShowFrustumsCommand = function (\n  scene,\n  command,\n  passState,\n) {\n  // create debug command\n  const shaderProgramId = command.shaderProgram.id;\n  let debugShaderProgram = this._cachedShowFrustumsShaders[shaderProgramId];\n  if (!defined(debugShaderProgram)) {\n    debugShaderProgram = createDebugShowFrustumsShaderProgram(\n      scene,\n      command.shaderProgram,\n    );\n\n    this._cachedShowFrustumsShaders[shaderProgramId] = debugShaderProgram;\n  }\n\n  const debugCommand = DrawCommand.shallowClone(\n    command,\n    scratchShowFrustumCommand,\n  );\n  debugCommand.shaderProgram = debugShaderProgram;\n  debugCommand.uniformMap = createDebugShowFrustumsUniformMap(scene, command);\n  debugCommand.execute(scene.context, passState);\n};\nexport default DebugInspector;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}