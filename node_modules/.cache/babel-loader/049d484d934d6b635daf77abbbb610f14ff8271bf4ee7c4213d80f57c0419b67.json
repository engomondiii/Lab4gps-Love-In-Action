{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Billboard from \"./Billboard.js\";\nimport HeightReference from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport LabelStyle from \"./LabelStyle.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\nconst fontInfoCache = {};\nlet fontInfoCacheLength = 0;\nconst fontInfoCacheMaxSize = 256;\nconst defaultBackgroundColor = new Color(0.165, 0.165, 0.165, 0.8);\nconst defaultBackgroundPadding = new Cartesian2(7, 5);\nconst textTypes = Object.freeze({\n  LTR: 0,\n  RTL: 1,\n  WEAK: 2,\n  BRACKETS: 3\n});\nfunction rebindAllGlyphs(label) {\n  if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {\n    // only push label if it's not already been marked dirty\n    label._labelCollection._labelsToUpdate.push(label);\n  }\n  label._rebindAllGlyphs = true;\n}\nfunction repositionAllGlyphs(label) {\n  if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {\n    // only push label if it's not already been marked dirty\n    label._labelCollection._labelsToUpdate.push(label);\n  }\n  label._repositionAllGlyphs = true;\n}\nfunction getCSSValue(element, property) {\n  return document.defaultView.getComputedStyle(element, null).getPropertyValue(property);\n}\nfunction parseFont(label) {\n  let fontInfo = fontInfoCache[label._font];\n  if (!defined(fontInfo)) {\n    const div = document.createElement(\"div\");\n    div.style.position = \"absolute\";\n    div.style.opacity = 0;\n    div.style.font = label._font;\n    document.body.appendChild(div);\n    let lineHeight = parseFloat(getCSSValue(div, \"line-height\"));\n    if (isNaN(lineHeight)) {\n      // line-height isn't a number, i.e. 'normal'; apply default line-spacing\n      lineHeight = undefined;\n    }\n    fontInfo = {\n      family: getCSSValue(div, \"font-family\"),\n      size: getCSSValue(div, \"font-size\").replace(\"px\", \"\"),\n      style: getCSSValue(div, \"font-style\"),\n      weight: getCSSValue(div, \"font-weight\"),\n      lineHeight: lineHeight\n    };\n    document.body.removeChild(div);\n    if (fontInfoCacheLength < fontInfoCacheMaxSize) {\n      fontInfoCache[label._font] = fontInfo;\n      fontInfoCacheLength++;\n    }\n  }\n  label._fontFamily = fontInfo.family;\n  label._fontSize = fontInfo.size;\n  label._fontStyle = fontInfo.style;\n  label._fontWeight = fontInfo.weight;\n  label._lineHeight = fontInfo.lineHeight;\n}\n\n/**\n * @typedef {object} Label.ConstructorOptions\n *\n * Initialization options for the Label constructor\n *\n * @property {Cartesian3} position The cartesian position of the label.\n * @property {*} [id] A user-defined object to return when the label is picked with {@link Scene#pick}.\n * @property {boolean} [show=true] Determines if this label will be shown.\n * @property {string} [text] A string specifying the text of the label.\n * @property {string} [font='30px sans-serif'] A string specifying the font used to draw this label. Fonts are specified using the same syntax as the CSS 'font' property.\n * @property {LabelStyle} [style=LabelStyle.FILL] A {@link LabelStyle} specifying the style of the label.\n * @property {number} [scale=1.0] A number specifying the uniform scale that is multiplied with the label size.\n * @property {boolean} [showBackground=false] Determines if a background behind this label will be shown.\n * @property {Color} [backgroundColor=new Color(0.165, 0.165, 0.165, 0.8)] A {@link Color} specifying the background color of the label.\n * @property {Cartesian2} [backgroundPadding=new Cartesian2(7, 5)] A {@link Cartesian2} Specifying the horizontal and vertical background padding in pixels.\n * @property {Cartesian2} [pixelOffset=Cartesian2.ZERO] A {@link Cartesian2} specifying the pixel offset in screen space from the origin of this label.\n * @property {Cartesian3} [eyeOffset=Cartesian3.ZERO] A {@link Cartesian3} specifying the 3D Cartesian offset applied to this label in eye coordinates.\n * @property {HorizontalOrigin} [horizontalOrigin=HorizontalOrigin.LEFT] A {@link HorizontalOrigin} specifying the horizontal origin of this label.\n * @property {VerticalOrigin} [verticalOrigin=VerticalOrigin.BASELINE] A {@link VerticalOrigin} specifying the vertical origin of this label.\n * @property {HeightReference} [heightReference=HeightReference.NONE] A {@link HeightReference} specifying the height reference of this label.\n * @property {Color} [fillColor=Color.WHITE] A {@link Color} specifying the fill color of the label.\n * @property {Color} [outlineColor=Color.BLACK] A {@link Color} specifying the outline color of the label.\n * @property {number} [outlineWidth=1.0] A number specifying the outline width of the label.\n * @property {NearFarScalar} [translucencyByDistance] A {@link NearFarScalar} specifying near and far translucency properties of the label based on the label's distance from the camera.\n * @property {NearFarScalar} [pixelOffsetScaleByDistance] A {@link NearFarScalar} specifying near and far pixel offset scaling properties of the label based on the label's distance from the camera.\n * @property {NearFarScalar} [scaleByDistance] A {@link NearFarScalar} specifying near and far scaling properties of the label based on the label's distance from the camera.\n * @property {DistanceDisplayCondition} [distanceDisplayCondition] A {@link DistanceDisplayCondition} specifying at what distance from the camera that this label will be displayed.\n * @property {number} [disableDepthTestDistance] A number specifying the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.\n */\n\n/**\n * <div class=\"notice\">\n * Create labels by calling {@link LabelCollection#add}. Do not call the constructor directly.\n * </div>\n *\n * @alias Label\n * @internalConstructor\n * @class\n *\n * @param {Label.ConstructorOptions} options Object describing initialization options\n * @param {LabelCollection} labelCollection Instance of LabelCollection\n *\n * @exception {DeveloperError} translucencyByDistance.far must be greater than translucencyByDistance.near\n * @exception {DeveloperError} pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near\n * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near\n *\n * @see LabelCollection\n * @see LabelCollection#add\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Labels.html|Cesium Sandcastle Labels Demo}\n */\nfunction Label(options, labelCollection) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(options.disableDepthTestDistance) && options.disableDepthTestDistance < 0.0) {\n    throw new DeveloperError(\"disableDepthTestDistance must be greater than 0.0.\");\n  }\n  //>>includeEnd('debug');\n\n  let translucencyByDistance = options.translucencyByDistance;\n  let pixelOffsetScaleByDistance = options.pixelOffsetScaleByDistance;\n  let scaleByDistance = options.scaleByDistance;\n  let distanceDisplayCondition = options.distanceDisplayCondition;\n  if (defined(translucencyByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (translucencyByDistance.far <= translucencyByDistance.near) {\n      throw new DeveloperError(\"translucencyByDistance.far must be greater than translucencyByDistance.near.\");\n    }\n    //>>includeEnd('debug');\n    translucencyByDistance = NearFarScalar.clone(translucencyByDistance);\n  }\n  if (defined(pixelOffsetScaleByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (pixelOffsetScaleByDistance.far <= pixelOffsetScaleByDistance.near) {\n      throw new DeveloperError(\"pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near.\");\n    }\n    //>>includeEnd('debug');\n    pixelOffsetScaleByDistance = NearFarScalar.clone(pixelOffsetScaleByDistance);\n  }\n  if (defined(scaleByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (scaleByDistance.far <= scaleByDistance.near) {\n      throw new DeveloperError(\"scaleByDistance.far must be greater than scaleByDistance.near.\");\n    }\n    //>>includeEnd('debug');\n    scaleByDistance = NearFarScalar.clone(scaleByDistance);\n  }\n  if (defined(distanceDisplayCondition)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (distanceDisplayCondition.far <= distanceDisplayCondition.near) {\n      throw new DeveloperError(\"distanceDisplayCondition.far must be greater than distanceDisplayCondition.near.\");\n    }\n    //>>includeEnd('debug');\n    distanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition);\n  }\n  this._renderedText = undefined;\n  this._text = undefined;\n  this._show = defaultValue(options.show, true);\n  this._font = defaultValue(options.font, \"30px sans-serif\");\n  this._fillColor = Color.clone(defaultValue(options.fillColor, Color.WHITE));\n  this._outlineColor = Color.clone(defaultValue(options.outlineColor, Color.BLACK));\n  this._outlineWidth = defaultValue(options.outlineWidth, 1.0);\n  this._showBackground = defaultValue(options.showBackground, false);\n  this._backgroundColor = Color.clone(defaultValue(options.backgroundColor, defaultBackgroundColor));\n  this._backgroundPadding = Cartesian2.clone(defaultValue(options.backgroundPadding, defaultBackgroundPadding));\n  this._style = defaultValue(options.style, LabelStyle.FILL);\n  this._verticalOrigin = defaultValue(options.verticalOrigin, VerticalOrigin.BASELINE);\n  this._horizontalOrigin = defaultValue(options.horizontalOrigin, HorizontalOrigin.LEFT);\n  this._pixelOffset = Cartesian2.clone(defaultValue(options.pixelOffset, Cartesian2.ZERO));\n  this._eyeOffset = Cartesian3.clone(defaultValue(options.eyeOffset, Cartesian3.ZERO));\n  this._position = Cartesian3.clone(defaultValue(options.position, Cartesian3.ZERO));\n  this._scale = defaultValue(options.scale, 1.0);\n  this._id = options.id;\n  this._translucencyByDistance = translucencyByDistance;\n  this._pixelOffsetScaleByDistance = pixelOffsetScaleByDistance;\n  this._scaleByDistance = scaleByDistance;\n  this._heightReference = defaultValue(options.heightReference, HeightReference.NONE);\n  this._distanceDisplayCondition = distanceDisplayCondition;\n  this._disableDepthTestDistance = options.disableDepthTestDistance;\n  this._labelCollection = labelCollection;\n  this._glyphs = [];\n  this._backgroundBillboard = undefined;\n  this._batchIndex = undefined; // Used only by Vector3DTilePoints and BillboardCollection\n\n  this._rebindAllGlyphs = true;\n  this._repositionAllGlyphs = true;\n  this._actualClampedPosition = undefined;\n  this._removeCallbackFunc = undefined;\n  this._mode = undefined;\n  this._clusterShow = true;\n  this.text = defaultValue(options.text, \"\");\n  this._relativeSize = 1.0;\n  parseFont(this);\n  this._updateClamping();\n}\nObject.defineProperties(Label.prototype, {\n  /**\n   * Determines if this label will be shown.  Use this to hide or show a label, instead\n   * of removing it and re-adding it to the collection.\n   * @memberof Label.prototype\n   * @type {boolean}\n   * @default true\n   */\n  show: {\n    get: function () {\n      return this._show;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._show !== value) {\n        this._show = value;\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const billboard = glyphs[i].billboard;\n          if (defined(billboard)) {\n            billboard.show = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.show = value;\n        }\n      }\n    }\n  },\n  /**\n   * Gets or sets the Cartesian position of this label.\n   * @memberof Label.prototype\n   * @type {Cartesian3}\n   */\n  position: {\n    get: function () {\n      return this._position;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const position = this._position;\n      if (!Cartesian3.equals(position, value)) {\n        Cartesian3.clone(value, position);\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const billboard = glyphs[i].billboard;\n          if (defined(billboard)) {\n            billboard.position = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.position = value;\n        }\n        this._updateClamping();\n      }\n    }\n  },\n  /**\n   * Gets or sets the height reference of this billboard.\n   * @memberof Label.prototype\n   * @type {HeightReference}\n   * @default HeightReference.NONE\n   */\n  heightReference: {\n    get: function () {\n      return this._heightReference;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (value !== this._heightReference) {\n        this._heightReference = value;\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const billboard = glyphs[i].billboard;\n          if (defined(billboard)) {\n            billboard.heightReference = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.heightReference = value;\n        }\n        repositionAllGlyphs(this);\n        this._updateClamping();\n      }\n    }\n  },\n  /**\n   * Gets or sets the text of this label.\n   * @memberof Label.prototype\n   * @type {string}\n   */\n  text: {\n    get: function () {\n      return this._text;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._text !== value) {\n        this._text = value;\n        const renderedValue = Label.filterUnsupportedCharacters(value);\n        this._renderedText = Label.enableRightToLeftDetection ? reverseRtl(renderedValue) : renderedValue;\n        rebindAllGlyphs(this);\n      }\n    }\n  },\n  /**\n   * Gets or sets the font used to draw this label. Fonts are specified using the same syntax as the CSS 'font' property.\n   * @memberof Label.prototype\n   * @type {string}\n   * @default '30px sans-serif'\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles|HTML canvas 2D context text styles}\n   */\n  font: {\n    get: function () {\n      return this._font;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._font !== value) {\n        this._font = value;\n        rebindAllGlyphs(this);\n        parseFont(this);\n      }\n    }\n  },\n  /**\n   * Gets or sets the fill color of this label.\n   * @memberof Label.prototype\n   * @type {Color}\n   * @default Color.WHITE\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}\n   */\n  fillColor: {\n    get: function () {\n      return this._fillColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const fillColor = this._fillColor;\n      if (!Color.equals(fillColor, value)) {\n        Color.clone(value, fillColor);\n        rebindAllGlyphs(this);\n      }\n    }\n  },\n  /**\n   * Gets or sets the outline color of this label.\n   * @memberof Label.prototype\n   * @type {Color}\n   * @default Color.BLACK\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}\n   */\n  outlineColor: {\n    get: function () {\n      return this._outlineColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const outlineColor = this._outlineColor;\n      if (!Color.equals(outlineColor, value)) {\n        Color.clone(value, outlineColor);\n        rebindAllGlyphs(this);\n      }\n    }\n  },\n  /**\n   * Gets or sets the outline width of this label.\n   * @memberof Label.prototype\n   * @type {number}\n   * @default 1.0\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}\n   */\n  outlineWidth: {\n    get: function () {\n      return this._outlineWidth;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._outlineWidth !== value) {\n        this._outlineWidth = value;\n        rebindAllGlyphs(this);\n      }\n    }\n  },\n  /**\n   * Determines if a background behind this label will be shown.\n   * @memberof Label.prototype\n   * @default false\n   * @type {boolean}\n   */\n  showBackground: {\n    get: function () {\n      return this._showBackground;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._showBackground !== value) {\n        this._showBackground = value;\n        rebindAllGlyphs(this);\n      }\n    }\n  },\n  /**\n   * Gets or sets the background color of this label.\n   * @memberof Label.prototype\n   * @type {Color}\n   * @default new Color(0.165, 0.165, 0.165, 0.8)\n   */\n  backgroundColor: {\n    get: function () {\n      return this._backgroundColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const backgroundColor = this._backgroundColor;\n      if (!Color.equals(backgroundColor, value)) {\n        Color.clone(value, backgroundColor);\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.color = backgroundColor;\n        }\n      }\n    }\n  },\n  /**\n   * Gets or sets the background padding, in pixels, of this label.  The <code>x</code> value\n   * controls horizontal padding, and the <code>y</code> value controls vertical padding.\n   * @memberof Label.prototype\n   * @type {Cartesian2}\n   * @default new Cartesian2(7, 5)\n   */\n  backgroundPadding: {\n    get: function () {\n      return this._backgroundPadding;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const backgroundPadding = this._backgroundPadding;\n      if (!Cartesian2.equals(backgroundPadding, value)) {\n        Cartesian2.clone(value, backgroundPadding);\n        repositionAllGlyphs(this);\n      }\n    }\n  },\n  /**\n   * Gets or sets the style of this label.\n   * @memberof Label.prototype\n   * @type {LabelStyle}\n   * @default LabelStyle.FILL\n   */\n  style: {\n    get: function () {\n      return this._style;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._style !== value) {\n        this._style = value;\n        rebindAllGlyphs(this);\n      }\n    }\n  },\n  /**\n   * Gets or sets the pixel offset in screen space from the origin of this label.  This is commonly used\n   * to align multiple labels and billboards at the same position, e.g., an image and text.  The\n   * screen space origin is the top, left corner of the canvas; <code>x</code> increases from\n   * left to right, and <code>y</code> increases from top to bottom.\n   * <br /><br />\n   * <div align='center'>\n   * <table border='0' cellpadding='5'><tr>\n   * <td align='center'><code>default</code><br/><img src='Images/Label.setPixelOffset.default.png' width='250' height='188' /></td>\n   * <td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='Images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>\n   * </tr></table>\n   * The label's origin is indicated by the yellow point.\n   * </div>\n   * @memberof Label.prototype\n   * @type {Cartesian2}\n   * @default Cartesian2.ZERO\n   */\n  pixelOffset: {\n    get: function () {\n      return this._pixelOffset;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const pixelOffset = this._pixelOffset;\n      if (!Cartesian2.equals(pixelOffset, value)) {\n        Cartesian2.clone(value, pixelOffset);\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.pixelOffset = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.pixelOffset = value;\n        }\n      }\n    }\n  },\n  /**\n   * Gets or sets near and far translucency properties of a Label based on the Label's distance from the camera.\n   * A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the label's translucency remains clamped to the nearest bound.  If undefined,\n   * translucencyByDistance will be disabled.\n   * @memberof Label.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a label's translucencyByDistance to 1.0 when the\n   * // camera is 1500 meters from the label and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * text.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable translucency by distance\n   * text.translucencyByDistance = undefined;\n   */\n  translucencyByDistance: {\n    get: function () {\n      return this._translucencyByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far distance must be greater than near distance.\");\n      }\n      //>>includeEnd('debug');\n\n      const translucencyByDistance = this._translucencyByDistance;\n      if (!NearFarScalar.equals(translucencyByDistance, value)) {\n        this._translucencyByDistance = NearFarScalar.clone(value, translucencyByDistance);\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.translucencyByDistance = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.translucencyByDistance = value;\n        }\n      }\n    }\n  },\n  /**\n   * Gets or sets near and far pixel offset scaling properties of a Label based on the Label's distance from the camera.\n   * A label's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the label's pixel offset scaling remains clamped to the nearest bound.  If undefined,\n   * pixelOffsetScaleByDistance will be disabled.\n   * @memberof Label.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a label's pixel offset scale to 0.0 when the\n   * // camera is 1500 meters from the label and scale pixel offset to 10.0 pixels\n   * // in the y direction the camera distance approaches 8.0e6 meters.\n   * text.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);\n   * text.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable pixel offset by distance\n   * text.pixelOffsetScaleByDistance = undefined;\n   */\n  pixelOffsetScaleByDistance: {\n    get: function () {\n      return this._pixelOffsetScaleByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far distance must be greater than near distance.\");\n      }\n      //>>includeEnd('debug');\n\n      const pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;\n      if (!NearFarScalar.equals(pixelOffsetScaleByDistance, value)) {\n        this._pixelOffsetScaleByDistance = NearFarScalar.clone(value, pixelOffsetScaleByDistance);\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.pixelOffsetScaleByDistance = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.pixelOffsetScaleByDistance = value;\n        }\n      }\n    }\n  },\n  /**\n   * Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.\n   * A label's scale will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the label's scale remains clamped to the nearest bound.  If undefined,\n   * scaleByDistance will be disabled.\n   * @memberof Label.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a label's scaleByDistance to scale by 1.5 when the\n   * // camera is 1500 meters from the label and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * label.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable scaling by distance\n   * label.scaleByDistance = undefined;\n   */\n  scaleByDistance: {\n    get: function () {\n      return this._scaleByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far distance must be greater than near distance.\");\n      }\n      //>>includeEnd('debug');\n\n      const scaleByDistance = this._scaleByDistance;\n      if (!NearFarScalar.equals(scaleByDistance, value)) {\n        this._scaleByDistance = NearFarScalar.clone(value, scaleByDistance);\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.scaleByDistance = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.scaleByDistance = value;\n        }\n      }\n    }\n  },\n  /**\n   * Gets and sets the 3D Cartesian offset applied to this label in eye coordinates.  Eye coordinates is a left-handed\n   * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and\n   * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,\n   * which is typically meters.\n   * <br /><br />\n   * An eye offset is commonly used to arrange multiple label or objects at the same position, e.g., to\n   * arrange a label above its corresponding 3D model.\n   * <br /><br />\n   * Below, the label is positioned at the center of the Earth but an eye offset makes it always\n   * appear on top of the Earth regardless of the viewer's or Earth's orientation.\n   * <br /><br />\n   * <div align='center'>\n   * <table border='0' cellpadding='5'><tr>\n   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>\n   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>\n   * </tr></table>\n   * <code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />\n   * </div>\n   * @memberof Label.prototype\n   * @type {Cartesian3}\n   * @default Cartesian3.ZERO\n   */\n  eyeOffset: {\n    get: function () {\n      return this._eyeOffset;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const eyeOffset = this._eyeOffset;\n      if (!Cartesian3.equals(eyeOffset, value)) {\n        Cartesian3.clone(value, eyeOffset);\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.eyeOffset = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.eyeOffset = value;\n        }\n      }\n    }\n  },\n  /**\n   * Gets or sets the horizontal origin of this label, which determines if the label is drawn\n   * to the left, center, or right of its anchor position.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />\n   * </div>\n   * @memberof Label.prototype\n   * @type {HorizontalOrigin}\n   * @default HorizontalOrigin.LEFT\n   * @example\n   * // Use a top, right origin\n   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;\n   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;\n   */\n  horizontalOrigin: {\n    get: function () {\n      return this._horizontalOrigin;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._horizontalOrigin !== value) {\n        this._horizontalOrigin = value;\n        repositionAllGlyphs(this);\n      }\n    }\n  },\n  /**\n   * Gets or sets the vertical origin of this label, which determines if the label is\n   * to the above, below, or at the center of its anchor position.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />\n   * </div>\n   * @memberof Label.prototype\n   * @type {VerticalOrigin}\n   * @default VerticalOrigin.BASELINE\n   * @example\n   * // Use a top, right origin\n   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;\n   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;\n   */\n  verticalOrigin: {\n    get: function () {\n      return this._verticalOrigin;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._verticalOrigin !== value) {\n        this._verticalOrigin = value;\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.verticalOrigin = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.verticalOrigin = value;\n        }\n        repositionAllGlyphs(this);\n      }\n    }\n  },\n  /**\n   * Gets or sets the uniform scale that is multiplied with the label's size in pixels.\n   * A scale of <code>1.0</code> does not change the size of the label; a scale greater than\n   * <code>1.0</code> enlarges the label; a positive scale less than <code>1.0</code> shrinks\n   * the label.\n   * <br /><br />\n   * Applying a large scale value may pixelate the label.  To make text larger without pixelation,\n   * use a larger font size when calling {@link Label#font} instead.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Label.setScale.png' width='400' height='300' /><br/>\n   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,\n   * and <code>2.0</code>.\n   * </div>\n   * @memberof Label.prototype\n   * @type {number}\n   * @default 1.0\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._scale !== value) {\n        this._scale = value;\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.scale = value * this._relativeSize;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.scale = value * this._relativeSize;\n        }\n        repositionAllGlyphs(this);\n      }\n    }\n  },\n  /**\n   * Gets the total scale of the label, which is the label's scale multiplied by the computed relative size\n   * of the desired font compared to the generated glyph size.\n   * @memberof Label.prototype\n   * @type {number}\n   * @default 1.0\n   */\n  totalScale: {\n    get: function () {\n      return this._scale * this._relativeSize;\n    }\n  },\n  /**\n   * Gets or sets the condition specifying at what distance from the camera that this label will be displayed.\n   * @memberof Label.prototype\n   * @type {DistanceDisplayCondition}\n   * @default undefined\n   */\n  distanceDisplayCondition: {\n    get: function () {\n      return this._distanceDisplayCondition;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far must be greater than near\");\n      }\n      //>>includeEnd('debug');\n      if (!DistanceDisplayCondition.equals(value, this._distanceDisplayCondition)) {\n        this._distanceDisplayCondition = DistanceDisplayCondition.clone(value, this._distanceDisplayCondition);\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.distanceDisplayCondition = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.distanceDisplayCondition = value;\n        }\n      }\n    }\n  },\n  /**\n   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.\n   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.\n   * @memberof Label.prototype\n   * @type {number}\n   */\n  disableDepthTestDistance: {\n    get: function () {\n      return this._disableDepthTestDistance;\n    },\n    set: function (value) {\n      if (this._disableDepthTestDistance !== value) {\n        //>>includeStart('debug', pragmas.debug);\n        if (defined(value) && value < 0.0) {\n          throw new DeveloperError(\"disableDepthTestDistance must be greater than 0.0.\");\n        }\n        //>>includeEnd('debug');\n        this._disableDepthTestDistance = value;\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.disableDepthTestDistance = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.disableDepthTestDistance = value;\n        }\n      }\n    }\n  },\n  /**\n   * Gets or sets the user-defined value returned when the label is picked.\n   * @memberof Label.prototype\n   * @type {*}\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n    set: function (value) {\n      if (this._id !== value) {\n        this._id = value;\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.id = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.id = value;\n        }\n      }\n    }\n  },\n  /**\n   * @private\n   */\n  pickId: {\n    get: function () {\n      if (this._glyphs.length === 0 || !defined(this._glyphs[0].billboard)) {\n        return undefined;\n      }\n      return this._glyphs[0].billboard.pickId;\n    }\n  },\n  /**\n   * Keeps track of the position of the label based on the height reference.\n   * @memberof Label.prototype\n   * @type {Cartesian3}\n   * @private\n   */\n  _clampedPosition: {\n    get: function () {\n      return this._actualClampedPosition;\n    },\n    set: function (value) {\n      this._actualClampedPosition = Cartesian3.clone(value, this._actualClampedPosition);\n      const glyphs = this._glyphs;\n      for (let i = 0, len = glyphs.length; i < len; i++) {\n        const glyph = glyphs[i];\n        if (defined(glyph.billboard)) {\n          // Set all the private values here, because we already clamped to ground\n          //  so we don't want to do it again for every glyph\n          glyph.billboard._clampedPosition = value;\n        }\n      }\n      const backgroundBillboard = this._backgroundBillboard;\n      if (defined(backgroundBillboard)) {\n        backgroundBillboard._clampedPosition = value;\n      }\n    }\n  },\n  /**\n   * Determines whether or not this label will be shown or hidden because it was clustered.\n   * @memberof Label.prototype\n   * @type {boolean}\n   * @default true\n   * @private\n   */\n  clusterShow: {\n    get: function () {\n      return this._clusterShow;\n    },\n    set: function (value) {\n      if (this._clusterShow !== value) {\n        this._clusterShow = value;\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.clusterShow = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.clusterShow = value;\n        }\n      }\n    }\n  }\n});\nLabel.prototype._updateClamping = function () {\n  Billboard._updateClamping(this._labelCollection, this);\n};\n\n/**\n * Computes the screen-space position of the label's origin, taking into account eye and pixel offsets.\n * The screen space origin is the top, left corner of the canvas; <code>x</code> increases from\n * left to right, and <code>y</code> increases from top to bottom.\n *\n * @param {Scene} scene The scene the label is in.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The screen-space position of the label.\n *\n *\n * @example\n * console.log(l.computeScreenSpacePosition(scene).toString());\n *\n * @see Label#eyeOffset\n * @see Label#pixelOffset\n */\nLabel.prototype.computeScreenSpacePosition = function (scene, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n  const labelCollection = this._labelCollection;\n  const modelMatrix = labelCollection.modelMatrix;\n  const actualPosition = defined(this._actualClampedPosition) ? this._actualClampedPosition : this._position;\n  const windowCoordinates = Billboard._computeScreenSpacePosition(modelMatrix, actualPosition, this._eyeOffset, this._pixelOffset, scene, result);\n  return windowCoordinates;\n};\n\n/**\n * Gets a label's screen space bounding box centered around screenSpacePosition.\n * @param {Label} label The label to get the screen space bounding box for.\n * @param {Cartesian2} screenSpacePosition The screen space center of the label.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The screen space bounding box.\n *\n * @private\n */\nLabel.getScreenSpaceBoundingBox = function (label, screenSpacePosition, result) {\n  let x = 0;\n  let y = 0;\n  let width = 0;\n  let height = 0;\n  const scale = label.totalScale;\n  const backgroundBillboard = label._backgroundBillboard;\n  if (defined(backgroundBillboard)) {\n    x = screenSpacePosition.x + backgroundBillboard._translate.x;\n    y = screenSpacePosition.y - backgroundBillboard._translate.y;\n    width = backgroundBillboard.width * scale;\n    height = backgroundBillboard.height * scale;\n    if (label.verticalOrigin === VerticalOrigin.BOTTOM || label.verticalOrigin === VerticalOrigin.BASELINE) {\n      y -= height;\n    } else if (label.verticalOrigin === VerticalOrigin.CENTER) {\n      y -= height * 0.5;\n    }\n  } else {\n    x = Number.POSITIVE_INFINITY;\n    y = Number.POSITIVE_INFINITY;\n    let maxX = 0;\n    let maxY = 0;\n    const glyphs = label._glyphs;\n    const length = glyphs.length;\n    for (let i = 0; i < length; ++i) {\n      const glyph = glyphs[i];\n      const billboard = glyph.billboard;\n      if (!defined(billboard)) {\n        continue;\n      }\n      const glyphX = screenSpacePosition.x + billboard._translate.x;\n      let glyphY = screenSpacePosition.y - billboard._translate.y;\n      const glyphWidth = glyph.dimensions.width * scale;\n      const glyphHeight = glyph.dimensions.height * scale;\n      if (label.verticalOrigin === VerticalOrigin.BOTTOM || label.verticalOrigin === VerticalOrigin.BASELINE) {\n        glyphY -= glyphHeight;\n      } else if (label.verticalOrigin === VerticalOrigin.CENTER) {\n        glyphY -= glyphHeight * 0.5;\n      }\n      if (label._verticalOrigin === VerticalOrigin.TOP) {\n        glyphY += SDFSettings.PADDING * scale;\n      } else if (label._verticalOrigin === VerticalOrigin.BOTTOM || label._verticalOrigin === VerticalOrigin.BASELINE) {\n        glyphY -= SDFSettings.PADDING * scale;\n      }\n      x = Math.min(x, glyphX);\n      y = Math.min(y, glyphY);\n      maxX = Math.max(maxX, glyphX + glyphWidth);\n      maxY = Math.max(maxY, glyphY + glyphHeight);\n    }\n    width = maxX - x;\n    height = maxY - y;\n  }\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n  result.x = x;\n  result.y = y;\n  result.width = width;\n  result.height = height;\n  return result;\n};\n\n/**\n * Removes control characters and soft hyphon (auto-wrap) characters, which will cause an error when rendering a glyph. This does not remove tabs, carriage returns, or newlines.\n * @private\n * @param {string} text The original label text\n * @returns {string} The renderable filtered text\n */\nLabel.filterUnsupportedCharacters = function (text) {\n  const problematicCharactersRegex = new RegExp(\n  // eslint-disable-next-line no-control-regex\n  /[\\u0000-\\u0008\\u000E-\\u001F\\u00ad\\u202a-\\u206f\\u200b-\\u200f]/, \"g\");\n  return text.replace(problematicCharactersRegex, \"\");\n};\n\n/**\n * Determines if this label equals another label.  Labels are equal if all their properties\n * are equal.  Labels in different collections can be equal.\n *\n * @param {Label} other The label to compare for equality.\n * @returns {boolean} <code>true</code> if the labels are equal; otherwise, <code>false</code>.\n */\nLabel.prototype.equals = function (other) {\n  return this === other || defined(other) && this._show === other._show && this._scale === other._scale && this._outlineWidth === other._outlineWidth && this._showBackground === other._showBackground && this._style === other._style && this._verticalOrigin === other._verticalOrigin && this._horizontalOrigin === other._horizontalOrigin && this._heightReference === other._heightReference && this._renderedText === other._renderedText && this._font === other._font && Cartesian3.equals(this._position, other._position) && Color.equals(this._fillColor, other._fillColor) && Color.equals(this._outlineColor, other._outlineColor) && Color.equals(this._backgroundColor, other._backgroundColor) && Cartesian2.equals(this._backgroundPadding, other._backgroundPadding) && Cartesian2.equals(this._pixelOffset, other._pixelOffset) && Cartesian3.equals(this._eyeOffset, other._eyeOffset) && NearFarScalar.equals(this._translucencyByDistance, other._translucencyByDistance) && NearFarScalar.equals(this._pixelOffsetScaleByDistance, other._pixelOffsetScaleByDistance) && NearFarScalar.equals(this._scaleByDistance, other._scaleByDistance) && DistanceDisplayCondition.equals(this._distanceDisplayCondition, other._distanceDisplayCondition) && this._disableDepthTestDistance === other._disableDepthTestDistance && this._id === other._id;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nLabel.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Determines whether or not run the algorithm, that match the text of the label to right-to-left languages\n * @memberof Label\n * @type {boolean}\n * @default false\n *\n * @example\n * // Example 1.\n * // Set a label's rightToLeft before init\n * Cesium.Label.enableRightToLeftDetection = true;\n * const myLabelEntity = viewer.entities.add({\n *   label: {\n *     id: 'my label',\n *     text: 'זה טקסט בעברית \\n ועכשיו יורדים שורה',\n *   }\n * });\n *\n * @example\n * // Example 2.\n * const myLabelEntity = viewer.entities.add({\n *   label: {\n *     id: 'my label',\n *     text: 'English text'\n *   }\n * });\n * // Set a label's rightToLeft after init\n * Cesium.Label.enableRightToLeftDetection = true;\n * myLabelEntity.text = 'טקסט חדש';\n */\nLabel.enableRightToLeftDetection = false;\nfunction convertTextToTypes(text, rtlChars) {\n  const ltrChars = /[a-zA-Z0-9]/;\n  const bracketsChars = /[()[\\]{}<>]/;\n  const parsedText = [];\n  let word = \"\";\n  let lastType = textTypes.LTR;\n  let currentType = \"\";\n  const textLength = text.length;\n  for (let textIndex = 0; textIndex < textLength; ++textIndex) {\n    const character = text.charAt(textIndex);\n    if (rtlChars.test(character)) {\n      currentType = textTypes.RTL;\n    } else if (ltrChars.test(character)) {\n      currentType = textTypes.LTR;\n    } else if (bracketsChars.test(character)) {\n      currentType = textTypes.BRACKETS;\n    } else {\n      currentType = textTypes.WEAK;\n    }\n    if (textIndex === 0) {\n      lastType = currentType;\n    }\n    if (lastType === currentType && currentType !== textTypes.BRACKETS) {\n      word += character;\n    } else {\n      if (word !== \"\") {\n        parsedText.push({\n          Type: lastType,\n          Word: word\n        });\n      }\n      lastType = currentType;\n      word = character;\n    }\n  }\n  parsedText.push({\n    Type: currentType,\n    Word: word\n  });\n  return parsedText;\n}\nfunction reverseWord(word) {\n  return word.split(\"\").reverse().join(\"\");\n}\nfunction spliceWord(result, pointer, word) {\n  return result.slice(0, pointer) + word + result.slice(pointer);\n}\nfunction reverseBrackets(bracket) {\n  switch (bracket) {\n    case \"(\":\n      return \")\";\n    case \")\":\n      return \"(\";\n    case \"[\":\n      return \"]\";\n    case \"]\":\n      return \"[\";\n    case \"{\":\n      return \"}\";\n    case \"}\":\n      return \"{\";\n    case \"<\":\n      return \">\";\n    case \">\":\n      return \"<\";\n  }\n}\n\n// To add another language, add its Unicode block range(s) to the below regex.\nconst hebrew = \"\\u05D0-\\u05EA\";\nconst arabic = \"\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\";\nconst rtlChars = new RegExp(`[${hebrew}${arabic}]`);\n\n/**\n *\n * @param {string} value the text to parse and reorder\n * @returns {string} the text as rightToLeft direction\n * @private\n */\nfunction reverseRtl(value) {\n  const texts = value.split(\"\\n\");\n  let result = \"\";\n  for (let i = 0; i < texts.length; i++) {\n    const text = texts[i];\n    // first character of the line is a RTL character, so need to manage different cases\n    const rtlDir = rtlChars.test(text.charAt(0));\n    const parsedText = convertTextToTypes(text, rtlChars);\n    let splicePointer = 0;\n    let line = \"\";\n    for (let wordIndex = 0; wordIndex < parsedText.length; ++wordIndex) {\n      const subText = parsedText[wordIndex];\n      const reverse = subText.Type === textTypes.BRACKETS ? reverseBrackets(subText.Word) : reverseWord(subText.Word);\n      if (rtlDir) {\n        if (subText.Type === textTypes.RTL) {\n          line = reverse + line;\n          splicePointer = 0;\n        } else if (subText.Type === textTypes.LTR) {\n          line = spliceWord(line, splicePointer, subText.Word);\n          splicePointer += subText.Word.length;\n        } else if (subText.Type === textTypes.WEAK || subText.Type === textTypes.BRACKETS) {\n          // current word is weak, last one was bracket\n          if (subText.Type === textTypes.WEAK && parsedText[wordIndex - 1].Type === textTypes.BRACKETS) {\n            line = reverse + line;\n          }\n          // current word is weak or bracket, last one was rtl\n          else if (parsedText[wordIndex - 1].Type === textTypes.RTL) {\n            line = reverse + line;\n            splicePointer = 0;\n          }\n          // current word is weak or bracket, there is at least one more word\n          else if (parsedText.length > wordIndex + 1) {\n            // next word is rtl\n            if (parsedText[wordIndex + 1].Type === textTypes.RTL) {\n              line = reverse + line;\n              splicePointer = 0;\n            } else {\n              line = spliceWord(line, splicePointer, subText.Word);\n              splicePointer += subText.Word.length;\n            }\n          }\n          // current word is weak or bracket, and it the last in this line\n          else {\n            line = spliceWord(line, 0, reverse);\n          }\n        }\n      }\n      // ltr line, rtl word\n      else if (subText.Type === textTypes.RTL) {\n        line = spliceWord(line, splicePointer, reverse);\n      }\n      // ltr line, ltr word\n      else if (subText.Type === textTypes.LTR) {\n        line += subText.Word;\n        splicePointer = line.length;\n      }\n      // ltr line, weak or bracket word\n      else if (subText.Type === textTypes.WEAK || subText.Type === textTypes.BRACKETS) {\n        // not first word in line\n        if (wordIndex > 0) {\n          // last word was rtl\n          if (parsedText[wordIndex - 1].Type === textTypes.RTL) {\n            // there is at least one more word\n            if (parsedText.length > wordIndex + 1) {\n              // next word is rtl\n              if (parsedText[wordIndex + 1].Type === textTypes.RTL) {\n                line = spliceWord(line, splicePointer, reverse);\n              } else {\n                line += subText.Word;\n                splicePointer = line.length;\n              }\n            } else {\n              line += subText.Word;\n            }\n          } else {\n            line += subText.Word;\n            splicePointer = line.length;\n          }\n        } else {\n          line += subText.Word;\n          splicePointer = line.length;\n        }\n      }\n    }\n    result += line;\n    if (i < texts.length - 1) {\n      result += \"\\n\";\n    }\n  }\n  return result;\n}\nexport default Label;","map":{"version":3,"names":["BoundingRectangle","Cartesian2","Cartesian3","Color","defaultValue","defined","DeveloperError","DistanceDisplayCondition","NearFarScalar","Billboard","HeightReference","HorizontalOrigin","LabelStyle","SDFSettings","VerticalOrigin","fontInfoCache","fontInfoCacheLength","fontInfoCacheMaxSize","defaultBackgroundColor","defaultBackgroundPadding","textTypes","Object","freeze","LTR","RTL","WEAK","BRACKETS","rebindAllGlyphs","label","_rebindAllGlyphs","_repositionAllGlyphs","_labelCollection","_labelsToUpdate","push","repositionAllGlyphs","getCSSValue","element","property","document","defaultView","getComputedStyle","getPropertyValue","parseFont","fontInfo","_font","div","createElement","style","position","opacity","font","body","appendChild","lineHeight","parseFloat","isNaN","undefined","family","size","replace","weight","removeChild","_fontFamily","_fontSize","_fontStyle","_fontWeight","_lineHeight","Label","options","labelCollection","EMPTY_OBJECT","disableDepthTestDistance","translucencyByDistance","pixelOffsetScaleByDistance","scaleByDistance","distanceDisplayCondition","far","near","clone","_renderedText","_text","_show","show","_fillColor","fillColor","WHITE","_outlineColor","outlineColor","BLACK","_outlineWidth","outlineWidth","_showBackground","showBackground","_backgroundColor","backgroundColor","_backgroundPadding","backgroundPadding","_style","FILL","_verticalOrigin","verticalOrigin","BASELINE","_horizontalOrigin","horizontalOrigin","LEFT","_pixelOffset","pixelOffset","ZERO","_eyeOffset","eyeOffset","_position","_scale","scale","_id","id","_translucencyByDistance","_pixelOffsetScaleByDistance","_scaleByDistance","_heightReference","heightReference","NONE","_distanceDisplayCondition","_disableDepthTestDistance","_glyphs","_backgroundBillboard","_batchIndex","_actualClampedPosition","_removeCallbackFunc","_mode","_clusterShow","text","_relativeSize","_updateClamping","defineProperties","prototype","get","set","value","glyphs","i","len","length","billboard","backgroundBillboard","equals","renderedValue","filterUnsupportedCharacters","enableRightToLeftDetection","reverseRtl","color","glyph","totalScale","pickId","_clampedPosition","clusterShow","computeScreenSpacePosition","scene","result","modelMatrix","actualPosition","windowCoordinates","_computeScreenSpacePosition","getScreenSpaceBoundingBox","screenSpacePosition","x","y","width","height","_translate","BOTTOM","CENTER","Number","POSITIVE_INFINITY","maxX","maxY","glyphX","glyphY","glyphWidth","dimensions","glyphHeight","TOP","PADDING","Math","min","max","problematicCharactersRegex","RegExp","other","isDestroyed","convertTextToTypes","rtlChars","ltrChars","bracketsChars","parsedText","word","lastType","currentType","textLength","textIndex","character","charAt","test","Type","Word","reverseWord","split","reverse","join","spliceWord","pointer","slice","reverseBrackets","bracket","hebrew","arabic","texts","rtlDir","splicePointer","line","wordIndex","subText"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Label.js"],"sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Billboard from \"./Billboard.js\";\nimport HeightReference from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport LabelStyle from \"./LabelStyle.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\n\nconst fontInfoCache = {};\nlet fontInfoCacheLength = 0;\nconst fontInfoCacheMaxSize = 256;\nconst defaultBackgroundColor = new Color(0.165, 0.165, 0.165, 0.8);\nconst defaultBackgroundPadding = new Cartesian2(7, 5);\n\nconst textTypes = Object.freeze({\n  LTR: 0,\n  RTL: 1,\n  WEAK: 2,\n  BRACKETS: 3,\n});\n\nfunction rebindAllGlyphs(label) {\n  if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {\n    // only push label if it's not already been marked dirty\n    label._labelCollection._labelsToUpdate.push(label);\n  }\n  label._rebindAllGlyphs = true;\n}\n\nfunction repositionAllGlyphs(label) {\n  if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {\n    // only push label if it's not already been marked dirty\n    label._labelCollection._labelsToUpdate.push(label);\n  }\n  label._repositionAllGlyphs = true;\n}\n\nfunction getCSSValue(element, property) {\n  return document.defaultView\n    .getComputedStyle(element, null)\n    .getPropertyValue(property);\n}\n\nfunction parseFont(label) {\n  let fontInfo = fontInfoCache[label._font];\n  if (!defined(fontInfo)) {\n    const div = document.createElement(\"div\");\n    div.style.position = \"absolute\";\n    div.style.opacity = 0;\n    div.style.font = label._font;\n    document.body.appendChild(div);\n\n    let lineHeight = parseFloat(getCSSValue(div, \"line-height\"));\n    if (isNaN(lineHeight)) {\n      // line-height isn't a number, i.e. 'normal'; apply default line-spacing\n      lineHeight = undefined;\n    }\n\n    fontInfo = {\n      family: getCSSValue(div, \"font-family\"),\n      size: getCSSValue(div, \"font-size\").replace(\"px\", \"\"),\n      style: getCSSValue(div, \"font-style\"),\n      weight: getCSSValue(div, \"font-weight\"),\n      lineHeight: lineHeight,\n    };\n\n    document.body.removeChild(div);\n    if (fontInfoCacheLength < fontInfoCacheMaxSize) {\n      fontInfoCache[label._font] = fontInfo;\n      fontInfoCacheLength++;\n    }\n  }\n  label._fontFamily = fontInfo.family;\n  label._fontSize = fontInfo.size;\n  label._fontStyle = fontInfo.style;\n  label._fontWeight = fontInfo.weight;\n  label._lineHeight = fontInfo.lineHeight;\n}\n\n/**\n * @typedef {object} Label.ConstructorOptions\n *\n * Initialization options for the Label constructor\n *\n * @property {Cartesian3} position The cartesian position of the label.\n * @property {*} [id] A user-defined object to return when the label is picked with {@link Scene#pick}.\n * @property {boolean} [show=true] Determines if this label will be shown.\n * @property {string} [text] A string specifying the text of the label.\n * @property {string} [font='30px sans-serif'] A string specifying the font used to draw this label. Fonts are specified using the same syntax as the CSS 'font' property.\n * @property {LabelStyle} [style=LabelStyle.FILL] A {@link LabelStyle} specifying the style of the label.\n * @property {number} [scale=1.0] A number specifying the uniform scale that is multiplied with the label size.\n * @property {boolean} [showBackground=false] Determines if a background behind this label will be shown.\n * @property {Color} [backgroundColor=new Color(0.165, 0.165, 0.165, 0.8)] A {@link Color} specifying the background color of the label.\n * @property {Cartesian2} [backgroundPadding=new Cartesian2(7, 5)] A {@link Cartesian2} Specifying the horizontal and vertical background padding in pixels.\n * @property {Cartesian2} [pixelOffset=Cartesian2.ZERO] A {@link Cartesian2} specifying the pixel offset in screen space from the origin of this label.\n * @property {Cartesian3} [eyeOffset=Cartesian3.ZERO] A {@link Cartesian3} specifying the 3D Cartesian offset applied to this label in eye coordinates.\n * @property {HorizontalOrigin} [horizontalOrigin=HorizontalOrigin.LEFT] A {@link HorizontalOrigin} specifying the horizontal origin of this label.\n * @property {VerticalOrigin} [verticalOrigin=VerticalOrigin.BASELINE] A {@link VerticalOrigin} specifying the vertical origin of this label.\n * @property {HeightReference} [heightReference=HeightReference.NONE] A {@link HeightReference} specifying the height reference of this label.\n * @property {Color} [fillColor=Color.WHITE] A {@link Color} specifying the fill color of the label.\n * @property {Color} [outlineColor=Color.BLACK] A {@link Color} specifying the outline color of the label.\n * @property {number} [outlineWidth=1.0] A number specifying the outline width of the label.\n * @property {NearFarScalar} [translucencyByDistance] A {@link NearFarScalar} specifying near and far translucency properties of the label based on the label's distance from the camera.\n * @property {NearFarScalar} [pixelOffsetScaleByDistance] A {@link NearFarScalar} specifying near and far pixel offset scaling properties of the label based on the label's distance from the camera.\n * @property {NearFarScalar} [scaleByDistance] A {@link NearFarScalar} specifying near and far scaling properties of the label based on the label's distance from the camera.\n * @property {DistanceDisplayCondition} [distanceDisplayCondition] A {@link DistanceDisplayCondition} specifying at what distance from the camera that this label will be displayed.\n * @property {number} [disableDepthTestDistance] A number specifying the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.\n */\n\n/**\n * <div class=\"notice\">\n * Create labels by calling {@link LabelCollection#add}. Do not call the constructor directly.\n * </div>\n *\n * @alias Label\n * @internalConstructor\n * @class\n *\n * @param {Label.ConstructorOptions} options Object describing initialization options\n * @param {LabelCollection} labelCollection Instance of LabelCollection\n *\n * @exception {DeveloperError} translucencyByDistance.far must be greater than translucencyByDistance.near\n * @exception {DeveloperError} pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near\n * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near\n *\n * @see LabelCollection\n * @see LabelCollection#add\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Labels.html|Cesium Sandcastle Labels Demo}\n */\nfunction Label(options, labelCollection) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    defined(options.disableDepthTestDistance) &&\n    options.disableDepthTestDistance < 0.0\n  ) {\n    throw new DeveloperError(\n      \"disableDepthTestDistance must be greater than 0.0.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  let translucencyByDistance = options.translucencyByDistance;\n  let pixelOffsetScaleByDistance = options.pixelOffsetScaleByDistance;\n  let scaleByDistance = options.scaleByDistance;\n  let distanceDisplayCondition = options.distanceDisplayCondition;\n  if (defined(translucencyByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (translucencyByDistance.far <= translucencyByDistance.near) {\n      throw new DeveloperError(\n        \"translucencyByDistance.far must be greater than translucencyByDistance.near.\",\n      );\n    }\n    //>>includeEnd('debug');\n    translucencyByDistance = NearFarScalar.clone(translucencyByDistance);\n  }\n  if (defined(pixelOffsetScaleByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (pixelOffsetScaleByDistance.far <= pixelOffsetScaleByDistance.near) {\n      throw new DeveloperError(\n        \"pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near.\",\n      );\n    }\n    //>>includeEnd('debug');\n    pixelOffsetScaleByDistance = NearFarScalar.clone(\n      pixelOffsetScaleByDistance,\n    );\n  }\n  if (defined(scaleByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (scaleByDistance.far <= scaleByDistance.near) {\n      throw new DeveloperError(\n        \"scaleByDistance.far must be greater than scaleByDistance.near.\",\n      );\n    }\n    //>>includeEnd('debug');\n    scaleByDistance = NearFarScalar.clone(scaleByDistance);\n  }\n  if (defined(distanceDisplayCondition)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (distanceDisplayCondition.far <= distanceDisplayCondition.near) {\n      throw new DeveloperError(\n        \"distanceDisplayCondition.far must be greater than distanceDisplayCondition.near.\",\n      );\n    }\n    //>>includeEnd('debug');\n    distanceDisplayCondition = DistanceDisplayCondition.clone(\n      distanceDisplayCondition,\n    );\n  }\n\n  this._renderedText = undefined;\n  this._text = undefined;\n  this._show = defaultValue(options.show, true);\n  this._font = defaultValue(options.font, \"30px sans-serif\");\n  this._fillColor = Color.clone(defaultValue(options.fillColor, Color.WHITE));\n  this._outlineColor = Color.clone(\n    defaultValue(options.outlineColor, Color.BLACK),\n  );\n  this._outlineWidth = defaultValue(options.outlineWidth, 1.0);\n  this._showBackground = defaultValue(options.showBackground, false);\n  this._backgroundColor = Color.clone(\n    defaultValue(options.backgroundColor, defaultBackgroundColor),\n  );\n  this._backgroundPadding = Cartesian2.clone(\n    defaultValue(options.backgroundPadding, defaultBackgroundPadding),\n  );\n  this._style = defaultValue(options.style, LabelStyle.FILL);\n  this._verticalOrigin = defaultValue(\n    options.verticalOrigin,\n    VerticalOrigin.BASELINE,\n  );\n  this._horizontalOrigin = defaultValue(\n    options.horizontalOrigin,\n    HorizontalOrigin.LEFT,\n  );\n  this._pixelOffset = Cartesian2.clone(\n    defaultValue(options.pixelOffset, Cartesian2.ZERO),\n  );\n  this._eyeOffset = Cartesian3.clone(\n    defaultValue(options.eyeOffset, Cartesian3.ZERO),\n  );\n  this._position = Cartesian3.clone(\n    defaultValue(options.position, Cartesian3.ZERO),\n  );\n  this._scale = defaultValue(options.scale, 1.0);\n  this._id = options.id;\n  this._translucencyByDistance = translucencyByDistance;\n  this._pixelOffsetScaleByDistance = pixelOffsetScaleByDistance;\n  this._scaleByDistance = scaleByDistance;\n  this._heightReference = defaultValue(\n    options.heightReference,\n    HeightReference.NONE,\n  );\n  this._distanceDisplayCondition = distanceDisplayCondition;\n  this._disableDepthTestDistance = options.disableDepthTestDistance;\n\n  this._labelCollection = labelCollection;\n  this._glyphs = [];\n  this._backgroundBillboard = undefined;\n  this._batchIndex = undefined; // Used only by Vector3DTilePoints and BillboardCollection\n\n  this._rebindAllGlyphs = true;\n  this._repositionAllGlyphs = true;\n\n  this._actualClampedPosition = undefined;\n  this._removeCallbackFunc = undefined;\n  this._mode = undefined;\n\n  this._clusterShow = true;\n\n  this.text = defaultValue(options.text, \"\");\n\n  this._relativeSize = 1.0;\n\n  parseFont(this);\n\n  this._updateClamping();\n}\n\nObject.defineProperties(Label.prototype, {\n  /**\n   * Determines if this label will be shown.  Use this to hide or show a label, instead\n   * of removing it and re-adding it to the collection.\n   * @memberof Label.prototype\n   * @type {boolean}\n   * @default true\n   */\n  show: {\n    get: function () {\n      return this._show;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._show !== value) {\n        this._show = value;\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const billboard = glyphs[i].billboard;\n          if (defined(billboard)) {\n            billboard.show = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.show = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the Cartesian position of this label.\n   * @memberof Label.prototype\n   * @type {Cartesian3}\n   */\n  position: {\n    get: function () {\n      return this._position;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const position = this._position;\n      if (!Cartesian3.equals(position, value)) {\n        Cartesian3.clone(value, position);\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const billboard = glyphs[i].billboard;\n          if (defined(billboard)) {\n            billboard.position = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.position = value;\n        }\n\n        this._updateClamping();\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the height reference of this billboard.\n   * @memberof Label.prototype\n   * @type {HeightReference}\n   * @default HeightReference.NONE\n   */\n  heightReference: {\n    get: function () {\n      return this._heightReference;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (value !== this._heightReference) {\n        this._heightReference = value;\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const billboard = glyphs[i].billboard;\n          if (defined(billboard)) {\n            billboard.heightReference = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.heightReference = value;\n        }\n\n        repositionAllGlyphs(this);\n\n        this._updateClamping();\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the text of this label.\n   * @memberof Label.prototype\n   * @type {string}\n   */\n  text: {\n    get: function () {\n      return this._text;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._text !== value) {\n        this._text = value;\n\n        const renderedValue = Label.filterUnsupportedCharacters(value);\n        this._renderedText = Label.enableRightToLeftDetection\n          ? reverseRtl(renderedValue)\n          : renderedValue;\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the font used to draw this label. Fonts are specified using the same syntax as the CSS 'font' property.\n   * @memberof Label.prototype\n   * @type {string}\n   * @default '30px sans-serif'\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles|HTML canvas 2D context text styles}\n   */\n  font: {\n    get: function () {\n      return this._font;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._font !== value) {\n        this._font = value;\n        rebindAllGlyphs(this);\n        parseFont(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the fill color of this label.\n   * @memberof Label.prototype\n   * @type {Color}\n   * @default Color.WHITE\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}\n   */\n  fillColor: {\n    get: function () {\n      return this._fillColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const fillColor = this._fillColor;\n      if (!Color.equals(fillColor, value)) {\n        Color.clone(value, fillColor);\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the outline color of this label.\n   * @memberof Label.prototype\n   * @type {Color}\n   * @default Color.BLACK\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}\n   */\n  outlineColor: {\n    get: function () {\n      return this._outlineColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const outlineColor = this._outlineColor;\n      if (!Color.equals(outlineColor, value)) {\n        Color.clone(value, outlineColor);\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the outline width of this label.\n   * @memberof Label.prototype\n   * @type {number}\n   * @default 1.0\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}\n   */\n  outlineWidth: {\n    get: function () {\n      return this._outlineWidth;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._outlineWidth !== value) {\n        this._outlineWidth = value;\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Determines if a background behind this label will be shown.\n   * @memberof Label.prototype\n   * @default false\n   * @type {boolean}\n   */\n  showBackground: {\n    get: function () {\n      return this._showBackground;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._showBackground !== value) {\n        this._showBackground = value;\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the background color of this label.\n   * @memberof Label.prototype\n   * @type {Color}\n   * @default new Color(0.165, 0.165, 0.165, 0.8)\n   */\n  backgroundColor: {\n    get: function () {\n      return this._backgroundColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const backgroundColor = this._backgroundColor;\n      if (!Color.equals(backgroundColor, value)) {\n        Color.clone(value, backgroundColor);\n\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.color = backgroundColor;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the background padding, in pixels, of this label.  The <code>x</code> value\n   * controls horizontal padding, and the <code>y</code> value controls vertical padding.\n   * @memberof Label.prototype\n   * @type {Cartesian2}\n   * @default new Cartesian2(7, 5)\n   */\n  backgroundPadding: {\n    get: function () {\n      return this._backgroundPadding;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const backgroundPadding = this._backgroundPadding;\n      if (!Cartesian2.equals(backgroundPadding, value)) {\n        Cartesian2.clone(value, backgroundPadding);\n        repositionAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the style of this label.\n   * @memberof Label.prototype\n   * @type {LabelStyle}\n   * @default LabelStyle.FILL\n   */\n  style: {\n    get: function () {\n      return this._style;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._style !== value) {\n        this._style = value;\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the pixel offset in screen space from the origin of this label.  This is commonly used\n   * to align multiple labels and billboards at the same position, e.g., an image and text.  The\n   * screen space origin is the top, left corner of the canvas; <code>x</code> increases from\n   * left to right, and <code>y</code> increases from top to bottom.\n   * <br /><br />\n   * <div align='center'>\n   * <table border='0' cellpadding='5'><tr>\n   * <td align='center'><code>default</code><br/><img src='Images/Label.setPixelOffset.default.png' width='250' height='188' /></td>\n   * <td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='Images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>\n   * </tr></table>\n   * The label's origin is indicated by the yellow point.\n   * </div>\n   * @memberof Label.prototype\n   * @type {Cartesian2}\n   * @default Cartesian2.ZERO\n   */\n  pixelOffset: {\n    get: function () {\n      return this._pixelOffset;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const pixelOffset = this._pixelOffset;\n      if (!Cartesian2.equals(pixelOffset, value)) {\n        Cartesian2.clone(value, pixelOffset);\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.pixelOffset = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.pixelOffset = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets near and far translucency properties of a Label based on the Label's distance from the camera.\n   * A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the label's translucency remains clamped to the nearest bound.  If undefined,\n   * translucencyByDistance will be disabled.\n   * @memberof Label.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a label's translucencyByDistance to 1.0 when the\n   * // camera is 1500 meters from the label and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * text.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable translucency by distance\n   * text.translucencyByDistance = undefined;\n   */\n  translucencyByDistance: {\n    get: function () {\n      return this._translucencyByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\",\n        );\n      }\n      //>>includeEnd('debug');\n\n      const translucencyByDistance = this._translucencyByDistance;\n      if (!NearFarScalar.equals(translucencyByDistance, value)) {\n        this._translucencyByDistance = NearFarScalar.clone(\n          value,\n          translucencyByDistance,\n        );\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.translucencyByDistance = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.translucencyByDistance = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets near and far pixel offset scaling properties of a Label based on the Label's distance from the camera.\n   * A label's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the label's pixel offset scaling remains clamped to the nearest bound.  If undefined,\n   * pixelOffsetScaleByDistance will be disabled.\n   * @memberof Label.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a label's pixel offset scale to 0.0 when the\n   * // camera is 1500 meters from the label and scale pixel offset to 10.0 pixels\n   * // in the y direction the camera distance approaches 8.0e6 meters.\n   * text.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);\n   * text.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable pixel offset by distance\n   * text.pixelOffsetScaleByDistance = undefined;\n   */\n  pixelOffsetScaleByDistance: {\n    get: function () {\n      return this._pixelOffsetScaleByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\",\n        );\n      }\n      //>>includeEnd('debug');\n\n      const pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;\n      if (!NearFarScalar.equals(pixelOffsetScaleByDistance, value)) {\n        this._pixelOffsetScaleByDistance = NearFarScalar.clone(\n          value,\n          pixelOffsetScaleByDistance,\n        );\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.pixelOffsetScaleByDistance = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.pixelOffsetScaleByDistance = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.\n   * A label's scale will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the label's scale remains clamped to the nearest bound.  If undefined,\n   * scaleByDistance will be disabled.\n   * @memberof Label.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a label's scaleByDistance to scale by 1.5 when the\n   * // camera is 1500 meters from the label and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * label.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable scaling by distance\n   * label.scaleByDistance = undefined;\n   */\n  scaleByDistance: {\n    get: function () {\n      return this._scaleByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\",\n        );\n      }\n      //>>includeEnd('debug');\n\n      const scaleByDistance = this._scaleByDistance;\n      if (!NearFarScalar.equals(scaleByDistance, value)) {\n        this._scaleByDistance = NearFarScalar.clone(value, scaleByDistance);\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.scaleByDistance = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.scaleByDistance = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets and sets the 3D Cartesian offset applied to this label in eye coordinates.  Eye coordinates is a left-handed\n   * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and\n   * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,\n   * which is typically meters.\n   * <br /><br />\n   * An eye offset is commonly used to arrange multiple label or objects at the same position, e.g., to\n   * arrange a label above its corresponding 3D model.\n   * <br /><br />\n   * Below, the label is positioned at the center of the Earth but an eye offset makes it always\n   * appear on top of the Earth regardless of the viewer's or Earth's orientation.\n   * <br /><br />\n   * <div align='center'>\n   * <table border='0' cellpadding='5'><tr>\n   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>\n   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>\n   * </tr></table>\n   * <code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />\n   * </div>\n   * @memberof Label.prototype\n   * @type {Cartesian3}\n   * @default Cartesian3.ZERO\n   */\n  eyeOffset: {\n    get: function () {\n      return this._eyeOffset;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const eyeOffset = this._eyeOffset;\n      if (!Cartesian3.equals(eyeOffset, value)) {\n        Cartesian3.clone(value, eyeOffset);\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.eyeOffset = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.eyeOffset = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the horizontal origin of this label, which determines if the label is drawn\n   * to the left, center, or right of its anchor position.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />\n   * </div>\n   * @memberof Label.prototype\n   * @type {HorizontalOrigin}\n   * @default HorizontalOrigin.LEFT\n   * @example\n   * // Use a top, right origin\n   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;\n   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;\n   */\n  horizontalOrigin: {\n    get: function () {\n      return this._horizontalOrigin;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._horizontalOrigin !== value) {\n        this._horizontalOrigin = value;\n        repositionAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the vertical origin of this label, which determines if the label is\n   * to the above, below, or at the center of its anchor position.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />\n   * </div>\n   * @memberof Label.prototype\n   * @type {VerticalOrigin}\n   * @default VerticalOrigin.BASELINE\n   * @example\n   * // Use a top, right origin\n   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;\n   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;\n   */\n  verticalOrigin: {\n    get: function () {\n      return this._verticalOrigin;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._verticalOrigin !== value) {\n        this._verticalOrigin = value;\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.verticalOrigin = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.verticalOrigin = value;\n        }\n\n        repositionAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the uniform scale that is multiplied with the label's size in pixels.\n   * A scale of <code>1.0</code> does not change the size of the label; a scale greater than\n   * <code>1.0</code> enlarges the label; a positive scale less than <code>1.0</code> shrinks\n   * the label.\n   * <br /><br />\n   * Applying a large scale value may pixelate the label.  To make text larger without pixelation,\n   * use a larger font size when calling {@link Label#font} instead.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Label.setScale.png' width='400' height='300' /><br/>\n   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,\n   * and <code>2.0</code>.\n   * </div>\n   * @memberof Label.prototype\n   * @type {number}\n   * @default 1.0\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._scale !== value) {\n        this._scale = value;\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.scale = value * this._relativeSize;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.scale = value * this._relativeSize;\n        }\n\n        repositionAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets the total scale of the label, which is the label's scale multiplied by the computed relative size\n   * of the desired font compared to the generated glyph size.\n   * @memberof Label.prototype\n   * @type {number}\n   * @default 1.0\n   */\n  totalScale: {\n    get: function () {\n      return this._scale * this._relativeSize;\n    },\n  },\n\n  /**\n   * Gets or sets the condition specifying at what distance from the camera that this label will be displayed.\n   * @memberof Label.prototype\n   * @type {DistanceDisplayCondition}\n   * @default undefined\n   */\n  distanceDisplayCondition: {\n    get: function () {\n      return this._distanceDisplayCondition;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far must be greater than near\");\n      }\n      //>>includeEnd('debug');\n      if (\n        !DistanceDisplayCondition.equals(value, this._distanceDisplayCondition)\n      ) {\n        this._distanceDisplayCondition = DistanceDisplayCondition.clone(\n          value,\n          this._distanceDisplayCondition,\n        );\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.distanceDisplayCondition = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.distanceDisplayCondition = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.\n   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.\n   * @memberof Label.prototype\n   * @type {number}\n   */\n  disableDepthTestDistance: {\n    get: function () {\n      return this._disableDepthTestDistance;\n    },\n    set: function (value) {\n      if (this._disableDepthTestDistance !== value) {\n        //>>includeStart('debug', pragmas.debug);\n        if (defined(value) && value < 0.0) {\n          throw new DeveloperError(\n            \"disableDepthTestDistance must be greater than 0.0.\",\n          );\n        }\n        //>>includeEnd('debug');\n        this._disableDepthTestDistance = value;\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.disableDepthTestDistance = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.disableDepthTestDistance = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the user-defined value returned when the label is picked.\n   * @memberof Label.prototype\n   * @type {*}\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n    set: function (value) {\n      if (this._id !== value) {\n        this._id = value;\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.id = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.id = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * @private\n   */\n  pickId: {\n    get: function () {\n      if (this._glyphs.length === 0 || !defined(this._glyphs[0].billboard)) {\n        return undefined;\n      }\n      return this._glyphs[0].billboard.pickId;\n    },\n  },\n\n  /**\n   * Keeps track of the position of the label based on the height reference.\n   * @memberof Label.prototype\n   * @type {Cartesian3}\n   * @private\n   */\n  _clampedPosition: {\n    get: function () {\n      return this._actualClampedPosition;\n    },\n    set: function (value) {\n      this._actualClampedPosition = Cartesian3.clone(\n        value,\n        this._actualClampedPosition,\n      );\n\n      const glyphs = this._glyphs;\n      for (let i = 0, len = glyphs.length; i < len; i++) {\n        const glyph = glyphs[i];\n        if (defined(glyph.billboard)) {\n          // Set all the private values here, because we already clamped to ground\n          //  so we don't want to do it again for every glyph\n          glyph.billboard._clampedPosition = value;\n        }\n      }\n      const backgroundBillboard = this._backgroundBillboard;\n      if (defined(backgroundBillboard)) {\n        backgroundBillboard._clampedPosition = value;\n      }\n    },\n  },\n\n  /**\n   * Determines whether or not this label will be shown or hidden because it was clustered.\n   * @memberof Label.prototype\n   * @type {boolean}\n   * @default true\n   * @private\n   */\n  clusterShow: {\n    get: function () {\n      return this._clusterShow;\n    },\n    set: function (value) {\n      if (this._clusterShow !== value) {\n        this._clusterShow = value;\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.clusterShow = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.clusterShow = value;\n        }\n      }\n    },\n  },\n});\n\nLabel.prototype._updateClamping = function () {\n  Billboard._updateClamping(this._labelCollection, this);\n};\n\n/**\n * Computes the screen-space position of the label's origin, taking into account eye and pixel offsets.\n * The screen space origin is the top, left corner of the canvas; <code>x</code> increases from\n * left to right, and <code>y</code> increases from top to bottom.\n *\n * @param {Scene} scene The scene the label is in.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The screen-space position of the label.\n *\n *\n * @example\n * console.log(l.computeScreenSpacePosition(scene).toString());\n *\n * @see Label#eyeOffset\n * @see Label#pixelOffset\n */\nLabel.prototype.computeScreenSpacePosition = function (scene, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  const labelCollection = this._labelCollection;\n  const modelMatrix = labelCollection.modelMatrix;\n  const actualPosition = defined(this._actualClampedPosition)\n    ? this._actualClampedPosition\n    : this._position;\n\n  const windowCoordinates = Billboard._computeScreenSpacePosition(\n    modelMatrix,\n    actualPosition,\n    this._eyeOffset,\n    this._pixelOffset,\n    scene,\n    result,\n  );\n  return windowCoordinates;\n};\n\n/**\n * Gets a label's screen space bounding box centered around screenSpacePosition.\n * @param {Label} label The label to get the screen space bounding box for.\n * @param {Cartesian2} screenSpacePosition The screen space center of the label.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The screen space bounding box.\n *\n * @private\n */\nLabel.getScreenSpaceBoundingBox = function (\n  label,\n  screenSpacePosition,\n  result,\n) {\n  let x = 0;\n  let y = 0;\n  let width = 0;\n  let height = 0;\n  const scale = label.totalScale;\n\n  const backgroundBillboard = label._backgroundBillboard;\n  if (defined(backgroundBillboard)) {\n    x = screenSpacePosition.x + backgroundBillboard._translate.x;\n    y = screenSpacePosition.y - backgroundBillboard._translate.y;\n    width = backgroundBillboard.width * scale;\n    height = backgroundBillboard.height * scale;\n\n    if (\n      label.verticalOrigin === VerticalOrigin.BOTTOM ||\n      label.verticalOrigin === VerticalOrigin.BASELINE\n    ) {\n      y -= height;\n    } else if (label.verticalOrigin === VerticalOrigin.CENTER) {\n      y -= height * 0.5;\n    }\n  } else {\n    x = Number.POSITIVE_INFINITY;\n    y = Number.POSITIVE_INFINITY;\n    let maxX = 0;\n    let maxY = 0;\n    const glyphs = label._glyphs;\n    const length = glyphs.length;\n    for (let i = 0; i < length; ++i) {\n      const glyph = glyphs[i];\n      const billboard = glyph.billboard;\n      if (!defined(billboard)) {\n        continue;\n      }\n\n      const glyphX = screenSpacePosition.x + billboard._translate.x;\n      let glyphY = screenSpacePosition.y - billboard._translate.y;\n      const glyphWidth = glyph.dimensions.width * scale;\n      const glyphHeight = glyph.dimensions.height * scale;\n\n      if (\n        label.verticalOrigin === VerticalOrigin.BOTTOM ||\n        label.verticalOrigin === VerticalOrigin.BASELINE\n      ) {\n        glyphY -= glyphHeight;\n      } else if (label.verticalOrigin === VerticalOrigin.CENTER) {\n        glyphY -= glyphHeight * 0.5;\n      }\n\n      if (label._verticalOrigin === VerticalOrigin.TOP) {\n        glyphY += SDFSettings.PADDING * scale;\n      } else if (\n        label._verticalOrigin === VerticalOrigin.BOTTOM ||\n        label._verticalOrigin === VerticalOrigin.BASELINE\n      ) {\n        glyphY -= SDFSettings.PADDING * scale;\n      }\n\n      x = Math.min(x, glyphX);\n      y = Math.min(y, glyphY);\n      maxX = Math.max(maxX, glyphX + glyphWidth);\n      maxY = Math.max(maxY, glyphY + glyphHeight);\n    }\n\n    width = maxX - x;\n    height = maxY - y;\n  }\n\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  result.x = x;\n  result.y = y;\n  result.width = width;\n  result.height = height;\n\n  return result;\n};\n\n/**\n * Removes control characters and soft hyphon (auto-wrap) characters, which will cause an error when rendering a glyph. This does not remove tabs, carriage returns, or newlines.\n * @private\n * @param {string} text The original label text\n * @returns {string} The renderable filtered text\n */\nLabel.filterUnsupportedCharacters = function (text) {\n  const problematicCharactersRegex = new RegExp(\n    // eslint-disable-next-line no-control-regex\n    /[\\u0000-\\u0008\\u000E-\\u001F\\u00ad\\u202a-\\u206f\\u200b-\\u200f]/,\n    \"g\",\n  );\n  return text.replace(problematicCharactersRegex, \"\");\n};\n\n/**\n * Determines if this label equals another label.  Labels are equal if all their properties\n * are equal.  Labels in different collections can be equal.\n *\n * @param {Label} other The label to compare for equality.\n * @returns {boolean} <code>true</code> if the labels are equal; otherwise, <code>false</code>.\n */\nLabel.prototype.equals = function (other) {\n  return (\n    this === other ||\n    (defined(other) &&\n      this._show === other._show &&\n      this._scale === other._scale &&\n      this._outlineWidth === other._outlineWidth &&\n      this._showBackground === other._showBackground &&\n      this._style === other._style &&\n      this._verticalOrigin === other._verticalOrigin &&\n      this._horizontalOrigin === other._horizontalOrigin &&\n      this._heightReference === other._heightReference &&\n      this._renderedText === other._renderedText &&\n      this._font === other._font &&\n      Cartesian3.equals(this._position, other._position) &&\n      Color.equals(this._fillColor, other._fillColor) &&\n      Color.equals(this._outlineColor, other._outlineColor) &&\n      Color.equals(this._backgroundColor, other._backgroundColor) &&\n      Cartesian2.equals(this._backgroundPadding, other._backgroundPadding) &&\n      Cartesian2.equals(this._pixelOffset, other._pixelOffset) &&\n      Cartesian3.equals(this._eyeOffset, other._eyeOffset) &&\n      NearFarScalar.equals(\n        this._translucencyByDistance,\n        other._translucencyByDistance,\n      ) &&\n      NearFarScalar.equals(\n        this._pixelOffsetScaleByDistance,\n        other._pixelOffsetScaleByDistance,\n      ) &&\n      NearFarScalar.equals(this._scaleByDistance, other._scaleByDistance) &&\n      DistanceDisplayCondition.equals(\n        this._distanceDisplayCondition,\n        other._distanceDisplayCondition,\n      ) &&\n      this._disableDepthTestDistance === other._disableDepthTestDistance &&\n      this._id === other._id)\n  );\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} True if this object was destroyed; otherwise, false.\n */\nLabel.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Determines whether or not run the algorithm, that match the text of the label to right-to-left languages\n * @memberof Label\n * @type {boolean}\n * @default false\n *\n * @example\n * // Example 1.\n * // Set a label's rightToLeft before init\n * Cesium.Label.enableRightToLeftDetection = true;\n * const myLabelEntity = viewer.entities.add({\n *   label: {\n *     id: 'my label',\n *     text: 'זה טקסט בעברית \\n ועכשיו יורדים שורה',\n *   }\n * });\n *\n * @example\n * // Example 2.\n * const myLabelEntity = viewer.entities.add({\n *   label: {\n *     id: 'my label',\n *     text: 'English text'\n *   }\n * });\n * // Set a label's rightToLeft after init\n * Cesium.Label.enableRightToLeftDetection = true;\n * myLabelEntity.text = 'טקסט חדש';\n */\nLabel.enableRightToLeftDetection = false;\n\nfunction convertTextToTypes(text, rtlChars) {\n  const ltrChars = /[a-zA-Z0-9]/;\n  const bracketsChars = /[()[\\]{}<>]/;\n  const parsedText = [];\n  let word = \"\";\n  let lastType = textTypes.LTR;\n  let currentType = \"\";\n  const textLength = text.length;\n  for (let textIndex = 0; textIndex < textLength; ++textIndex) {\n    const character = text.charAt(textIndex);\n    if (rtlChars.test(character)) {\n      currentType = textTypes.RTL;\n    } else if (ltrChars.test(character)) {\n      currentType = textTypes.LTR;\n    } else if (bracketsChars.test(character)) {\n      currentType = textTypes.BRACKETS;\n    } else {\n      currentType = textTypes.WEAK;\n    }\n\n    if (textIndex === 0) {\n      lastType = currentType;\n    }\n\n    if (lastType === currentType && currentType !== textTypes.BRACKETS) {\n      word += character;\n    } else {\n      if (word !== \"\") {\n        parsedText.push({ Type: lastType, Word: word });\n      }\n      lastType = currentType;\n      word = character;\n    }\n  }\n  parsedText.push({ Type: currentType, Word: word });\n  return parsedText;\n}\n\nfunction reverseWord(word) {\n  return word.split(\"\").reverse().join(\"\");\n}\n\nfunction spliceWord(result, pointer, word) {\n  return result.slice(0, pointer) + word + result.slice(pointer);\n}\n\nfunction reverseBrackets(bracket) {\n  switch (bracket) {\n    case \"(\":\n      return \")\";\n    case \")\":\n      return \"(\";\n    case \"[\":\n      return \"]\";\n    case \"]\":\n      return \"[\";\n    case \"{\":\n      return \"}\";\n    case \"}\":\n      return \"{\";\n    case \"<\":\n      return \">\";\n    case \">\":\n      return \"<\";\n  }\n}\n\n// To add another language, add its Unicode block range(s) to the below regex.\nconst hebrew = \"\\u05D0-\\u05EA\";\nconst arabic = \"\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\";\nconst rtlChars = new RegExp(`[${hebrew}${arabic}]`);\n\n/**\n *\n * @param {string} value the text to parse and reorder\n * @returns {string} the text as rightToLeft direction\n * @private\n */\nfunction reverseRtl(value) {\n  const texts = value.split(\"\\n\");\n  let result = \"\";\n  for (let i = 0; i < texts.length; i++) {\n    const text = texts[i];\n    // first character of the line is a RTL character, so need to manage different cases\n    const rtlDir = rtlChars.test(text.charAt(0));\n    const parsedText = convertTextToTypes(text, rtlChars);\n\n    let splicePointer = 0;\n    let line = \"\";\n    for (let wordIndex = 0; wordIndex < parsedText.length; ++wordIndex) {\n      const subText = parsedText[wordIndex];\n      const reverse =\n        subText.Type === textTypes.BRACKETS\n          ? reverseBrackets(subText.Word)\n          : reverseWord(subText.Word);\n      if (rtlDir) {\n        if (subText.Type === textTypes.RTL) {\n          line = reverse + line;\n          splicePointer = 0;\n        } else if (subText.Type === textTypes.LTR) {\n          line = spliceWord(line, splicePointer, subText.Word);\n          splicePointer += subText.Word.length;\n        } else if (\n          subText.Type === textTypes.WEAK ||\n          subText.Type === textTypes.BRACKETS\n        ) {\n          // current word is weak, last one was bracket\n          if (\n            subText.Type === textTypes.WEAK &&\n            parsedText[wordIndex - 1].Type === textTypes.BRACKETS\n          ) {\n            line = reverse + line;\n          }\n          // current word is weak or bracket, last one was rtl\n          else if (parsedText[wordIndex - 1].Type === textTypes.RTL) {\n            line = reverse + line;\n            splicePointer = 0;\n          }\n          // current word is weak or bracket, there is at least one more word\n          else if (parsedText.length > wordIndex + 1) {\n            // next word is rtl\n            if (parsedText[wordIndex + 1].Type === textTypes.RTL) {\n              line = reverse + line;\n              splicePointer = 0;\n            } else {\n              line = spliceWord(line, splicePointer, subText.Word);\n              splicePointer += subText.Word.length;\n            }\n          }\n          // current word is weak or bracket, and it the last in this line\n          else {\n            line = spliceWord(line, 0, reverse);\n          }\n        }\n      }\n      // ltr line, rtl word\n      else if (subText.Type === textTypes.RTL) {\n        line = spliceWord(line, splicePointer, reverse);\n      }\n      // ltr line, ltr word\n      else if (subText.Type === textTypes.LTR) {\n        line += subText.Word;\n        splicePointer = line.length;\n      }\n      // ltr line, weak or bracket word\n      else if (\n        subText.Type === textTypes.WEAK ||\n        subText.Type === textTypes.BRACKETS\n      ) {\n        // not first word in line\n        if (wordIndex > 0) {\n          // last word was rtl\n          if (parsedText[wordIndex - 1].Type === textTypes.RTL) {\n            // there is at least one more word\n            if (parsedText.length > wordIndex + 1) {\n              // next word is rtl\n              if (parsedText[wordIndex + 1].Type === textTypes.RTL) {\n                line = spliceWord(line, splicePointer, reverse);\n              } else {\n                line += subText.Word;\n                splicePointer = line.length;\n              }\n            } else {\n              line += subText.Word;\n            }\n          } else {\n            line += subText.Word;\n            splicePointer = line.length;\n          }\n        } else {\n          line += subText.Word;\n          splicePointer = line.length;\n        }\n      }\n    }\n\n    result += line;\n    if (i < texts.length - 1) {\n      result += \"\\n\";\n    }\n  }\n  return result;\n}\nexport default Label;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}