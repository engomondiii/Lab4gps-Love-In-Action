{"ast":null,"code":"import AttributeType from \"../AttributeType.js\";\nimport combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport MorphTargetsStageVS from \"../../Shaders/Model/MorphTargetsStageVS.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * The morph targets pipeline stage processes the morph targets and weights of a primitive.\n *\n * @namespace MorphTargetsPipelineStage\n *\n * @private\n */\nconst MorphTargetsPipelineStage = {\n  name: \"MorphTargetsPipelineStage\",\n  // Helps with debugging\n\n  FUNCTION_ID_GET_MORPHED_POSITION: \"getMorphedPosition\",\n  FUNCTION_SIGNATURE_GET_MORPHED_POSITION: \"vec3 getMorphedPosition(in vec3 position)\",\n  FUNCTION_ID_GET_MORPHED_NORMAL: \"getMorphedNormal\",\n  FUNCTION_SIGNATURE_GET_MORPHED_NORMAL: \"vec3 getMorphedNormal(in vec3 normal)\",\n  FUNCTION_ID_GET_MORPHED_TANGENT: \"getMorphedTangent\",\n  FUNCTION_SIGNATURE_GET_MORPHED_TANGENT: \"vec3 getMorphedTangent(in vec3 tangent)\"\n};\n\n/**\n * This pipeline stage processes the morph targets and weights of a primitive,\n * adding the relevant attribute declarations and functions to the shaders.\n *\n * Processes a primitive. This stage modifies the following parts of the render resources:\n * <ul>\n *  <li> adds attribute declarations for the morph targets in the vertex shader\n *  <li> adds the uniform declaration for the morph weights in the vertex shader\n *  <li> adds functions to apply the morphs in the vertex shader\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n *\n * @private\n */\nMorphTargetsPipelineStage.process = function (renderResources, primitive) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addDefine(\"HAS_MORPH_TARGETS\", undefined, ShaderDestination.VERTEX);\n  addGetMorphedAttributeFunctionDeclarations(shaderBuilder);\n  const morphTargetsLength = primitive.morphTargets.length;\n  for (let i = 0; i < morphTargetsLength; i++) {\n    const attributes = primitive.morphTargets[i].attributes;\n    const attributesLength = attributes.length;\n    for (let j = 0; j < attributesLength; j++) {\n      const attribute = attributes[j];\n      const semantic = attribute.semantic;\n\n      // Cesium only supports morph targets for positions, normals, and tangents\n      if (semantic !== VertexAttributeSemantic.POSITION && semantic !== VertexAttributeSemantic.NORMAL && semantic !== VertexAttributeSemantic.TANGENT) {\n        continue;\n      }\n      processMorphTargetAttribute(renderResources, attribute, renderResources.attributeIndex, i);\n      renderResources.attributeIndex++;\n    }\n  }\n  addGetMorphedAttributeFunctionReturns(shaderBuilder);\n  const weights = renderResources.runtimeNode.morphWeights;\n  const weightsLength = weights.length;\n  shaderBuilder.addUniform(\"float\", `u_morphWeights[${weightsLength}]`, ShaderDestination.VERTEX);\n  shaderBuilder.addVertexLines(MorphTargetsStageVS);\n  const uniformMap = {\n    u_morphWeights: function () {\n      return renderResources.runtimeNode.morphWeights;\n    }\n  };\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\nconst scratchAttributeInfo = {\n  attributeString: undefined,\n  functionId: undefined\n};\nfunction processMorphTargetAttribute(renderResources, attribute, attributeIndex, morphTargetIndex) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  addMorphTargetAttributeToRenderResources(renderResources, attribute, attributeIndex);\n  const attributeInfo = getMorphTargetAttributeInfo(attribute, scratchAttributeInfo);\n  addMorphTargetAttributeDeclarationAndFunctionLine(shaderBuilder, attributeInfo, morphTargetIndex);\n}\nfunction addMorphTargetAttributeToRenderResources(renderResources, attribute, attributeIndex) {\n  const vertexAttribute = {\n    index: attributeIndex,\n    value: defined(attribute.buffer) ? undefined : attribute.constant,\n    vertexBuffer: attribute.buffer,\n    componentsPerAttribute: AttributeType.getNumberOfComponents(attribute.type),\n    componentDatatype: attribute.componentDatatype,\n    offsetInBytes: attribute.byteOffset,\n    strideInBytes: attribute.byteStride,\n    normalize: attribute.normalized\n  };\n  renderResources.attributes.push(vertexAttribute);\n}\nfunction getMorphTargetAttributeInfo(attribute, result) {\n  const semantic = attribute.semantic;\n  switch (semantic) {\n    case VertexAttributeSemantic.POSITION:\n      result.attributeString = \"Position\";\n      result.functionId = MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION;\n      break;\n    case VertexAttributeSemantic.NORMAL:\n      result.attributeString = \"Normal\";\n      result.functionId = MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL;\n      break;\n    case VertexAttributeSemantic.TANGENT:\n      result.attributeString = \"Tangent\";\n      result.functionId = MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT;\n      break;\n    default:\n      break;\n  }\n  return result;\n}\nfunction addMorphTargetAttributeDeclarationAndFunctionLine(shaderBuilder, attributeInfo, morphTargetIndex) {\n  const attributeString = attributeInfo.attributeString;\n  const attributeName = `a_target${attributeString}_${morphTargetIndex}`;\n  const line = `morphed${attributeString} += u_morphWeights[${morphTargetIndex}] * a_target${attributeString}_${morphTargetIndex};`;\n  shaderBuilder.addAttribute(\"vec3\", attributeName);\n  shaderBuilder.addFunctionLines(attributeInfo.functionId, [line]);\n}\nfunction addGetMorphedAttributeFunctionDeclarations(shaderBuilder) {\n  shaderBuilder.addFunction(MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION, MorphTargetsPipelineStage.FUNCTION_SIGNATURE_GET_MORPHED_POSITION, ShaderDestination.VERTEX);\n  const positionLine = \"vec3 morphedPosition = position;\";\n  shaderBuilder.addFunctionLines(MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION, [positionLine]);\n  shaderBuilder.addFunction(MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL, MorphTargetsPipelineStage.FUNCTION_SIGNATURE_GET_MORPHED_NORMAL, ShaderDestination.VERTEX);\n  const normalLine = \"vec3 morphedNormal = normal;\";\n  shaderBuilder.addFunctionLines(MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL, [normalLine]);\n  shaderBuilder.addFunction(MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT, MorphTargetsPipelineStage.FUNCTION_SIGNATURE_GET_MORPHED_TANGENT, ShaderDestination.VERTEX);\n  const tangentLine = \"vec3 morphedTangent = tangent;\";\n  shaderBuilder.addFunctionLines(MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT, [tangentLine]);\n}\nfunction addGetMorphedAttributeFunctionReturns(shaderBuilder) {\n  const positionLine = \"return morphedPosition;\";\n  shaderBuilder.addFunctionLines(MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION, [positionLine]);\n  const normalLine = \"return morphedNormal;\";\n  shaderBuilder.addFunctionLines(MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL, [normalLine]);\n  const tangentLine = \"return morphedTangent;\";\n  shaderBuilder.addFunctionLines(MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT, [tangentLine]);\n}\nexport default MorphTargetsPipelineStage;","map":{"version":3,"names":["AttributeType","combine","defined","ShaderDestination","MorphTargetsStageVS","VertexAttributeSemantic","MorphTargetsPipelineStage","name","FUNCTION_ID_GET_MORPHED_POSITION","FUNCTION_SIGNATURE_GET_MORPHED_POSITION","FUNCTION_ID_GET_MORPHED_NORMAL","FUNCTION_SIGNATURE_GET_MORPHED_NORMAL","FUNCTION_ID_GET_MORPHED_TANGENT","FUNCTION_SIGNATURE_GET_MORPHED_TANGENT","process","renderResources","primitive","shaderBuilder","addDefine","undefined","VERTEX","addGetMorphedAttributeFunctionDeclarations","morphTargetsLength","morphTargets","length","i","attributes","attributesLength","j","attribute","semantic","POSITION","NORMAL","TANGENT","processMorphTargetAttribute","attributeIndex","addGetMorphedAttributeFunctionReturns","weights","runtimeNode","morphWeights","weightsLength","addUniform","addVertexLines","uniformMap","u_morphWeights","scratchAttributeInfo","attributeString","functionId","morphTargetIndex","addMorphTargetAttributeToRenderResources","attributeInfo","getMorphTargetAttributeInfo","addMorphTargetAttributeDeclarationAndFunctionLine","vertexAttribute","index","value","buffer","constant","vertexBuffer","componentsPerAttribute","getNumberOfComponents","type","componentDatatype","offsetInBytes","byteOffset","strideInBytes","byteStride","normalize","normalized","push","result","attributeName","line","addAttribute","addFunctionLines","addFunction","positionLine","normalLine","tangentLine"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/MorphTargetsPipelineStage.js"],"sourcesContent":["import AttributeType from \"../AttributeType.js\";\nimport combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport MorphTargetsStageVS from \"../../Shaders/Model/MorphTargetsStageVS.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * The morph targets pipeline stage processes the morph targets and weights of a primitive.\n *\n * @namespace MorphTargetsPipelineStage\n *\n * @private\n */\nconst MorphTargetsPipelineStage = {\n  name: \"MorphTargetsPipelineStage\", // Helps with debugging\n\n  FUNCTION_ID_GET_MORPHED_POSITION: \"getMorphedPosition\",\n  FUNCTION_SIGNATURE_GET_MORPHED_POSITION:\n    \"vec3 getMorphedPosition(in vec3 position)\",\n  FUNCTION_ID_GET_MORPHED_NORMAL: \"getMorphedNormal\",\n  FUNCTION_SIGNATURE_GET_MORPHED_NORMAL:\n    \"vec3 getMorphedNormal(in vec3 normal)\",\n  FUNCTION_ID_GET_MORPHED_TANGENT: \"getMorphedTangent\",\n  FUNCTION_SIGNATURE_GET_MORPHED_TANGENT:\n    \"vec3 getMorphedTangent(in vec3 tangent)\",\n};\n\n/**\n * This pipeline stage processes the morph targets and weights of a primitive,\n * adding the relevant attribute declarations and functions to the shaders.\n *\n * Processes a primitive. This stage modifies the following parts of the render resources:\n * <ul>\n *  <li> adds attribute declarations for the morph targets in the vertex shader\n *  <li> adds the uniform declaration for the morph weights in the vertex shader\n *  <li> adds functions to apply the morphs in the vertex shader\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n *\n * @private\n */\nMorphTargetsPipelineStage.process = function (renderResources, primitive) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\n    \"HAS_MORPH_TARGETS\",\n    undefined,\n    ShaderDestination.VERTEX,\n  );\n\n  addGetMorphedAttributeFunctionDeclarations(shaderBuilder);\n\n  const morphTargetsLength = primitive.morphTargets.length;\n  for (let i = 0; i < morphTargetsLength; i++) {\n    const attributes = primitive.morphTargets[i].attributes;\n\n    const attributesLength = attributes.length;\n    for (let j = 0; j < attributesLength; j++) {\n      const attribute = attributes[j];\n      const semantic = attribute.semantic;\n\n      // Cesium only supports morph targets for positions, normals, and tangents\n      if (\n        semantic !== VertexAttributeSemantic.POSITION &&\n        semantic !== VertexAttributeSemantic.NORMAL &&\n        semantic !== VertexAttributeSemantic.TANGENT\n      ) {\n        continue;\n      }\n\n      processMorphTargetAttribute(\n        renderResources,\n        attribute,\n        renderResources.attributeIndex,\n        i,\n      );\n      renderResources.attributeIndex++;\n    }\n  }\n\n  addGetMorphedAttributeFunctionReturns(shaderBuilder);\n\n  const weights = renderResources.runtimeNode.morphWeights;\n  const weightsLength = weights.length;\n  shaderBuilder.addUniform(\n    \"float\",\n    `u_morphWeights[${weightsLength}]`,\n    ShaderDestination.VERTEX,\n  );\n\n  shaderBuilder.addVertexLines(MorphTargetsStageVS);\n\n  const uniformMap = {\n    u_morphWeights: function () {\n      return renderResources.runtimeNode.morphWeights;\n    },\n  };\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\n\nconst scratchAttributeInfo = {\n  attributeString: undefined,\n  functionId: undefined,\n};\n\nfunction processMorphTargetAttribute(\n  renderResources,\n  attribute,\n  attributeIndex,\n  morphTargetIndex,\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  addMorphTargetAttributeToRenderResources(\n    renderResources,\n    attribute,\n    attributeIndex,\n  );\n\n  const attributeInfo = getMorphTargetAttributeInfo(\n    attribute,\n    scratchAttributeInfo,\n  );\n\n  addMorphTargetAttributeDeclarationAndFunctionLine(\n    shaderBuilder,\n    attributeInfo,\n    morphTargetIndex,\n  );\n}\n\nfunction addMorphTargetAttributeToRenderResources(\n  renderResources,\n  attribute,\n  attributeIndex,\n) {\n  const vertexAttribute = {\n    index: attributeIndex,\n    value: defined(attribute.buffer) ? undefined : attribute.constant,\n    vertexBuffer: attribute.buffer,\n    componentsPerAttribute: AttributeType.getNumberOfComponents(attribute.type),\n    componentDatatype: attribute.componentDatatype,\n    offsetInBytes: attribute.byteOffset,\n    strideInBytes: attribute.byteStride,\n    normalize: attribute.normalized,\n  };\n\n  renderResources.attributes.push(vertexAttribute);\n}\n\nfunction getMorphTargetAttributeInfo(attribute, result) {\n  const semantic = attribute.semantic;\n  switch (semantic) {\n    case VertexAttributeSemantic.POSITION:\n      result.attributeString = \"Position\";\n      result.functionId =\n        MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION;\n      break;\n    case VertexAttributeSemantic.NORMAL:\n      result.attributeString = \"Normal\";\n      result.functionId =\n        MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL;\n      break;\n    case VertexAttributeSemantic.TANGENT:\n      result.attributeString = \"Tangent\";\n      result.functionId =\n        MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT;\n      break;\n    default:\n      break;\n  }\n  return result;\n}\n\nfunction addMorphTargetAttributeDeclarationAndFunctionLine(\n  shaderBuilder,\n  attributeInfo,\n  morphTargetIndex,\n) {\n  const attributeString = attributeInfo.attributeString;\n  const attributeName = `a_target${attributeString}_${morphTargetIndex}`;\n  const line = `morphed${attributeString} += u_morphWeights[${morphTargetIndex}] * a_target${attributeString}_${morphTargetIndex};`;\n  shaderBuilder.addAttribute(\"vec3\", attributeName);\n  shaderBuilder.addFunctionLines(attributeInfo.functionId, [line]);\n}\n\nfunction addGetMorphedAttributeFunctionDeclarations(shaderBuilder) {\n  shaderBuilder.addFunction(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION,\n    MorphTargetsPipelineStage.FUNCTION_SIGNATURE_GET_MORPHED_POSITION,\n    ShaderDestination.VERTEX,\n  );\n\n  const positionLine = \"vec3 morphedPosition = position;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION,\n    [positionLine],\n  );\n\n  shaderBuilder.addFunction(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL,\n    MorphTargetsPipelineStage.FUNCTION_SIGNATURE_GET_MORPHED_NORMAL,\n    ShaderDestination.VERTEX,\n  );\n\n  const normalLine = \"vec3 morphedNormal = normal;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL,\n    [normalLine],\n  );\n\n  shaderBuilder.addFunction(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT,\n    MorphTargetsPipelineStage.FUNCTION_SIGNATURE_GET_MORPHED_TANGENT,\n    ShaderDestination.VERTEX,\n  );\n\n  const tangentLine = \"vec3 morphedTangent = tangent;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT,\n    [tangentLine],\n  );\n}\n\nfunction addGetMorphedAttributeFunctionReturns(shaderBuilder) {\n  const positionLine = \"return morphedPosition;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION,\n    [positionLine],\n  );\n\n  const normalLine = \"return morphedNormal;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL,\n    [normalLine],\n  );\n\n  const tangentLine = \"return morphedTangent;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT,\n    [tangentLine],\n  );\n}\n\nexport default MorphTargetsPipelineStage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}