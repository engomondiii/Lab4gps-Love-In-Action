{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nconst scaleToGeodeticSurfaceIntersection = new Cartesian3();\nconst scaleToGeodeticSurfaceGradient = new Cartesian3();\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} oneOverRadii One over radii of the ellipsoid.\n * @param {Cartesian3} oneOverRadiiSquared One over radii squared of the ellipsoid.\n * @param {number} centerToleranceSquared Tolerance for closeness to the center.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n *\n * @function scaleToGeodeticSurface\n *\n * @private\n */\nfunction scaleToGeodeticSurface(cartesian, oneOverRadii, oneOverRadiiSquared, centerToleranceSquared, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  if (!defined(oneOverRadii)) {\n    throw new DeveloperError(\"oneOverRadii is required.\");\n  }\n  if (!defined(oneOverRadiiSquared)) {\n    throw new DeveloperError(\"oneOverRadiiSquared is required.\");\n  }\n  if (!defined(centerToleranceSquared)) {\n    throw new DeveloperError(\"centerToleranceSquared is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const positionX = cartesian.x;\n  const positionY = cartesian.y;\n  const positionZ = cartesian.z;\n  const oneOverRadiiX = oneOverRadii.x;\n  const oneOverRadiiY = oneOverRadii.y;\n  const oneOverRadiiZ = oneOverRadii.z;\n  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n\n  // Compute the squared ellipsoid norm.\n  const squaredNorm = x2 + y2 + z2;\n  const ratio = Math.sqrt(1.0 / squaredNorm);\n\n  // As an initial approximation, assume that the radial intersection is the projection point.\n  const intersection = Cartesian3.multiplyByScalar(cartesian, ratio, scaleToGeodeticSurfaceIntersection);\n\n  // If the position is near the center, the iteration will not converge.\n  if (squaredNorm < centerToleranceSquared) {\n    return !isFinite(ratio) ? undefined : Cartesian3.clone(intersection, result);\n  }\n  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n\n  // Use the gradient at the intersection point in place of the true unit normal.\n  // The difference in magnitude will be absorbed in the multiplier.\n  const gradient = scaleToGeodeticSurfaceGradient;\n  gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;\n  gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;\n  gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;\n\n  // Compute the initial guess at the normal vector multiplier, lambda.\n  let lambda = (1.0 - ratio) * Cartesian3.magnitude(cartesian) / (0.5 * Cartesian3.magnitude(gradient));\n  let correction = 0.0;\n  let func;\n  let denominator;\n  let xMultiplier;\n  let yMultiplier;\n  let zMultiplier;\n  let xMultiplier2;\n  let yMultiplier2;\n  let zMultiplier2;\n  let xMultiplier3;\n  let yMultiplier3;\n  let zMultiplier3;\n  do {\n    lambda -= correction;\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n    xMultiplier2 = xMultiplier * xMultiplier;\n    yMultiplier2 = yMultiplier * yMultiplier;\n    zMultiplier2 = zMultiplier * zMultiplier;\n    xMultiplier3 = xMultiplier2 * xMultiplier;\n    yMultiplier3 = yMultiplier2 * yMultiplier;\n    zMultiplier3 = zMultiplier2 * zMultiplier;\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n\n    // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n    // computations in the sections to follow.\n    denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n    const derivative = -2.0 * denominator;\n    correction = func / derivative;\n  } while (Math.abs(func) > CesiumMath.EPSILON12);\n  if (!defined(result)) {\n    return new Cartesian3(positionX * xMultiplier, positionY * yMultiplier, positionZ * zMultiplier);\n  }\n  result.x = positionX * xMultiplier;\n  result.y = positionY * yMultiplier;\n  result.z = positionZ * zMultiplier;\n  return result;\n}\nexport default scaleToGeodeticSurface;","map":{"version":3,"names":["Cartesian3","defined","DeveloperError","CesiumMath","scaleToGeodeticSurfaceIntersection","scaleToGeodeticSurfaceGradient","scaleToGeodeticSurface","cartesian","oneOverRadii","oneOverRadiiSquared","centerToleranceSquared","result","positionX","x","positionY","y","positionZ","z","oneOverRadiiX","oneOverRadiiY","oneOverRadiiZ","x2","y2","z2","squaredNorm","ratio","Math","sqrt","intersection","multiplyByScalar","isFinite","undefined","clone","oneOverRadiiSquaredX","oneOverRadiiSquaredY","oneOverRadiiSquaredZ","gradient","lambda","magnitude","correction","func","denominator","xMultiplier","yMultiplier","zMultiplier","xMultiplier2","yMultiplier2","zMultiplier2","xMultiplier3","yMultiplier3","zMultiplier3","derivative","abs","EPSILON12"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/scaleToGeodeticSurface.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\nconst scaleToGeodeticSurfaceIntersection = new Cartesian3();\nconst scaleToGeodeticSurfaceGradient = new Cartesian3();\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} oneOverRadii One over radii of the ellipsoid.\n * @param {Cartesian3} oneOverRadiiSquared One over radii squared of the ellipsoid.\n * @param {number} centerToleranceSquared Tolerance for closeness to the center.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n *\n * @function scaleToGeodeticSurface\n *\n * @private\n */\nfunction scaleToGeodeticSurface(\n  cartesian,\n  oneOverRadii,\n  oneOverRadiiSquared,\n  centerToleranceSquared,\n  result,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  if (!defined(oneOverRadii)) {\n    throw new DeveloperError(\"oneOverRadii is required.\");\n  }\n  if (!defined(oneOverRadiiSquared)) {\n    throw new DeveloperError(\"oneOverRadiiSquared is required.\");\n  }\n  if (!defined(centerToleranceSquared)) {\n    throw new DeveloperError(\"centerToleranceSquared is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const positionX = cartesian.x;\n  const positionY = cartesian.y;\n  const positionZ = cartesian.z;\n\n  const oneOverRadiiX = oneOverRadii.x;\n  const oneOverRadiiY = oneOverRadii.y;\n  const oneOverRadiiZ = oneOverRadii.z;\n\n  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n\n  // Compute the squared ellipsoid norm.\n  const squaredNorm = x2 + y2 + z2;\n  const ratio = Math.sqrt(1.0 / squaredNorm);\n\n  // As an initial approximation, assume that the radial intersection is the projection point.\n  const intersection = Cartesian3.multiplyByScalar(\n    cartesian,\n    ratio,\n    scaleToGeodeticSurfaceIntersection,\n  );\n\n  // If the position is near the center, the iteration will not converge.\n  if (squaredNorm < centerToleranceSquared) {\n    return !isFinite(ratio)\n      ? undefined\n      : Cartesian3.clone(intersection, result);\n  }\n\n  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n\n  // Use the gradient at the intersection point in place of the true unit normal.\n  // The difference in magnitude will be absorbed in the multiplier.\n  const gradient = scaleToGeodeticSurfaceGradient;\n  gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;\n  gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;\n  gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;\n\n  // Compute the initial guess at the normal vector multiplier, lambda.\n  let lambda =\n    ((1.0 - ratio) * Cartesian3.magnitude(cartesian)) /\n    (0.5 * Cartesian3.magnitude(gradient));\n  let correction = 0.0;\n\n  let func;\n  let denominator;\n  let xMultiplier;\n  let yMultiplier;\n  let zMultiplier;\n  let xMultiplier2;\n  let yMultiplier2;\n  let zMultiplier2;\n  let xMultiplier3;\n  let yMultiplier3;\n  let zMultiplier3;\n\n  do {\n    lambda -= correction;\n\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n\n    xMultiplier2 = xMultiplier * xMultiplier;\n    yMultiplier2 = yMultiplier * yMultiplier;\n    zMultiplier2 = zMultiplier * zMultiplier;\n\n    xMultiplier3 = xMultiplier2 * xMultiplier;\n    yMultiplier3 = yMultiplier2 * yMultiplier;\n    zMultiplier3 = zMultiplier2 * zMultiplier;\n\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n\n    // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n    // computations in the sections to follow.\n    denominator =\n      x2 * xMultiplier3 * oneOverRadiiSquaredX +\n      y2 * yMultiplier3 * oneOverRadiiSquaredY +\n      z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n\n    const derivative = -2.0 * denominator;\n\n    correction = func / derivative;\n  } while (Math.abs(func) > CesiumMath.EPSILON12);\n\n  if (!defined(result)) {\n    return new Cartesian3(\n      positionX * xMultiplier,\n      positionY * yMultiplier,\n      positionZ * zMultiplier,\n    );\n  }\n  result.x = positionX * xMultiplier;\n  result.y = positionY * yMultiplier;\n  result.z = positionZ * zMultiplier;\n  return result;\n}\nexport default scaleToGeodeticSurface;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}