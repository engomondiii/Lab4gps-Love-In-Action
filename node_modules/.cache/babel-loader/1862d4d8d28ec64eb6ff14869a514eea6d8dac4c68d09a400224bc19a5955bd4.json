{"ast":null,"code":"import AssociativeArray from \"./AssociativeArray.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport destroyObject from \"./destroyObject.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport FeatureDetection from \"./FeatureDetection.js\";\nimport getTimestamp from \"./getTimestamp.js\";\nimport KeyboardEventModifier from \"./KeyboardEventModifier.js\";\nimport ScreenSpaceEventType from \"./ScreenSpaceEventType.js\";\nfunction getPosition(screenSpaceEventHandler, event, result) {\n  const element = screenSpaceEventHandler._element;\n  if (element === document) {\n    result.x = event.clientX;\n    result.y = event.clientY;\n    return result;\n  }\n  const rect = element.getBoundingClientRect();\n  result.x = event.clientX - rect.left;\n  result.y = event.clientY - rect.top;\n  return result;\n}\nfunction getInputEventKey(type, modifier) {\n  let key = type;\n  if (defined(modifier)) {\n    key += `+${modifier}`;\n  }\n  return key;\n}\nfunction getModifier(event) {\n  if (event.shiftKey) {\n    return KeyboardEventModifier.SHIFT;\n  } else if (event.ctrlKey) {\n    return KeyboardEventModifier.CTRL;\n  } else if (event.altKey) {\n    return KeyboardEventModifier.ALT;\n  }\n  return undefined;\n}\nconst MouseButton = {\n  LEFT: 0,\n  MIDDLE: 1,\n  RIGHT: 2\n};\nfunction registerListener(screenSpaceEventHandler, domType, element, callback) {\n  function listener(e) {\n    callback(screenSpaceEventHandler, e);\n  }\n  if (FeatureDetection.isInternetExplorer()) {\n    element.addEventListener(domType, listener, false);\n  } else {\n    element.addEventListener(domType, listener, {\n      capture: false,\n      passive: false\n    });\n  }\n  screenSpaceEventHandler._removalFunctions.push(function () {\n    element.removeEventListener(domType, listener, false);\n  });\n}\nfunction registerListeners(screenSpaceEventHandler) {\n  const element = screenSpaceEventHandler._element;\n\n  // some listeners may be registered on the document, so we still get events even after\n  // leaving the bounds of element.\n  // this is affected by the existence of an undocumented disableRootEvents property on element.\n  const alternateElement = !defined(element.disableRootEvents) ? document : element;\n  if (FeatureDetection.supportsPointerEvents()) {\n    registerListener(screenSpaceEventHandler, \"pointerdown\", element, handlePointerDown);\n    registerListener(screenSpaceEventHandler, \"pointerup\", element, handlePointerUp);\n    registerListener(screenSpaceEventHandler, \"pointermove\", element, handlePointerMove);\n    registerListener(screenSpaceEventHandler, \"pointercancel\", element, handlePointerUp);\n  } else {\n    registerListener(screenSpaceEventHandler, \"mousedown\", element, handleMouseDown);\n    registerListener(screenSpaceEventHandler, \"mouseup\", alternateElement, handleMouseUp);\n    registerListener(screenSpaceEventHandler, \"mousemove\", alternateElement, handleMouseMove);\n    registerListener(screenSpaceEventHandler, \"touchstart\", element, handleTouchStart);\n    registerListener(screenSpaceEventHandler, \"touchend\", alternateElement, handleTouchEnd);\n    registerListener(screenSpaceEventHandler, \"touchmove\", alternateElement, handleTouchMove);\n    registerListener(screenSpaceEventHandler, \"touchcancel\", alternateElement, handleTouchEnd);\n  }\n  registerListener(screenSpaceEventHandler, \"dblclick\", element, handleDblClick);\n\n  // detect available wheel event\n  let wheelEvent;\n  if (\"onwheel\" in element) {\n    // spec event type\n    wheelEvent = \"wheel\";\n  } else if (document.onmousewheel !== undefined) {\n    // legacy event type\n    wheelEvent = \"mousewheel\";\n  } else {\n    // older Firefox\n    wheelEvent = \"DOMMouseScroll\";\n  }\n  registerListener(screenSpaceEventHandler, wheelEvent, element, handleWheel);\n}\nfunction unregisterListeners(screenSpaceEventHandler) {\n  const removalFunctions = screenSpaceEventHandler._removalFunctions;\n  for (let i = 0; i < removalFunctions.length; ++i) {\n    removalFunctions[i]();\n  }\n}\nconst mouseDownEvent = {\n  position: new Cartesian2()\n};\nfunction gotTouchEvent(screenSpaceEventHandler) {\n  screenSpaceEventHandler._lastSeenTouchEvent = getTimestamp();\n}\nfunction canProcessMouseEvent(screenSpaceEventHandler) {\n  return getTimestamp() - screenSpaceEventHandler._lastSeenTouchEvent > ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds;\n}\nfunction checkPixelTolerance(startPosition, endPosition, pixelTolerance) {\n  const xDiff = startPosition.x - endPosition.x;\n  const yDiff = startPosition.y - endPosition.y;\n  const totalPixels = Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n  return totalPixels < pixelTolerance;\n}\nfunction handleMouseDown(screenSpaceEventHandler, event) {\n  if (!canProcessMouseEvent(screenSpaceEventHandler)) {\n    return;\n  }\n  const button = event.button;\n  screenSpaceEventHandler._buttonDown[button] = true;\n  let screenSpaceEventType;\n  if (button === MouseButton.LEFT) {\n    screenSpaceEventType = ScreenSpaceEventType.LEFT_DOWN;\n  } else if (button === MouseButton.MIDDLE) {\n    screenSpaceEventType = ScreenSpaceEventType.MIDDLE_DOWN;\n  } else if (button === MouseButton.RIGHT) {\n    screenSpaceEventType = ScreenSpaceEventType.RIGHT_DOWN;\n  } else {\n    return;\n  }\n  const position = getPosition(screenSpaceEventHandler, event, screenSpaceEventHandler._primaryPosition);\n  Cartesian2.clone(position, screenSpaceEventHandler._primaryStartPosition);\n  Cartesian2.clone(position, screenSpaceEventHandler._primaryPreviousPosition);\n  const modifier = getModifier(event);\n  const action = screenSpaceEventHandler.getInputAction(screenSpaceEventType, modifier);\n  if (defined(action)) {\n    Cartesian2.clone(position, mouseDownEvent.position);\n    action(mouseDownEvent);\n    event.preventDefault();\n  }\n}\nconst mouseUpEvent = {\n  position: new Cartesian2()\n};\nconst mouseClickEvent = {\n  position: new Cartesian2()\n};\nfunction cancelMouseEvent(screenSpaceEventHandler, screenSpaceEventType, clickScreenSpaceEventType, event) {\n  const modifier = getModifier(event);\n  const action = screenSpaceEventHandler.getInputAction(screenSpaceEventType, modifier);\n  const clickAction = screenSpaceEventHandler.getInputAction(clickScreenSpaceEventType, modifier);\n  if (defined(action) || defined(clickAction)) {\n    const position = getPosition(screenSpaceEventHandler, event, screenSpaceEventHandler._primaryPosition);\n    if (defined(action)) {\n      Cartesian2.clone(position, mouseUpEvent.position);\n      action(mouseUpEvent);\n    }\n    if (defined(clickAction)) {\n      const startPosition = screenSpaceEventHandler._primaryStartPosition;\n      if (checkPixelTolerance(startPosition, position, screenSpaceEventHandler._clickPixelTolerance)) {\n        Cartesian2.clone(position, mouseClickEvent.position);\n        clickAction(mouseClickEvent);\n      }\n    }\n  }\n}\nfunction handleMouseUp(screenSpaceEventHandler, event) {\n  if (!canProcessMouseEvent(screenSpaceEventHandler)) {\n    return;\n  }\n  const button = event.button;\n  if (button !== MouseButton.LEFT && button !== MouseButton.MIDDLE && button !== MouseButton.RIGHT) {\n    return;\n  }\n  if (screenSpaceEventHandler._buttonDown[MouseButton.LEFT]) {\n    cancelMouseEvent(screenSpaceEventHandler, ScreenSpaceEventType.LEFT_UP, ScreenSpaceEventType.LEFT_CLICK, event);\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = false;\n  }\n  if (screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE]) {\n    cancelMouseEvent(screenSpaceEventHandler, ScreenSpaceEventType.MIDDLE_UP, ScreenSpaceEventType.MIDDLE_CLICK, event);\n    screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE] = false;\n  }\n  if (screenSpaceEventHandler._buttonDown[MouseButton.RIGHT]) {\n    cancelMouseEvent(screenSpaceEventHandler, ScreenSpaceEventType.RIGHT_UP, ScreenSpaceEventType.RIGHT_CLICK, event);\n    screenSpaceEventHandler._buttonDown[MouseButton.RIGHT] = false;\n  }\n}\nconst mouseMoveEvent = {\n  startPosition: new Cartesian2(),\n  endPosition: new Cartesian2()\n};\nfunction handleMouseMove(screenSpaceEventHandler, event) {\n  if (!canProcessMouseEvent(screenSpaceEventHandler)) {\n    return;\n  }\n  const modifier = getModifier(event);\n  const position = getPosition(screenSpaceEventHandler, event, screenSpaceEventHandler._primaryPosition);\n  const previousPosition = screenSpaceEventHandler._primaryPreviousPosition;\n  const action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.MOUSE_MOVE, modifier);\n  if (defined(action)) {\n    Cartesian2.clone(previousPosition, mouseMoveEvent.startPosition);\n    Cartesian2.clone(position, mouseMoveEvent.endPosition);\n    action(mouseMoveEvent);\n  }\n  Cartesian2.clone(position, previousPosition);\n  if (screenSpaceEventHandler._buttonDown[MouseButton.LEFT] || screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE] || screenSpaceEventHandler._buttonDown[MouseButton.RIGHT]) {\n    event.preventDefault();\n  }\n}\nconst mouseDblClickEvent = {\n  position: new Cartesian2()\n};\nfunction handleDblClick(screenSpaceEventHandler, event) {\n  const button = event.button;\n  let screenSpaceEventType;\n  if (button === MouseButton.LEFT) {\n    screenSpaceEventType = ScreenSpaceEventType.LEFT_DOUBLE_CLICK;\n  } else {\n    return;\n  }\n  const modifier = getModifier(event);\n  const action = screenSpaceEventHandler.getInputAction(screenSpaceEventType, modifier);\n  if (defined(action)) {\n    getPosition(screenSpaceEventHandler, event, mouseDblClickEvent.position);\n    action(mouseDblClickEvent);\n  }\n}\nfunction handleWheel(screenSpaceEventHandler, event) {\n  // currently this event exposes the delta value in terms of\n  // the obsolete mousewheel event type.  so, for now, we adapt the other\n  // values to that scheme.\n  let delta;\n\n  // standard wheel event uses deltaY.  sign is opposite wheelDelta.\n  // deltaMode indicates what unit it is in.\n  if (defined(event.deltaY)) {\n    const deltaMode = event.deltaMode;\n    if (deltaMode === event.DOM_DELTA_PIXEL) {\n      delta = -event.deltaY;\n    } else if (deltaMode === event.DOM_DELTA_LINE) {\n      delta = -event.deltaY * 40;\n    } else {\n      // DOM_DELTA_PAGE\n      delta = -event.deltaY * 120;\n    }\n  } else if (event.detail > 0) {\n    // old Firefox versions use event.detail to count the number of clicks. The sign\n    // of the integer is the direction the wheel is scrolled.\n    delta = event.detail * -120;\n  } else {\n    delta = event.wheelDelta;\n  }\n  if (!defined(delta)) {\n    return;\n  }\n  const modifier = getModifier(event);\n  const action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.WHEEL, modifier);\n  if (defined(action)) {\n    action(delta);\n    event.preventDefault();\n  }\n}\nfunction handleTouchStart(screenSpaceEventHandler, event) {\n  gotTouchEvent(screenSpaceEventHandler);\n  const changedTouches = event.changedTouches;\n  let i;\n  const length = changedTouches.length;\n  let touch;\n  let identifier;\n  const positions = screenSpaceEventHandler._positions;\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    positions.set(identifier, getPosition(screenSpaceEventHandler, touch, new Cartesian2()));\n  }\n  fireTouchEvents(screenSpaceEventHandler, event);\n  const previousPositions = screenSpaceEventHandler._previousPositions;\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    previousPositions.set(identifier, Cartesian2.clone(positions.get(identifier)));\n  }\n}\nfunction handleTouchEnd(screenSpaceEventHandler, event) {\n  gotTouchEvent(screenSpaceEventHandler);\n  const changedTouches = event.changedTouches;\n  let i;\n  const length = changedTouches.length;\n  let touch;\n  let identifier;\n  const positions = screenSpaceEventHandler._positions;\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    positions.remove(identifier);\n  }\n  fireTouchEvents(screenSpaceEventHandler, event);\n  const previousPositions = screenSpaceEventHandler._previousPositions;\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    previousPositions.remove(identifier);\n  }\n}\nconst touchStartEvent = {\n  position: new Cartesian2()\n};\nconst touch2StartEvent = {\n  position1: new Cartesian2(),\n  position2: new Cartesian2()\n};\nconst touchEndEvent = {\n  position: new Cartesian2()\n};\nconst touchClickEvent = {\n  position: new Cartesian2()\n};\nconst touchHoldEvent = {\n  position: new Cartesian2()\n};\nfunction fireTouchEvents(screenSpaceEventHandler, event) {\n  const modifier = getModifier(event);\n  const positions = screenSpaceEventHandler._positions;\n  const numberOfTouches = positions.length;\n  let action;\n  let clickAction;\n  const pinching = screenSpaceEventHandler._isPinching;\n  if (numberOfTouches !== 1 && screenSpaceEventHandler._buttonDown[MouseButton.LEFT]) {\n    // transitioning from single touch, trigger UP and might trigger CLICK\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = false;\n    if (defined(screenSpaceEventHandler._touchHoldTimer)) {\n      clearTimeout(screenSpaceEventHandler._touchHoldTimer);\n      screenSpaceEventHandler._touchHoldTimer = undefined;\n    }\n    action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.LEFT_UP, modifier);\n    if (defined(action)) {\n      Cartesian2.clone(screenSpaceEventHandler._primaryPosition, touchEndEvent.position);\n      action(touchEndEvent);\n    }\n    if (numberOfTouches === 0 && !screenSpaceEventHandler._isTouchHolding) {\n      // releasing single touch, check for CLICK\n      clickAction = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.LEFT_CLICK, modifier);\n      if (defined(clickAction)) {\n        const startPosition = screenSpaceEventHandler._primaryStartPosition;\n        const endPosition = screenSpaceEventHandler._previousPositions.values[0];\n        if (checkPixelTolerance(startPosition, endPosition, screenSpaceEventHandler._clickPixelTolerance)) {\n          Cartesian2.clone(screenSpaceEventHandler._primaryPosition, touchClickEvent.position);\n          clickAction(touchClickEvent);\n        }\n      }\n    }\n    screenSpaceEventHandler._isTouchHolding = false;\n\n    // Otherwise don't trigger CLICK, because we are adding more touches.\n  }\n  if (numberOfTouches === 0 && pinching) {\n    // transitioning from pinch, trigger PINCH_END\n    screenSpaceEventHandler._isPinching = false;\n    action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.PINCH_END, modifier);\n    if (defined(action)) {\n      action();\n    }\n  }\n  if (numberOfTouches === 1 && !pinching) {\n    // transitioning to single touch, trigger DOWN\n    const position = positions.values[0];\n    Cartesian2.clone(position, screenSpaceEventHandler._primaryPosition);\n    Cartesian2.clone(position, screenSpaceEventHandler._primaryStartPosition);\n    Cartesian2.clone(position, screenSpaceEventHandler._primaryPreviousPosition);\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = true;\n    action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.LEFT_DOWN, modifier);\n    if (defined(action)) {\n      Cartesian2.clone(position, touchStartEvent.position);\n      action(touchStartEvent);\n    }\n    screenSpaceEventHandler._touchHoldTimer = setTimeout(function () {\n      if (!screenSpaceEventHandler.isDestroyed()) {\n        screenSpaceEventHandler._touchHoldTimer = undefined;\n        screenSpaceEventHandler._isTouchHolding = true;\n        clickAction = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.RIGHT_CLICK, modifier);\n        if (defined(clickAction)) {\n          const startPosition = screenSpaceEventHandler._primaryStartPosition;\n          const endPosition = screenSpaceEventHandler._previousPositions.values[0];\n          if (checkPixelTolerance(startPosition, endPosition, screenSpaceEventHandler._holdPixelTolerance)) {\n            Cartesian2.clone(screenSpaceEventHandler._primaryPosition, touchHoldEvent.position);\n            clickAction(touchHoldEvent);\n          }\n        }\n      }\n    }, ScreenSpaceEventHandler.touchHoldDelayMilliseconds);\n    event.preventDefault();\n  }\n  if (numberOfTouches === 2 && !pinching) {\n    // transitioning to pinch, trigger PINCH_START\n    screenSpaceEventHandler._isPinching = true;\n    action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.PINCH_START, modifier);\n    if (defined(action)) {\n      Cartesian2.clone(positions.values[0], touch2StartEvent.position1);\n      Cartesian2.clone(positions.values[1], touch2StartEvent.position2);\n      action(touch2StartEvent);\n\n      // Touch-enabled devices, in particular iOS can have many default behaviours for\n      // \"pinch\" events, which can still be executed unless we prevent them here.\n      event.preventDefault();\n    }\n  }\n}\nfunction handleTouchMove(screenSpaceEventHandler, event) {\n  gotTouchEvent(screenSpaceEventHandler);\n  const changedTouches = event.changedTouches;\n  let i;\n  const length = changedTouches.length;\n  let touch;\n  let identifier;\n  const positions = screenSpaceEventHandler._positions;\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    const position = positions.get(identifier);\n    if (defined(position)) {\n      getPosition(screenSpaceEventHandler, touch, position);\n    }\n  }\n  fireTouchMoveEvents(screenSpaceEventHandler, event);\n  const previousPositions = screenSpaceEventHandler._previousPositions;\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    Cartesian2.clone(positions.get(identifier), previousPositions.get(identifier));\n  }\n}\nconst touchMoveEvent = {\n  startPosition: new Cartesian2(),\n  endPosition: new Cartesian2()\n};\nconst touchPinchMovementEvent = {\n  distance: {\n    startPosition: new Cartesian2(),\n    endPosition: new Cartesian2()\n  },\n  angleAndHeight: {\n    startPosition: new Cartesian2(),\n    endPosition: new Cartesian2()\n  }\n};\nfunction fireTouchMoveEvents(screenSpaceEventHandler, event) {\n  const modifier = getModifier(event);\n  const positions = screenSpaceEventHandler._positions;\n  const previousPositions = screenSpaceEventHandler._previousPositions;\n  const numberOfTouches = positions.length;\n  let action;\n  if (numberOfTouches === 1 && screenSpaceEventHandler._buttonDown[MouseButton.LEFT]) {\n    // moving single touch\n    const position = positions.values[0];\n    Cartesian2.clone(position, screenSpaceEventHandler._primaryPosition);\n    const previousPosition = screenSpaceEventHandler._primaryPreviousPosition;\n    action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.MOUSE_MOVE, modifier);\n    if (defined(action)) {\n      Cartesian2.clone(previousPosition, touchMoveEvent.startPosition);\n      Cartesian2.clone(position, touchMoveEvent.endPosition);\n      action(touchMoveEvent);\n    }\n    Cartesian2.clone(position, previousPosition);\n    event.preventDefault();\n  } else if (numberOfTouches === 2 && screenSpaceEventHandler._isPinching) {\n    // moving pinch\n\n    action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.PINCH_MOVE, modifier);\n    if (defined(action)) {\n      const position1 = positions.values[0];\n      const position2 = positions.values[1];\n      const previousPosition1 = previousPositions.values[0];\n      const previousPosition2 = previousPositions.values[1];\n      const dX = position2.x - position1.x;\n      const dY = position2.y - position1.y;\n      const dist = Math.sqrt(dX * dX + dY * dY) * 0.25;\n      const prevDX = previousPosition2.x - previousPosition1.x;\n      const prevDY = previousPosition2.y - previousPosition1.y;\n      const prevDist = Math.sqrt(prevDX * prevDX + prevDY * prevDY) * 0.25;\n      const cY = (position2.y + position1.y) * 0.125;\n      const prevCY = (previousPosition2.y + previousPosition1.y) * 0.125;\n      const angle = Math.atan2(dY, dX);\n      const prevAngle = Math.atan2(prevDY, prevDX);\n      Cartesian2.fromElements(0.0, prevDist, touchPinchMovementEvent.distance.startPosition);\n      Cartesian2.fromElements(0.0, dist, touchPinchMovementEvent.distance.endPosition);\n      Cartesian2.fromElements(prevAngle, prevCY, touchPinchMovementEvent.angleAndHeight.startPosition);\n      Cartesian2.fromElements(angle, cY, touchPinchMovementEvent.angleAndHeight.endPosition);\n      action(touchPinchMovementEvent);\n    }\n  }\n}\nfunction handlePointerDown(screenSpaceEventHandler, event) {\n  event.target.setPointerCapture(event.pointerId);\n  if (event.pointerType === \"touch\") {\n    const positions = screenSpaceEventHandler._positions;\n    const identifier = event.pointerId;\n    positions.set(identifier, getPosition(screenSpaceEventHandler, event, new Cartesian2()));\n    fireTouchEvents(screenSpaceEventHandler, event);\n    const previousPositions = screenSpaceEventHandler._previousPositions;\n    previousPositions.set(identifier, Cartesian2.clone(positions.get(identifier)));\n  } else {\n    handleMouseDown(screenSpaceEventHandler, event);\n  }\n}\nfunction handlePointerUp(screenSpaceEventHandler, event) {\n  if (event.pointerType === \"touch\") {\n    const positions = screenSpaceEventHandler._positions;\n    const identifier = event.pointerId;\n    positions.remove(identifier);\n    fireTouchEvents(screenSpaceEventHandler, event);\n    const previousPositions = screenSpaceEventHandler._previousPositions;\n    previousPositions.remove(identifier);\n  } else {\n    handleMouseUp(screenSpaceEventHandler, event);\n  }\n}\nfunction handlePointerMove(screenSpaceEventHandler, event) {\n  if (event.pointerType === \"touch\") {\n    const positions = screenSpaceEventHandler._positions;\n    const identifier = event.pointerId;\n    const position = positions.get(identifier);\n    if (!defined(position)) {\n      return;\n    }\n    getPosition(screenSpaceEventHandler, event, position);\n    fireTouchMoveEvents(screenSpaceEventHandler, event);\n    const previousPositions = screenSpaceEventHandler._previousPositions;\n    Cartesian2.clone(positions.get(identifier), previousPositions.get(identifier));\n  } else {\n    handleMouseMove(screenSpaceEventHandler, event);\n  }\n}\n\n/**\n * @typedef {object} ScreenSpaceEventHandler.PositionedEvent\n *\n * An Event that occurs at a single position on screen.\n *\n * @property {Cartesian2} position\n */\n\n/**\n * @callback ScreenSpaceEventHandler.PositionedEventCallback\n *\n * The callback invoked when a positioned event triggers an event listener.\n *\n * @param {ScreenSpaceEventHandler.PositionedEvent} event The event which triggered the listener\n */\n\n/**\n * @typedef {object} ScreenSpaceEventHandler.MotionEvent\n *\n * An Event that starts at one position and ends at another.\n *\n * @property {Cartesian2} startPosition\n * @property {Cartesian2} endPosition\n */\n\n/**\n * @callback ScreenSpaceEventHandler.MotionEventCallback\n *\n * The callback invoked when a motion event triggers an event listener.\n *\n * @param {ScreenSpaceEventHandler.MotionEvent} event The event which triggered the listener\n */\n\n/**\n * @typedef {object} ScreenSpaceEventHandler.TwoPointEvent\n *\n * An Event that occurs at a two positions on screen.\n *\n * @property {Cartesian2} position1\n * @property {Cartesian2} position2\n */\n\n/**\n * @callback ScreenSpaceEventHandler.TwoPointEventCallback\n *\n * The callback invoked when a two-point event triggers an event listener.\n *\n * @param {ScreenSpaceEventHandler.TwoPointEvent} event The event which triggered the listener\n */\n\n/**\n * @typedef {object} ScreenSpaceEventHandler.TwoPointMotionEvent\n *\n * An Event that starts at a two positions on screen and moves to two other positions.\n *\n * @property {Cartesian2} position1\n * @property {Cartesian2} position2\n * @property {Cartesian2} previousPosition1\n * @property {Cartesian2} previousPosition2\n */\n\n/**\n * @callback ScreenSpaceEventHandler.TwoPointMotionEventCallback\n *\n * The callback invoked when a two-point motion event triggers an event listener.\n *\n * @param {ScreenSpaceEventHandler.TwoPointMotionEvent} event The event which triggered the listener\n */\n\n/**\n * @callback ScreenSpaceEventHandler.WheelEventCallback\n *\n * The callback invoked when a mouse-wheel event triggers an event listener.\n *\n * @param {number} delta The amount that the mouse wheel moved\n */\n\n/**\n * Handles user input events. Custom functions can be added to be executed on\n * when the user enters input.\n *\n * @alias ScreenSpaceEventHandler\n *\n * @param {HTMLCanvasElement} [element=document] The element to add events to.\n *\n * @constructor\n */\nfunction ScreenSpaceEventHandler(element) {\n  this._inputEvents = {};\n  this._buttonDown = {\n    LEFT: false,\n    MIDDLE: false,\n    RIGHT: false\n  };\n  this._isPinching = false;\n  this._isTouchHolding = false;\n  this._lastSeenTouchEvent = -ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds;\n  this._primaryStartPosition = new Cartesian2();\n  this._primaryPosition = new Cartesian2();\n  this._primaryPreviousPosition = new Cartesian2();\n  this._positions = new AssociativeArray();\n  this._previousPositions = new AssociativeArray();\n  this._removalFunctions = [];\n  this._touchHoldTimer = undefined;\n\n  // TODO: Revisit when doing mobile development. May need to be configurable\n  // or determined based on the platform?\n  this._clickPixelTolerance = 5;\n  this._holdPixelTolerance = 25;\n  this._element = defaultValue(element, document);\n  registerListeners(this);\n}\n\n/**\n * Set a function to be executed on an input event.\n *\n * @param {ScreenSpaceEventHandler.PositionedEventCallback|ScreenSpaceEventHandler.MotionEventCallback|ScreenSpaceEventHandler.WheelEventCallback|ScreenSpaceEventHandler.TwoPointEventCallback|ScreenSpaceEventHandler.TwoPointMotionEventCallback} action Function to be executed when the input event occurs.\n * @param {ScreenSpaceEventType} type The ScreenSpaceEventType of input event.\n * @param {KeyboardEventModifier} [modifier] A KeyboardEventModifier key that is held when a <code>type</code>\n * event occurs.\n *\n * @see ScreenSpaceEventHandler#getInputAction\n * @see ScreenSpaceEventHandler#removeInputAction\n */\nScreenSpaceEventHandler.prototype.setInputAction = function (action, type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(action)) {\n    throw new DeveloperError(\"action is required.\");\n  }\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getInputEventKey(type, modifier);\n  this._inputEvents[key] = action;\n};\n\n/**\n * Returns the function to be executed on an input event.\n *\n * @param {ScreenSpaceEventType} type The ScreenSpaceEventType of input event.\n * @param {KeyboardEventModifier} [modifier] A KeyboardEventModifier key that is held when a <code>type</code>\n * event occurs.\n *\n * @returns {ScreenSpaceEventHandler.PositionedEventCallback|ScreenSpaceEventHandler.MotionEventCallback|ScreenSpaceEventHandler.WheelEventCallback|ScreenSpaceEventHandler.TwoPointEventCallback|ScreenSpaceEventHandler.TwoPointMotionEventCallback} The function to be executed on an input event.\n *\n * @see ScreenSpaceEventHandler#setInputAction\n * @see ScreenSpaceEventHandler#removeInputAction\n */\nScreenSpaceEventHandler.prototype.getInputAction = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getInputEventKey(type, modifier);\n  return this._inputEvents[key];\n};\n\n/**\n * Removes the function to be executed on an input event.\n *\n * @param {ScreenSpaceEventType} type The ScreenSpaceEventType of input event.\n * @param {KeyboardEventModifier} [modifier] A KeyboardEventModifier key that is held when a <code>type</code>\n * event occurs.\n *\n * @see ScreenSpaceEventHandler#getInputAction\n * @see ScreenSpaceEventHandler#setInputAction\n */\nScreenSpaceEventHandler.prototype.removeInputAction = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getInputEventKey(type, modifier);\n  delete this._inputEvents[key];\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ScreenSpaceEventHandler#destroy\n */\nScreenSpaceEventHandler.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * handler = handler && handler.destroy();\n *\n * @see ScreenSpaceEventHandler#isDestroyed\n */\nScreenSpaceEventHandler.prototype.destroy = function () {\n  unregisterListeners(this);\n  return destroyObject(this);\n};\n\n/**\n * The amount of time, in milliseconds, that mouse events will be disabled after\n * receiving any touch events, such that any emulated mouse events will be ignored.\n * @type {number}\n * @default 800\n */\nScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds = 800;\n\n/**\n * The amount of time, in milliseconds, before a touch on the screen becomes a\n * touch and hold.\n * @type {number}\n * @default 1500\n */\nScreenSpaceEventHandler.touchHoldDelayMilliseconds = 1500;\nexport default ScreenSpaceEventHandler;","map":{"version":3,"names":["AssociativeArray","Cartesian2","defaultValue","defined","destroyObject","DeveloperError","FeatureDetection","getTimestamp","KeyboardEventModifier","ScreenSpaceEventType","getPosition","screenSpaceEventHandler","event","result","element","_element","document","x","clientX","y","clientY","rect","getBoundingClientRect","left","top","getInputEventKey","type","modifier","key","getModifier","shiftKey","SHIFT","ctrlKey","CTRL","altKey","ALT","undefined","MouseButton","LEFT","MIDDLE","RIGHT","registerListener","domType","callback","listener","e","isInternetExplorer","addEventListener","capture","passive","_removalFunctions","push","removeEventListener","registerListeners","alternateElement","disableRootEvents","supportsPointerEvents","handlePointerDown","handlePointerUp","handlePointerMove","handleMouseDown","handleMouseUp","handleMouseMove","handleTouchStart","handleTouchEnd","handleTouchMove","handleDblClick","wheelEvent","onmousewheel","handleWheel","unregisterListeners","removalFunctions","i","length","mouseDownEvent","position","gotTouchEvent","_lastSeenTouchEvent","canProcessMouseEvent","ScreenSpaceEventHandler","mouseEmulationIgnoreMilliseconds","checkPixelTolerance","startPosition","endPosition","pixelTolerance","xDiff","yDiff","totalPixels","Math","sqrt","button","_buttonDown","screenSpaceEventType","LEFT_DOWN","MIDDLE_DOWN","RIGHT_DOWN","_primaryPosition","clone","_primaryStartPosition","_primaryPreviousPosition","action","getInputAction","preventDefault","mouseUpEvent","mouseClickEvent","cancelMouseEvent","clickScreenSpaceEventType","clickAction","_clickPixelTolerance","LEFT_UP","LEFT_CLICK","MIDDLE_UP","MIDDLE_CLICK","RIGHT_UP","RIGHT_CLICK","mouseMoveEvent","previousPosition","MOUSE_MOVE","mouseDblClickEvent","LEFT_DOUBLE_CLICK","delta","deltaY","deltaMode","DOM_DELTA_PIXEL","DOM_DELTA_LINE","detail","wheelDelta","WHEEL","changedTouches","touch","identifier","positions","_positions","set","fireTouchEvents","previousPositions","_previousPositions","get","remove","touchStartEvent","touch2StartEvent","position1","position2","touchEndEvent","touchClickEvent","touchHoldEvent","numberOfTouches","pinching","_isPinching","_touchHoldTimer","clearTimeout","_isTouchHolding","values","PINCH_END","setTimeout","isDestroyed","_holdPixelTolerance","touchHoldDelayMilliseconds","PINCH_START","fireTouchMoveEvents","touchMoveEvent","touchPinchMovementEvent","distance","angleAndHeight","PINCH_MOVE","previousPosition1","previousPosition2","dX","dY","dist","prevDX","prevDY","prevDist","cY","prevCY","angle","atan2","prevAngle","fromElements","target","setPointerCapture","pointerId","pointerType","_inputEvents","prototype","setInputAction","removeInputAction","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/ScreenSpaceEventHandler.js"],"sourcesContent":["import AssociativeArray from \"./AssociativeArray.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport destroyObject from \"./destroyObject.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport FeatureDetection from \"./FeatureDetection.js\";\nimport getTimestamp from \"./getTimestamp.js\";\nimport KeyboardEventModifier from \"./KeyboardEventModifier.js\";\nimport ScreenSpaceEventType from \"./ScreenSpaceEventType.js\";\n\nfunction getPosition(screenSpaceEventHandler, event, result) {\n  const element = screenSpaceEventHandler._element;\n  if (element === document) {\n    result.x = event.clientX;\n    result.y = event.clientY;\n    return result;\n  }\n\n  const rect = element.getBoundingClientRect();\n  result.x = event.clientX - rect.left;\n  result.y = event.clientY - rect.top;\n  return result;\n}\n\nfunction getInputEventKey(type, modifier) {\n  let key = type;\n  if (defined(modifier)) {\n    key += `+${modifier}`;\n  }\n  return key;\n}\n\nfunction getModifier(event) {\n  if (event.shiftKey) {\n    return KeyboardEventModifier.SHIFT;\n  } else if (event.ctrlKey) {\n    return KeyboardEventModifier.CTRL;\n  } else if (event.altKey) {\n    return KeyboardEventModifier.ALT;\n  }\n\n  return undefined;\n}\n\nconst MouseButton = {\n  LEFT: 0,\n  MIDDLE: 1,\n  RIGHT: 2,\n};\n\nfunction registerListener(screenSpaceEventHandler, domType, element, callback) {\n  function listener(e) {\n    callback(screenSpaceEventHandler, e);\n  }\n\n  if (FeatureDetection.isInternetExplorer()) {\n    element.addEventListener(domType, listener, false);\n  } else {\n    element.addEventListener(domType, listener, {\n      capture: false,\n      passive: false,\n    });\n  }\n\n  screenSpaceEventHandler._removalFunctions.push(function () {\n    element.removeEventListener(domType, listener, false);\n  });\n}\n\nfunction registerListeners(screenSpaceEventHandler) {\n  const element = screenSpaceEventHandler._element;\n\n  // some listeners may be registered on the document, so we still get events even after\n  // leaving the bounds of element.\n  // this is affected by the existence of an undocumented disableRootEvents property on element.\n  const alternateElement = !defined(element.disableRootEvents)\n    ? document\n    : element;\n\n  if (FeatureDetection.supportsPointerEvents()) {\n    registerListener(\n      screenSpaceEventHandler,\n      \"pointerdown\",\n      element,\n      handlePointerDown,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"pointerup\",\n      element,\n      handlePointerUp,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"pointermove\",\n      element,\n      handlePointerMove,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"pointercancel\",\n      element,\n      handlePointerUp,\n    );\n  } else {\n    registerListener(\n      screenSpaceEventHandler,\n      \"mousedown\",\n      element,\n      handleMouseDown,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"mouseup\",\n      alternateElement,\n      handleMouseUp,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"mousemove\",\n      alternateElement,\n      handleMouseMove,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"touchstart\",\n      element,\n      handleTouchStart,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"touchend\",\n      alternateElement,\n      handleTouchEnd,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"touchmove\",\n      alternateElement,\n      handleTouchMove,\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      \"touchcancel\",\n      alternateElement,\n      handleTouchEnd,\n    );\n  }\n\n  registerListener(\n    screenSpaceEventHandler,\n    \"dblclick\",\n    element,\n    handleDblClick,\n  );\n\n  // detect available wheel event\n  let wheelEvent;\n  if (\"onwheel\" in element) {\n    // spec event type\n    wheelEvent = \"wheel\";\n  } else if (document.onmousewheel !== undefined) {\n    // legacy event type\n    wheelEvent = \"mousewheel\";\n  } else {\n    // older Firefox\n    wheelEvent = \"DOMMouseScroll\";\n  }\n\n  registerListener(screenSpaceEventHandler, wheelEvent, element, handleWheel);\n}\n\nfunction unregisterListeners(screenSpaceEventHandler) {\n  const removalFunctions = screenSpaceEventHandler._removalFunctions;\n  for (let i = 0; i < removalFunctions.length; ++i) {\n    removalFunctions[i]();\n  }\n}\n\nconst mouseDownEvent = {\n  position: new Cartesian2(),\n};\n\nfunction gotTouchEvent(screenSpaceEventHandler) {\n  screenSpaceEventHandler._lastSeenTouchEvent = getTimestamp();\n}\n\nfunction canProcessMouseEvent(screenSpaceEventHandler) {\n  return (\n    getTimestamp() - screenSpaceEventHandler._lastSeenTouchEvent >\n    ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds\n  );\n}\n\nfunction checkPixelTolerance(startPosition, endPosition, pixelTolerance) {\n  const xDiff = startPosition.x - endPosition.x;\n  const yDiff = startPosition.y - endPosition.y;\n  const totalPixels = Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n\n  return totalPixels < pixelTolerance;\n}\n\nfunction handleMouseDown(screenSpaceEventHandler, event) {\n  if (!canProcessMouseEvent(screenSpaceEventHandler)) {\n    return;\n  }\n\n  const button = event.button;\n  screenSpaceEventHandler._buttonDown[button] = true;\n\n  let screenSpaceEventType;\n  if (button === MouseButton.LEFT) {\n    screenSpaceEventType = ScreenSpaceEventType.LEFT_DOWN;\n  } else if (button === MouseButton.MIDDLE) {\n    screenSpaceEventType = ScreenSpaceEventType.MIDDLE_DOWN;\n  } else if (button === MouseButton.RIGHT) {\n    screenSpaceEventType = ScreenSpaceEventType.RIGHT_DOWN;\n  } else {\n    return;\n  }\n\n  const position = getPosition(\n    screenSpaceEventHandler,\n    event,\n    screenSpaceEventHandler._primaryPosition,\n  );\n  Cartesian2.clone(position, screenSpaceEventHandler._primaryStartPosition);\n  Cartesian2.clone(position, screenSpaceEventHandler._primaryPreviousPosition);\n\n  const modifier = getModifier(event);\n\n  const action = screenSpaceEventHandler.getInputAction(\n    screenSpaceEventType,\n    modifier,\n  );\n\n  if (defined(action)) {\n    Cartesian2.clone(position, mouseDownEvent.position);\n\n    action(mouseDownEvent);\n\n    event.preventDefault();\n  }\n}\n\nconst mouseUpEvent = {\n  position: new Cartesian2(),\n};\nconst mouseClickEvent = {\n  position: new Cartesian2(),\n};\n\nfunction cancelMouseEvent(\n  screenSpaceEventHandler,\n  screenSpaceEventType,\n  clickScreenSpaceEventType,\n  event,\n) {\n  const modifier = getModifier(event);\n\n  const action = screenSpaceEventHandler.getInputAction(\n    screenSpaceEventType,\n    modifier,\n  );\n  const clickAction = screenSpaceEventHandler.getInputAction(\n    clickScreenSpaceEventType,\n    modifier,\n  );\n\n  if (defined(action) || defined(clickAction)) {\n    const position = getPosition(\n      screenSpaceEventHandler,\n      event,\n      screenSpaceEventHandler._primaryPosition,\n    );\n\n    if (defined(action)) {\n      Cartesian2.clone(position, mouseUpEvent.position);\n\n      action(mouseUpEvent);\n    }\n\n    if (defined(clickAction)) {\n      const startPosition = screenSpaceEventHandler._primaryStartPosition;\n      if (\n        checkPixelTolerance(\n          startPosition,\n          position,\n          screenSpaceEventHandler._clickPixelTolerance,\n        )\n      ) {\n        Cartesian2.clone(position, mouseClickEvent.position);\n\n        clickAction(mouseClickEvent);\n      }\n    }\n  }\n}\n\nfunction handleMouseUp(screenSpaceEventHandler, event) {\n  if (!canProcessMouseEvent(screenSpaceEventHandler)) {\n    return;\n  }\n\n  const button = event.button;\n\n  if (\n    button !== MouseButton.LEFT &&\n    button !== MouseButton.MIDDLE &&\n    button !== MouseButton.RIGHT\n  ) {\n    return;\n  }\n\n  if (screenSpaceEventHandler._buttonDown[MouseButton.LEFT]) {\n    cancelMouseEvent(\n      screenSpaceEventHandler,\n      ScreenSpaceEventType.LEFT_UP,\n      ScreenSpaceEventType.LEFT_CLICK,\n      event,\n    );\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = false;\n  }\n  if (screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE]) {\n    cancelMouseEvent(\n      screenSpaceEventHandler,\n      ScreenSpaceEventType.MIDDLE_UP,\n      ScreenSpaceEventType.MIDDLE_CLICK,\n      event,\n    );\n    screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE] = false;\n  }\n  if (screenSpaceEventHandler._buttonDown[MouseButton.RIGHT]) {\n    cancelMouseEvent(\n      screenSpaceEventHandler,\n      ScreenSpaceEventType.RIGHT_UP,\n      ScreenSpaceEventType.RIGHT_CLICK,\n      event,\n    );\n    screenSpaceEventHandler._buttonDown[MouseButton.RIGHT] = false;\n  }\n}\n\nconst mouseMoveEvent = {\n  startPosition: new Cartesian2(),\n  endPosition: new Cartesian2(),\n};\n\nfunction handleMouseMove(screenSpaceEventHandler, event) {\n  if (!canProcessMouseEvent(screenSpaceEventHandler)) {\n    return;\n  }\n\n  const modifier = getModifier(event);\n\n  const position = getPosition(\n    screenSpaceEventHandler,\n    event,\n    screenSpaceEventHandler._primaryPosition,\n  );\n  const previousPosition = screenSpaceEventHandler._primaryPreviousPosition;\n\n  const action = screenSpaceEventHandler.getInputAction(\n    ScreenSpaceEventType.MOUSE_MOVE,\n    modifier,\n  );\n\n  if (defined(action)) {\n    Cartesian2.clone(previousPosition, mouseMoveEvent.startPosition);\n    Cartesian2.clone(position, mouseMoveEvent.endPosition);\n\n    action(mouseMoveEvent);\n  }\n\n  Cartesian2.clone(position, previousPosition);\n\n  if (\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] ||\n    screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE] ||\n    screenSpaceEventHandler._buttonDown[MouseButton.RIGHT]\n  ) {\n    event.preventDefault();\n  }\n}\n\nconst mouseDblClickEvent = {\n  position: new Cartesian2(),\n};\n\nfunction handleDblClick(screenSpaceEventHandler, event) {\n  const button = event.button;\n\n  let screenSpaceEventType;\n  if (button === MouseButton.LEFT) {\n    screenSpaceEventType = ScreenSpaceEventType.LEFT_DOUBLE_CLICK;\n  } else {\n    return;\n  }\n\n  const modifier = getModifier(event);\n\n  const action = screenSpaceEventHandler.getInputAction(\n    screenSpaceEventType,\n    modifier,\n  );\n\n  if (defined(action)) {\n    getPosition(screenSpaceEventHandler, event, mouseDblClickEvent.position);\n\n    action(mouseDblClickEvent);\n  }\n}\n\nfunction handleWheel(screenSpaceEventHandler, event) {\n  // currently this event exposes the delta value in terms of\n  // the obsolete mousewheel event type.  so, for now, we adapt the other\n  // values to that scheme.\n  let delta;\n\n  // standard wheel event uses deltaY.  sign is opposite wheelDelta.\n  // deltaMode indicates what unit it is in.\n  if (defined(event.deltaY)) {\n    const deltaMode = event.deltaMode;\n    if (deltaMode === event.DOM_DELTA_PIXEL) {\n      delta = -event.deltaY;\n    } else if (deltaMode === event.DOM_DELTA_LINE) {\n      delta = -event.deltaY * 40;\n    } else {\n      // DOM_DELTA_PAGE\n      delta = -event.deltaY * 120;\n    }\n  } else if (event.detail > 0) {\n    // old Firefox versions use event.detail to count the number of clicks. The sign\n    // of the integer is the direction the wheel is scrolled.\n    delta = event.detail * -120;\n  } else {\n    delta = event.wheelDelta;\n  }\n\n  if (!defined(delta)) {\n    return;\n  }\n\n  const modifier = getModifier(event);\n  const action = screenSpaceEventHandler.getInputAction(\n    ScreenSpaceEventType.WHEEL,\n    modifier,\n  );\n\n  if (defined(action)) {\n    action(delta);\n\n    event.preventDefault();\n  }\n}\n\nfunction handleTouchStart(screenSpaceEventHandler, event) {\n  gotTouchEvent(screenSpaceEventHandler);\n\n  const changedTouches = event.changedTouches;\n\n  let i;\n  const length = changedTouches.length;\n  let touch;\n  let identifier;\n  const positions = screenSpaceEventHandler._positions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    positions.set(\n      identifier,\n      getPosition(screenSpaceEventHandler, touch, new Cartesian2()),\n    );\n  }\n\n  fireTouchEvents(screenSpaceEventHandler, event);\n\n  const previousPositions = screenSpaceEventHandler._previousPositions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    previousPositions.set(\n      identifier,\n      Cartesian2.clone(positions.get(identifier)),\n    );\n  }\n}\n\nfunction handleTouchEnd(screenSpaceEventHandler, event) {\n  gotTouchEvent(screenSpaceEventHandler);\n\n  const changedTouches = event.changedTouches;\n\n  let i;\n  const length = changedTouches.length;\n  let touch;\n  let identifier;\n  const positions = screenSpaceEventHandler._positions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    positions.remove(identifier);\n  }\n\n  fireTouchEvents(screenSpaceEventHandler, event);\n\n  const previousPositions = screenSpaceEventHandler._previousPositions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    previousPositions.remove(identifier);\n  }\n}\n\nconst touchStartEvent = {\n  position: new Cartesian2(),\n};\nconst touch2StartEvent = {\n  position1: new Cartesian2(),\n  position2: new Cartesian2(),\n};\nconst touchEndEvent = {\n  position: new Cartesian2(),\n};\nconst touchClickEvent = {\n  position: new Cartesian2(),\n};\nconst touchHoldEvent = {\n  position: new Cartesian2(),\n};\n\nfunction fireTouchEvents(screenSpaceEventHandler, event) {\n  const modifier = getModifier(event);\n  const positions = screenSpaceEventHandler._positions;\n  const numberOfTouches = positions.length;\n  let action;\n  let clickAction;\n  const pinching = screenSpaceEventHandler._isPinching;\n\n  if (\n    numberOfTouches !== 1 &&\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT]\n  ) {\n    // transitioning from single touch, trigger UP and might trigger CLICK\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = false;\n\n    if (defined(screenSpaceEventHandler._touchHoldTimer)) {\n      clearTimeout(screenSpaceEventHandler._touchHoldTimer);\n      screenSpaceEventHandler._touchHoldTimer = undefined;\n    }\n\n    action = screenSpaceEventHandler.getInputAction(\n      ScreenSpaceEventType.LEFT_UP,\n      modifier,\n    );\n\n    if (defined(action)) {\n      Cartesian2.clone(\n        screenSpaceEventHandler._primaryPosition,\n        touchEndEvent.position,\n      );\n\n      action(touchEndEvent);\n    }\n\n    if (numberOfTouches === 0 && !screenSpaceEventHandler._isTouchHolding) {\n      // releasing single touch, check for CLICK\n      clickAction = screenSpaceEventHandler.getInputAction(\n        ScreenSpaceEventType.LEFT_CLICK,\n        modifier,\n      );\n\n      if (defined(clickAction)) {\n        const startPosition = screenSpaceEventHandler._primaryStartPosition;\n        const endPosition =\n          screenSpaceEventHandler._previousPositions.values[0];\n        if (\n          checkPixelTolerance(\n            startPosition,\n            endPosition,\n            screenSpaceEventHandler._clickPixelTolerance,\n          )\n        ) {\n          Cartesian2.clone(\n            screenSpaceEventHandler._primaryPosition,\n            touchClickEvent.position,\n          );\n\n          clickAction(touchClickEvent);\n        }\n      }\n    }\n\n    screenSpaceEventHandler._isTouchHolding = false;\n\n    // Otherwise don't trigger CLICK, because we are adding more touches.\n  }\n\n  if (numberOfTouches === 0 && pinching) {\n    // transitioning from pinch, trigger PINCH_END\n    screenSpaceEventHandler._isPinching = false;\n\n    action = screenSpaceEventHandler.getInputAction(\n      ScreenSpaceEventType.PINCH_END,\n      modifier,\n    );\n\n    if (defined(action)) {\n      action();\n    }\n  }\n\n  if (numberOfTouches === 1 && !pinching) {\n    // transitioning to single touch, trigger DOWN\n    const position = positions.values[0];\n    Cartesian2.clone(position, screenSpaceEventHandler._primaryPosition);\n    Cartesian2.clone(position, screenSpaceEventHandler._primaryStartPosition);\n    Cartesian2.clone(\n      position,\n      screenSpaceEventHandler._primaryPreviousPosition,\n    );\n\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = true;\n\n    action = screenSpaceEventHandler.getInputAction(\n      ScreenSpaceEventType.LEFT_DOWN,\n      modifier,\n    );\n\n    if (defined(action)) {\n      Cartesian2.clone(position, touchStartEvent.position);\n\n      action(touchStartEvent);\n    }\n\n    screenSpaceEventHandler._touchHoldTimer = setTimeout(function () {\n      if (!screenSpaceEventHandler.isDestroyed()) {\n        screenSpaceEventHandler._touchHoldTimer = undefined;\n        screenSpaceEventHandler._isTouchHolding = true;\n\n        clickAction = screenSpaceEventHandler.getInputAction(\n          ScreenSpaceEventType.RIGHT_CLICK,\n          modifier,\n        );\n\n        if (defined(clickAction)) {\n          const startPosition = screenSpaceEventHandler._primaryStartPosition;\n          const endPosition =\n            screenSpaceEventHandler._previousPositions.values[0];\n          if (\n            checkPixelTolerance(\n              startPosition,\n              endPosition,\n              screenSpaceEventHandler._holdPixelTolerance,\n            )\n          ) {\n            Cartesian2.clone(\n              screenSpaceEventHandler._primaryPosition,\n              touchHoldEvent.position,\n            );\n\n            clickAction(touchHoldEvent);\n          }\n        }\n      }\n    }, ScreenSpaceEventHandler.touchHoldDelayMilliseconds);\n\n    event.preventDefault();\n  }\n\n  if (numberOfTouches === 2 && !pinching) {\n    // transitioning to pinch, trigger PINCH_START\n    screenSpaceEventHandler._isPinching = true;\n\n    action = screenSpaceEventHandler.getInputAction(\n      ScreenSpaceEventType.PINCH_START,\n      modifier,\n    );\n\n    if (defined(action)) {\n      Cartesian2.clone(positions.values[0], touch2StartEvent.position1);\n      Cartesian2.clone(positions.values[1], touch2StartEvent.position2);\n\n      action(touch2StartEvent);\n\n      // Touch-enabled devices, in particular iOS can have many default behaviours for\n      // \"pinch\" events, which can still be executed unless we prevent them here.\n      event.preventDefault();\n    }\n  }\n}\n\nfunction handleTouchMove(screenSpaceEventHandler, event) {\n  gotTouchEvent(screenSpaceEventHandler);\n\n  const changedTouches = event.changedTouches;\n\n  let i;\n  const length = changedTouches.length;\n  let touch;\n  let identifier;\n  const positions = screenSpaceEventHandler._positions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    const position = positions.get(identifier);\n    if (defined(position)) {\n      getPosition(screenSpaceEventHandler, touch, position);\n    }\n  }\n\n  fireTouchMoveEvents(screenSpaceEventHandler, event);\n\n  const previousPositions = screenSpaceEventHandler._previousPositions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    Cartesian2.clone(\n      positions.get(identifier),\n      previousPositions.get(identifier),\n    );\n  }\n}\n\nconst touchMoveEvent = {\n  startPosition: new Cartesian2(),\n  endPosition: new Cartesian2(),\n};\nconst touchPinchMovementEvent = {\n  distance: {\n    startPosition: new Cartesian2(),\n    endPosition: new Cartesian2(),\n  },\n  angleAndHeight: {\n    startPosition: new Cartesian2(),\n    endPosition: new Cartesian2(),\n  },\n};\n\nfunction fireTouchMoveEvents(screenSpaceEventHandler, event) {\n  const modifier = getModifier(event);\n  const positions = screenSpaceEventHandler._positions;\n  const previousPositions = screenSpaceEventHandler._previousPositions;\n  const numberOfTouches = positions.length;\n  let action;\n\n  if (\n    numberOfTouches === 1 &&\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT]\n  ) {\n    // moving single touch\n    const position = positions.values[0];\n    Cartesian2.clone(position, screenSpaceEventHandler._primaryPosition);\n\n    const previousPosition = screenSpaceEventHandler._primaryPreviousPosition;\n\n    action = screenSpaceEventHandler.getInputAction(\n      ScreenSpaceEventType.MOUSE_MOVE,\n      modifier,\n    );\n\n    if (defined(action)) {\n      Cartesian2.clone(previousPosition, touchMoveEvent.startPosition);\n      Cartesian2.clone(position, touchMoveEvent.endPosition);\n\n      action(touchMoveEvent);\n    }\n\n    Cartesian2.clone(position, previousPosition);\n\n    event.preventDefault();\n  } else if (numberOfTouches === 2 && screenSpaceEventHandler._isPinching) {\n    // moving pinch\n\n    action = screenSpaceEventHandler.getInputAction(\n      ScreenSpaceEventType.PINCH_MOVE,\n      modifier,\n    );\n    if (defined(action)) {\n      const position1 = positions.values[0];\n      const position2 = positions.values[1];\n      const previousPosition1 = previousPositions.values[0];\n      const previousPosition2 = previousPositions.values[1];\n\n      const dX = position2.x - position1.x;\n      const dY = position2.y - position1.y;\n      const dist = Math.sqrt(dX * dX + dY * dY) * 0.25;\n\n      const prevDX = previousPosition2.x - previousPosition1.x;\n      const prevDY = previousPosition2.y - previousPosition1.y;\n      const prevDist = Math.sqrt(prevDX * prevDX + prevDY * prevDY) * 0.25;\n\n      const cY = (position2.y + position1.y) * 0.125;\n      const prevCY = (previousPosition2.y + previousPosition1.y) * 0.125;\n      const angle = Math.atan2(dY, dX);\n      const prevAngle = Math.atan2(prevDY, prevDX);\n\n      Cartesian2.fromElements(\n        0.0,\n        prevDist,\n        touchPinchMovementEvent.distance.startPosition,\n      );\n      Cartesian2.fromElements(\n        0.0,\n        dist,\n        touchPinchMovementEvent.distance.endPosition,\n      );\n\n      Cartesian2.fromElements(\n        prevAngle,\n        prevCY,\n        touchPinchMovementEvent.angleAndHeight.startPosition,\n      );\n      Cartesian2.fromElements(\n        angle,\n        cY,\n        touchPinchMovementEvent.angleAndHeight.endPosition,\n      );\n\n      action(touchPinchMovementEvent);\n    }\n  }\n}\n\nfunction handlePointerDown(screenSpaceEventHandler, event) {\n  event.target.setPointerCapture(event.pointerId);\n\n  if (event.pointerType === \"touch\") {\n    const positions = screenSpaceEventHandler._positions;\n\n    const identifier = event.pointerId;\n    positions.set(\n      identifier,\n      getPosition(screenSpaceEventHandler, event, new Cartesian2()),\n    );\n\n    fireTouchEvents(screenSpaceEventHandler, event);\n\n    const previousPositions = screenSpaceEventHandler._previousPositions;\n    previousPositions.set(\n      identifier,\n      Cartesian2.clone(positions.get(identifier)),\n    );\n  } else {\n    handleMouseDown(screenSpaceEventHandler, event);\n  }\n}\n\nfunction handlePointerUp(screenSpaceEventHandler, event) {\n  if (event.pointerType === \"touch\") {\n    const positions = screenSpaceEventHandler._positions;\n\n    const identifier = event.pointerId;\n    positions.remove(identifier);\n\n    fireTouchEvents(screenSpaceEventHandler, event);\n\n    const previousPositions = screenSpaceEventHandler._previousPositions;\n    previousPositions.remove(identifier);\n  } else {\n    handleMouseUp(screenSpaceEventHandler, event);\n  }\n}\n\nfunction handlePointerMove(screenSpaceEventHandler, event) {\n  if (event.pointerType === \"touch\") {\n    const positions = screenSpaceEventHandler._positions;\n\n    const identifier = event.pointerId;\n    const position = positions.get(identifier);\n    if (!defined(position)) {\n      return;\n    }\n\n    getPosition(screenSpaceEventHandler, event, position);\n    fireTouchMoveEvents(screenSpaceEventHandler, event);\n\n    const previousPositions = screenSpaceEventHandler._previousPositions;\n    Cartesian2.clone(\n      positions.get(identifier),\n      previousPositions.get(identifier),\n    );\n  } else {\n    handleMouseMove(screenSpaceEventHandler, event);\n  }\n}\n\n/**\n * @typedef {object} ScreenSpaceEventHandler.PositionedEvent\n *\n * An Event that occurs at a single position on screen.\n *\n * @property {Cartesian2} position\n */\n\n/**\n * @callback ScreenSpaceEventHandler.PositionedEventCallback\n *\n * The callback invoked when a positioned event triggers an event listener.\n *\n * @param {ScreenSpaceEventHandler.PositionedEvent} event The event which triggered the listener\n */\n\n/**\n * @typedef {object} ScreenSpaceEventHandler.MotionEvent\n *\n * An Event that starts at one position and ends at another.\n *\n * @property {Cartesian2} startPosition\n * @property {Cartesian2} endPosition\n */\n\n/**\n * @callback ScreenSpaceEventHandler.MotionEventCallback\n *\n * The callback invoked when a motion event triggers an event listener.\n *\n * @param {ScreenSpaceEventHandler.MotionEvent} event The event which triggered the listener\n */\n\n/**\n * @typedef {object} ScreenSpaceEventHandler.TwoPointEvent\n *\n * An Event that occurs at a two positions on screen.\n *\n * @property {Cartesian2} position1\n * @property {Cartesian2} position2\n */\n\n/**\n * @callback ScreenSpaceEventHandler.TwoPointEventCallback\n *\n * The callback invoked when a two-point event triggers an event listener.\n *\n * @param {ScreenSpaceEventHandler.TwoPointEvent} event The event which triggered the listener\n */\n\n/**\n * @typedef {object} ScreenSpaceEventHandler.TwoPointMotionEvent\n *\n * An Event that starts at a two positions on screen and moves to two other positions.\n *\n * @property {Cartesian2} position1\n * @property {Cartesian2} position2\n * @property {Cartesian2} previousPosition1\n * @property {Cartesian2} previousPosition2\n */\n\n/**\n * @callback ScreenSpaceEventHandler.TwoPointMotionEventCallback\n *\n * The callback invoked when a two-point motion event triggers an event listener.\n *\n * @param {ScreenSpaceEventHandler.TwoPointMotionEvent} event The event which triggered the listener\n */\n\n/**\n * @callback ScreenSpaceEventHandler.WheelEventCallback\n *\n * The callback invoked when a mouse-wheel event triggers an event listener.\n *\n * @param {number} delta The amount that the mouse wheel moved\n */\n\n/**\n * Handles user input events. Custom functions can be added to be executed on\n * when the user enters input.\n *\n * @alias ScreenSpaceEventHandler\n *\n * @param {HTMLCanvasElement} [element=document] The element to add events to.\n *\n * @constructor\n */\nfunction ScreenSpaceEventHandler(element) {\n  this._inputEvents = {};\n  this._buttonDown = {\n    LEFT: false,\n    MIDDLE: false,\n    RIGHT: false,\n  };\n  this._isPinching = false;\n  this._isTouchHolding = false;\n  this._lastSeenTouchEvent =\n    -ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds;\n\n  this._primaryStartPosition = new Cartesian2();\n  this._primaryPosition = new Cartesian2();\n  this._primaryPreviousPosition = new Cartesian2();\n\n  this._positions = new AssociativeArray();\n  this._previousPositions = new AssociativeArray();\n\n  this._removalFunctions = [];\n\n  this._touchHoldTimer = undefined;\n\n  // TODO: Revisit when doing mobile development. May need to be configurable\n  // or determined based on the platform?\n  this._clickPixelTolerance = 5;\n  this._holdPixelTolerance = 25;\n\n  this._element = defaultValue(element, document);\n\n  registerListeners(this);\n}\n\n/**\n * Set a function to be executed on an input event.\n *\n * @param {ScreenSpaceEventHandler.PositionedEventCallback|ScreenSpaceEventHandler.MotionEventCallback|ScreenSpaceEventHandler.WheelEventCallback|ScreenSpaceEventHandler.TwoPointEventCallback|ScreenSpaceEventHandler.TwoPointMotionEventCallback} action Function to be executed when the input event occurs.\n * @param {ScreenSpaceEventType} type The ScreenSpaceEventType of input event.\n * @param {KeyboardEventModifier} [modifier] A KeyboardEventModifier key that is held when a <code>type</code>\n * event occurs.\n *\n * @see ScreenSpaceEventHandler#getInputAction\n * @see ScreenSpaceEventHandler#removeInputAction\n */\nScreenSpaceEventHandler.prototype.setInputAction = function (\n  action,\n  type,\n  modifier,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(action)) {\n    throw new DeveloperError(\"action is required.\");\n  }\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getInputEventKey(type, modifier);\n  this._inputEvents[key] = action;\n};\n\n/**\n * Returns the function to be executed on an input event.\n *\n * @param {ScreenSpaceEventType} type The ScreenSpaceEventType of input event.\n * @param {KeyboardEventModifier} [modifier] A KeyboardEventModifier key that is held when a <code>type</code>\n * event occurs.\n *\n * @returns {ScreenSpaceEventHandler.PositionedEventCallback|ScreenSpaceEventHandler.MotionEventCallback|ScreenSpaceEventHandler.WheelEventCallback|ScreenSpaceEventHandler.TwoPointEventCallback|ScreenSpaceEventHandler.TwoPointMotionEventCallback} The function to be executed on an input event.\n *\n * @see ScreenSpaceEventHandler#setInputAction\n * @see ScreenSpaceEventHandler#removeInputAction\n */\nScreenSpaceEventHandler.prototype.getInputAction = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getInputEventKey(type, modifier);\n  return this._inputEvents[key];\n};\n\n/**\n * Removes the function to be executed on an input event.\n *\n * @param {ScreenSpaceEventType} type The ScreenSpaceEventType of input event.\n * @param {KeyboardEventModifier} [modifier] A KeyboardEventModifier key that is held when a <code>type</code>\n * event occurs.\n *\n * @see ScreenSpaceEventHandler#getInputAction\n * @see ScreenSpaceEventHandler#setInputAction\n */\nScreenSpaceEventHandler.prototype.removeInputAction = function (\n  type,\n  modifier,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getInputEventKey(type, modifier);\n  delete this._inputEvents[key];\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ScreenSpaceEventHandler#destroy\n */\nScreenSpaceEventHandler.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * handler = handler && handler.destroy();\n *\n * @see ScreenSpaceEventHandler#isDestroyed\n */\nScreenSpaceEventHandler.prototype.destroy = function () {\n  unregisterListeners(this);\n\n  return destroyObject(this);\n};\n\n/**\n * The amount of time, in milliseconds, that mouse events will be disabled after\n * receiving any touch events, such that any emulated mouse events will be ignored.\n * @type {number}\n * @default 800\n */\nScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds = 800;\n\n/**\n * The amount of time, in milliseconds, before a touch on the screen becomes a\n * touch and hold.\n * @type {number}\n * @default 1500\n */\nScreenSpaceEventHandler.touchHoldDelayMilliseconds = 1500;\nexport default ScreenSpaceEventHandler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}