{"ast":null,"code":"//This file is automatically rebuilt by the Cesium build process.\nexport default \"// See Intersection.glsl for the definition of intersectScene\\n\\\n// See IntersectionUtils.glsl for the definition of nextIntersection\\n\\\n// See convertUvToBox.glsl, convertUvToCylinder.glsl, or convertUvToEllipsoid.glsl\\n\\\n// for the definition of convertUvToShapeUvSpace. The appropriate function is \\n\\\n// selected based on the VoxelPrimitive shape type, and added to the shader in\\n\\\n// Scene/VoxelRenderResources.js.\\n\\\n// See Octree.glsl for the definitions of TraversalData, SampleData,\\n\\\n// traverseOctreeFromBeginning, and traverseOctreeFromExisting\\n\\\n// See Megatexture.glsl for the definition of accumulatePropertiesFromMegatexture\\n\\\n\\n\\\n#define STEP_COUNT_MAX 1000 // Harcoded value because GLSL doesn't like variable length loops\\n\\\n#if defined(PICKING_VOXEL)\\n\\\n    #define ALPHA_ACCUM_MAX 0.1\\n\\\n#else\\n\\\n    #define ALPHA_ACCUM_MAX 0.98 // Must be > 0.0 and <= 1.0\\n\\\n#endif\\n\\\n\\n\\\nuniform mat3 u_transformDirectionViewToLocal;\\n\\\nuniform vec3 u_cameraPositionUv;\\n\\\nuniform float u_stepSize;\\n\\\n\\n\\\n#if defined(PICKING)\\n\\\n    uniform vec4 u_pickColor;\\n\\\n#endif\\n\\\n\\n\\\nvec3 getSampleSize(in int level) {\\n\\\n    vec3 sampleCount = exp2(float(level)) * vec3(u_dimensions);\\n\\\n    vec3 sampleSizeUv = 1.0 / sampleCount;\\n\\\n    return scaleShapeUvToShapeSpace(sampleSizeUv);\\n\\\n}\\n\\\n\\n\\\n#define MINIMUM_STEP_SCALAR (0.02)\\n\\\n#define SHIFT_FRACTION (0.001)\\n\\\n\\n\\\n/**\\n\\\n * Given a coordinate within a tile, and sample spacings along a ray through\\n\\\n * the coordinate, find the distance to the points where the ray entered and\\n\\\n * exited the voxel cell, along with the surface normals at those points.\\n\\\n * The surface normals are returned in shape space coordinates.\\n\\\n */\\n\\\nRayShapeIntersection getVoxelIntersection(in vec3 tileUv, in vec3 sampleSizeAlongRay) {\\n\\\n    vec3 voxelCoord = tileUv * vec3(u_dimensions);\\n\\\n    vec3 directions = sign(sampleSizeAlongRay);\\n\\\n    vec3 positiveDirections = max(directions, 0.0);\\n\\\n    vec3 entryCoord = mix(ceil(voxelCoord), floor(voxelCoord), positiveDirections);\\n\\\n    vec3 exitCoord = entryCoord + directions;\\n\\\n\\n\\\n    vec3 distanceFromEntry = -abs((entryCoord - voxelCoord) * sampleSizeAlongRay);\\n\\\n    float lastEntry = maxComponent(distanceFromEntry);\\n\\\n    bvec3 isLastEntry = equal(distanceFromEntry, vec3(lastEntry));\\n\\\n    vec3 entryNormal = -1.0 * vec3(isLastEntry) * directions;\\n\\\n    vec4 entry = vec4(entryNormal, lastEntry);\\n\\\n\\n\\\n    vec3 distanceToExit = abs((exitCoord - voxelCoord) * sampleSizeAlongRay);\\n\\\n    float firstExit = minComponent(distanceToExit);\\n\\\n    bvec3 isFirstExit = equal(distanceToExit, vec3(firstExit));\\n\\\n    vec3 exitNormal = vec3(isFirstExit) * directions;\\n\\\n    vec4 exit = vec4(exitNormal, firstExit);\\n\\\n\\n\\\n    return RayShapeIntersection(entry, exit);\\n\\\n}\\n\\\n\\n\\\nvec4 getStepSize(in SampleData sampleData, in Ray viewRay, in RayShapeIntersection shapeIntersection, in mat3 jacobianT, in float currentT) {\\n\\\n    // The Jacobian is computed in a space where the shape spans [-1, 1].\\n\\\n    // But the ray is marched in a space where the shape fills [0, 1].\\n\\\n    // So we need to scale the Jacobian by 2.\\n\\\n    vec3 gradient = 2.0 * viewRay.rawDir * jacobianT;\\n\\\n    vec3 sampleSizeAlongRay = getSampleSize(sampleData.tileCoords.w) / gradient;\\n\\\n\\n\\\n    RayShapeIntersection voxelIntersection = getVoxelIntersection(sampleData.tileUv, sampleSizeAlongRay);\\n\\\n\\n\\\n    // Transform normal from shape space to Cartesian space\\n\\\n    vec3 voxelNormal = normalize(jacobianT * voxelIntersection.entry.xyz);\\n\\\n    // Compare with the shape intersection, to choose the appropriate normal\\n\\\n    vec4 voxelEntry = vec4(voxelNormal, currentT + voxelIntersection.entry.w);\\n\\\n    vec4 entry = intersectionMax(shapeIntersection.entry, voxelEntry);\\n\\\n\\n\\\n    float fixedStep = minComponent(abs(sampleSizeAlongRay)) * u_stepSize;\\n\\\n    float shift = fixedStep * SHIFT_FRACTION;\\n\\\n    float dt = voxelIntersection.exit.w + shift;\\n\\\n    if ((currentT + dt) > shapeIntersection.exit.w) {\\n\\\n        // Stop at end of shape\\n\\\n        dt = shapeIntersection.exit.w - currentT + shift;\\n\\\n    }\\n\\\n    float stepSize = clamp(dt, fixedStep * MINIMUM_STEP_SCALAR, fixedStep + shift);\\n\\\n\\n\\\n    return vec4(entry.xyz, stepSize);\\n\\\n}\\n\\\n\\n\\\nvec2 packIntToVec2(int value) {\\n\\\n    float shifted = float(value) / 255.0;\\n\\\n    float lowBits = fract(shifted);\\n\\\n    float highBits = floor(shifted) / 255.0;\\n\\\n    return vec2(highBits, lowBits);\\n\\\n}\\n\\\n\\n\\\nvec2 packFloatToVec2(float value) {\\n\\\n    float lowBits = fract(value);\\n\\\n    float highBits = floor(value) / 255.0;\\n\\\n    return vec2(highBits, lowBits);\\n\\\n}\\n\\\n\\n\\\nint getSampleIndex(in vec3 tileUv) {\\n\\\n    ivec3 voxelDimensions = u_dimensions;\\n\\\n    vec3 sampleCoordinate = tileUv * vec3(voxelDimensions);\\n\\\n    // tileUv = 1.0 is a valid coordinate but sampleIndex = voxelDimensions is not.\\n\\\n    // (tileUv = 1.0 corresponds to the last sample, at index = voxelDimensions - 1).\\n\\\n    // Clamp to [0, voxelDimensions - 0.5) to avoid numerical error before flooring\\n\\\n    vec3 maxCoordinate = vec3(voxelDimensions) - vec3(0.5);\\n\\\n    sampleCoordinate = clamp(sampleCoordinate, vec3(0.0), maxCoordinate);\\n\\\n    ivec3 sampleIndex = ivec3(floor(sampleCoordinate));\\n\\\n    #if defined(PADDING)\\n\\\n        voxelDimensions += u_paddingBefore + u_paddingAfter;\\n\\\n        sampleIndex += u_paddingBefore;\\n\\\n    #endif\\n\\\n    // Convert to a 1D index for lookup in a 1D data array\\n\\\n    return sampleIndex.x + voxelDimensions.x * (sampleIndex.y + voxelDimensions.y * sampleIndex.z);\\n\\\n}\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 fragCoord = gl_FragCoord;\\n\\\n    vec2 screenCoord = (fragCoord.xy - czm_viewport.xy) / czm_viewport.zw; // [0,1]\\n\\\n    vec3 eyeDirection = normalize(czm_windowToEyeCoordinates(fragCoord).xyz);\\n\\\n    vec3 viewDirWorld = normalize(czm_inverseViewRotation * eyeDirection); // normalize again just in case\\n\\\n    vec3 viewDirUv = normalize(u_transformDirectionViewToLocal * eyeDirection); // normalize again just in case\\n\\\n    vec3 viewPosUv = u_cameraPositionUv;\\n\\\n    #if defined(SHAPE_ELLIPSOID)\\n\\\n        // viewDirUv has been scaled to a space where the ellipsoid is a sphere.\\n\\\n        // Undo this scaling to get the raw direction.\\n\\\n        vec3 rawDir = viewDirUv * u_ellipsoidRadiiUv;\\n\\\n        Ray viewRayUv = Ray(viewPosUv, viewDirUv, rawDir);\\n\\\n    #else\\n\\\n        Ray viewRayUv = Ray(viewPosUv, viewDirUv, viewDirUv);\\n\\\n    #endif\\n\\\n\\n\\\n    Intersections ix;\\n\\\n    RayShapeIntersection shapeIntersection = intersectScene(screenCoord, viewRayUv, ix);\\n\\\n\\n\\\n    // Exit early if the scene was completely missed.\\n\\\n    if (shapeIntersection.entry.w == NO_HIT) {\\n\\\n        discard;\\n\\\n    }\\n\\\n\\n\\\n    float currentT = shapeIntersection.entry.w;\\n\\\n    float endT = shapeIntersection.exit.w;\\n\\\n    vec3 positionUv = viewPosUv + currentT * viewDirUv;\\n\\\n    PointJacobianT pointJacobian = convertUvToShapeUvSpaceDerivative(positionUv);\\n\\\n\\n\\\n    // Traverse the tree from the start position\\n\\\n    TraversalData traversalData;\\n\\\n    SampleData sampleDatas[SAMPLE_COUNT];\\n\\\n    traverseOctreeFromBeginning(pointJacobian.point, traversalData, sampleDatas);\\n\\\n    vec4 step = getStepSize(sampleDatas[0], viewRayUv, shapeIntersection, pointJacobian.jacobianT, currentT);\\n\\\n\\n\\\n    #if defined(JITTER)\\n\\\n        float noise = hash(screenCoord); // [0,1]\\n\\\n        currentT += noise * step.w;\\n\\\n        positionUv += noise * step.w * viewDirUv;\\n\\\n    #endif\\n\\\n\\n\\\n    FragmentInput fragmentInput;\\n\\\n    #if defined(STATISTICS)\\n\\\n        setStatistics(fragmentInput.metadata.statistics);\\n\\\n    #endif\\n\\\n\\n\\\n    vec4 colorAccum = vec4(0.0);\\n\\\n\\n\\\n    for (int stepCount = 0; stepCount < STEP_COUNT_MAX; ++stepCount) {\\n\\\n        // Read properties from the megatexture based on the traversal state\\n\\\n        Properties properties = accumulatePropertiesFromMegatexture(sampleDatas);\\n\\\n\\n\\\n        // Prepare the custom shader inputs\\n\\\n        copyPropertiesToMetadata(properties, fragmentInput.metadata);\\n\\\n        fragmentInput.voxel.positionUv = positionUv;\\n\\\n        fragmentInput.voxel.positionShapeUv = pointJacobian.point;\\n\\\n        fragmentInput.voxel.positionUvLocal = sampleDatas[0].tileUv;\\n\\\n        fragmentInput.voxel.viewDirUv = viewDirUv;\\n\\\n        fragmentInput.voxel.viewDirWorld = viewDirWorld;\\n\\\n        fragmentInput.voxel.surfaceNormal = step.xyz;\\n\\\n        fragmentInput.voxel.travelDistance = step.w;\\n\\\n        fragmentInput.voxel.stepCount = stepCount;\\n\\\n        fragmentInput.voxel.tileIndex = sampleDatas[0].megatextureIndex;\\n\\\n        fragmentInput.voxel.sampleIndex = getSampleIndex(sampleDatas[0].tileUv);\\n\\\n\\n\\\n        // Run the custom shader\\n\\\n        czm_modelMaterial materialOutput;\\n\\\n        fragmentMain(fragmentInput, materialOutput);\\n\\\n\\n\\\n        // Sanitize the custom shader output\\n\\\n        vec4 color = vec4(materialOutput.diffuse, materialOutput.alpha);\\n\\\n        color.rgb = max(color.rgb, vec3(0.0));\\n\\\n        color.a = clamp(color.a, 0.0, 1.0);\\n\\\n\\n\\\n        // Pre-multiplied alpha blend\\n\\\n        colorAccum += (1.0 - colorAccum.a) * vec4(color.rgb * color.a, color.a);\\n\\\n\\n\\\n        // Stop traversing if the alpha has been fully saturated\\n\\\n        if (colorAccum.a > ALPHA_ACCUM_MAX) {\\n\\\n            colorAccum.a = ALPHA_ACCUM_MAX;\\n\\\n            break;\\n\\\n        }\\n\\\n\\n\\\n        if (step.w == 0.0) {\\n\\\n            // Shape is infinitely thin. The ray may have hit the edge of a\\n\\\n            // foreground voxel. Step ahead slightly to check for more voxels\\n\\\n            step.w == 0.00001;\\n\\\n        }\\n\\\n\\n\\\n        // Keep raymarching\\n\\\n        currentT += step.w;\\n\\\n        positionUv = viewPosUv + currentT * viewDirUv;\\n\\\n\\n\\\n        // Check if there's more intersections.\\n\\\n        if (currentT > endT) {\\n\\\n            #if (INTERSECTION_COUNT == 1)\\n\\\n                break;\\n\\\n            #else\\n\\\n                shapeIntersection = nextIntersection(ix);\\n\\\n                if (shapeIntersection.entry.w == NO_HIT) {\\n\\\n                    break;\\n\\\n                } else {\\n\\\n                    // Found another intersection. Resume raymarching there\\n\\\n                    currentT = shapeIntersection.entry.w;\\n\\\n                    endT = shapeIntersection.exit.w;\\n\\\n                    positionUv = viewPosUv + currentT * viewDirUv;\\n\\\n                }\\n\\\n            #endif\\n\\\n        }\\n\\\n\\n\\\n        // Traverse the tree from the current ray position.\\n\\\n        // This is similar to traverseOctreeFromBeginning but is faster when the ray is in the same tile as the previous step.\\n\\\n        pointJacobian = convertUvToShapeUvSpaceDerivative(positionUv);\\n\\\n        traverseOctreeFromExisting(pointJacobian.point, traversalData, sampleDatas);\\n\\\n        step = getStepSize(sampleDatas[0], viewRayUv, shapeIntersection, pointJacobian.jacobianT, currentT);\\n\\\n    }\\n\\\n\\n\\\n    // Convert the alpha from [0,ALPHA_ACCUM_MAX] to [0,1]\\n\\\n    colorAccum.a /= ALPHA_ACCUM_MAX;\\n\\\n\\n\\\n    #if defined(PICKING)\\n\\\n        // If alpha is 0.0 there is nothing to pick\\n\\\n        if (colorAccum.a == 0.0) {\\n\\\n            discard;\\n\\\n        }\\n\\\n        out_FragColor = u_pickColor;\\n\\\n    #elif defined(PICKING_VOXEL)\\n\\\n        // If alpha is 0.0 there is nothing to pick\\n\\\n        if (colorAccum.a == 0.0) {\\n\\\n            discard;\\n\\\n        }\\n\\\n        vec2 megatextureId = packIntToVec2(sampleDatas[0].megatextureIndex);\\n\\\n        vec2 sampleIndex = packIntToVec2(getSampleIndex(sampleDatas[0].tileUv));\\n\\\n        out_FragColor = vec4(megatextureId, sampleIndex);\\n\\\n    #else\\n\\\n        out_FragColor = colorAccum;\\n\\\n    #endif\\n\\\n}\\n\\\n\";","map":{"version":3,"names":[],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Shaders/Voxels/VoxelFS.js"],"sourcesContent":["//This file is automatically rebuilt by the Cesium build process.\nexport default \"// See Intersection.glsl for the definition of intersectScene\\n\\\n// See IntersectionUtils.glsl for the definition of nextIntersection\\n\\\n// See convertUvToBox.glsl, convertUvToCylinder.glsl, or convertUvToEllipsoid.glsl\\n\\\n// for the definition of convertUvToShapeUvSpace. The appropriate function is \\n\\\n// selected based on the VoxelPrimitive shape type, and added to the shader in\\n\\\n// Scene/VoxelRenderResources.js.\\n\\\n// See Octree.glsl for the definitions of TraversalData, SampleData,\\n\\\n// traverseOctreeFromBeginning, and traverseOctreeFromExisting\\n\\\n// See Megatexture.glsl for the definition of accumulatePropertiesFromMegatexture\\n\\\n\\n\\\n#define STEP_COUNT_MAX 1000 // Harcoded value because GLSL doesn't like variable length loops\\n\\\n#if defined(PICKING_VOXEL)\\n\\\n    #define ALPHA_ACCUM_MAX 0.1\\n\\\n#else\\n\\\n    #define ALPHA_ACCUM_MAX 0.98 // Must be > 0.0 and <= 1.0\\n\\\n#endif\\n\\\n\\n\\\nuniform mat3 u_transformDirectionViewToLocal;\\n\\\nuniform vec3 u_cameraPositionUv;\\n\\\nuniform float u_stepSize;\\n\\\n\\n\\\n#if defined(PICKING)\\n\\\n    uniform vec4 u_pickColor;\\n\\\n#endif\\n\\\n\\n\\\nvec3 getSampleSize(in int level) {\\n\\\n    vec3 sampleCount = exp2(float(level)) * vec3(u_dimensions);\\n\\\n    vec3 sampleSizeUv = 1.0 / sampleCount;\\n\\\n    return scaleShapeUvToShapeSpace(sampleSizeUv);\\n\\\n}\\n\\\n\\n\\\n#define MINIMUM_STEP_SCALAR (0.02)\\n\\\n#define SHIFT_FRACTION (0.001)\\n\\\n\\n\\\n/**\\n\\\n * Given a coordinate within a tile, and sample spacings along a ray through\\n\\\n * the coordinate, find the distance to the points where the ray entered and\\n\\\n * exited the voxel cell, along with the surface normals at those points.\\n\\\n * The surface normals are returned in shape space coordinates.\\n\\\n */\\n\\\nRayShapeIntersection getVoxelIntersection(in vec3 tileUv, in vec3 sampleSizeAlongRay) {\\n\\\n    vec3 voxelCoord = tileUv * vec3(u_dimensions);\\n\\\n    vec3 directions = sign(sampleSizeAlongRay);\\n\\\n    vec3 positiveDirections = max(directions, 0.0);\\n\\\n    vec3 entryCoord = mix(ceil(voxelCoord), floor(voxelCoord), positiveDirections);\\n\\\n    vec3 exitCoord = entryCoord + directions;\\n\\\n\\n\\\n    vec3 distanceFromEntry = -abs((entryCoord - voxelCoord) * sampleSizeAlongRay);\\n\\\n    float lastEntry = maxComponent(distanceFromEntry);\\n\\\n    bvec3 isLastEntry = equal(distanceFromEntry, vec3(lastEntry));\\n\\\n    vec3 entryNormal = -1.0 * vec3(isLastEntry) * directions;\\n\\\n    vec4 entry = vec4(entryNormal, lastEntry);\\n\\\n\\n\\\n    vec3 distanceToExit = abs((exitCoord - voxelCoord) * sampleSizeAlongRay);\\n\\\n    float firstExit = minComponent(distanceToExit);\\n\\\n    bvec3 isFirstExit = equal(distanceToExit, vec3(firstExit));\\n\\\n    vec3 exitNormal = vec3(isFirstExit) * directions;\\n\\\n    vec4 exit = vec4(exitNormal, firstExit);\\n\\\n\\n\\\n    return RayShapeIntersection(entry, exit);\\n\\\n}\\n\\\n\\n\\\nvec4 getStepSize(in SampleData sampleData, in Ray viewRay, in RayShapeIntersection shapeIntersection, in mat3 jacobianT, in float currentT) {\\n\\\n    // The Jacobian is computed in a space where the shape spans [-1, 1].\\n\\\n    // But the ray is marched in a space where the shape fills [0, 1].\\n\\\n    // So we need to scale the Jacobian by 2.\\n\\\n    vec3 gradient = 2.0 * viewRay.rawDir * jacobianT;\\n\\\n    vec3 sampleSizeAlongRay = getSampleSize(sampleData.tileCoords.w) / gradient;\\n\\\n\\n\\\n    RayShapeIntersection voxelIntersection = getVoxelIntersection(sampleData.tileUv, sampleSizeAlongRay);\\n\\\n\\n\\\n    // Transform normal from shape space to Cartesian space\\n\\\n    vec3 voxelNormal = normalize(jacobianT * voxelIntersection.entry.xyz);\\n\\\n    // Compare with the shape intersection, to choose the appropriate normal\\n\\\n    vec4 voxelEntry = vec4(voxelNormal, currentT + voxelIntersection.entry.w);\\n\\\n    vec4 entry = intersectionMax(shapeIntersection.entry, voxelEntry);\\n\\\n\\n\\\n    float fixedStep = minComponent(abs(sampleSizeAlongRay)) * u_stepSize;\\n\\\n    float shift = fixedStep * SHIFT_FRACTION;\\n\\\n    float dt = voxelIntersection.exit.w + shift;\\n\\\n    if ((currentT + dt) > shapeIntersection.exit.w) {\\n\\\n        // Stop at end of shape\\n\\\n        dt = shapeIntersection.exit.w - currentT + shift;\\n\\\n    }\\n\\\n    float stepSize = clamp(dt, fixedStep * MINIMUM_STEP_SCALAR, fixedStep + shift);\\n\\\n\\n\\\n    return vec4(entry.xyz, stepSize);\\n\\\n}\\n\\\n\\n\\\nvec2 packIntToVec2(int value) {\\n\\\n    float shifted = float(value) / 255.0;\\n\\\n    float lowBits = fract(shifted);\\n\\\n    float highBits = floor(shifted) / 255.0;\\n\\\n    return vec2(highBits, lowBits);\\n\\\n}\\n\\\n\\n\\\nvec2 packFloatToVec2(float value) {\\n\\\n    float lowBits = fract(value);\\n\\\n    float highBits = floor(value) / 255.0;\\n\\\n    return vec2(highBits, lowBits);\\n\\\n}\\n\\\n\\n\\\nint getSampleIndex(in vec3 tileUv) {\\n\\\n    ivec3 voxelDimensions = u_dimensions;\\n\\\n    vec3 sampleCoordinate = tileUv * vec3(voxelDimensions);\\n\\\n    // tileUv = 1.0 is a valid coordinate but sampleIndex = voxelDimensions is not.\\n\\\n    // (tileUv = 1.0 corresponds to the last sample, at index = voxelDimensions - 1).\\n\\\n    // Clamp to [0, voxelDimensions - 0.5) to avoid numerical error before flooring\\n\\\n    vec3 maxCoordinate = vec3(voxelDimensions) - vec3(0.5);\\n\\\n    sampleCoordinate = clamp(sampleCoordinate, vec3(0.0), maxCoordinate);\\n\\\n    ivec3 sampleIndex = ivec3(floor(sampleCoordinate));\\n\\\n    #if defined(PADDING)\\n\\\n        voxelDimensions += u_paddingBefore + u_paddingAfter;\\n\\\n        sampleIndex += u_paddingBefore;\\n\\\n    #endif\\n\\\n    // Convert to a 1D index for lookup in a 1D data array\\n\\\n    return sampleIndex.x + voxelDimensions.x * (sampleIndex.y + voxelDimensions.y * sampleIndex.z);\\n\\\n}\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 fragCoord = gl_FragCoord;\\n\\\n    vec2 screenCoord = (fragCoord.xy - czm_viewport.xy) / czm_viewport.zw; // [0,1]\\n\\\n    vec3 eyeDirection = normalize(czm_windowToEyeCoordinates(fragCoord).xyz);\\n\\\n    vec3 viewDirWorld = normalize(czm_inverseViewRotation * eyeDirection); // normalize again just in case\\n\\\n    vec3 viewDirUv = normalize(u_transformDirectionViewToLocal * eyeDirection); // normalize again just in case\\n\\\n    vec3 viewPosUv = u_cameraPositionUv;\\n\\\n    #if defined(SHAPE_ELLIPSOID)\\n\\\n        // viewDirUv has been scaled to a space where the ellipsoid is a sphere.\\n\\\n        // Undo this scaling to get the raw direction.\\n\\\n        vec3 rawDir = viewDirUv * u_ellipsoidRadiiUv;\\n\\\n        Ray viewRayUv = Ray(viewPosUv, viewDirUv, rawDir);\\n\\\n    #else\\n\\\n        Ray viewRayUv = Ray(viewPosUv, viewDirUv, viewDirUv);\\n\\\n    #endif\\n\\\n\\n\\\n    Intersections ix;\\n\\\n    RayShapeIntersection shapeIntersection = intersectScene(screenCoord, viewRayUv, ix);\\n\\\n\\n\\\n    // Exit early if the scene was completely missed.\\n\\\n    if (shapeIntersection.entry.w == NO_HIT) {\\n\\\n        discard;\\n\\\n    }\\n\\\n\\n\\\n    float currentT = shapeIntersection.entry.w;\\n\\\n    float endT = shapeIntersection.exit.w;\\n\\\n    vec3 positionUv = viewPosUv + currentT * viewDirUv;\\n\\\n    PointJacobianT pointJacobian = convertUvToShapeUvSpaceDerivative(positionUv);\\n\\\n\\n\\\n    // Traverse the tree from the start position\\n\\\n    TraversalData traversalData;\\n\\\n    SampleData sampleDatas[SAMPLE_COUNT];\\n\\\n    traverseOctreeFromBeginning(pointJacobian.point, traversalData, sampleDatas);\\n\\\n    vec4 step = getStepSize(sampleDatas[0], viewRayUv, shapeIntersection, pointJacobian.jacobianT, currentT);\\n\\\n\\n\\\n    #if defined(JITTER)\\n\\\n        float noise = hash(screenCoord); // [0,1]\\n\\\n        currentT += noise * step.w;\\n\\\n        positionUv += noise * step.w * viewDirUv;\\n\\\n    #endif\\n\\\n\\n\\\n    FragmentInput fragmentInput;\\n\\\n    #if defined(STATISTICS)\\n\\\n        setStatistics(fragmentInput.metadata.statistics);\\n\\\n    #endif\\n\\\n\\n\\\n    vec4 colorAccum = vec4(0.0);\\n\\\n\\n\\\n    for (int stepCount = 0; stepCount < STEP_COUNT_MAX; ++stepCount) {\\n\\\n        // Read properties from the megatexture based on the traversal state\\n\\\n        Properties properties = accumulatePropertiesFromMegatexture(sampleDatas);\\n\\\n\\n\\\n        // Prepare the custom shader inputs\\n\\\n        copyPropertiesToMetadata(properties, fragmentInput.metadata);\\n\\\n        fragmentInput.voxel.positionUv = positionUv;\\n\\\n        fragmentInput.voxel.positionShapeUv = pointJacobian.point;\\n\\\n        fragmentInput.voxel.positionUvLocal = sampleDatas[0].tileUv;\\n\\\n        fragmentInput.voxel.viewDirUv = viewDirUv;\\n\\\n        fragmentInput.voxel.viewDirWorld = viewDirWorld;\\n\\\n        fragmentInput.voxel.surfaceNormal = step.xyz;\\n\\\n        fragmentInput.voxel.travelDistance = step.w;\\n\\\n        fragmentInput.voxel.stepCount = stepCount;\\n\\\n        fragmentInput.voxel.tileIndex = sampleDatas[0].megatextureIndex;\\n\\\n        fragmentInput.voxel.sampleIndex = getSampleIndex(sampleDatas[0].tileUv);\\n\\\n\\n\\\n        // Run the custom shader\\n\\\n        czm_modelMaterial materialOutput;\\n\\\n        fragmentMain(fragmentInput, materialOutput);\\n\\\n\\n\\\n        // Sanitize the custom shader output\\n\\\n        vec4 color = vec4(materialOutput.diffuse, materialOutput.alpha);\\n\\\n        color.rgb = max(color.rgb, vec3(0.0));\\n\\\n        color.a = clamp(color.a, 0.0, 1.0);\\n\\\n\\n\\\n        // Pre-multiplied alpha blend\\n\\\n        colorAccum += (1.0 - colorAccum.a) * vec4(color.rgb * color.a, color.a);\\n\\\n\\n\\\n        // Stop traversing if the alpha has been fully saturated\\n\\\n        if (colorAccum.a > ALPHA_ACCUM_MAX) {\\n\\\n            colorAccum.a = ALPHA_ACCUM_MAX;\\n\\\n            break;\\n\\\n        }\\n\\\n\\n\\\n        if (step.w == 0.0) {\\n\\\n            // Shape is infinitely thin. The ray may have hit the edge of a\\n\\\n            // foreground voxel. Step ahead slightly to check for more voxels\\n\\\n            step.w == 0.00001;\\n\\\n        }\\n\\\n\\n\\\n        // Keep raymarching\\n\\\n        currentT += step.w;\\n\\\n        positionUv = viewPosUv + currentT * viewDirUv;\\n\\\n\\n\\\n        // Check if there's more intersections.\\n\\\n        if (currentT > endT) {\\n\\\n            #if (INTERSECTION_COUNT == 1)\\n\\\n                break;\\n\\\n            #else\\n\\\n                shapeIntersection = nextIntersection(ix);\\n\\\n                if (shapeIntersection.entry.w == NO_HIT) {\\n\\\n                    break;\\n\\\n                } else {\\n\\\n                    // Found another intersection. Resume raymarching there\\n\\\n                    currentT = shapeIntersection.entry.w;\\n\\\n                    endT = shapeIntersection.exit.w;\\n\\\n                    positionUv = viewPosUv + currentT * viewDirUv;\\n\\\n                }\\n\\\n            #endif\\n\\\n        }\\n\\\n\\n\\\n        // Traverse the tree from the current ray position.\\n\\\n        // This is similar to traverseOctreeFromBeginning but is faster when the ray is in the same tile as the previous step.\\n\\\n        pointJacobian = convertUvToShapeUvSpaceDerivative(positionUv);\\n\\\n        traverseOctreeFromExisting(pointJacobian.point, traversalData, sampleDatas);\\n\\\n        step = getStepSize(sampleDatas[0], viewRayUv, shapeIntersection, pointJacobian.jacobianT, currentT);\\n\\\n    }\\n\\\n\\n\\\n    // Convert the alpha from [0,ALPHA_ACCUM_MAX] to [0,1]\\n\\\n    colorAccum.a /= ALPHA_ACCUM_MAX;\\n\\\n\\n\\\n    #if defined(PICKING)\\n\\\n        // If alpha is 0.0 there is nothing to pick\\n\\\n        if (colorAccum.a == 0.0) {\\n\\\n            discard;\\n\\\n        }\\n\\\n        out_FragColor = u_pickColor;\\n\\\n    #elif defined(PICKING_VOXEL)\\n\\\n        // If alpha is 0.0 there is nothing to pick\\n\\\n        if (colorAccum.a == 0.0) {\\n\\\n            discard;\\n\\\n        }\\n\\\n        vec2 megatextureId = packIntToVec2(sampleDatas[0].megatextureIndex);\\n\\\n        vec2 sampleIndex = packIntToVec2(getSampleIndex(sampleDatas[0].tileUv));\\n\\\n        out_FragColor = vec4(megatextureId, sampleIndex);\\n\\\n    #else\\n\\\n        out_FragColor = colorAccum;\\n\\\n    #endif\\n\\\n}\\n\\\n\";\n"],"mappings":"AAAA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}