{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestState from \"../Core/RequestState.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport TerrainEncoding from \"../Core/TerrainEncoding.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport TerrainState from \"./TerrainState.js\";\n\n/**\n * Contains additional information about a {@link QuadtreeTile} of the globe's surface, and\n * encapsulates state transition logic for loading tiles.\n *\n * @constructor\n * @alias GlobeSurfaceTile\n * @private\n */\nfunction GlobeSurfaceTile() {\n  /**\n   * The {@link TileImagery} attached to this tile.\n   * @type {TileImagery[]}\n   * @default []\n   */\n  this.imagery = [];\n  this.waterMaskTexture = undefined;\n  this.waterMaskTranslationAndScale = new Cartesian4(0.0, 0.0, 1.0, 1.0);\n  this.terrainData = undefined;\n  this.vertexArray = undefined;\n\n  /**\n   * A bounding region used to estimate distance to the tile. The horizontal bounds are always tight-fitting,\n   * but the `minimumHeight` and `maximumHeight` properties may be derived from the min/max of an ancestor tile\n   * and be quite loose-fitting and thus very poor for estimating distance.\n   * @type {TileBoundingRegion}\n   */\n  this.tileBoundingRegion = undefined;\n  this.occludeePointInScaledSpace = new Cartesian3();\n  this.boundingVolumeSourceTile = undefined;\n  this.boundingVolumeIsFromMesh = false;\n  this.terrainState = TerrainState.UNLOADED;\n  this.mesh = undefined;\n  this.fill = undefined;\n  this.pickBoundingSphere = new BoundingSphere();\n  this.surfaceShader = undefined;\n  this.isClipped = true;\n  this.clippedByBoundaries = false;\n}\nObject.defineProperties(GlobeSurfaceTile.prototype, {\n  /**\n   * Gets a value indicating whether or not this tile is eligible to be unloaded.\n   * Typically, a tile is ineligible to be unloaded while an asynchronous operation,\n   * such as a request for data, is in progress on it.  A tile will never be\n   * unloaded while it is needed for rendering, regardless of the value of this\n   * property.\n   * @memberof GlobeSurfaceTile.prototype\n   * @type {boolean}\n   */\n  eligibleForUnloading: {\n    get: function () {\n      // Do not remove tiles that are transitioning or that have\n      // imagery that is transitioning.\n      const terrainState = this.terrainState;\n      const loadingIsTransitioning = terrainState === TerrainState.RECEIVING || terrainState === TerrainState.TRANSFORMING;\n      let shouldRemoveTile = !loadingIsTransitioning;\n      const imagery = this.imagery;\n      for (let i = 0, len = imagery.length; shouldRemoveTile && i < len; ++i) {\n        const tileImagery = imagery[i];\n        shouldRemoveTile = !defined(tileImagery.loadingImagery) || tileImagery.loadingImagery.state !== ImageryState.TRANSITIONING;\n      }\n      return shouldRemoveTile;\n    }\n  },\n  /**\n   * Gets the {@link TerrainMesh} that is used for rendering this tile, if any.\n   * Returns the value of the {@link GlobeSurfaceTile#mesh} property if\n   * {@link GlobeSurfaceTile#vertexArray} is defined. Otherwise, It returns the\n   * {@link TerrainFillMesh#mesh} property of the {@link GlobeSurfaceTile#fill}.\n   * If there is no fill, it returns undefined.\n   *\n   * @memberof GlobeSurfaceTile.prototype\n   * @type {TerrainMesh}\n   */\n  renderedMesh: {\n    get: function () {\n      if (defined(this.vertexArray)) {\n        return this.mesh;\n      } else if (defined(this.fill)) {\n        return this.fill.mesh;\n      }\n      return undefined;\n    }\n  }\n});\nconst scratchCartographic = new Cartographic();\nfunction getPosition(encoding, mode, projection, vertices, index, result) {\n  let position = encoding.getExaggeratedPosition(vertices, index, result);\n  if (defined(mode) && mode !== SceneMode.SCENE3D) {\n    const ellipsoid = projection.ellipsoid;\n    const positionCartographic = ellipsoid.cartesianToCartographic(position, scratchCartographic);\n    position = projection.project(positionCartographic, result);\n    position = Cartesian3.fromElements(position.z, position.x, position.y, result);\n  }\n  return position;\n}\nconst scratchV0 = new Cartesian3();\nconst scratchV1 = new Cartesian3();\nconst scratchV2 = new Cartesian3();\nGlobeSurfaceTile.prototype.pick = function (ray, mode, projection, cullBackFaces, result) {\n  const mesh = this.renderedMesh;\n  if (!defined(mesh)) {\n    return undefined;\n  }\n  const vertices = mesh.vertices;\n  const indices = mesh.indices;\n  const encoding = mesh.encoding;\n  const indicesLength = indices.length;\n  let minT = Number.MAX_VALUE;\n  for (let i = 0; i < indicesLength; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n    const v0 = getPosition(encoding, mode, projection, vertices, i0, scratchV0);\n    const v1 = getPosition(encoding, mode, projection, vertices, i1, scratchV1);\n    const v2 = getPosition(encoding, mode, projection, vertices, i2, scratchV2);\n    const t = IntersectionTests.rayTriangleParametric(ray, v0, v1, v2, cullBackFaces);\n    if (defined(t) && t < minT && t >= 0.0) {\n      minT = t;\n    }\n  }\n  return minT !== Number.MAX_VALUE ? Ray.getPoint(ray, minT, result) : undefined;\n};\nGlobeSurfaceTile.prototype.freeResources = function () {\n  if (defined(this.waterMaskTexture)) {\n    --this.waterMaskTexture.referenceCount;\n    if (this.waterMaskTexture.referenceCount === 0) {\n      this.waterMaskTexture.destroy();\n    }\n    this.waterMaskTexture = undefined;\n  }\n  this.terrainData = undefined;\n  this.terrainState = TerrainState.UNLOADED;\n  this.mesh = undefined;\n  this.fill = this.fill && this.fill.destroy();\n  const imageryList = this.imagery;\n  for (let i = 0, len = imageryList.length; i < len; ++i) {\n    imageryList[i].freeResources();\n  }\n  this.imagery.length = 0;\n  this.freeVertexArray();\n};\nGlobeSurfaceTile.prototype.freeVertexArray = function () {\n  GlobeSurfaceTile._freeVertexArray(this.vertexArray);\n  this.vertexArray = undefined;\n  GlobeSurfaceTile._freeVertexArray(this.wireframeVertexArray);\n  this.wireframeVertexArray = undefined;\n};\nGlobeSurfaceTile.initialize = function (tile, terrainProvider, imageryLayerCollection) {\n  let surfaceTile = tile.data;\n  if (!defined(surfaceTile)) {\n    surfaceTile = tile.data = new GlobeSurfaceTile();\n  }\n  if (tile.state === QuadtreeTileLoadState.START) {\n    prepareNewTile(tile, terrainProvider, imageryLayerCollection);\n    tile.state = QuadtreeTileLoadState.LOADING;\n  }\n};\nGlobeSurfaceTile.processStateMachine = function (tile, frameState, terrainProvider, imageryLayerCollection, quadtree, vertexArraysToDestroy, terrainOnly) {\n  GlobeSurfaceTile.initialize(tile, terrainProvider, imageryLayerCollection);\n  const surfaceTile = tile.data;\n  if (tile.state === QuadtreeTileLoadState.LOADING) {\n    processTerrainStateMachine(tile, frameState, terrainProvider, imageryLayerCollection, quadtree, vertexArraysToDestroy);\n  }\n\n  // From here down we're loading imagery, not terrain. We don't want to load imagery until\n  // we're certain that the terrain tiles are actually visible, though. We'll load terrainOnly\n  // in these scenarios:\n  //   * our bounding volume isn't accurate so we're not certain this tile is really visible (see GlobeSurfaceTileProvider#loadTile).\n  //   * we want to upsample from this tile but don't plan to render it (see processTerrainStateMachine).\n  if (terrainOnly) {\n    return;\n  }\n  const wasAlreadyRenderable = tile.renderable;\n\n  // The terrain is renderable as soon as we have a valid vertex array.\n  tile.renderable = defined(surfaceTile.vertexArray);\n\n  // But it's not done loading until it's in the READY state.\n  const isTerrainDoneLoading = surfaceTile.terrainState === TerrainState.READY;\n\n  // If this tile's terrain and imagery are just upsampled from its parent, mark the tile as\n  // upsampled only.  We won't refine a tile if its four children are upsampled only.\n  tile.upsampledFromParent = defined(surfaceTile.terrainData) && surfaceTile.terrainData.wasCreatedByUpsampling();\n  const isImageryDoneLoading = surfaceTile.processImagery(tile, terrainProvider, frameState);\n  if (isTerrainDoneLoading && isImageryDoneLoading) {\n    const callbacks = tile._loadedCallbacks;\n    const newCallbacks = {};\n    for (const layerId in callbacks) {\n      if (callbacks.hasOwnProperty(layerId)) {\n        if (!callbacks[layerId](tile)) {\n          newCallbacks[layerId] = callbacks[layerId];\n        }\n      }\n    }\n    tile._loadedCallbacks = newCallbacks;\n    tile.state = QuadtreeTileLoadState.DONE;\n  }\n\n  // Once a tile is renderable, it stays renderable, because doing otherwise would\n  // cause detail (or maybe even the entire globe) to vanish when adding a new\n  // imagery layer. `GlobeSurfaceTileProvider._onLayerAdded` sets renderable to\n  // false for all affected tiles that are not currently being rendered.\n  if (wasAlreadyRenderable) {\n    tile.renderable = true;\n  }\n};\nGlobeSurfaceTile.prototype.processImagery = function (tile, terrainProvider, frameState, skipLoading) {\n  const surfaceTile = tile.data;\n  let isUpsampledOnly = tile.upsampledFromParent;\n  let isAnyTileLoaded = false;\n  let isDoneLoading = true;\n\n  // Transition imagery states\n  const tileImageryCollection = surfaceTile.imagery;\n  let i, len;\n  for (i = 0, len = tileImageryCollection.length; i < len; ++i) {\n    const tileImagery = tileImageryCollection[i];\n    if (!defined(tileImagery.loadingImagery)) {\n      isUpsampledOnly = false;\n      continue;\n    }\n    if (tileImagery.loadingImagery.state === ImageryState.PLACEHOLDER) {\n      const imageryLayer = tileImagery.loadingImagery.imageryLayer;\n      if (imageryLayer.ready) {\n        // Remove the placeholder and add the actual skeletons (if any)\n        // at the same position.  Then continue the loop at the same index.\n        tileImagery.freeResources();\n        tileImageryCollection.splice(i, 1);\n        imageryLayer._createTileImagerySkeletons(tile, terrainProvider, i);\n        --i;\n        len = tileImageryCollection.length;\n        continue;\n      } else {\n        isUpsampledOnly = false;\n      }\n    }\n    const thisTileDoneLoading = tileImagery.processStateMachine(tile, frameState, skipLoading);\n    isDoneLoading = isDoneLoading && thisTileDoneLoading;\n\n    // The imagery is renderable as soon as we have any renderable imagery for this region.\n    isAnyTileLoaded = isAnyTileLoaded || thisTileDoneLoading || defined(tileImagery.readyImagery);\n    isUpsampledOnly = isUpsampledOnly && defined(tileImagery.loadingImagery) && (tileImagery.loadingImagery.state === ImageryState.FAILED || tileImagery.loadingImagery.state === ImageryState.INVALID);\n  }\n  tile.upsampledFromParent = isUpsampledOnly;\n\n  // Allow rendering if any available layers are loaded\n  tile.renderable = tile.renderable && (isAnyTileLoaded || isDoneLoading);\n  return isDoneLoading;\n};\nfunction toggleGeodeticSurfaceNormals(surfaceTile, enabled, ellipsoid, frameState) {\n  const renderedMesh = surfaceTile.renderedMesh;\n  const vertexBuffer = renderedMesh.vertices;\n  const encoding = renderedMesh.encoding;\n  const vertexCount = vertexBuffer.length / encoding.stride;\n\n  // Calculate the new stride and generate a new buffer\n  // Clone the other encoding, toggle geodetic surface normals, then clone again to get updated stride\n  let newEncoding = TerrainEncoding.clone(encoding);\n  newEncoding.hasGeodeticSurfaceNormals = enabled;\n  newEncoding = TerrainEncoding.clone(newEncoding);\n  const newStride = newEncoding.stride;\n  const newVertexBuffer = new Float32Array(vertexCount * newStride);\n  if (enabled) {\n    encoding.addGeodeticSurfaceNormals(vertexBuffer, newVertexBuffer, ellipsoid);\n  } else {\n    encoding.removeGeodeticSurfaceNormals(vertexBuffer, newVertexBuffer);\n  }\n  renderedMesh.vertices = newVertexBuffer;\n  renderedMesh.stride = newStride;\n\n  // delete the old vertex array (which deletes the vertex buffer attached to it), and create a new vertex array with the new vertex buffer\n  const isFill = renderedMesh !== surfaceTile.mesh;\n  if (isFill) {\n    GlobeSurfaceTile._freeVertexArray(surfaceTile.fill.vertexArray);\n    surfaceTile.fill.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(frameState.context, renderedMesh);\n  } else {\n    GlobeSurfaceTile._freeVertexArray(surfaceTile.vertexArray);\n    surfaceTile.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(frameState.context, renderedMesh);\n  }\n  GlobeSurfaceTile._freeVertexArray(surfaceTile.wireframeVertexArray);\n  surfaceTile.wireframeVertexArray = undefined;\n}\nGlobeSurfaceTile.prototype.addGeodeticSurfaceNormals = function (ellipsoid, frameState) {\n  toggleGeodeticSurfaceNormals(this, true, ellipsoid, frameState);\n};\nGlobeSurfaceTile.prototype.removeGeodeticSurfaceNormals = function (frameState) {\n  toggleGeodeticSurfaceNormals(this, false, undefined, frameState);\n};\nGlobeSurfaceTile.prototype.updateExaggeration = function (tile, frameState, quadtree) {\n  const surfaceTile = this;\n  const mesh = surfaceTile.renderedMesh;\n  if (mesh === undefined) {\n    return;\n  }\n\n  // Check the tile's terrain encoding to see if it has been exaggerated yet\n  const exaggeration = frameState.verticalExaggeration;\n  const exaggerationRelativeHeight = frameState.verticalExaggerationRelativeHeight;\n  const hasExaggerationScale = exaggeration !== 1.0;\n  const encoding = mesh.encoding;\n  const encodingExaggerationScaleChanged = encoding.exaggeration !== exaggeration;\n  const encodingRelativeHeightChanged = encoding.exaggerationRelativeHeight !== exaggerationRelativeHeight;\n  if (encodingExaggerationScaleChanged || encodingRelativeHeightChanged) {\n    // Turning exaggeration scale on/off requires adding or removing geodetic surface normals\n    // Relative height only translates, so it has no effect on normals\n    if (encodingExaggerationScaleChanged) {\n      if (hasExaggerationScale && !encoding.hasGeodeticSurfaceNormals) {\n        const ellipsoid = tile.tilingScheme.ellipsoid;\n        surfaceTile.addGeodeticSurfaceNormals(ellipsoid, frameState);\n      } else if (!hasExaggerationScale && encoding.hasGeodeticSurfaceNormals) {\n        surfaceTile.removeGeodeticSurfaceNormals(frameState);\n      }\n    }\n    encoding.exaggeration = exaggeration;\n    encoding.exaggerationRelativeHeight = exaggerationRelativeHeight;\n\n    // Notify the quadtree that this tile's height has changed\n    if (quadtree !== undefined) {\n      quadtree._tileToUpdateHeights.push(tile);\n      const customData = tile.customData;\n      const customDataLength = customData.length;\n      for (let i = 0; i < customDataLength; i++) {\n        // Restart the level so that a height update is triggered\n        const data = customData[i];\n        data.level = -1;\n      }\n    }\n  }\n};\nfunction prepareNewTile(tile, terrainProvider, imageryLayerCollection) {\n  let available = terrainProvider.getTileDataAvailable(tile.x, tile.y, tile.level);\n  if (!defined(available) && defined(tile.parent)) {\n    // Provider doesn't know if this tile is available. Does the parent tile know?\n    const parent = tile.parent;\n    const parentSurfaceTile = parent.data;\n    if (defined(parentSurfaceTile) && defined(parentSurfaceTile.terrainData)) {\n      available = parentSurfaceTile.terrainData.isChildAvailable(parent.x, parent.y, tile.x, tile.y);\n    }\n  }\n  if (available === false) {\n    // This tile is not available, so mark it failed so we start upsampling right away.\n    tile.data.terrainState = TerrainState.FAILED;\n  }\n\n  // Map imagery tiles to this terrain tile\n  for (let i = 0, len = imageryLayerCollection.length; i < len; ++i) {\n    const layer = imageryLayerCollection.get(i);\n    if (layer.show) {\n      layer._createTileImagerySkeletons(tile, terrainProvider);\n    }\n  }\n}\nfunction processTerrainStateMachine(tile, frameState, terrainProvider, imageryLayerCollection, quadtree, vertexArraysToDestroy) {\n  const surfaceTile = tile.data;\n\n  // If this tile is FAILED, we'll need to upsample from the parent. If the parent isn't\n  // ready for that, let's push it along.\n  const parent = tile.parent;\n  if (surfaceTile.terrainState === TerrainState.FAILED && parent !== undefined) {\n    const parentReady = parent.data !== undefined && parent.data.terrainData !== undefined && parent.data.terrainData.canUpsample !== false;\n    if (!parentReady) {\n      GlobeSurfaceTile.processStateMachine(parent, frameState, terrainProvider, imageryLayerCollection, quadtree, vertexArraysToDestroy, true);\n    }\n  }\n  if (surfaceTile.terrainState === TerrainState.FAILED) {\n    upsample(surfaceTile, tile, frameState, terrainProvider, tile.x, tile.y, tile.level);\n  }\n  if (surfaceTile.terrainState === TerrainState.UNLOADED) {\n    requestTileGeometry(surfaceTile, terrainProvider, tile.x, tile.y, tile.level);\n  }\n  if (surfaceTile.terrainState === TerrainState.RECEIVED) {\n    transform(surfaceTile, frameState, terrainProvider, tile.x, tile.y, tile.level);\n  }\n  if (surfaceTile.terrainState === TerrainState.TRANSFORMED) {\n    createResources(surfaceTile, frameState.context, terrainProvider, tile.x, tile.y, tile.level, vertexArraysToDestroy);\n\n    // Update the tile's exaggeration in case the globe's exaggeration changed while the tile was being processed\n    surfaceTile.updateExaggeration(tile, frameState, quadtree);\n  }\n  if (surfaceTile.terrainState >= TerrainState.RECEIVED && surfaceTile.waterMaskTexture === undefined && terrainProvider.hasWaterMask) {\n    const terrainData = surfaceTile.terrainData;\n    if (terrainData.waterMask !== undefined) {\n      createWaterMaskTextureIfNeeded(frameState.context, surfaceTile);\n    } else {\n      const sourceTile = surfaceTile._findAncestorTileWithTerrainData(tile);\n      if (defined(sourceTile) && defined(sourceTile.data.waterMaskTexture)) {\n        surfaceTile.waterMaskTexture = sourceTile.data.waterMaskTexture;\n        ++surfaceTile.waterMaskTexture.referenceCount;\n        surfaceTile._computeWaterMaskTranslationAndScale(tile, sourceTile, surfaceTile.waterMaskTranslationAndScale);\n      }\n    }\n  }\n}\nfunction upsample(surfaceTile, tile, frameState, terrainProvider, x, y, level) {\n  const parent = tile.parent;\n  if (!parent) {\n    // Trying to upsample from a root tile. No can do. This tile is a failure.\n    tile.state = QuadtreeTileLoadState.FAILED;\n    return;\n  }\n  const sourceData = parent.data.terrainData;\n  const sourceX = parent.x;\n  const sourceY = parent.y;\n  const sourceLevel = parent.level;\n  if (!defined(sourceData)) {\n    // Parent is not available, so we can't upsample this tile yet.\n    return;\n  }\n  const terrainDataPromise = sourceData.upsample(terrainProvider.tilingScheme, sourceX, sourceY, sourceLevel, x, y, level);\n  if (!defined(terrainDataPromise)) {\n    // The upsample request has been deferred - try again later.\n    return;\n  }\n  surfaceTile.terrainState = TerrainState.RECEIVING;\n  Promise.resolve(terrainDataPromise).then(function (terrainData) {\n    if (!defined(terrainData)) {\n      // The upsample request has been deferred - try again later.\n      return;\n    }\n    surfaceTile.terrainData = terrainData;\n    surfaceTile.terrainState = TerrainState.RECEIVED;\n  }).catch(function () {\n    surfaceTile.terrainState = TerrainState.FAILED;\n  });\n}\nfunction requestTileGeometry(surfaceTile, terrainProvider, x, y, level) {\n  function success(terrainData) {\n    if (!defined(terrainData)) {\n      // Throttled due to low priority - try again later.\n      surfaceTile.terrainState = TerrainState.UNLOADED;\n      surfaceTile.request = undefined;\n      return;\n    }\n    surfaceTile.terrainData = terrainData;\n    surfaceTile.terrainState = TerrainState.RECEIVED;\n    surfaceTile.request = undefined;\n  }\n  function failure(error) {\n    if (surfaceTile.request.state === RequestState.CANCELLED) {\n      // Cancelled due to low priority - try again later.\n      surfaceTile.terrainData = undefined;\n      surfaceTile.terrainState = TerrainState.UNLOADED;\n      surfaceTile.request = undefined;\n      return;\n    }\n\n    // Initially assume failure.  reportError may retry, in which case the state will\n    // change to RECEIVING or UNLOADED.\n    surfaceTile.terrainState = TerrainState.FAILED;\n    surfaceTile.request = undefined;\n    const message = `Failed to obtain terrain tile X: ${x} Y: ${y} Level: ${level}. Error message: \"${error}\"`;\n    terrainProvider._requestError = TileProviderError.reportError(terrainProvider._requestError, terrainProvider, terrainProvider.errorEvent, message, x, y, level);\n    if (terrainProvider._requestError.retry) {\n      doRequest();\n    }\n  }\n  function doRequest() {\n    // Request the terrain from the terrain provider.\n    const request = new Request({\n      throttle: false,\n      throttleByServer: true,\n      type: RequestType.TERRAIN\n    });\n    surfaceTile.request = request;\n    const requestPromise = terrainProvider.requestTileGeometry(x, y, level, request);\n\n    // If the request method returns undefined (instead of a promise), the request\n    // has been deferred.\n    if (defined(requestPromise)) {\n      surfaceTile.terrainState = TerrainState.RECEIVING;\n      Promise.resolve(requestPromise).then(function (terrainData) {\n        success(terrainData);\n      }).catch(function (e) {\n        failure(e);\n      });\n    } else {\n      // Deferred - try again later.\n      surfaceTile.terrainState = TerrainState.UNLOADED;\n      surfaceTile.request = undefined;\n    }\n  }\n  doRequest();\n}\nconst scratchCreateMeshOptions = {\n  tilingScheme: undefined,\n  x: 0,\n  y: 0,\n  level: 0,\n  exaggeration: 1.0,\n  exaggerationRelativeHeight: 0.0,\n  throttle: true\n};\nfunction transform(surfaceTile, frameState, terrainProvider, x, y, level) {\n  const tilingScheme = terrainProvider.tilingScheme;\n  const createMeshOptions = scratchCreateMeshOptions;\n  createMeshOptions.tilingScheme = tilingScheme;\n  createMeshOptions.x = x;\n  createMeshOptions.y = y;\n  createMeshOptions.level = level;\n  createMeshOptions.exaggeration = frameState.verticalExaggeration;\n  createMeshOptions.exaggerationRelativeHeight = frameState.verticalExaggerationRelativeHeight;\n  createMeshOptions.throttle = true;\n  const terrainData = surfaceTile.terrainData;\n  const meshPromise = terrainData.createMesh(createMeshOptions);\n  if (!defined(meshPromise)) {\n    // Postponed.\n    return;\n  }\n  surfaceTile.terrainState = TerrainState.TRANSFORMING;\n  Promise.resolve(meshPromise).then(function (mesh) {\n    surfaceTile.mesh = mesh;\n    surfaceTile.terrainState = TerrainState.TRANSFORMED;\n  }).catch(function () {\n    surfaceTile.terrainState = TerrainState.FAILED;\n  });\n}\nGlobeSurfaceTile._createVertexArrayForMesh = function (context, mesh) {\n  const typedArray = mesh.vertices;\n  const buffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: typedArray,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  const attributes = mesh.encoding.getAttributes(buffer);\n  const indexBuffers = mesh.indices.indexBuffers || {};\n  let indexBuffer = indexBuffers[context.id];\n  if (!defined(indexBuffer) || indexBuffer.isDestroyed()) {\n    const indices = mesh.indices;\n    indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: indices,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: IndexDatatype.fromSizeInBytes(indices.BYTES_PER_ELEMENT)\n    });\n    indexBuffer.vertexArrayDestroyable = false;\n    indexBuffer.referenceCount = 1;\n    indexBuffers[context.id] = indexBuffer;\n    mesh.indices.indexBuffers = indexBuffers;\n  } else {\n    ++indexBuffer.referenceCount;\n  }\n  return new VertexArray({\n    context: context,\n    attributes: attributes,\n    indexBuffer: indexBuffer\n  });\n};\nGlobeSurfaceTile._freeVertexArray = function (vertexArray) {\n  if (defined(vertexArray)) {\n    const indexBuffer = vertexArray.indexBuffer;\n    if (!vertexArray.isDestroyed()) {\n      vertexArray.destroy();\n    }\n    if (defined(indexBuffer) && !indexBuffer.isDestroyed() && defined(indexBuffer.referenceCount)) {\n      --indexBuffer.referenceCount;\n      if (indexBuffer.referenceCount === 0) {\n        indexBuffer.destroy();\n      }\n    }\n  }\n};\nfunction createResources(surfaceTile, context, terrainProvider, x, y, level, vertexArraysToDestroy) {\n  surfaceTile.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(context, surfaceTile.mesh);\n  surfaceTile.terrainState = TerrainState.READY;\n  surfaceTile.fill = surfaceTile.fill && surfaceTile.fill.destroy(vertexArraysToDestroy);\n}\nfunction getContextWaterMaskData(context) {\n  let data = context.cache.tile_waterMaskData;\n  if (!defined(data)) {\n    const allWaterTexture = Texture.create({\n      context: context,\n      pixelFormat: PixelFormat.LUMINANCE,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      source: {\n        arrayBufferView: new Uint8Array([255]),\n        width: 1,\n        height: 1\n      }\n    });\n    allWaterTexture.referenceCount = 1;\n    const sampler = new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR\n    });\n    data = {\n      allWaterTexture: allWaterTexture,\n      sampler: sampler,\n      destroy: function () {\n        this.allWaterTexture.destroy();\n      }\n    };\n    context.cache.tile_waterMaskData = data;\n  }\n  return data;\n}\nfunction createWaterMaskTextureIfNeeded(context, surfaceTile) {\n  const waterMask = surfaceTile.terrainData.waterMask;\n  const waterMaskData = getContextWaterMaskData(context);\n  let texture;\n  const waterMaskLength = waterMask.length;\n  if (waterMaskLength === 1) {\n    // Length 1 means the tile is entirely land or entirely water.\n    // A value of 0 indicates entirely land, a value of 1 indicates entirely water.\n    if (waterMask[0] !== 0) {\n      texture = waterMaskData.allWaterTexture;\n    } else {\n      // Leave the texture undefined if the tile is entirely land.\n      return;\n    }\n  } else {\n    const textureSize = Math.sqrt(waterMaskLength);\n    texture = Texture.create({\n      context: context,\n      pixelFormat: PixelFormat.LUMINANCE,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      source: {\n        width: textureSize,\n        height: textureSize,\n        arrayBufferView: waterMask\n      },\n      sampler: waterMaskData.sampler,\n      flipY: false\n    });\n    texture.referenceCount = 0;\n  }\n  ++texture.referenceCount;\n  surfaceTile.waterMaskTexture = texture;\n  Cartesian4.fromElements(0.0, 0.0, 1.0, 1.0, surfaceTile.waterMaskTranslationAndScale);\n}\nGlobeSurfaceTile.prototype._findAncestorTileWithTerrainData = function (tile) {\n  let sourceTile = tile.parent;\n  while (defined(sourceTile) && (!defined(sourceTile.data) || !defined(sourceTile.data.terrainData) || sourceTile.data.terrainData.wasCreatedByUpsampling())) {\n    sourceTile = sourceTile.parent;\n  }\n  return sourceTile;\n};\nGlobeSurfaceTile.prototype._computeWaterMaskTranslationAndScale = function (tile, sourceTile, result) {\n  const sourceTileRectangle = sourceTile.rectangle;\n  const tileRectangle = tile.rectangle;\n  const tileWidth = tileRectangle.width;\n  const tileHeight = tileRectangle.height;\n  const scaleX = tileWidth / sourceTileRectangle.width;\n  const scaleY = tileHeight / sourceTileRectangle.height;\n  result.x = scaleX * (tileRectangle.west - sourceTileRectangle.west) / tileWidth;\n  result.y = scaleY * (tileRectangle.south - sourceTileRectangle.south) / tileHeight;\n  result.z = scaleX;\n  result.w = scaleY;\n  return result;\n};\nexport default GlobeSurfaceTile;","map":{"version":3,"names":["BoundingSphere","Cartesian3","Cartesian4","Cartographic","defined","IndexDatatype","IntersectionTests","PixelFormat","Ray","Request","RequestState","RequestType","TerrainEncoding","TileProviderError","Buffer","BufferUsage","PixelDatatype","Sampler","Texture","TextureMagnificationFilter","TextureMinificationFilter","TextureWrap","VertexArray","ImageryState","QuadtreeTileLoadState","SceneMode","TerrainState","GlobeSurfaceTile","imagery","waterMaskTexture","undefined","waterMaskTranslationAndScale","terrainData","vertexArray","tileBoundingRegion","occludeePointInScaledSpace","boundingVolumeSourceTile","boundingVolumeIsFromMesh","terrainState","UNLOADED","mesh","fill","pickBoundingSphere","surfaceShader","isClipped","clippedByBoundaries","Object","defineProperties","prototype","eligibleForUnloading","get","loadingIsTransitioning","RECEIVING","TRANSFORMING","shouldRemoveTile","i","len","length","tileImagery","loadingImagery","state","TRANSITIONING","renderedMesh","scratchCartographic","getPosition","encoding","mode","projection","vertices","index","result","position","getExaggeratedPosition","SCENE3D","ellipsoid","positionCartographic","cartesianToCartographic","project","fromElements","z","x","y","scratchV0","scratchV1","scratchV2","pick","ray","cullBackFaces","indices","indicesLength","minT","Number","MAX_VALUE","i0","i1","i2","v0","v1","v2","t","rayTriangleParametric","getPoint","freeResources","referenceCount","destroy","imageryList","freeVertexArray","_freeVertexArray","wireframeVertexArray","initialize","tile","terrainProvider","imageryLayerCollection","surfaceTile","data","START","prepareNewTile","LOADING","processStateMachine","frameState","quadtree","vertexArraysToDestroy","terrainOnly","processTerrainStateMachine","wasAlreadyRenderable","renderable","isTerrainDoneLoading","READY","upsampledFromParent","wasCreatedByUpsampling","isImageryDoneLoading","processImagery","callbacks","_loadedCallbacks","newCallbacks","layerId","hasOwnProperty","DONE","skipLoading","isUpsampledOnly","isAnyTileLoaded","isDoneLoading","tileImageryCollection","PLACEHOLDER","imageryLayer","ready","splice","_createTileImagerySkeletons","thisTileDoneLoading","readyImagery","FAILED","INVALID","toggleGeodeticSurfaceNormals","enabled","vertexBuffer","vertexCount","stride","newEncoding","clone","hasGeodeticSurfaceNormals","newStride","newVertexBuffer","Float32Array","addGeodeticSurfaceNormals","removeGeodeticSurfaceNormals","isFill","_createVertexArrayForMesh","context","updateExaggeration","exaggeration","verticalExaggeration","exaggerationRelativeHeight","verticalExaggerationRelativeHeight","hasExaggerationScale","encodingExaggerationScaleChanged","encodingRelativeHeightChanged","tilingScheme","_tileToUpdateHeights","push","customData","customDataLength","level","available","getTileDataAvailable","parent","parentSurfaceTile","isChildAvailable","layer","show","parentReady","canUpsample","upsample","requestTileGeometry","RECEIVED","transform","TRANSFORMED","createResources","hasWaterMask","waterMask","createWaterMaskTextureIfNeeded","sourceTile","_findAncestorTileWithTerrainData","_computeWaterMaskTranslationAndScale","sourceData","sourceX","sourceY","sourceLevel","terrainDataPromise","Promise","resolve","then","catch","success","request","failure","error","CANCELLED","message","_requestError","reportError","errorEvent","retry","doRequest","throttle","throttleByServer","type","TERRAIN","requestPromise","e","scratchCreateMeshOptions","createMeshOptions","meshPromise","createMesh","typedArray","buffer","createVertexBuffer","usage","STATIC_DRAW","attributes","getAttributes","indexBuffers","indexBuffer","id","isDestroyed","createIndexBuffer","indexDatatype","fromSizeInBytes","BYTES_PER_ELEMENT","vertexArrayDestroyable","getContextWaterMaskData","cache","tile_waterMaskData","allWaterTexture","create","pixelFormat","LUMINANCE","pixelDatatype","UNSIGNED_BYTE","source","arrayBufferView","Uint8Array","width","height","sampler","wrapS","CLAMP_TO_EDGE","wrapT","minificationFilter","LINEAR","magnificationFilter","waterMaskData","texture","waterMaskLength","textureSize","Math","sqrt","flipY","sourceTileRectangle","rectangle","tileRectangle","tileWidth","tileHeight","scaleX","scaleY","west","south","w"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/GlobeSurfaceTile.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestState from \"../Core/RequestState.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport TerrainEncoding from \"../Core/TerrainEncoding.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport TerrainState from \"./TerrainState.js\";\n\n/**\n * Contains additional information about a {@link QuadtreeTile} of the globe's surface, and\n * encapsulates state transition logic for loading tiles.\n *\n * @constructor\n * @alias GlobeSurfaceTile\n * @private\n */\nfunction GlobeSurfaceTile() {\n  /**\n   * The {@link TileImagery} attached to this tile.\n   * @type {TileImagery[]}\n   * @default []\n   */\n  this.imagery = [];\n\n  this.waterMaskTexture = undefined;\n  this.waterMaskTranslationAndScale = new Cartesian4(0.0, 0.0, 1.0, 1.0);\n\n  this.terrainData = undefined;\n  this.vertexArray = undefined;\n\n  /**\n   * A bounding region used to estimate distance to the tile. The horizontal bounds are always tight-fitting,\n   * but the `minimumHeight` and `maximumHeight` properties may be derived from the min/max of an ancestor tile\n   * and be quite loose-fitting and thus very poor for estimating distance.\n   * @type {TileBoundingRegion}\n   */\n  this.tileBoundingRegion = undefined;\n  this.occludeePointInScaledSpace = new Cartesian3();\n  this.boundingVolumeSourceTile = undefined;\n  this.boundingVolumeIsFromMesh = false;\n\n  this.terrainState = TerrainState.UNLOADED;\n  this.mesh = undefined;\n  this.fill = undefined;\n\n  this.pickBoundingSphere = new BoundingSphere();\n\n  this.surfaceShader = undefined;\n  this.isClipped = true;\n\n  this.clippedByBoundaries = false;\n}\n\nObject.defineProperties(GlobeSurfaceTile.prototype, {\n  /**\n   * Gets a value indicating whether or not this tile is eligible to be unloaded.\n   * Typically, a tile is ineligible to be unloaded while an asynchronous operation,\n   * such as a request for data, is in progress on it.  A tile will never be\n   * unloaded while it is needed for rendering, regardless of the value of this\n   * property.\n   * @memberof GlobeSurfaceTile.prototype\n   * @type {boolean}\n   */\n  eligibleForUnloading: {\n    get: function () {\n      // Do not remove tiles that are transitioning or that have\n      // imagery that is transitioning.\n      const terrainState = this.terrainState;\n      const loadingIsTransitioning =\n        terrainState === TerrainState.RECEIVING ||\n        terrainState === TerrainState.TRANSFORMING;\n\n      let shouldRemoveTile = !loadingIsTransitioning;\n\n      const imagery = this.imagery;\n      for (let i = 0, len = imagery.length; shouldRemoveTile && i < len; ++i) {\n        const tileImagery = imagery[i];\n        shouldRemoveTile =\n          !defined(tileImagery.loadingImagery) ||\n          tileImagery.loadingImagery.state !== ImageryState.TRANSITIONING;\n      }\n\n      return shouldRemoveTile;\n    },\n  },\n\n  /**\n   * Gets the {@link TerrainMesh} that is used for rendering this tile, if any.\n   * Returns the value of the {@link GlobeSurfaceTile#mesh} property if\n   * {@link GlobeSurfaceTile#vertexArray} is defined. Otherwise, It returns the\n   * {@link TerrainFillMesh#mesh} property of the {@link GlobeSurfaceTile#fill}.\n   * If there is no fill, it returns undefined.\n   *\n   * @memberof GlobeSurfaceTile.prototype\n   * @type {TerrainMesh}\n   */\n  renderedMesh: {\n    get: function () {\n      if (defined(this.vertexArray)) {\n        return this.mesh;\n      } else if (defined(this.fill)) {\n        return this.fill.mesh;\n      }\n      return undefined;\n    },\n  },\n});\n\nconst scratchCartographic = new Cartographic();\n\nfunction getPosition(encoding, mode, projection, vertices, index, result) {\n  let position = encoding.getExaggeratedPosition(vertices, index, result);\n\n  if (defined(mode) && mode !== SceneMode.SCENE3D) {\n    const ellipsoid = projection.ellipsoid;\n    const positionCartographic = ellipsoid.cartesianToCartographic(\n      position,\n      scratchCartographic,\n    );\n    position = projection.project(positionCartographic, result);\n    position = Cartesian3.fromElements(\n      position.z,\n      position.x,\n      position.y,\n      result,\n    );\n  }\n\n  return position;\n}\n\nconst scratchV0 = new Cartesian3();\nconst scratchV1 = new Cartesian3();\nconst scratchV2 = new Cartesian3();\n\nGlobeSurfaceTile.prototype.pick = function (\n  ray,\n  mode,\n  projection,\n  cullBackFaces,\n  result,\n) {\n  const mesh = this.renderedMesh;\n  if (!defined(mesh)) {\n    return undefined;\n  }\n\n  const vertices = mesh.vertices;\n  const indices = mesh.indices;\n  const encoding = mesh.encoding;\n  const indicesLength = indices.length;\n\n  let minT = Number.MAX_VALUE;\n\n  for (let i = 0; i < indicesLength; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n\n    const v0 = getPosition(encoding, mode, projection, vertices, i0, scratchV0);\n    const v1 = getPosition(encoding, mode, projection, vertices, i1, scratchV1);\n    const v2 = getPosition(encoding, mode, projection, vertices, i2, scratchV2);\n\n    const t = IntersectionTests.rayTriangleParametric(\n      ray,\n      v0,\n      v1,\n      v2,\n      cullBackFaces,\n    );\n    if (defined(t) && t < minT && t >= 0.0) {\n      minT = t;\n    }\n  }\n\n  return minT !== Number.MAX_VALUE\n    ? Ray.getPoint(ray, minT, result)\n    : undefined;\n};\n\nGlobeSurfaceTile.prototype.freeResources = function () {\n  if (defined(this.waterMaskTexture)) {\n    --this.waterMaskTexture.referenceCount;\n    if (this.waterMaskTexture.referenceCount === 0) {\n      this.waterMaskTexture.destroy();\n    }\n    this.waterMaskTexture = undefined;\n  }\n\n  this.terrainData = undefined;\n\n  this.terrainState = TerrainState.UNLOADED;\n  this.mesh = undefined;\n  this.fill = this.fill && this.fill.destroy();\n\n  const imageryList = this.imagery;\n  for (let i = 0, len = imageryList.length; i < len; ++i) {\n    imageryList[i].freeResources();\n  }\n  this.imagery.length = 0;\n\n  this.freeVertexArray();\n};\n\nGlobeSurfaceTile.prototype.freeVertexArray = function () {\n  GlobeSurfaceTile._freeVertexArray(this.vertexArray);\n  this.vertexArray = undefined;\n  GlobeSurfaceTile._freeVertexArray(this.wireframeVertexArray);\n  this.wireframeVertexArray = undefined;\n};\n\nGlobeSurfaceTile.initialize = function (\n  tile,\n  terrainProvider,\n  imageryLayerCollection,\n) {\n  let surfaceTile = tile.data;\n  if (!defined(surfaceTile)) {\n    surfaceTile = tile.data = new GlobeSurfaceTile();\n  }\n\n  if (tile.state === QuadtreeTileLoadState.START) {\n    prepareNewTile(tile, terrainProvider, imageryLayerCollection);\n    tile.state = QuadtreeTileLoadState.LOADING;\n  }\n};\n\nGlobeSurfaceTile.processStateMachine = function (\n  tile,\n  frameState,\n  terrainProvider,\n  imageryLayerCollection,\n  quadtree,\n  vertexArraysToDestroy,\n  terrainOnly,\n) {\n  GlobeSurfaceTile.initialize(tile, terrainProvider, imageryLayerCollection);\n\n  const surfaceTile = tile.data;\n\n  if (tile.state === QuadtreeTileLoadState.LOADING) {\n    processTerrainStateMachine(\n      tile,\n      frameState,\n      terrainProvider,\n      imageryLayerCollection,\n      quadtree,\n      vertexArraysToDestroy,\n    );\n  }\n\n  // From here down we're loading imagery, not terrain. We don't want to load imagery until\n  // we're certain that the terrain tiles are actually visible, though. We'll load terrainOnly\n  // in these scenarios:\n  //   * our bounding volume isn't accurate so we're not certain this tile is really visible (see GlobeSurfaceTileProvider#loadTile).\n  //   * we want to upsample from this tile but don't plan to render it (see processTerrainStateMachine).\n  if (terrainOnly) {\n    return;\n  }\n\n  const wasAlreadyRenderable = tile.renderable;\n\n  // The terrain is renderable as soon as we have a valid vertex array.\n  tile.renderable = defined(surfaceTile.vertexArray);\n\n  // But it's not done loading until it's in the READY state.\n  const isTerrainDoneLoading = surfaceTile.terrainState === TerrainState.READY;\n\n  // If this tile's terrain and imagery are just upsampled from its parent, mark the tile as\n  // upsampled only.  We won't refine a tile if its four children are upsampled only.\n  tile.upsampledFromParent =\n    defined(surfaceTile.terrainData) &&\n    surfaceTile.terrainData.wasCreatedByUpsampling();\n\n  const isImageryDoneLoading = surfaceTile.processImagery(\n    tile,\n    terrainProvider,\n    frameState,\n  );\n\n  if (isTerrainDoneLoading && isImageryDoneLoading) {\n    const callbacks = tile._loadedCallbacks;\n    const newCallbacks = {};\n    for (const layerId in callbacks) {\n      if (callbacks.hasOwnProperty(layerId)) {\n        if (!callbacks[layerId](tile)) {\n          newCallbacks[layerId] = callbacks[layerId];\n        }\n      }\n    }\n    tile._loadedCallbacks = newCallbacks;\n\n    tile.state = QuadtreeTileLoadState.DONE;\n  }\n\n  // Once a tile is renderable, it stays renderable, because doing otherwise would\n  // cause detail (or maybe even the entire globe) to vanish when adding a new\n  // imagery layer. `GlobeSurfaceTileProvider._onLayerAdded` sets renderable to\n  // false for all affected tiles that are not currently being rendered.\n  if (wasAlreadyRenderable) {\n    tile.renderable = true;\n  }\n};\n\nGlobeSurfaceTile.prototype.processImagery = function (\n  tile,\n  terrainProvider,\n  frameState,\n  skipLoading,\n) {\n  const surfaceTile = tile.data;\n  let isUpsampledOnly = tile.upsampledFromParent;\n  let isAnyTileLoaded = false;\n  let isDoneLoading = true;\n\n  // Transition imagery states\n  const tileImageryCollection = surfaceTile.imagery;\n  let i, len;\n  for (i = 0, len = tileImageryCollection.length; i < len; ++i) {\n    const tileImagery = tileImageryCollection[i];\n    if (!defined(tileImagery.loadingImagery)) {\n      isUpsampledOnly = false;\n      continue;\n    }\n\n    if (tileImagery.loadingImagery.state === ImageryState.PLACEHOLDER) {\n      const imageryLayer = tileImagery.loadingImagery.imageryLayer;\n      if (imageryLayer.ready) {\n        // Remove the placeholder and add the actual skeletons (if any)\n        // at the same position.  Then continue the loop at the same index.\n        tileImagery.freeResources();\n        tileImageryCollection.splice(i, 1);\n        imageryLayer._createTileImagerySkeletons(tile, terrainProvider, i);\n        --i;\n        len = tileImageryCollection.length;\n        continue;\n      } else {\n        isUpsampledOnly = false;\n      }\n    }\n\n    const thisTileDoneLoading = tileImagery.processStateMachine(\n      tile,\n      frameState,\n      skipLoading,\n    );\n    isDoneLoading = isDoneLoading && thisTileDoneLoading;\n\n    // The imagery is renderable as soon as we have any renderable imagery for this region.\n    isAnyTileLoaded =\n      isAnyTileLoaded ||\n      thisTileDoneLoading ||\n      defined(tileImagery.readyImagery);\n\n    isUpsampledOnly =\n      isUpsampledOnly &&\n      defined(tileImagery.loadingImagery) &&\n      (tileImagery.loadingImagery.state === ImageryState.FAILED ||\n        tileImagery.loadingImagery.state === ImageryState.INVALID);\n  }\n\n  tile.upsampledFromParent = isUpsampledOnly;\n\n  // Allow rendering if any available layers are loaded\n  tile.renderable = tile.renderable && (isAnyTileLoaded || isDoneLoading);\n\n  return isDoneLoading;\n};\n\nfunction toggleGeodeticSurfaceNormals(\n  surfaceTile,\n  enabled,\n  ellipsoid,\n  frameState,\n) {\n  const renderedMesh = surfaceTile.renderedMesh;\n  const vertexBuffer = renderedMesh.vertices;\n  const encoding = renderedMesh.encoding;\n  const vertexCount = vertexBuffer.length / encoding.stride;\n\n  // Calculate the new stride and generate a new buffer\n  // Clone the other encoding, toggle geodetic surface normals, then clone again to get updated stride\n  let newEncoding = TerrainEncoding.clone(encoding);\n  newEncoding.hasGeodeticSurfaceNormals = enabled;\n  newEncoding = TerrainEncoding.clone(newEncoding);\n  const newStride = newEncoding.stride;\n  const newVertexBuffer = new Float32Array(vertexCount * newStride);\n\n  if (enabled) {\n    encoding.addGeodeticSurfaceNormals(\n      vertexBuffer,\n      newVertexBuffer,\n      ellipsoid,\n    );\n  } else {\n    encoding.removeGeodeticSurfaceNormals(vertexBuffer, newVertexBuffer);\n  }\n\n  renderedMesh.vertices = newVertexBuffer;\n  renderedMesh.stride = newStride;\n\n  // delete the old vertex array (which deletes the vertex buffer attached to it), and create a new vertex array with the new vertex buffer\n  const isFill = renderedMesh !== surfaceTile.mesh;\n  if (isFill) {\n    GlobeSurfaceTile._freeVertexArray(surfaceTile.fill.vertexArray);\n    surfaceTile.fill.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(\n      frameState.context,\n      renderedMesh,\n    );\n  } else {\n    GlobeSurfaceTile._freeVertexArray(surfaceTile.vertexArray);\n    surfaceTile.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(\n      frameState.context,\n      renderedMesh,\n    );\n  }\n  GlobeSurfaceTile._freeVertexArray(surfaceTile.wireframeVertexArray);\n  surfaceTile.wireframeVertexArray = undefined;\n}\n\nGlobeSurfaceTile.prototype.addGeodeticSurfaceNormals = function (\n  ellipsoid,\n  frameState,\n) {\n  toggleGeodeticSurfaceNormals(this, true, ellipsoid, frameState);\n};\n\nGlobeSurfaceTile.prototype.removeGeodeticSurfaceNormals = function (\n  frameState,\n) {\n  toggleGeodeticSurfaceNormals(this, false, undefined, frameState);\n};\n\nGlobeSurfaceTile.prototype.updateExaggeration = function (\n  tile,\n  frameState,\n  quadtree,\n) {\n  const surfaceTile = this;\n  const mesh = surfaceTile.renderedMesh;\n  if (mesh === undefined) {\n    return;\n  }\n\n  // Check the tile's terrain encoding to see if it has been exaggerated yet\n  const exaggeration = frameState.verticalExaggeration;\n  const exaggerationRelativeHeight =\n    frameState.verticalExaggerationRelativeHeight;\n  const hasExaggerationScale = exaggeration !== 1.0;\n\n  const encoding = mesh.encoding;\n  const encodingExaggerationScaleChanged =\n    encoding.exaggeration !== exaggeration;\n  const encodingRelativeHeightChanged =\n    encoding.exaggerationRelativeHeight !== exaggerationRelativeHeight;\n\n  if (encodingExaggerationScaleChanged || encodingRelativeHeightChanged) {\n    // Turning exaggeration scale on/off requires adding or removing geodetic surface normals\n    // Relative height only translates, so it has no effect on normals\n    if (encodingExaggerationScaleChanged) {\n      if (hasExaggerationScale && !encoding.hasGeodeticSurfaceNormals) {\n        const ellipsoid = tile.tilingScheme.ellipsoid;\n        surfaceTile.addGeodeticSurfaceNormals(ellipsoid, frameState);\n      } else if (!hasExaggerationScale && encoding.hasGeodeticSurfaceNormals) {\n        surfaceTile.removeGeodeticSurfaceNormals(frameState);\n      }\n    }\n\n    encoding.exaggeration = exaggeration;\n    encoding.exaggerationRelativeHeight = exaggerationRelativeHeight;\n\n    // Notify the quadtree that this tile's height has changed\n    if (quadtree !== undefined) {\n      quadtree._tileToUpdateHeights.push(tile);\n      const customData = tile.customData;\n      const customDataLength = customData.length;\n      for (let i = 0; i < customDataLength; i++) {\n        // Restart the level so that a height update is triggered\n        const data = customData[i];\n        data.level = -1;\n      }\n    }\n  }\n};\n\nfunction prepareNewTile(tile, terrainProvider, imageryLayerCollection) {\n  let available = terrainProvider.getTileDataAvailable(\n    tile.x,\n    tile.y,\n    tile.level,\n  );\n\n  if (!defined(available) && defined(tile.parent)) {\n    // Provider doesn't know if this tile is available. Does the parent tile know?\n    const parent = tile.parent;\n    const parentSurfaceTile = parent.data;\n    if (defined(parentSurfaceTile) && defined(parentSurfaceTile.terrainData)) {\n      available = parentSurfaceTile.terrainData.isChildAvailable(\n        parent.x,\n        parent.y,\n        tile.x,\n        tile.y,\n      );\n    }\n  }\n\n  if (available === false) {\n    // This tile is not available, so mark it failed so we start upsampling right away.\n    tile.data.terrainState = TerrainState.FAILED;\n  }\n\n  // Map imagery tiles to this terrain tile\n  for (let i = 0, len = imageryLayerCollection.length; i < len; ++i) {\n    const layer = imageryLayerCollection.get(i);\n    if (layer.show) {\n      layer._createTileImagerySkeletons(tile, terrainProvider);\n    }\n  }\n}\n\nfunction processTerrainStateMachine(\n  tile,\n  frameState,\n  terrainProvider,\n  imageryLayerCollection,\n  quadtree,\n  vertexArraysToDestroy,\n) {\n  const surfaceTile = tile.data;\n\n  // If this tile is FAILED, we'll need to upsample from the parent. If the parent isn't\n  // ready for that, let's push it along.\n  const parent = tile.parent;\n  if (\n    surfaceTile.terrainState === TerrainState.FAILED &&\n    parent !== undefined\n  ) {\n    const parentReady =\n      parent.data !== undefined &&\n      parent.data.terrainData !== undefined &&\n      parent.data.terrainData.canUpsample !== false;\n    if (!parentReady) {\n      GlobeSurfaceTile.processStateMachine(\n        parent,\n        frameState,\n        terrainProvider,\n        imageryLayerCollection,\n        quadtree,\n        vertexArraysToDestroy,\n        true,\n      );\n    }\n  }\n\n  if (surfaceTile.terrainState === TerrainState.FAILED) {\n    upsample(\n      surfaceTile,\n      tile,\n      frameState,\n      terrainProvider,\n      tile.x,\n      tile.y,\n      tile.level,\n    );\n  }\n\n  if (surfaceTile.terrainState === TerrainState.UNLOADED) {\n    requestTileGeometry(\n      surfaceTile,\n      terrainProvider,\n      tile.x,\n      tile.y,\n      tile.level,\n    );\n  }\n\n  if (surfaceTile.terrainState === TerrainState.RECEIVED) {\n    transform(\n      surfaceTile,\n      frameState,\n      terrainProvider,\n      tile.x,\n      tile.y,\n      tile.level,\n    );\n  }\n\n  if (surfaceTile.terrainState === TerrainState.TRANSFORMED) {\n    createResources(\n      surfaceTile,\n      frameState.context,\n      terrainProvider,\n      tile.x,\n      tile.y,\n      tile.level,\n      vertexArraysToDestroy,\n    );\n\n    // Update the tile's exaggeration in case the globe's exaggeration changed while the tile was being processed\n    surfaceTile.updateExaggeration(tile, frameState, quadtree);\n  }\n\n  if (\n    surfaceTile.terrainState >= TerrainState.RECEIVED &&\n    surfaceTile.waterMaskTexture === undefined &&\n    terrainProvider.hasWaterMask\n  ) {\n    const terrainData = surfaceTile.terrainData;\n    if (terrainData.waterMask !== undefined) {\n      createWaterMaskTextureIfNeeded(frameState.context, surfaceTile);\n    } else {\n      const sourceTile = surfaceTile._findAncestorTileWithTerrainData(tile);\n      if (defined(sourceTile) && defined(sourceTile.data.waterMaskTexture)) {\n        surfaceTile.waterMaskTexture = sourceTile.data.waterMaskTexture;\n        ++surfaceTile.waterMaskTexture.referenceCount;\n        surfaceTile._computeWaterMaskTranslationAndScale(\n          tile,\n          sourceTile,\n          surfaceTile.waterMaskTranslationAndScale,\n        );\n      }\n    }\n  }\n}\n\nfunction upsample(surfaceTile, tile, frameState, terrainProvider, x, y, level) {\n  const parent = tile.parent;\n  if (!parent) {\n    // Trying to upsample from a root tile. No can do. This tile is a failure.\n    tile.state = QuadtreeTileLoadState.FAILED;\n    return;\n  }\n\n  const sourceData = parent.data.terrainData;\n  const sourceX = parent.x;\n  const sourceY = parent.y;\n  const sourceLevel = parent.level;\n\n  if (!defined(sourceData)) {\n    // Parent is not available, so we can't upsample this tile yet.\n    return;\n  }\n\n  const terrainDataPromise = sourceData.upsample(\n    terrainProvider.tilingScheme,\n    sourceX,\n    sourceY,\n    sourceLevel,\n    x,\n    y,\n    level,\n  );\n  if (!defined(terrainDataPromise)) {\n    // The upsample request has been deferred - try again later.\n    return;\n  }\n\n  surfaceTile.terrainState = TerrainState.RECEIVING;\n\n  Promise.resolve(terrainDataPromise)\n    .then(function (terrainData) {\n      if (!defined(terrainData)) {\n        // The upsample request has been deferred - try again later.\n        return;\n      }\n\n      surfaceTile.terrainData = terrainData;\n      surfaceTile.terrainState = TerrainState.RECEIVED;\n    })\n    .catch(function () {\n      surfaceTile.terrainState = TerrainState.FAILED;\n    });\n}\n\nfunction requestTileGeometry(surfaceTile, terrainProvider, x, y, level) {\n  function success(terrainData) {\n    if (!defined(terrainData)) {\n      // Throttled due to low priority - try again later.\n      surfaceTile.terrainState = TerrainState.UNLOADED;\n      surfaceTile.request = undefined;\n      return;\n    }\n\n    surfaceTile.terrainData = terrainData;\n    surfaceTile.terrainState = TerrainState.RECEIVED;\n    surfaceTile.request = undefined;\n  }\n\n  function failure(error) {\n    if (surfaceTile.request.state === RequestState.CANCELLED) {\n      // Cancelled due to low priority - try again later.\n      surfaceTile.terrainData = undefined;\n      surfaceTile.terrainState = TerrainState.UNLOADED;\n      surfaceTile.request = undefined;\n      return;\n    }\n\n    // Initially assume failure.  reportError may retry, in which case the state will\n    // change to RECEIVING or UNLOADED.\n    surfaceTile.terrainState = TerrainState.FAILED;\n    surfaceTile.request = undefined;\n\n    const message = `Failed to obtain terrain tile X: ${x} Y: ${y} Level: ${level}. Error message: \"${error}\"`;\n    terrainProvider._requestError = TileProviderError.reportError(\n      terrainProvider._requestError,\n      terrainProvider,\n      terrainProvider.errorEvent,\n      message,\n      x,\n      y,\n      level,\n    );\n    if (terrainProvider._requestError.retry) {\n      doRequest();\n    }\n  }\n\n  function doRequest() {\n    // Request the terrain from the terrain provider.\n    const request = new Request({\n      throttle: false,\n      throttleByServer: true,\n      type: RequestType.TERRAIN,\n    });\n    surfaceTile.request = request;\n\n    const requestPromise = terrainProvider.requestTileGeometry(\n      x,\n      y,\n      level,\n      request,\n    );\n\n    // If the request method returns undefined (instead of a promise), the request\n    // has been deferred.\n    if (defined(requestPromise)) {\n      surfaceTile.terrainState = TerrainState.RECEIVING;\n      Promise.resolve(requestPromise)\n        .then(function (terrainData) {\n          success(terrainData);\n        })\n        .catch(function (e) {\n          failure(e);\n        });\n    } else {\n      // Deferred - try again later.\n      surfaceTile.terrainState = TerrainState.UNLOADED;\n      surfaceTile.request = undefined;\n    }\n  }\n\n  doRequest();\n}\n\nconst scratchCreateMeshOptions = {\n  tilingScheme: undefined,\n  x: 0,\n  y: 0,\n  level: 0,\n  exaggeration: 1.0,\n  exaggerationRelativeHeight: 0.0,\n  throttle: true,\n};\n\nfunction transform(surfaceTile, frameState, terrainProvider, x, y, level) {\n  const tilingScheme = terrainProvider.tilingScheme;\n\n  const createMeshOptions = scratchCreateMeshOptions;\n  createMeshOptions.tilingScheme = tilingScheme;\n  createMeshOptions.x = x;\n  createMeshOptions.y = y;\n  createMeshOptions.level = level;\n  createMeshOptions.exaggeration = frameState.verticalExaggeration;\n  createMeshOptions.exaggerationRelativeHeight =\n    frameState.verticalExaggerationRelativeHeight;\n  createMeshOptions.throttle = true;\n\n  const terrainData = surfaceTile.terrainData;\n  const meshPromise = terrainData.createMesh(createMeshOptions);\n\n  if (!defined(meshPromise)) {\n    // Postponed.\n    return;\n  }\n\n  surfaceTile.terrainState = TerrainState.TRANSFORMING;\n\n  Promise.resolve(meshPromise)\n    .then(function (mesh) {\n      surfaceTile.mesh = mesh;\n      surfaceTile.terrainState = TerrainState.TRANSFORMED;\n    })\n    .catch(function () {\n      surfaceTile.terrainState = TerrainState.FAILED;\n    });\n}\n\nGlobeSurfaceTile._createVertexArrayForMesh = function (context, mesh) {\n  const typedArray = mesh.vertices;\n  const buffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: typedArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  const attributes = mesh.encoding.getAttributes(buffer);\n\n  const indexBuffers = mesh.indices.indexBuffers || {};\n  let indexBuffer = indexBuffers[context.id];\n  if (!defined(indexBuffer) || indexBuffer.isDestroyed()) {\n    const indices = mesh.indices;\n    indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: indices,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: IndexDatatype.fromSizeInBytes(indices.BYTES_PER_ELEMENT),\n    });\n    indexBuffer.vertexArrayDestroyable = false;\n    indexBuffer.referenceCount = 1;\n    indexBuffers[context.id] = indexBuffer;\n    mesh.indices.indexBuffers = indexBuffers;\n  } else {\n    ++indexBuffer.referenceCount;\n  }\n\n  return new VertexArray({\n    context: context,\n    attributes: attributes,\n    indexBuffer: indexBuffer,\n  });\n};\n\nGlobeSurfaceTile._freeVertexArray = function (vertexArray) {\n  if (defined(vertexArray)) {\n    const indexBuffer = vertexArray.indexBuffer;\n\n    if (!vertexArray.isDestroyed()) {\n      vertexArray.destroy();\n    }\n\n    if (\n      defined(indexBuffer) &&\n      !indexBuffer.isDestroyed() &&\n      defined(indexBuffer.referenceCount)\n    ) {\n      --indexBuffer.referenceCount;\n      if (indexBuffer.referenceCount === 0) {\n        indexBuffer.destroy();\n      }\n    }\n  }\n};\n\nfunction createResources(\n  surfaceTile,\n  context,\n  terrainProvider,\n  x,\n  y,\n  level,\n  vertexArraysToDestroy,\n) {\n  surfaceTile.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(\n    context,\n    surfaceTile.mesh,\n  );\n  surfaceTile.terrainState = TerrainState.READY;\n  surfaceTile.fill =\n    surfaceTile.fill && surfaceTile.fill.destroy(vertexArraysToDestroy);\n}\n\nfunction getContextWaterMaskData(context) {\n  let data = context.cache.tile_waterMaskData;\n\n  if (!defined(data)) {\n    const allWaterTexture = Texture.create({\n      context: context,\n      pixelFormat: PixelFormat.LUMINANCE,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      source: {\n        arrayBufferView: new Uint8Array([255]),\n        width: 1,\n        height: 1,\n      },\n    });\n    allWaterTexture.referenceCount = 1;\n\n    const sampler = new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR,\n    });\n\n    data = {\n      allWaterTexture: allWaterTexture,\n      sampler: sampler,\n      destroy: function () {\n        this.allWaterTexture.destroy();\n      },\n    };\n\n    context.cache.tile_waterMaskData = data;\n  }\n\n  return data;\n}\n\nfunction createWaterMaskTextureIfNeeded(context, surfaceTile) {\n  const waterMask = surfaceTile.terrainData.waterMask;\n  const waterMaskData = getContextWaterMaskData(context);\n  let texture;\n\n  const waterMaskLength = waterMask.length;\n  if (waterMaskLength === 1) {\n    // Length 1 means the tile is entirely land or entirely water.\n    // A value of 0 indicates entirely land, a value of 1 indicates entirely water.\n    if (waterMask[0] !== 0) {\n      texture = waterMaskData.allWaterTexture;\n    } else {\n      // Leave the texture undefined if the tile is entirely land.\n      return;\n    }\n  } else {\n    const textureSize = Math.sqrt(waterMaskLength);\n    texture = Texture.create({\n      context: context,\n      pixelFormat: PixelFormat.LUMINANCE,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      source: {\n        width: textureSize,\n        height: textureSize,\n        arrayBufferView: waterMask,\n      },\n      sampler: waterMaskData.sampler,\n      flipY: false,\n    });\n\n    texture.referenceCount = 0;\n  }\n\n  ++texture.referenceCount;\n  surfaceTile.waterMaskTexture = texture;\n\n  Cartesian4.fromElements(\n    0.0,\n    0.0,\n    1.0,\n    1.0,\n    surfaceTile.waterMaskTranslationAndScale,\n  );\n}\n\nGlobeSurfaceTile.prototype._findAncestorTileWithTerrainData = function (tile) {\n  let sourceTile = tile.parent;\n\n  while (\n    defined(sourceTile) &&\n    (!defined(sourceTile.data) ||\n      !defined(sourceTile.data.terrainData) ||\n      sourceTile.data.terrainData.wasCreatedByUpsampling())\n  ) {\n    sourceTile = sourceTile.parent;\n  }\n\n  return sourceTile;\n};\n\nGlobeSurfaceTile.prototype._computeWaterMaskTranslationAndScale = function (\n  tile,\n  sourceTile,\n  result,\n) {\n  const sourceTileRectangle = sourceTile.rectangle;\n  const tileRectangle = tile.rectangle;\n  const tileWidth = tileRectangle.width;\n  const tileHeight = tileRectangle.height;\n\n  const scaleX = tileWidth / sourceTileRectangle.width;\n  const scaleY = tileHeight / sourceTileRectangle.height;\n  result.x =\n    (scaleX * (tileRectangle.west - sourceTileRectangle.west)) / tileWidth;\n  result.y =\n    (scaleY * (tileRectangle.south - sourceTileRectangle.south)) / tileHeight;\n  result.z = scaleX;\n  result.w = scaleY;\n\n  return result;\n};\nexport default GlobeSurfaceTile;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}