{"ast":null,"code":"import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\n\n/**\n * Represents a {@link Packable} number that always interpolates values\n * towards the shortest angle of rotation. This object is never used directly\n * but is instead passed to the constructor of {@link SampledProperty}\n * in order to represent a two-dimensional angle of rotation.\n *\n * @interface Rotation\n *\n *\n * @example\n * const time1 = Cesium.JulianDate.fromIso8601('2010-05-07T00:00:00');\n * const time2 = Cesium.JulianDate.fromIso8601('2010-05-07T00:01:00');\n * const time3 = Cesium.JulianDate.fromIso8601('2010-05-07T00:02:00');\n *\n * const property = new Cesium.SampledProperty(Cesium.Rotation);\n * property.addSample(time1, 0);\n * property.addSample(time3, Cesium.Math.toRadians(350));\n *\n * //Getting the value at time2 will equal 355 degrees instead\n * //of 175 degrees (which is what you get if you construct\n * //a SampledProperty(Number) instead.  Note, the actual\n * //return value is in radians, not degrees.\n * property.getValue(time2);\n *\n * @see PackableForInterpolation\n */\nconst Rotation = {\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  packedLength: 1,\n  /**\n   * Stores the provided instance into the provided array.\n   *\n   * @param {Rotation} value The value to pack.\n   * @param {number[]} array The array to pack into.\n   * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n   *\n   * @returns {number[]} The array that was packed into\n   */\n  pack: function (value, array, startingIndex) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(value)) {\n      throw new DeveloperError(\"value is required\");\n    }\n    if (!defined(array)) {\n      throw new DeveloperError(\"array is required\");\n    }\n    //>>includeEnd('debug');\n\n    startingIndex = defaultValue(startingIndex, 0);\n    array[startingIndex] = value;\n    return array;\n  },\n  /**\n   * Retrieves an instance from a packed array.\n   *\n   * @param {number[]} array The packed array.\n   * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n   * @param {Rotation} [result] The object into which to store the result.\n   * @returns {Rotation} The modified result parameter or a new Rotation instance if one was not provided.\n   */\n  unpack: function (array, startingIndex, result) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(array)) {\n      throw new DeveloperError(\"array is required\");\n    }\n    //>>includeEnd('debug');\n\n    startingIndex = defaultValue(startingIndex, 0);\n    return array[startingIndex];\n  },\n  /**\n   * Converts a packed array into a form suitable for interpolation.\n   *\n   * @param {number[]} packedArray The packed array.\n   * @param {number} [startingIndex=0] The index of the first element to be converted.\n   * @param {number} [lastIndex=packedArray.length] The index of the last element to be converted.\n   * @param {number[]} [result] The object into which to store the result.\n   */\n  convertPackedArrayForInterpolation: function (packedArray, startingIndex, lastIndex, result) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(packedArray)) {\n      throw new DeveloperError(\"packedArray is required\");\n    }\n    //>>includeEnd('debug');\n\n    if (!defined(result)) {\n      result = [];\n    }\n    startingIndex = defaultValue(startingIndex, 0);\n    lastIndex = defaultValue(lastIndex, packedArray.length);\n    let previousValue;\n    for (let i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {\n      const value = packedArray[startingIndex + i];\n      if (i === 0 || Math.abs(previousValue - value) < Math.PI) {\n        result[i] = value;\n      } else {\n        result[i] = value - CesiumMath.TWO_PI;\n      }\n      previousValue = value;\n    }\n  },\n  /**\n   * Retrieves an instance from a packed array converted with {@link Rotation.convertPackedArrayForInterpolation}.\n   *\n   * @param {number[]} array The array previously packed for interpolation.\n   * @param {number[]} sourceArray The original packed array.\n   * @param {number} [firstIndex=0] The firstIndex used to convert the array.\n   * @param {number} [lastIndex=packedArray.length] The lastIndex used to convert the array.\n   * @param {Rotation} [result] The object into which to store the result.\n   * @returns {Rotation} The modified result parameter or a new Rotation instance if one was not provided.\n   */\n  unpackInterpolationResult: function (array, sourceArray, firstIndex, lastIndex, result) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(array)) {\n      throw new DeveloperError(\"array is required\");\n    }\n    if (!defined(sourceArray)) {\n      throw new DeveloperError(\"sourceArray is required\");\n    }\n    //>>includeEnd('debug');\n\n    result = array[0];\n    if (result < 0) {\n      return result + CesiumMath.TWO_PI;\n    }\n    return result;\n  }\n};\nexport default Rotation;","map":{"version":3,"names":["defaultValue","defined","DeveloperError","CesiumMath","Rotation","packedLength","pack","value","array","startingIndex","unpack","result","convertPackedArrayForInterpolation","packedArray","lastIndex","length","previousValue","i","len","Math","abs","PI","TWO_PI","unpackInterpolationResult","sourceArray","firstIndex"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/Rotation.js"],"sourcesContent":["import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\n\n/**\n * Represents a {@link Packable} number that always interpolates values\n * towards the shortest angle of rotation. This object is never used directly\n * but is instead passed to the constructor of {@link SampledProperty}\n * in order to represent a two-dimensional angle of rotation.\n *\n * @interface Rotation\n *\n *\n * @example\n * const time1 = Cesium.JulianDate.fromIso8601('2010-05-07T00:00:00');\n * const time2 = Cesium.JulianDate.fromIso8601('2010-05-07T00:01:00');\n * const time3 = Cesium.JulianDate.fromIso8601('2010-05-07T00:02:00');\n *\n * const property = new Cesium.SampledProperty(Cesium.Rotation);\n * property.addSample(time1, 0);\n * property.addSample(time3, Cesium.Math.toRadians(350));\n *\n * //Getting the value at time2 will equal 355 degrees instead\n * //of 175 degrees (which is what you get if you construct\n * //a SampledProperty(Number) instead.  Note, the actual\n * //return value is in radians, not degrees.\n * property.getValue(time2);\n *\n * @see PackableForInterpolation\n */\nconst Rotation = {\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {number}\n   */\n  packedLength: 1,\n\n  /**\n   * Stores the provided instance into the provided array.\n   *\n   * @param {Rotation} value The value to pack.\n   * @param {number[]} array The array to pack into.\n   * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n   *\n   * @returns {number[]} The array that was packed into\n   */\n  pack: function (value, array, startingIndex) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(value)) {\n      throw new DeveloperError(\"value is required\");\n    }\n\n    if (!defined(array)) {\n      throw new DeveloperError(\"array is required\");\n    }\n    //>>includeEnd('debug');\n\n    startingIndex = defaultValue(startingIndex, 0);\n    array[startingIndex] = value;\n\n    return array;\n  },\n\n  /**\n   * Retrieves an instance from a packed array.\n   *\n   * @param {number[]} array The packed array.\n   * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n   * @param {Rotation} [result] The object into which to store the result.\n   * @returns {Rotation} The modified result parameter or a new Rotation instance if one was not provided.\n   */\n  unpack: function (array, startingIndex, result) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(array)) {\n      throw new DeveloperError(\"array is required\");\n    }\n    //>>includeEnd('debug');\n\n    startingIndex = defaultValue(startingIndex, 0);\n    return array[startingIndex];\n  },\n\n  /**\n   * Converts a packed array into a form suitable for interpolation.\n   *\n   * @param {number[]} packedArray The packed array.\n   * @param {number} [startingIndex=0] The index of the first element to be converted.\n   * @param {number} [lastIndex=packedArray.length] The index of the last element to be converted.\n   * @param {number[]} [result] The object into which to store the result.\n   */\n  convertPackedArrayForInterpolation: function (\n    packedArray,\n    startingIndex,\n    lastIndex,\n    result,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(packedArray)) {\n      throw new DeveloperError(\"packedArray is required\");\n    }\n    //>>includeEnd('debug');\n\n    if (!defined(result)) {\n      result = [];\n    }\n\n    startingIndex = defaultValue(startingIndex, 0);\n    lastIndex = defaultValue(lastIndex, packedArray.length);\n\n    let previousValue;\n    for (let i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {\n      const value = packedArray[startingIndex + i];\n      if (i === 0 || Math.abs(previousValue - value) < Math.PI) {\n        result[i] = value;\n      } else {\n        result[i] = value - CesiumMath.TWO_PI;\n      }\n      previousValue = value;\n    }\n  },\n\n  /**\n   * Retrieves an instance from a packed array converted with {@link Rotation.convertPackedArrayForInterpolation}.\n   *\n   * @param {number[]} array The array previously packed for interpolation.\n   * @param {number[]} sourceArray The original packed array.\n   * @param {number} [firstIndex=0] The firstIndex used to convert the array.\n   * @param {number} [lastIndex=packedArray.length] The lastIndex used to convert the array.\n   * @param {Rotation} [result] The object into which to store the result.\n   * @returns {Rotation} The modified result parameter or a new Rotation instance if one was not provided.\n   */\n  unpackInterpolationResult: function (\n    array,\n    sourceArray,\n    firstIndex,\n    lastIndex,\n    result,\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(array)) {\n      throw new DeveloperError(\"array is required\");\n    }\n    if (!defined(sourceArray)) {\n      throw new DeveloperError(\"sourceArray is required\");\n    }\n    //>>includeEnd('debug');\n\n    result = array[0];\n    if (result < 0) {\n      return result + CesiumMath.TWO_PI;\n    }\n    return result;\n  },\n};\nexport default Rotation;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}