{"ast":null,"code":"import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport SplitDirection from \"../SplitDirection.js\";\nimport TilesetPipelineStage from \"./TilesetPipelineStage.js\";\nimport AtmospherePipelineStage from \"./AtmospherePipelineStage.js\";\nimport ImageBasedLightingPipelineStage from \"./ImageBasedLightingPipelineStage.js\";\nimport ModelArticulation from \"./ModelArticulation.js\";\nimport ModelColorPipelineStage from \"./ModelColorPipelineStage.js\";\nimport ModelClippingPlanesPipelineStage from \"./ModelClippingPlanesPipelineStage.js\";\nimport ModelClippingPolygonsPipelineStage from \"./ModelClippingPolygonsPipelineStage.js\";\nimport ModelNode from \"./ModelNode.js\";\nimport ModelRuntimeNode from \"./ModelRuntimeNode.js\";\nimport ModelRuntimePrimitive from \"./ModelRuntimePrimitive.js\";\nimport ModelSkin from \"./ModelSkin.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport ModelRenderResources from \"./ModelRenderResources.js\";\nimport ModelSilhouettePipelineStage from \"./ModelSilhouettePipelineStage.js\";\nimport ModelSplitterPipelineStage from \"./ModelSplitterPipelineStage.js\";\nimport ModelType from \"./ModelType.js\";\nimport NodeRenderResources from \"./NodeRenderResources.js\";\nimport PrimitiveRenderResources from \"./PrimitiveRenderResources.js\";\nimport ModelDrawCommands from \"./ModelDrawCommands.js\";\n\n/**\n * An in memory representation of the scene graph for a {@link Model}\n *\n * @param {object} options An object containing the following options\n * @param {Model} options.model The model this scene graph belongs to\n * @param {ModelComponents} options.modelComponents The model components describing the model\n *\n * @alias ModelSceneGraph\n * @constructor\n *\n * @private\n */\nfunction ModelSceneGraph(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const components = options.modelComponents;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.model\", options.model);\n  Check.typeOf.object(\"options.modelComponents\", components);\n  //>>includeEnd('debug');\n\n  /**\n   * A reference to the {@link Model} that owns this scene graph.\n   *\n   * @type {Model}\n   * @readonly\n   *\n   * @private\n   */\n  this._model = options.model;\n\n  /**\n   * The model components that represent the contents of the 3D model file.\n   *\n   * @type {ModelComponents}\n   * @readonly\n   *\n   * @private\n   */\n  this._components = components;\n\n  /**\n   * Pipeline stages to apply across the model.\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._pipelineStages = [];\n\n  /**\n   * Update stages to apply across the model.\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._updateStages = [];\n\n  /**\n   * The runtime nodes that make up the scene graph\n   *\n   * @type {ModelRuntimeNode[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._runtimeNodes = [];\n\n  /**\n   * The indices of the root nodes in the runtime nodes array.\n   *\n   * @type {number[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._rootNodes = [];\n\n  /**\n   * The indices of the skinned nodes in the runtime nodes array. These refer\n   * to the nodes that will be manipulated by their skin, as opposed to the nodes\n   * acting as joints for the skin.\n   *\n   * @type {number[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._skinnedNodes = [];\n\n  /**\n   * The runtime skins that affect nodes in the scene graph.\n   *\n   * @type {ModelSkin[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._runtimeSkins = [];\n\n  /**\n   * Pipeline stages to apply to this model. This\n   * is an array of classes, each with a static method called\n   * <code>process()</code>\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.modelPipelineStages = [];\n\n  // The scene graph's bounding sphere is model space, so that\n  // the model's bounding sphere can be recomputed when given a\n  // new model matrix.\n  this._boundingSphere = undefined;\n\n  // The 2D bounding sphere is in world space. This is checked\n  // by the draw commands to see if the model is over the IDL,\n  // and if so, renders the primitives using extra commands.\n  this._boundingSphere2D = undefined;\n  this._computedModelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._computedModelMatrix2D = Matrix4.clone(Matrix4.IDENTITY);\n  this._axisCorrectionMatrix = ModelUtility.getAxisCorrectionMatrix(components.upAxis, components.forwardAxis, new Matrix4());\n\n  // Store articulations from the AGI_articulations extension\n  // by name in a dictionary for easy retrieval.\n  this._runtimeArticulations = {};\n  initialize(this);\n}\nObject.defineProperties(ModelSceneGraph.prototype, {\n  /**\n   * The model components this scene graph represents.\n   *\n   * @type {ModelComponents}\n   * @readonly\n   *\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    }\n  },\n  /**\n   * The axis-corrected model matrix.\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  computedModelMatrix: {\n    get: function () {\n      return this._computedModelMatrix;\n    }\n  },\n  /**\n   * A matrix to correct from y-up in some model formats (e.g. glTF) to the\n   * z-up coordinate system Cesium uses.\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  axisCorrectionMatrix: {\n    get: function () {\n      return this._axisCorrectionMatrix;\n    }\n  },\n  /**\n   * The bounding sphere containing all the primitives in the scene graph\n   * in model space.\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   *\n   * @private\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    }\n  }\n});\nfunction initialize(sceneGraph) {\n  const components = sceneGraph._components;\n  const scene = components.scene;\n  const model = sceneGraph._model;\n\n  // If the model has a height reference that modifies the model matrix,\n  // it will be accounted for in updateModelMatrix.\n  const modelMatrix = model.modelMatrix;\n  computeModelMatrix(sceneGraph, modelMatrix);\n  const articulations = components.articulations;\n  const articulationsLength = articulations.length;\n  const runtimeArticulations = sceneGraph._runtimeArticulations;\n  for (let i = 0; i < articulationsLength; i++) {\n    const articulation = articulations[i];\n    const runtimeArticulation = new ModelArticulation({\n      articulation: articulation,\n      sceneGraph: sceneGraph\n    });\n    const name = runtimeArticulation.name;\n    runtimeArticulations[name] = runtimeArticulation;\n  }\n  const nodes = components.nodes;\n  const nodesLength = nodes.length;\n\n  // Initialize this array to be the same size as the nodes array in\n  // the model file. This is so the node indices remain the same. However,\n  // only nodes reachable from the scene's root node will be populated, the\n  // rest will be undefined\n  sceneGraph._runtimeNodes = new Array(nodesLength);\n  const rootNodes = scene.nodes;\n  const rootNodesLength = rootNodes.length;\n  const transformToRoot = Matrix4.IDENTITY;\n  for (let i = 0; i < rootNodesLength; i++) {\n    const rootNode = scene.nodes[i];\n    const rootNodeIndex = traverseAndCreateSceneGraph(sceneGraph, rootNode, transformToRoot);\n    sceneGraph._rootNodes.push(rootNodeIndex);\n  }\n\n  // Handle skins after all runtime nodes are created\n  const skins = components.skins;\n  const runtimeSkins = sceneGraph._runtimeSkins;\n  const skinsLength = skins.length;\n  for (let i = 0; i < skinsLength; i++) {\n    const skin = skins[i];\n    runtimeSkins.push(new ModelSkin({\n      skin: skin,\n      sceneGraph: sceneGraph\n    }));\n  }\n  const skinnedNodes = sceneGraph._skinnedNodes;\n  const skinnedNodesLength = skinnedNodes.length;\n  for (let i = 0; i < skinnedNodesLength; i++) {\n    const skinnedNodeIndex = skinnedNodes[i];\n    const skinnedNode = sceneGraph._runtimeNodes[skinnedNodeIndex];\n\n    // Use the index of the skin in the model components to find\n    // the corresponding runtime skin.\n    const skin = nodes[skinnedNodeIndex].skin;\n    const skinIndex = skin.index;\n    skinnedNode._runtimeSkin = runtimeSkins[skinIndex];\n    skinnedNode.updateJointMatrices();\n  }\n\n  // Ensure articulations are applied with their initial values to their target nodes.\n  sceneGraph.applyArticulations();\n}\nfunction computeModelMatrix(sceneGraph, modelMatrix) {\n  const components = sceneGraph._components;\n  const model = sceneGraph._model;\n  sceneGraph._computedModelMatrix = Matrix4.multiplyTransformation(modelMatrix, components.transform, sceneGraph._computedModelMatrix);\n  sceneGraph._computedModelMatrix = Matrix4.multiplyTransformation(sceneGraph._computedModelMatrix, sceneGraph._axisCorrectionMatrix, sceneGraph._computedModelMatrix);\n  sceneGraph._computedModelMatrix = Matrix4.multiplyByUniformScale(sceneGraph._computedModelMatrix, model.computedScale, sceneGraph._computedModelMatrix);\n}\nconst scratchComputedTranslation = new Cartesian3();\nfunction computeModelMatrix2D(sceneGraph, frameState) {\n  const computedModelMatrix = sceneGraph._computedModelMatrix;\n  const translation = Matrix4.getTranslation(computedModelMatrix, scratchComputedTranslation);\n  if (!Cartesian3.equals(translation, Cartesian3.ZERO)) {\n    sceneGraph._computedModelMatrix2D = Transforms.basisTo2D(frameState.mapProjection, computedModelMatrix, sceneGraph._computedModelMatrix2D);\n  } else {\n    const center = sceneGraph.boundingSphere.center;\n    const to2D = Transforms.ellipsoidTo2DModelMatrix(frameState.mapProjection, center, sceneGraph._computedModelMatrix2D);\n    sceneGraph._computedModelMatrix2D = Matrix4.multiply(to2D, computedModelMatrix, sceneGraph._computedModelMatrix2D);\n  }\n  sceneGraph._boundingSphere2D = BoundingSphere.transform(sceneGraph._boundingSphere, sceneGraph._computedModelMatrix2D, sceneGraph._boundingSphere2D);\n}\n\n/**\n * Recursively traverse through the nodes in the scene graph to create\n * their runtime versions, using a post-order depth-first traversal.\n *\n * @param {ModelSceneGraph} sceneGraph The scene graph\n * @param {ModelComponents.Node} node The current node\n * @param {Matrix4} transformToRoot The transforms of this node's ancestors.\n * @returns {number} The index of this node in the runtimeNodes array.\n *\n * @private\n */\nfunction traverseAndCreateSceneGraph(sceneGraph, node, transformToRoot) {\n  // The indices of the children of this node in the runtimeNodes array.\n  const childrenIndices = [];\n  const transform = ModelUtility.getNodeTransform(node);\n\n  // Traverse through scene graph.\n  const childrenLength = node.children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const childNode = node.children[i];\n    const childNodeTransformToRoot = Matrix4.multiplyTransformation(transformToRoot, transform, new Matrix4());\n    const childIndex = traverseAndCreateSceneGraph(sceneGraph, childNode, childNodeTransformToRoot);\n    childrenIndices.push(childIndex);\n  }\n\n  // Process node and mesh primitives.\n  const runtimeNode = new ModelRuntimeNode({\n    node: node,\n    transform: transform,\n    transformToRoot: transformToRoot,\n    children: childrenIndices,\n    sceneGraph: sceneGraph\n  });\n  const primitivesLength = node.primitives.length;\n  for (let i = 0; i < primitivesLength; i++) {\n    runtimeNode.runtimePrimitives.push(new ModelRuntimePrimitive({\n      primitive: node.primitives[i],\n      node: node,\n      model: sceneGraph._model\n    }));\n  }\n  const index = node.index;\n  sceneGraph._runtimeNodes[index] = runtimeNode;\n  if (defined(node.skin)) {\n    sceneGraph._skinnedNodes.push(index);\n  }\n\n  // Create and store the public version of the runtime node.\n  const name = node.name;\n  if (defined(name)) {\n    const model = sceneGraph._model;\n    const publicNode = new ModelNode(model, runtimeNode);\n    model._nodesByName[name] = publicNode;\n  }\n  return index;\n}\nconst scratchModelPositionMin = new Cartesian3();\nconst scratchModelPositionMax = new Cartesian3();\nconst scratchPrimitivePositionMin = new Cartesian3();\nconst scratchPrimitivePositionMax = new Cartesian3();\n/**\n * Generates the {@link ModelDrawCommand} for each primitive in the model.\n * If the model is used for classification, a {@link ClassificationModelDrawCommand}\n * is generated for each primitive instead.\n *\n * @param {FrameState} frameState The current frame state. This is needed to\n * allocate GPU resources as needed.\n *\n * @private\n */\nModelSceneGraph.prototype.buildDrawCommands = function (frameState) {\n  const model = this._model;\n  const modelRenderResources = new ModelRenderResources(model);\n\n  // Reset the memory counts before running the pipeline\n  model.statistics.clear();\n  this.configurePipeline(frameState);\n  const modelPipelineStages = this.modelPipelineStages;\n  let i, j, k;\n  for (i = 0; i < modelPipelineStages.length; i++) {\n    const modelPipelineStage = modelPipelineStages[i];\n    modelPipelineStage.process(modelRenderResources, model, frameState);\n  }\n  const modelPositionMin = Cartesian3.fromElements(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, scratchModelPositionMin);\n  const modelPositionMax = Cartesian3.fromElements(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, scratchModelPositionMax);\n  for (i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    // If a node in the model was unreachable from the scene graph, there will\n    // be no corresponding runtime node and therefore should be skipped.\n    if (!defined(runtimeNode)) {\n      continue;\n    }\n    runtimeNode.configurePipeline();\n    const nodePipelineStages = runtimeNode.pipelineStages;\n    const nodeRenderResources = new NodeRenderResources(modelRenderResources, runtimeNode);\n    for (j = 0; j < nodePipelineStages.length; j++) {\n      const nodePipelineStage = nodePipelineStages[j];\n      nodePipelineStage.process(nodeRenderResources, runtimeNode.node, frameState);\n    }\n    const nodeTransform = runtimeNode.computedTransform;\n    for (j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n      runtimePrimitive.configurePipeline(frameState);\n      const primitivePipelineStages = runtimePrimitive.pipelineStages;\n      const primitiveRenderResources = new PrimitiveRenderResources(nodeRenderResources, runtimePrimitive);\n      for (k = 0; k < primitivePipelineStages.length; k++) {\n        const primitivePipelineStage = primitivePipelineStages[k];\n        primitivePipelineStage.process(primitiveRenderResources, runtimePrimitive.primitive, frameState);\n      }\n      runtimePrimitive.boundingSphere = BoundingSphere.clone(primitiveRenderResources.boundingSphere, new BoundingSphere());\n      const primitivePositionMin = Matrix4.multiplyByPoint(nodeTransform, primitiveRenderResources.positionMin, scratchPrimitivePositionMin);\n      const primitivePositionMax = Matrix4.multiplyByPoint(nodeTransform, primitiveRenderResources.positionMax, scratchPrimitivePositionMax);\n      Cartesian3.minimumByComponent(modelPositionMin, primitivePositionMin, modelPositionMin);\n      Cartesian3.maximumByComponent(modelPositionMax, primitivePositionMax, modelPositionMax);\n      const drawCommand = ModelDrawCommands.buildModelDrawCommand(primitiveRenderResources, frameState);\n      runtimePrimitive.drawCommand = drawCommand;\n    }\n  }\n  this._boundingSphere = BoundingSphere.fromCornerPoints(modelPositionMin, modelPositionMax, new BoundingSphere());\n  this._boundingSphere = BoundingSphere.transformWithoutScale(this._boundingSphere, this._axisCorrectionMatrix, this._boundingSphere);\n  this._boundingSphere = BoundingSphere.transform(this._boundingSphere, this._components.transform, this._boundingSphere);\n  model._boundingSphere = BoundingSphere.transform(this._boundingSphere, model.modelMatrix, model._boundingSphere);\n  model._initialRadius = model._boundingSphere.radius;\n  model._boundingSphere.radius *= model._clampedScale;\n};\n\n/**\n * Configure the model pipeline stages. If the pipeline needs to be re-run, call\n * this method again to ensure the correct sequence of pipeline stages are\n * used.\n *\n * @param {FrameState} frameState\n * @private\n */\nModelSceneGraph.prototype.configurePipeline = function (frameState) {\n  const modelPipelineStages = this.modelPipelineStages;\n  modelPipelineStages.length = 0;\n  const model = this._model;\n  const fogRenderable = frameState.fog.enabled && frameState.fog.renderable;\n  if (defined(model.color)) {\n    modelPipelineStages.push(ModelColorPipelineStage);\n  }\n\n  // Skip these pipeline stages for classification models.\n  if (defined(model.classificationType)) {\n    return;\n  }\n  if (model.imageBasedLighting.enabled) {\n    modelPipelineStages.push(ImageBasedLightingPipelineStage);\n  }\n  if (model.isClippingEnabled()) {\n    modelPipelineStages.push(ModelClippingPlanesPipelineStage);\n  }\n  if (model.isClippingPolygonsEnabled()) {\n    modelPipelineStages.push(ModelClippingPolygonsPipelineStage);\n  }\n  if (model.hasSilhouette(frameState)) {\n    modelPipelineStages.push(ModelSilhouettePipelineStage);\n  }\n  if (defined(model.splitDirection) && model.splitDirection !== SplitDirection.NONE) {\n    modelPipelineStages.push(ModelSplitterPipelineStage);\n  }\n  if (ModelType.is3DTiles(model.type)) {\n    modelPipelineStages.push(TilesetPipelineStage);\n  }\n  if (fogRenderable) {\n    modelPipelineStages.push(AtmospherePipelineStage);\n  }\n};\nModelSceneGraph.prototype.update = function (frameState, updateForAnimations) {\n  let i, j, k;\n  for (i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    // If a node in the model was unreachable from the scene graph, there will\n    // be no corresponding runtime node and therefore should be skipped.\n    if (!defined(runtimeNode)) {\n      continue;\n    }\n    for (j = 0; j < runtimeNode.updateStages.length; j++) {\n      const nodeUpdateStage = runtimeNode.updateStages[j];\n      nodeUpdateStage.update(runtimeNode, this, frameState);\n    }\n    const disableAnimations = frameState.mode !== SceneMode.SCENE3D && this._model._projectTo2D;\n    if (updateForAnimations && !disableAnimations) {\n      this.updateJointMatrices();\n    }\n    for (j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n      for (k = 0; k < runtimePrimitive.updateStages.length; k++) {\n        const stage = runtimePrimitive.updateStages[k];\n        stage.update(runtimePrimitive, this);\n      }\n    }\n  }\n};\nModelSceneGraph.prototype.updateModelMatrix = function (modelMatrix, frameState) {\n  computeModelMatrix(this, modelMatrix);\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    computeModelMatrix2D(this, frameState);\n  }\n\n  // Mark all root nodes as dirty. Any and all children will be\n  // affected recursively in the update stage.\n  const rootNodes = this._rootNodes;\n  for (let i = 0; i < rootNodes.length; i++) {\n    const node = this._runtimeNodes[rootNodes[i]];\n    node._transformDirty = true;\n  }\n};\n\n/**\n * Updates the joint matrices for the skins and nodes of the model.\n *\n * @private\n */\nModelSceneGraph.prototype.updateJointMatrices = function () {\n  const skinnedNodes = this._skinnedNodes;\n  const length = skinnedNodes.length;\n  for (let i = 0; i < length; i++) {\n    const nodeIndex = skinnedNodes[i];\n    const runtimeNode = this._runtimeNodes[nodeIndex];\n    runtimeNode.updateJointMatrices();\n  }\n};\n\n/**\n * A callback to be applied once at each runtime primitive in the\n * scene graph\n * @callback traverseSceneGraphCallback\n *\n * @param {ModelRuntimePrimitive} runtimePrimitive The runtime primitive for the current step of the traversal\n * @param {object} [options] A dictionary of additional options to be passed to the callback, or undefined if the callback does not need any additional information.\n *\n * @private\n */\n\n/**\n * Recursively traverse through the runtime nodes in the scene graph\n * using a post-order depth-first traversal to perform a callback on\n * their runtime primitives.\n *\n * @param {ModelSceneGraph} sceneGraph The scene graph.\n * @param {ModelRuntimeNode} runtimeNode The current runtime node.\n * @param {boolean} visibleNodesOnly Whether to only traverse nodes that are visible.\n * @param {traverseSceneGraphCallback} callback The callback to perform on the runtime primitives of the node.\n * @param {object} [callbackOptions] A dictionary of additional options to be passed to the callback, if needed.\n *\n * @private\n */\nfunction traverseSceneGraph(sceneGraph, runtimeNode, visibleNodesOnly, callback, callbackOptions) {\n  if (visibleNodesOnly && !runtimeNode.show) {\n    return;\n  }\n  const childrenLength = runtimeNode.children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const childRuntimeNode = runtimeNode.getChild(i);\n    traverseSceneGraph(sceneGraph, childRuntimeNode, visibleNodesOnly, callback, callbackOptions);\n  }\n  const runtimePrimitives = runtimeNode.runtimePrimitives;\n  const runtimePrimitivesLength = runtimePrimitives.length;\n  for (let j = 0; j < runtimePrimitivesLength; j++) {\n    const runtimePrimitive = runtimePrimitives[j];\n    callback(runtimePrimitive, callbackOptions);\n  }\n}\nfunction forEachRuntimePrimitive(sceneGraph, visibleNodesOnly, callback, callbackOptions) {\n  const rootNodes = sceneGraph._rootNodes;\n  const rootNodesLength = rootNodes.length;\n  for (let i = 0; i < rootNodesLength; i++) {\n    const rootNodeIndex = rootNodes[i];\n    const runtimeNode = sceneGraph._runtimeNodes[rootNodeIndex];\n    traverseSceneGraph(sceneGraph, runtimeNode, visibleNodesOnly, callback, callbackOptions);\n  }\n}\nconst scratchBackFaceCullingOptions = {\n  backFaceCulling: undefined\n};\n\n/**\n * Traverses through all draw commands and changes the back-face culling setting.\n *\n * @param {boolean} backFaceCulling The new value for the back-face culling setting.\n *\n * @private\n */\nModelSceneGraph.prototype.updateBackFaceCulling = function (backFaceCulling) {\n  const backFaceCullingOptions = scratchBackFaceCullingOptions;\n  backFaceCullingOptions.backFaceCulling = backFaceCulling;\n  forEachRuntimePrimitive(this, false, updatePrimitiveBackFaceCulling, backFaceCullingOptions);\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction updatePrimitiveBackFaceCulling(runtimePrimitive, options) {\n  const drawCommand = runtimePrimitive.drawCommand;\n  drawCommand.backFaceCulling = options.backFaceCulling;\n}\nconst scratchShadowOptions = {\n  shadowMode: undefined\n};\n\n/**\n * Traverses through all draw commands and changes the shadow settings.\n *\n * @param {ShadowMode} shadowMode The new shadow settings.\n *\n * @private\n */\nModelSceneGraph.prototype.updateShadows = function (shadowMode) {\n  const shadowOptions = scratchShadowOptions;\n  shadowOptions.shadowMode = shadowMode;\n  forEachRuntimePrimitive(this, false, updatePrimitiveShadows, shadowOptions);\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction updatePrimitiveShadows(runtimePrimitive, options) {\n  const drawCommand = runtimePrimitive.drawCommand;\n  drawCommand.shadows = options.shadowMode;\n}\nconst scratchShowBoundingVolumeOptions = {\n  debugShowBoundingVolume: undefined\n};\n\n/**\n * Traverses through all draw commands and changes whether to show the debug bounding volume.\n *\n * @param {boolean} debugShowBoundingVolume The new value for showing the debug bounding volume.\n *\n * @private\n */\nModelSceneGraph.prototype.updateShowBoundingVolume = function (debugShowBoundingVolume) {\n  const showBoundingVolumeOptions = scratchShowBoundingVolumeOptions;\n  showBoundingVolumeOptions.debugShowBoundingVolume = debugShowBoundingVolume;\n  forEachRuntimePrimitive(this, false, updatePrimitiveShowBoundingVolume, showBoundingVolumeOptions);\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction updatePrimitiveShowBoundingVolume(runtimePrimitive, options) {\n  const drawCommand = runtimePrimitive.drawCommand;\n  drawCommand.debugShowBoundingVolume = options.debugShowBoundingVolume;\n}\nconst scratchSilhouetteCommands = [];\nconst scratchPushDrawCommandOptions = {\n  frameState: undefined,\n  hasSilhouette: undefined\n};\n\n/**\n * Traverses through the scene graph and pushes the draw commands associated\n * with each primitive to the frame state's command list.\n *\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nModelSceneGraph.prototype.pushDrawCommands = function (frameState) {\n  // If a model has silhouettes, the commands that draw the silhouettes for\n  // each primitive can only be invoked after the entire model has drawn.\n  // Otherwise, the silhouette may draw on top of the model. This requires\n  // gathering the original commands and the silhouette commands separately.\n  const silhouetteCommands = scratchSilhouetteCommands;\n  silhouetteCommands.length = 0;\n\n  // Since this function is called each frame, the options object is\n  // preallocated in a scratch variable\n  const pushDrawCommandOptions = scratchPushDrawCommandOptions;\n  pushDrawCommandOptions.hasSilhouette = this._model.hasSilhouette(frameState);\n  pushDrawCommandOptions.frameState = frameState;\n  forEachRuntimePrimitive(this, true, pushPrimitiveDrawCommands, pushDrawCommandOptions);\n  frameState.commandList.push.apply(frameState.commandList, silhouetteCommands);\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction pushPrimitiveDrawCommands(runtimePrimitive, options) {\n  const frameState = options.frameState;\n  const hasSilhouette = options.hasSilhouette;\n  const passes = frameState.passes;\n  const silhouetteCommands = scratchSilhouetteCommands;\n  const primitiveDrawCommand = runtimePrimitive.drawCommand;\n  primitiveDrawCommand.pushCommands(frameState, frameState.commandList);\n\n  // If a model has silhouettes, the commands that draw the silhouettes for\n  // each primitive can only be invoked after the entire model has drawn.\n  // Otherwise, the silhouette may draw on top of the model. This requires\n  // gathering the original commands and the silhouette commands separately.\n  if (hasSilhouette && !passes.pick) {\n    primitiveDrawCommand.pushSilhouetteCommands(frameState, silhouetteCommands);\n  }\n}\n\n/**\n * Sets the current value of an articulation stage.\n *\n * @param {string} articulationStageKey The name of the articulation, a space, and the name of the stage.\n * @param {number} value The numeric value of this stage of the articulation.\n *\n * @private\n */\nModelSceneGraph.prototype.setArticulationStage = function (articulationStageKey, value) {\n  const names = articulationStageKey.split(\" \");\n  if (names.length !== 2) {\n    return;\n  }\n  const articulationName = names[0];\n  const stageName = names[1];\n  const runtimeArticulation = this._runtimeArticulations[articulationName];\n  if (defined(runtimeArticulation)) {\n    runtimeArticulation.setArticulationStage(stageName, value);\n  }\n};\n\n/**\n * Applies any modified articulation stages to the matrix of each node that participates\n * in any articulation.  Note that this will overwrite any nodeTransformations on participating nodes.\n *\n * @private\n */\nModelSceneGraph.prototype.applyArticulations = function () {\n  const runtimeArticulations = this._runtimeArticulations;\n  for (const articulationName in runtimeArticulations) {\n    if (runtimeArticulations.hasOwnProperty(articulationName)) {\n      const articulation = runtimeArticulations[articulationName];\n      articulation.apply();\n    }\n  }\n};\nexport default ModelSceneGraph;","map":{"version":3,"names":["BoundingSphere","Cartesian3","Check","defaultValue","defined","Matrix4","Transforms","SceneMode","SplitDirection","TilesetPipelineStage","AtmospherePipelineStage","ImageBasedLightingPipelineStage","ModelArticulation","ModelColorPipelineStage","ModelClippingPlanesPipelineStage","ModelClippingPolygonsPipelineStage","ModelNode","ModelRuntimeNode","ModelRuntimePrimitive","ModelSkin","ModelUtility","ModelRenderResources","ModelSilhouettePipelineStage","ModelSplitterPipelineStage","ModelType","NodeRenderResources","PrimitiveRenderResources","ModelDrawCommands","ModelSceneGraph","options","EMPTY_OBJECT","components","modelComponents","typeOf","object","model","_model","_components","_pipelineStages","_updateStages","_runtimeNodes","_rootNodes","_skinnedNodes","_runtimeSkins","modelPipelineStages","_boundingSphere","undefined","_boundingSphere2D","_computedModelMatrix","clone","IDENTITY","_computedModelMatrix2D","_axisCorrectionMatrix","getAxisCorrectionMatrix","upAxis","forwardAxis","_runtimeArticulations","initialize","Object","defineProperties","prototype","get","computedModelMatrix","axisCorrectionMatrix","boundingSphere","sceneGraph","scene","modelMatrix","computeModelMatrix","articulations","articulationsLength","length","runtimeArticulations","i","articulation","runtimeArticulation","name","nodes","nodesLength","Array","rootNodes","rootNodesLength","transformToRoot","rootNode","rootNodeIndex","traverseAndCreateSceneGraph","push","skins","runtimeSkins","skinsLength","skin","skinnedNodes","skinnedNodesLength","skinnedNodeIndex","skinnedNode","skinIndex","index","_runtimeSkin","updateJointMatrices","applyArticulations","multiplyTransformation","transform","multiplyByUniformScale","computedScale","scratchComputedTranslation","computeModelMatrix2D","frameState","translation","getTranslation","equals","ZERO","basisTo2D","mapProjection","center","to2D","ellipsoidTo2DModelMatrix","multiply","node","childrenIndices","getNodeTransform","childrenLength","children","childNode","childNodeTransformToRoot","childIndex","runtimeNode","primitivesLength","primitives","runtimePrimitives","primitive","publicNode","_nodesByName","scratchModelPositionMin","scratchModelPositionMax","scratchPrimitivePositionMin","scratchPrimitivePositionMax","buildDrawCommands","modelRenderResources","statistics","clear","configurePipeline","j","k","modelPipelineStage","process","modelPositionMin","fromElements","Number","MAX_VALUE","modelPositionMax","nodePipelineStages","pipelineStages","nodeRenderResources","nodePipelineStage","nodeTransform","computedTransform","runtimePrimitive","primitivePipelineStages","primitiveRenderResources","primitivePipelineStage","primitivePositionMin","multiplyByPoint","positionMin","primitivePositionMax","positionMax","minimumByComponent","maximumByComponent","drawCommand","buildModelDrawCommand","fromCornerPoints","transformWithoutScale","_initialRadius","radius","_clampedScale","fogRenderable","fog","enabled","renderable","color","classificationType","imageBasedLighting","isClippingEnabled","isClippingPolygonsEnabled","hasSilhouette","splitDirection","NONE","is3DTiles","type","update","updateForAnimations","updateStages","nodeUpdateStage","disableAnimations","mode","SCENE3D","_projectTo2D","stage","updateModelMatrix","_transformDirty","nodeIndex","traverseSceneGraph","visibleNodesOnly","callback","callbackOptions","show","childRuntimeNode","getChild","runtimePrimitivesLength","forEachRuntimePrimitive","scratchBackFaceCullingOptions","backFaceCulling","updateBackFaceCulling","backFaceCullingOptions","updatePrimitiveBackFaceCulling","scratchShadowOptions","shadowMode","updateShadows","shadowOptions","updatePrimitiveShadows","shadows","scratchShowBoundingVolumeOptions","debugShowBoundingVolume","updateShowBoundingVolume","showBoundingVolumeOptions","updatePrimitiveShowBoundingVolume","scratchSilhouetteCommands","scratchPushDrawCommandOptions","pushDrawCommands","silhouetteCommands","pushDrawCommandOptions","pushPrimitiveDrawCommands","commandList","apply","passes","primitiveDrawCommand","pushCommands","pick","pushSilhouetteCommands","setArticulationStage","articulationStageKey","value","names","split","articulationName","stageName","hasOwnProperty"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/ModelSceneGraph.js"],"sourcesContent":["import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport SplitDirection from \"../SplitDirection.js\";\nimport TilesetPipelineStage from \"./TilesetPipelineStage.js\";\nimport AtmospherePipelineStage from \"./AtmospherePipelineStage.js\";\nimport ImageBasedLightingPipelineStage from \"./ImageBasedLightingPipelineStage.js\";\nimport ModelArticulation from \"./ModelArticulation.js\";\nimport ModelColorPipelineStage from \"./ModelColorPipelineStage.js\";\nimport ModelClippingPlanesPipelineStage from \"./ModelClippingPlanesPipelineStage.js\";\nimport ModelClippingPolygonsPipelineStage from \"./ModelClippingPolygonsPipelineStage.js\";\nimport ModelNode from \"./ModelNode.js\";\nimport ModelRuntimeNode from \"./ModelRuntimeNode.js\";\nimport ModelRuntimePrimitive from \"./ModelRuntimePrimitive.js\";\nimport ModelSkin from \"./ModelSkin.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport ModelRenderResources from \"./ModelRenderResources.js\";\nimport ModelSilhouettePipelineStage from \"./ModelSilhouettePipelineStage.js\";\nimport ModelSplitterPipelineStage from \"./ModelSplitterPipelineStage.js\";\nimport ModelType from \"./ModelType.js\";\nimport NodeRenderResources from \"./NodeRenderResources.js\";\nimport PrimitiveRenderResources from \"./PrimitiveRenderResources.js\";\nimport ModelDrawCommands from \"./ModelDrawCommands.js\";\n\n/**\n * An in memory representation of the scene graph for a {@link Model}\n *\n * @param {object} options An object containing the following options\n * @param {Model} options.model The model this scene graph belongs to\n * @param {ModelComponents} options.modelComponents The model components describing the model\n *\n * @alias ModelSceneGraph\n * @constructor\n *\n * @private\n */\nfunction ModelSceneGraph(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const components = options.modelComponents;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.model\", options.model);\n  Check.typeOf.object(\"options.modelComponents\", components);\n  //>>includeEnd('debug');\n\n  /**\n   * A reference to the {@link Model} that owns this scene graph.\n   *\n   * @type {Model}\n   * @readonly\n   *\n   * @private\n   */\n  this._model = options.model;\n\n  /**\n   * The model components that represent the contents of the 3D model file.\n   *\n   * @type {ModelComponents}\n   * @readonly\n   *\n   * @private\n   */\n  this._components = components;\n\n  /**\n   * Pipeline stages to apply across the model.\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._pipelineStages = [];\n\n  /**\n   * Update stages to apply across the model.\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._updateStages = [];\n\n  /**\n   * The runtime nodes that make up the scene graph\n   *\n   * @type {ModelRuntimeNode[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._runtimeNodes = [];\n\n  /**\n   * The indices of the root nodes in the runtime nodes array.\n   *\n   * @type {number[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._rootNodes = [];\n\n  /**\n   * The indices of the skinned nodes in the runtime nodes array. These refer\n   * to the nodes that will be manipulated by their skin, as opposed to the nodes\n   * acting as joints for the skin.\n   *\n   * @type {number[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._skinnedNodes = [];\n\n  /**\n   * The runtime skins that affect nodes in the scene graph.\n   *\n   * @type {ModelSkin[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._runtimeSkins = [];\n\n  /**\n   * Pipeline stages to apply to this model. This\n   * is an array of classes, each with a static method called\n   * <code>process()</code>\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.modelPipelineStages = [];\n\n  // The scene graph's bounding sphere is model space, so that\n  // the model's bounding sphere can be recomputed when given a\n  // new model matrix.\n  this._boundingSphere = undefined;\n\n  // The 2D bounding sphere is in world space. This is checked\n  // by the draw commands to see if the model is over the IDL,\n  // and if so, renders the primitives using extra commands.\n  this._boundingSphere2D = undefined;\n\n  this._computedModelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._computedModelMatrix2D = Matrix4.clone(Matrix4.IDENTITY);\n\n  this._axisCorrectionMatrix = ModelUtility.getAxisCorrectionMatrix(\n    components.upAxis,\n    components.forwardAxis,\n    new Matrix4(),\n  );\n\n  // Store articulations from the AGI_articulations extension\n  // by name in a dictionary for easy retrieval.\n  this._runtimeArticulations = {};\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelSceneGraph.prototype, {\n  /**\n   * The model components this scene graph represents.\n   *\n   * @type {ModelComponents}\n   * @readonly\n   *\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n\n  /**\n   * The axis-corrected model matrix.\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  computedModelMatrix: {\n    get: function () {\n      return this._computedModelMatrix;\n    },\n  },\n\n  /**\n   * A matrix to correct from y-up in some model formats (e.g. glTF) to the\n   * z-up coordinate system Cesium uses.\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  axisCorrectionMatrix: {\n    get: function () {\n      return this._axisCorrectionMatrix;\n    },\n  },\n\n  /**\n   * The bounding sphere containing all the primitives in the scene graph\n   * in model space.\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   *\n   * @private\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n});\n\nfunction initialize(sceneGraph) {\n  const components = sceneGraph._components;\n  const scene = components.scene;\n  const model = sceneGraph._model;\n\n  // If the model has a height reference that modifies the model matrix,\n  // it will be accounted for in updateModelMatrix.\n  const modelMatrix = model.modelMatrix;\n  computeModelMatrix(sceneGraph, modelMatrix);\n\n  const articulations = components.articulations;\n  const articulationsLength = articulations.length;\n\n  const runtimeArticulations = sceneGraph._runtimeArticulations;\n  for (let i = 0; i < articulationsLength; i++) {\n    const articulation = articulations[i];\n    const runtimeArticulation = new ModelArticulation({\n      articulation: articulation,\n      sceneGraph: sceneGraph,\n    });\n\n    const name = runtimeArticulation.name;\n    runtimeArticulations[name] = runtimeArticulation;\n  }\n\n  const nodes = components.nodes;\n  const nodesLength = nodes.length;\n\n  // Initialize this array to be the same size as the nodes array in\n  // the model file. This is so the node indices remain the same. However,\n  // only nodes reachable from the scene's root node will be populated, the\n  // rest will be undefined\n  sceneGraph._runtimeNodes = new Array(nodesLength);\n\n  const rootNodes = scene.nodes;\n  const rootNodesLength = rootNodes.length;\n  const transformToRoot = Matrix4.IDENTITY;\n  for (let i = 0; i < rootNodesLength; i++) {\n    const rootNode = scene.nodes[i];\n\n    const rootNodeIndex = traverseAndCreateSceneGraph(\n      sceneGraph,\n      rootNode,\n      transformToRoot,\n    );\n\n    sceneGraph._rootNodes.push(rootNodeIndex);\n  }\n\n  // Handle skins after all runtime nodes are created\n  const skins = components.skins;\n  const runtimeSkins = sceneGraph._runtimeSkins;\n\n  const skinsLength = skins.length;\n  for (let i = 0; i < skinsLength; i++) {\n    const skin = skins[i];\n    runtimeSkins.push(\n      new ModelSkin({\n        skin: skin,\n        sceneGraph: sceneGraph,\n      }),\n    );\n  }\n\n  const skinnedNodes = sceneGraph._skinnedNodes;\n  const skinnedNodesLength = skinnedNodes.length;\n  for (let i = 0; i < skinnedNodesLength; i++) {\n    const skinnedNodeIndex = skinnedNodes[i];\n    const skinnedNode = sceneGraph._runtimeNodes[skinnedNodeIndex];\n\n    // Use the index of the skin in the model components to find\n    // the corresponding runtime skin.\n    const skin = nodes[skinnedNodeIndex].skin;\n    const skinIndex = skin.index;\n\n    skinnedNode._runtimeSkin = runtimeSkins[skinIndex];\n    skinnedNode.updateJointMatrices();\n  }\n\n  // Ensure articulations are applied with their initial values to their target nodes.\n  sceneGraph.applyArticulations();\n}\n\nfunction computeModelMatrix(sceneGraph, modelMatrix) {\n  const components = sceneGraph._components;\n  const model = sceneGraph._model;\n\n  sceneGraph._computedModelMatrix = Matrix4.multiplyTransformation(\n    modelMatrix,\n    components.transform,\n    sceneGraph._computedModelMatrix,\n  );\n\n  sceneGraph._computedModelMatrix = Matrix4.multiplyTransformation(\n    sceneGraph._computedModelMatrix,\n    sceneGraph._axisCorrectionMatrix,\n    sceneGraph._computedModelMatrix,\n  );\n\n  sceneGraph._computedModelMatrix = Matrix4.multiplyByUniformScale(\n    sceneGraph._computedModelMatrix,\n    model.computedScale,\n    sceneGraph._computedModelMatrix,\n  );\n}\n\nconst scratchComputedTranslation = new Cartesian3();\n\nfunction computeModelMatrix2D(sceneGraph, frameState) {\n  const computedModelMatrix = sceneGraph._computedModelMatrix;\n  const translation = Matrix4.getTranslation(\n    computedModelMatrix,\n    scratchComputedTranslation,\n  );\n\n  if (!Cartesian3.equals(translation, Cartesian3.ZERO)) {\n    sceneGraph._computedModelMatrix2D = Transforms.basisTo2D(\n      frameState.mapProjection,\n      computedModelMatrix,\n      sceneGraph._computedModelMatrix2D,\n    );\n  } else {\n    const center = sceneGraph.boundingSphere.center;\n    const to2D = Transforms.ellipsoidTo2DModelMatrix(\n      frameState.mapProjection,\n      center,\n      sceneGraph._computedModelMatrix2D,\n    );\n    sceneGraph._computedModelMatrix2D = Matrix4.multiply(\n      to2D,\n      computedModelMatrix,\n      sceneGraph._computedModelMatrix2D,\n    );\n  }\n\n  sceneGraph._boundingSphere2D = BoundingSphere.transform(\n    sceneGraph._boundingSphere,\n    sceneGraph._computedModelMatrix2D,\n    sceneGraph._boundingSphere2D,\n  );\n}\n\n/**\n * Recursively traverse through the nodes in the scene graph to create\n * their runtime versions, using a post-order depth-first traversal.\n *\n * @param {ModelSceneGraph} sceneGraph The scene graph\n * @param {ModelComponents.Node} node The current node\n * @param {Matrix4} transformToRoot The transforms of this node's ancestors.\n * @returns {number} The index of this node in the runtimeNodes array.\n *\n * @private\n */\nfunction traverseAndCreateSceneGraph(sceneGraph, node, transformToRoot) {\n  // The indices of the children of this node in the runtimeNodes array.\n  const childrenIndices = [];\n  const transform = ModelUtility.getNodeTransform(node);\n\n  // Traverse through scene graph.\n  const childrenLength = node.children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const childNode = node.children[i];\n    const childNodeTransformToRoot = Matrix4.multiplyTransformation(\n      transformToRoot,\n      transform,\n      new Matrix4(),\n    );\n\n    const childIndex = traverseAndCreateSceneGraph(\n      sceneGraph,\n      childNode,\n      childNodeTransformToRoot,\n    );\n    childrenIndices.push(childIndex);\n  }\n\n  // Process node and mesh primitives.\n  const runtimeNode = new ModelRuntimeNode({\n    node: node,\n    transform: transform,\n    transformToRoot: transformToRoot,\n    children: childrenIndices,\n    sceneGraph: sceneGraph,\n  });\n\n  const primitivesLength = node.primitives.length;\n  for (let i = 0; i < primitivesLength; i++) {\n    runtimeNode.runtimePrimitives.push(\n      new ModelRuntimePrimitive({\n        primitive: node.primitives[i],\n        node: node,\n        model: sceneGraph._model,\n      }),\n    );\n  }\n\n  const index = node.index;\n  sceneGraph._runtimeNodes[index] = runtimeNode;\n  if (defined(node.skin)) {\n    sceneGraph._skinnedNodes.push(index);\n  }\n\n  // Create and store the public version of the runtime node.\n  const name = node.name;\n  if (defined(name)) {\n    const model = sceneGraph._model;\n    const publicNode = new ModelNode(model, runtimeNode);\n    model._nodesByName[name] = publicNode;\n  }\n\n  return index;\n}\n\nconst scratchModelPositionMin = new Cartesian3();\nconst scratchModelPositionMax = new Cartesian3();\nconst scratchPrimitivePositionMin = new Cartesian3();\nconst scratchPrimitivePositionMax = new Cartesian3();\n/**\n * Generates the {@link ModelDrawCommand} for each primitive in the model.\n * If the model is used for classification, a {@link ClassificationModelDrawCommand}\n * is generated for each primitive instead.\n *\n * @param {FrameState} frameState The current frame state. This is needed to\n * allocate GPU resources as needed.\n *\n * @private\n */\nModelSceneGraph.prototype.buildDrawCommands = function (frameState) {\n  const model = this._model;\n  const modelRenderResources = new ModelRenderResources(model);\n\n  // Reset the memory counts before running the pipeline\n  model.statistics.clear();\n\n  this.configurePipeline(frameState);\n  const modelPipelineStages = this.modelPipelineStages;\n\n  let i, j, k;\n  for (i = 0; i < modelPipelineStages.length; i++) {\n    const modelPipelineStage = modelPipelineStages[i];\n    modelPipelineStage.process(modelRenderResources, model, frameState);\n  }\n\n  const modelPositionMin = Cartesian3.fromElements(\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    scratchModelPositionMin,\n  );\n  const modelPositionMax = Cartesian3.fromElements(\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    scratchModelPositionMax,\n  );\n\n  for (i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    // If a node in the model was unreachable from the scene graph, there will\n    // be no corresponding runtime node and therefore should be skipped.\n    if (!defined(runtimeNode)) {\n      continue;\n    }\n\n    runtimeNode.configurePipeline();\n    const nodePipelineStages = runtimeNode.pipelineStages;\n\n    const nodeRenderResources = new NodeRenderResources(\n      modelRenderResources,\n      runtimeNode,\n    );\n\n    for (j = 0; j < nodePipelineStages.length; j++) {\n      const nodePipelineStage = nodePipelineStages[j];\n\n      nodePipelineStage.process(\n        nodeRenderResources,\n        runtimeNode.node,\n        frameState,\n      );\n    }\n\n    const nodeTransform = runtimeNode.computedTransform;\n    for (j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n\n      runtimePrimitive.configurePipeline(frameState);\n      const primitivePipelineStages = runtimePrimitive.pipelineStages;\n\n      const primitiveRenderResources = new PrimitiveRenderResources(\n        nodeRenderResources,\n        runtimePrimitive,\n      );\n\n      for (k = 0; k < primitivePipelineStages.length; k++) {\n        const primitivePipelineStage = primitivePipelineStages[k];\n\n        primitivePipelineStage.process(\n          primitiveRenderResources,\n          runtimePrimitive.primitive,\n          frameState,\n        );\n      }\n\n      runtimePrimitive.boundingSphere = BoundingSphere.clone(\n        primitiveRenderResources.boundingSphere,\n        new BoundingSphere(),\n      );\n\n      const primitivePositionMin = Matrix4.multiplyByPoint(\n        nodeTransform,\n        primitiveRenderResources.positionMin,\n        scratchPrimitivePositionMin,\n      );\n      const primitivePositionMax = Matrix4.multiplyByPoint(\n        nodeTransform,\n        primitiveRenderResources.positionMax,\n        scratchPrimitivePositionMax,\n      );\n\n      Cartesian3.minimumByComponent(\n        modelPositionMin,\n        primitivePositionMin,\n        modelPositionMin,\n      );\n      Cartesian3.maximumByComponent(\n        modelPositionMax,\n        primitivePositionMax,\n        modelPositionMax,\n      );\n\n      const drawCommand = ModelDrawCommands.buildModelDrawCommand(\n        primitiveRenderResources,\n        frameState,\n      );\n      runtimePrimitive.drawCommand = drawCommand;\n    }\n  }\n\n  this._boundingSphere = BoundingSphere.fromCornerPoints(\n    modelPositionMin,\n    modelPositionMax,\n    new BoundingSphere(),\n  );\n\n  this._boundingSphere = BoundingSphere.transformWithoutScale(\n    this._boundingSphere,\n    this._axisCorrectionMatrix,\n    this._boundingSphere,\n  );\n\n  this._boundingSphere = BoundingSphere.transform(\n    this._boundingSphere,\n    this._components.transform,\n    this._boundingSphere,\n  );\n\n  model._boundingSphere = BoundingSphere.transform(\n    this._boundingSphere,\n    model.modelMatrix,\n    model._boundingSphere,\n  );\n\n  model._initialRadius = model._boundingSphere.radius;\n  model._boundingSphere.radius *= model._clampedScale;\n};\n\n/**\n * Configure the model pipeline stages. If the pipeline needs to be re-run, call\n * this method again to ensure the correct sequence of pipeline stages are\n * used.\n *\n * @param {FrameState} frameState\n * @private\n */\nModelSceneGraph.prototype.configurePipeline = function (frameState) {\n  const modelPipelineStages = this.modelPipelineStages;\n  modelPipelineStages.length = 0;\n\n  const model = this._model;\n  const fogRenderable = frameState.fog.enabled && frameState.fog.renderable;\n\n  if (defined(model.color)) {\n    modelPipelineStages.push(ModelColorPipelineStage);\n  }\n\n  // Skip these pipeline stages for classification models.\n  if (defined(model.classificationType)) {\n    return;\n  }\n\n  if (model.imageBasedLighting.enabled) {\n    modelPipelineStages.push(ImageBasedLightingPipelineStage);\n  }\n\n  if (model.isClippingEnabled()) {\n    modelPipelineStages.push(ModelClippingPlanesPipelineStage);\n  }\n\n  if (model.isClippingPolygonsEnabled()) {\n    modelPipelineStages.push(ModelClippingPolygonsPipelineStage);\n  }\n\n  if (model.hasSilhouette(frameState)) {\n    modelPipelineStages.push(ModelSilhouettePipelineStage);\n  }\n\n  if (\n    defined(model.splitDirection) &&\n    model.splitDirection !== SplitDirection.NONE\n  ) {\n    modelPipelineStages.push(ModelSplitterPipelineStage);\n  }\n\n  if (ModelType.is3DTiles(model.type)) {\n    modelPipelineStages.push(TilesetPipelineStage);\n  }\n\n  if (fogRenderable) {\n    modelPipelineStages.push(AtmospherePipelineStage);\n  }\n};\n\nModelSceneGraph.prototype.update = function (frameState, updateForAnimations) {\n  let i, j, k;\n\n  for (i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    // If a node in the model was unreachable from the scene graph, there will\n    // be no corresponding runtime node and therefore should be skipped.\n    if (!defined(runtimeNode)) {\n      continue;\n    }\n\n    for (j = 0; j < runtimeNode.updateStages.length; j++) {\n      const nodeUpdateStage = runtimeNode.updateStages[j];\n      nodeUpdateStage.update(runtimeNode, this, frameState);\n    }\n\n    const disableAnimations =\n      frameState.mode !== SceneMode.SCENE3D && this._model._projectTo2D;\n    if (updateForAnimations && !disableAnimations) {\n      this.updateJointMatrices();\n    }\n\n    for (j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n      for (k = 0; k < runtimePrimitive.updateStages.length; k++) {\n        const stage = runtimePrimitive.updateStages[k];\n        stage.update(runtimePrimitive, this);\n      }\n    }\n  }\n};\n\nModelSceneGraph.prototype.updateModelMatrix = function (\n  modelMatrix,\n  frameState,\n) {\n  computeModelMatrix(this, modelMatrix);\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    computeModelMatrix2D(this, frameState);\n  }\n\n  // Mark all root nodes as dirty. Any and all children will be\n  // affected recursively in the update stage.\n  const rootNodes = this._rootNodes;\n  for (let i = 0; i < rootNodes.length; i++) {\n    const node = this._runtimeNodes[rootNodes[i]];\n    node._transformDirty = true;\n  }\n};\n\n/**\n * Updates the joint matrices for the skins and nodes of the model.\n *\n * @private\n */\nModelSceneGraph.prototype.updateJointMatrices = function () {\n  const skinnedNodes = this._skinnedNodes;\n  const length = skinnedNodes.length;\n\n  for (let i = 0; i < length; i++) {\n    const nodeIndex = skinnedNodes[i];\n    const runtimeNode = this._runtimeNodes[nodeIndex];\n    runtimeNode.updateJointMatrices();\n  }\n};\n\n/**\n * A callback to be applied once at each runtime primitive in the\n * scene graph\n * @callback traverseSceneGraphCallback\n *\n * @param {ModelRuntimePrimitive} runtimePrimitive The runtime primitive for the current step of the traversal\n * @param {object} [options] A dictionary of additional options to be passed to the callback, or undefined if the callback does not need any additional information.\n *\n * @private\n */\n\n/**\n * Recursively traverse through the runtime nodes in the scene graph\n * using a post-order depth-first traversal to perform a callback on\n * their runtime primitives.\n *\n * @param {ModelSceneGraph} sceneGraph The scene graph.\n * @param {ModelRuntimeNode} runtimeNode The current runtime node.\n * @param {boolean} visibleNodesOnly Whether to only traverse nodes that are visible.\n * @param {traverseSceneGraphCallback} callback The callback to perform on the runtime primitives of the node.\n * @param {object} [callbackOptions] A dictionary of additional options to be passed to the callback, if needed.\n *\n * @private\n */\nfunction traverseSceneGraph(\n  sceneGraph,\n  runtimeNode,\n  visibleNodesOnly,\n  callback,\n  callbackOptions,\n) {\n  if (visibleNodesOnly && !runtimeNode.show) {\n    return;\n  }\n\n  const childrenLength = runtimeNode.children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const childRuntimeNode = runtimeNode.getChild(i);\n    traverseSceneGraph(\n      sceneGraph,\n      childRuntimeNode,\n      visibleNodesOnly,\n      callback,\n      callbackOptions,\n    );\n  }\n\n  const runtimePrimitives = runtimeNode.runtimePrimitives;\n  const runtimePrimitivesLength = runtimePrimitives.length;\n  for (let j = 0; j < runtimePrimitivesLength; j++) {\n    const runtimePrimitive = runtimePrimitives[j];\n    callback(runtimePrimitive, callbackOptions);\n  }\n}\n\nfunction forEachRuntimePrimitive(\n  sceneGraph,\n  visibleNodesOnly,\n  callback,\n  callbackOptions,\n) {\n  const rootNodes = sceneGraph._rootNodes;\n  const rootNodesLength = rootNodes.length;\n  for (let i = 0; i < rootNodesLength; i++) {\n    const rootNodeIndex = rootNodes[i];\n    const runtimeNode = sceneGraph._runtimeNodes[rootNodeIndex];\n    traverseSceneGraph(\n      sceneGraph,\n      runtimeNode,\n      visibleNodesOnly,\n      callback,\n      callbackOptions,\n    );\n  }\n}\n\nconst scratchBackFaceCullingOptions = {\n  backFaceCulling: undefined,\n};\n\n/**\n * Traverses through all draw commands and changes the back-face culling setting.\n *\n * @param {boolean} backFaceCulling The new value for the back-face culling setting.\n *\n * @private\n */\nModelSceneGraph.prototype.updateBackFaceCulling = function (backFaceCulling) {\n  const backFaceCullingOptions = scratchBackFaceCullingOptions;\n  backFaceCullingOptions.backFaceCulling = backFaceCulling;\n  forEachRuntimePrimitive(\n    this,\n    false,\n    updatePrimitiveBackFaceCulling,\n    backFaceCullingOptions,\n  );\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction updatePrimitiveBackFaceCulling(runtimePrimitive, options) {\n  const drawCommand = runtimePrimitive.drawCommand;\n  drawCommand.backFaceCulling = options.backFaceCulling;\n}\n\nconst scratchShadowOptions = {\n  shadowMode: undefined,\n};\n\n/**\n * Traverses through all draw commands and changes the shadow settings.\n *\n * @param {ShadowMode} shadowMode The new shadow settings.\n *\n * @private\n */\nModelSceneGraph.prototype.updateShadows = function (shadowMode) {\n  const shadowOptions = scratchShadowOptions;\n  shadowOptions.shadowMode = shadowMode;\n  forEachRuntimePrimitive(this, false, updatePrimitiveShadows, shadowOptions);\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction updatePrimitiveShadows(runtimePrimitive, options) {\n  const drawCommand = runtimePrimitive.drawCommand;\n  drawCommand.shadows = options.shadowMode;\n}\n\nconst scratchShowBoundingVolumeOptions = {\n  debugShowBoundingVolume: undefined,\n};\n\n/**\n * Traverses through all draw commands and changes whether to show the debug bounding volume.\n *\n * @param {boolean} debugShowBoundingVolume The new value for showing the debug bounding volume.\n *\n * @private\n */\nModelSceneGraph.prototype.updateShowBoundingVolume = function (\n  debugShowBoundingVolume,\n) {\n  const showBoundingVolumeOptions = scratchShowBoundingVolumeOptions;\n  showBoundingVolumeOptions.debugShowBoundingVolume = debugShowBoundingVolume;\n\n  forEachRuntimePrimitive(\n    this,\n    false,\n    updatePrimitiveShowBoundingVolume,\n    showBoundingVolumeOptions,\n  );\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction updatePrimitiveShowBoundingVolume(runtimePrimitive, options) {\n  const drawCommand = runtimePrimitive.drawCommand;\n  drawCommand.debugShowBoundingVolume = options.debugShowBoundingVolume;\n}\n\nconst scratchSilhouetteCommands = [];\nconst scratchPushDrawCommandOptions = {\n  frameState: undefined,\n  hasSilhouette: undefined,\n};\n\n/**\n * Traverses through the scene graph and pushes the draw commands associated\n * with each primitive to the frame state's command list.\n *\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nModelSceneGraph.prototype.pushDrawCommands = function (frameState) {\n  // If a model has silhouettes, the commands that draw the silhouettes for\n  // each primitive can only be invoked after the entire model has drawn.\n  // Otherwise, the silhouette may draw on top of the model. This requires\n  // gathering the original commands and the silhouette commands separately.\n  const silhouetteCommands = scratchSilhouetteCommands;\n  silhouetteCommands.length = 0;\n\n  // Since this function is called each frame, the options object is\n  // preallocated in a scratch variable\n  const pushDrawCommandOptions = scratchPushDrawCommandOptions;\n  pushDrawCommandOptions.hasSilhouette = this._model.hasSilhouette(frameState);\n  pushDrawCommandOptions.frameState = frameState;\n\n  forEachRuntimePrimitive(\n    this,\n    true,\n    pushPrimitiveDrawCommands,\n    pushDrawCommandOptions,\n  );\n\n  frameState.commandList.push.apply(frameState.commandList, silhouetteCommands);\n};\n\n// Callback is defined here to avoid allocating a closure in the render loop\nfunction pushPrimitiveDrawCommands(runtimePrimitive, options) {\n  const frameState = options.frameState;\n  const hasSilhouette = options.hasSilhouette;\n\n  const passes = frameState.passes;\n  const silhouetteCommands = scratchSilhouetteCommands;\n  const primitiveDrawCommand = runtimePrimitive.drawCommand;\n  primitiveDrawCommand.pushCommands(frameState, frameState.commandList);\n\n  // If a model has silhouettes, the commands that draw the silhouettes for\n  // each primitive can only be invoked after the entire model has drawn.\n  // Otherwise, the silhouette may draw on top of the model. This requires\n  // gathering the original commands and the silhouette commands separately.\n  if (hasSilhouette && !passes.pick) {\n    primitiveDrawCommand.pushSilhouetteCommands(frameState, silhouetteCommands);\n  }\n}\n\n/**\n * Sets the current value of an articulation stage.\n *\n * @param {string} articulationStageKey The name of the articulation, a space, and the name of the stage.\n * @param {number} value The numeric value of this stage of the articulation.\n *\n * @private\n */\nModelSceneGraph.prototype.setArticulationStage = function (\n  articulationStageKey,\n  value,\n) {\n  const names = articulationStageKey.split(\" \");\n  if (names.length !== 2) {\n    return;\n  }\n\n  const articulationName = names[0];\n  const stageName = names[1];\n\n  const runtimeArticulation = this._runtimeArticulations[articulationName];\n  if (defined(runtimeArticulation)) {\n    runtimeArticulation.setArticulationStage(stageName, value);\n  }\n};\n\n/**\n * Applies any modified articulation stages to the matrix of each node that participates\n * in any articulation.  Note that this will overwrite any nodeTransformations on participating nodes.\n *\n * @private\n */\nModelSceneGraph.prototype.applyArticulations = function () {\n  const runtimeArticulations = this._runtimeArticulations;\n  for (const articulationName in runtimeArticulations) {\n    if (runtimeArticulations.hasOwnProperty(articulationName)) {\n      const articulation = runtimeArticulations[articulationName];\n      articulation.apply();\n    }\n  }\n};\n\nexport default ModelSceneGraph;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}