{"ast":null,"code":"import buildVoxelDrawCommands from \"./buildVoxelDrawCommands.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport Material from \"./Material.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport PolylineCollection from \"./PolylineCollection.js\";\nimport VoxelShapeType from \"./VoxelShapeType.js\";\nimport VoxelTraversal from \"./VoxelTraversal.js\";\nimport CustomShader from \"./Model/CustomShader.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport VerticalExaggeration from \"../Core/VerticalExaggeration.js\";\n\n/**\n * A primitive that renders voxel data from a {@link VoxelProvider}.\n *\n * @alias VoxelPrimitive\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {VoxelProvider} [options.provider] The voxel provider that supplies the primitive with tile data.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The model matrix used to transform the primitive.\n * @param {CustomShader} [options.customShader] The custom shader used to style the primitive.\n * @param {Clock} [options.clock] The clock used to control time dynamic behavior.\n *\n * @see VoxelProvider\n * @see Cesium3DTilesVoxelProvider\n * @see VoxelShapeType\n *\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction VoxelPrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._ready = false;\n\n  /**\n   * @type {VoxelProvider}\n   * @private\n   */\n  this._provider = defaultValue(options.provider, VoxelPrimitive.DefaultProvider);\n\n  /**\n   * This member is not created until the provider and shape are ready.\n   *\n   * @type {VoxelTraversal}\n   * @private\n   */\n  this._traversal = undefined;\n\n  /**\n   * This member is not created until the provider is ready.\n   *\n   * @type {VoxelShape}\n   * @private\n   */\n  this._shape = undefined;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._shapeVisible = false;\n\n  /**\n   * This member is not created until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._paddingBefore = new Cartesian3();\n\n  /**\n   * This member is not created until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._paddingAfter = new Cartesian3();\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the shape is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minBoundsOld = new Cartesian3();\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the shape is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxBoundsOld = new Cartesian3();\n\n  /**\n   * Minimum bounds with vertical exaggeration applied\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._exaggeratedMinBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the shape is dirty.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._exaggeratedMinBoundsOld = new Cartesian3();\n\n  /**\n   * Maximum bounds with vertical exaggeration applied\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._exaggeratedMaxBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the shape is dirty.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._exaggeratedMaxBoundsOld = new Cartesian3();\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minClippingBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the clipping is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minClippingBoundsOld = new Cartesian3();\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxClippingBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the clipping is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxClippingBoundsOld = new Cartesian3();\n\n  /**\n   * Clipping planes on the primitive\n   *\n   * @type {ClippingPlaneCollection}\n   * @private\n   */\n  this._clippingPlanes = undefined;\n\n  /**\n   * Keeps track of when the clipping planes change\n   *\n   * @type {number}\n   * @private\n   */\n  this._clippingPlanesState = 0;\n\n  /**\n   * Keeps track of when the clipping planes are enabled / disabled\n   *\n   * @type {boolean}\n   * @private\n   */\n  this._clippingPlanesEnabled = false;\n\n  /**\n   * The primitive's model matrix.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this._modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n\n  /**\n   * Model matrix with vertical exaggeration applied. Only used for BOX shape type.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this._exaggeratedModelMatrix = Matrix4.clone(this._modelMatrix);\n\n  /**\n   * The primitive's model matrix multiplied by the provider's model matrix.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this._compoundModelMatrix = new Matrix4();\n\n  /**\n   * Used to detect if the shape is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this._compoundModelMatrixOld = new Matrix4();\n\n  /**\n   * @type {CustomShader}\n   * @private\n   */\n  this._customShader = defaultValue(options.customShader, VoxelPrimitive.DefaultCustomShader);\n\n  /**\n   * @type {Event}\n   * @private\n   */\n  this._customShaderCompilationEvent = new Event();\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._shaderDirty = true;\n\n  /**\n   * @type {DrawCommand}\n   * @private\n   */\n  this._drawCommand = undefined;\n\n  /**\n   * @type {DrawCommand}\n   * @private\n   */\n  this._drawCommandPick = undefined;\n\n  /**\n   * @type {object}\n   * @private\n   */\n  this._pickId = undefined;\n\n  /**\n   * @type {Clock}\n   * @private\n   */\n  this._clock = options.clock;\n\n  // Transforms and other values that are computed when the shape changes\n\n  /**\n   * @type {Matrix4}\n   * @private\n   */\n  this._transformPositionWorldToUv = new Matrix4();\n\n  /**\n   * @type {Matrix4}\n   * @private\n   */\n  this._transformPositionUvToWorld = new Matrix4();\n\n  /**\n   * @type {Matrix3}\n   * @private\n   */\n  this._transformDirectionWorldToLocal = new Matrix3();\n\n  /**\n   * @type {Matrix3}\n   * @private\n   */\n  this._transformNormalLocalToWorld = new Matrix3();\n\n  // Rendering\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._nearestSampling = false;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._levelBlendFactor = 0.0;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._stepSizeMultiplier = 1.0;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._depthTest = true;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._useLogDepth = undefined;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._screenSpaceError = 4.0; // in pixels\n\n  // Debug / statistics\n  /**\n   * @type {PolylineCollection}\n   * @private\n   */\n  this._debugPolylines = new PolylineCollection();\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._debugDraw = false;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._disableRender = false;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._disableUpdate = false;\n\n  /**\n   * @type {Object<string, any>}\n   * @private\n   */\n  this._uniforms = {\n    octreeInternalNodeTexture: undefined,\n    octreeInternalNodeTilesPerRow: 0,\n    octreeInternalNodeTexelSizeUv: new Cartesian2(),\n    octreeLeafNodeTexture: undefined,\n    octreeLeafNodeTilesPerRow: 0,\n    octreeLeafNodeTexelSizeUv: new Cartesian2(),\n    megatextureTextures: [],\n    megatextureSliceDimensions: new Cartesian2(),\n    megatextureTileDimensions: new Cartesian2(),\n    megatextureVoxelSizeUv: new Cartesian2(),\n    megatextureSliceSizeUv: new Cartesian2(),\n    megatextureTileSizeUv: new Cartesian2(),\n    dimensions: new Cartesian3(),\n    paddingBefore: new Cartesian3(),\n    paddingAfter: new Cartesian3(),\n    transformPositionViewToUv: new Matrix4(),\n    transformPositionUvToView: new Matrix4(),\n    transformDirectionViewToLocal: new Matrix3(),\n    transformNormalLocalToWorld: new Matrix3(),\n    cameraPositionUv: new Cartesian3(),\n    ndcSpaceAxisAlignedBoundingBox: new Cartesian4(),\n    clippingPlanesTexture: undefined,\n    clippingPlanesMatrix: new Matrix4(),\n    stepSize: 0,\n    pickColor: new Color()\n  };\n\n  /**\n   * Shape specific shader defines from the previous shape update. Used to detect if the shader needs to be rebuilt.\n   * @type {Object<string, any>}\n   * @private\n   */\n  this._shapeDefinesOld = {};\n\n  /**\n   * Map uniform names to functions that return the uniform values.\n   * @type {Object<string, function():any>}\n   * @private\n   */\n  this._uniformMap = {};\n  const uniforms = this._uniforms;\n  const uniformMap = this._uniformMap;\n  for (const key in uniforms) {\n    if (uniforms.hasOwnProperty(key)) {\n      const name = `u_${key}`;\n      uniformMap[name] = function () {\n        return uniforms[key];\n      };\n    }\n  }\n\n  // If the provider fails to initialize the primitive will fail too.\n  const provider = this._provider;\n  initialize(this, provider);\n}\nfunction initialize(primitive, provider) {\n  // Set the bounds\n  const {\n    shape: shapeType,\n    minBounds = VoxelShapeType.getMinBounds(shapeType),\n    maxBounds = VoxelShapeType.getMaxBounds(shapeType)\n  } = provider;\n  primitive.minBounds = minBounds;\n  primitive.maxBounds = maxBounds;\n  primitive.minClippingBounds = VoxelShapeType.getMinBounds(shapeType);\n  primitive.maxClippingBounds = VoxelShapeType.getMaxBounds(shapeType);\n\n  // Initialize the exaggerated versions of bounds and model matrix\n  primitive._exaggeratedMinBounds = Cartesian3.clone(primitive._minBounds, primitive._exaggeratedMinBounds);\n  primitive._exaggeratedMaxBounds = Cartesian3.clone(primitive._maxBounds, primitive._exaggeratedMaxBounds);\n  primitive._exaggeratedModelMatrix = Matrix4.clone(primitive._modelMatrix, primitive._exaggeratedModelMatrix);\n  checkTransformAndBounds(primitive, provider);\n\n  // Create the shape object, and update it so it is valid for VoxelTraversal\n  const ShapeConstructor = VoxelShapeType.getShapeConstructor(shapeType);\n  primitive._shape = new ShapeConstructor();\n  primitive._shapeVisible = updateShapeAndTransforms(primitive, primitive._shape, provider);\n}\nObject.defineProperties(VoxelPrimitive.prototype, {\n  /**\n   * Gets a value indicating whether or not the primitive is ready for use.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n  /**\n   * Gets the {@link VoxelProvider} associated with this primitive.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {VoxelProvider}\n   * @readonly\n   */\n  provider: {\n    get: function () {\n      return this._provider;\n    }\n  },\n  /**\n   * Gets the bounding sphere.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._shape.boundingSphere;\n    }\n  },\n  /**\n   * Gets the oriented bounding box.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {OrientedBoundingBox}\n   * @readonly\n   */\n  orientedBoundingBox: {\n    get: function () {\n      return this._shape.orientedBoundingBox;\n    }\n  },\n  /**\n   * Gets the model matrix.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  modelMatrix: {\n    get: function () {\n      return this._modelMatrix;\n    },\n    set: function (modelMatrix) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"modelMatrix\", modelMatrix);\n      //>>includeEnd('debug');\n\n      this._modelMatrix = Matrix4.clone(modelMatrix, this._modelMatrix);\n    }\n  },\n  /**\n   * Gets the shape type.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {VoxelShapeType}\n   * @readonly\n   */\n  shape: {\n    get: function () {\n      return this._provider.shape;\n    }\n  },\n  /**\n   * Gets the voxel dimensions.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  dimensions: {\n    get: function () {\n      return this._provider.dimensions;\n    }\n  },\n  /**\n   * Gets the minimum value per channel of the voxel data.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number[][]}\n   * @readonly\n   */\n  minimumValues: {\n    get: function () {\n      return this._provider.minimumValues;\n    }\n  },\n  /**\n   * Gets the maximum value per channel of the voxel data.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number[][]}\n   * @readonly\n   */\n  maximumValues: {\n    get: function () {\n      return this._provider.maximumValues;\n    }\n  },\n  /**\n   * Gets or sets whether or not this primitive should be displayed.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return !this._disableRender;\n    },\n    set: function (show) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"show\", show);\n      //>>includeEnd('debug');\n\n      this._disableRender = !show;\n    }\n  },\n  /**\n   * Gets or sets whether or not the primitive should update when the view changes.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  disableUpdate: {\n    get: function () {\n      return this._disableUpdate;\n    },\n    set: function (disableUpdate) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"disableUpdate\", disableUpdate);\n      //>>includeEnd('debug');\n\n      this._disableUpdate = disableUpdate;\n    }\n  },\n  /**\n   * Gets or sets whether or not to render debug visualizations.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  debugDraw: {\n    get: function () {\n      return this._debugDraw;\n    },\n    set: function (debugDraw) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"debugDraw\", debugDraw);\n      //>>includeEnd('debug');\n\n      this._debugDraw = debugDraw;\n    }\n  },\n  /**\n   * Gets or sets whether or not to test against depth when rendering.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  depthTest: {\n    get: function () {\n      return this._depthTest;\n    },\n    set: function (depthTest) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"depthTest\", depthTest);\n      //>>includeEnd('debug');\n\n      if (this._depthTest !== depthTest) {\n        this._depthTest = depthTest;\n        this._shaderDirty = true;\n      }\n    }\n  },\n  /**\n   * Gets or sets the nearest sampling.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  nearestSampling: {\n    get: function () {\n      return this._nearestSampling;\n    },\n    set: function (nearestSampling) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"nearestSampling\", nearestSampling);\n      //>>includeEnd('debug');\n\n      if (this._nearestSampling !== nearestSampling) {\n        this._nearestSampling = nearestSampling;\n        this._shaderDirty = true;\n      }\n    }\n  },\n  /**\n   * Controls how quickly to blend between different levels of the tree.\n   * 0.0 means an instantaneous pop.\n   * 1.0 means a full linear blend.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number}\n   * @private\n   */\n  levelBlendFactor: {\n    get: function () {\n      return this._levelBlendFactor;\n    },\n    set: function (levelBlendFactor) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"levelBlendFactor\", levelBlendFactor);\n      //>>includeEnd('debug');\n\n      this._levelBlendFactor = CesiumMath.clamp(levelBlendFactor, 0.0, 1.0);\n    }\n  },\n  /**\n   * Gets or sets the screen space error in pixels. If the screen space size\n   * of a voxel is greater than the screen space error, the tile is subdivided.\n   * Lower screen space error corresponds with higher detail rendering, but could\n   * result in worse performance and higher memory consumption.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number}\n   */\n  screenSpaceError: {\n    get: function () {\n      return this._screenSpaceError;\n    },\n    set: function (screenSpaceError) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"screenSpaceError\", screenSpaceError);\n      //>>includeEnd('debug');\n\n      this._screenSpaceError = screenSpaceError;\n    }\n  },\n  /**\n   * Gets or sets the step size multiplier used during raymarching.\n   * The lower the value, the higher the rendering quality, but\n   * also the worse the performance.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number}\n   */\n  stepSize: {\n    get: function () {\n      return this._stepSizeMultiplier;\n    },\n    set: function (stepSize) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"stepSize\", stepSize);\n      //>>includeEnd('debug');\n\n      this._stepSizeMultiplier = stepSize;\n    }\n  },\n  /**\n   * Gets or sets the minimum bounds in the shape's local coordinate system.\n   * Voxel data is stretched or squashed to fit the bounds.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  minBounds: {\n    get: function () {\n      return this._minBounds;\n    },\n    set: function (minBounds) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"minBounds\", minBounds);\n      //>>includeEnd('debug');\n\n      this._minBounds = Cartesian3.clone(minBounds, this._minBounds);\n    }\n  },\n  /**\n   * Gets or sets the maximum bounds in the shape's local coordinate system.\n   * Voxel data is stretched or squashed to fit the bounds.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  maxBounds: {\n    get: function () {\n      return this._maxBounds;\n    },\n    set: function (maxBounds) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"maxBounds\", maxBounds);\n      //>>includeEnd('debug');\n\n      this._maxBounds = Cartesian3.clone(maxBounds, this._maxBounds);\n    }\n  },\n  /**\n   * Gets or sets the minimum clipping location in the shape's local coordinate system.\n   * Any voxel content outside the range is clipped.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  minClippingBounds: {\n    get: function () {\n      return this._minClippingBounds;\n    },\n    set: function (minClippingBounds) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"minClippingBounds\", minClippingBounds);\n      //>>includeEnd('debug');\n\n      this._minClippingBounds = Cartesian3.clone(minClippingBounds, this._minClippingBounds);\n    }\n  },\n  /**\n   * Gets or sets the maximum clipping location in the shape's local coordinate system.\n   * Any voxel content outside the range is clipped.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  maxClippingBounds: {\n    get: function () {\n      return this._maxClippingBounds;\n    },\n    set: function (maxClippingBounds) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"maxClippingBounds\", maxClippingBounds);\n      //>>includeEnd('debug');\n\n      this._maxClippingBounds = Cartesian3.clone(maxClippingBounds, this._maxClippingBounds);\n    }\n  },\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the primitive.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (clippingPlanes) {\n      // Don't need to check if undefined, it's handled in the setOwner function\n      ClippingPlaneCollection.setOwner(clippingPlanes, this, \"_clippingPlanes\");\n    }\n  },\n  /**\n   * Gets or sets the custom shader. If undefined, {@link VoxelPrimitive.DefaultCustomShader} is set.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {CustomShader}\n   */\n  customShader: {\n    get: function () {\n      return this._customShader;\n    },\n    set: function (customShader) {\n      if (this._customShader !== customShader) {\n        // Delete old custom shader entries from the uniform map\n        const uniformMap = this._uniformMap;\n        const oldCustomShader = this._customShader;\n        const oldCustomShaderUniformMap = oldCustomShader.uniformMap;\n        for (const uniformName in oldCustomShaderUniformMap) {\n          if (oldCustomShaderUniformMap.hasOwnProperty(uniformName)) {\n            // If the custom shader was set but the voxel shader was never\n            // built, the custom shader uniforms wouldn't have been added to\n            // the uniform map. But it doesn't matter because the delete\n            // operator ignores if the key doesn't exist.\n            delete uniformMap[uniformName];\n          }\n        }\n        if (!defined(customShader)) {\n          this._customShader = VoxelPrimitive.DefaultCustomShader;\n        } else {\n          this._customShader = customShader;\n        }\n        this._shaderDirty = true;\n      }\n    }\n  },\n  /**\n   * Gets an event that is raised whenever a custom shader is compiled.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Event}\n   * @readonly\n   */\n  customShaderCompilationEvent: {\n    get: function () {\n      return this._customShaderCompilationEvent;\n    }\n  }\n});\nconst scratchDimensions = new Cartesian3();\nconst scratchIntersect = new Cartesian4();\nconst scratchNdcAabb = new Cartesian4();\nconst scratchScale = new Cartesian3();\nconst scratchLocalScale = new Cartesian3();\nconst scratchRotation = new Matrix3();\nconst scratchRotationAndLocalScale = new Matrix3();\nconst scratchTransformPositionWorldToLocal = new Matrix4();\nconst scratchTransformPositionLocalToWorld = new Matrix4();\nconst scratchTransformPositionLocalToProjection = new Matrix4();\nconst transformPositionLocalToUv = Matrix4.fromRotationTranslation(Matrix3.fromUniformScale(0.5, new Matrix3()), new Cartesian3(0.5, 0.5, 0.5), new Matrix4());\nconst transformPositionUvToLocal = Matrix4.fromRotationTranslation(Matrix3.fromUniformScale(2.0, new Matrix3()), new Cartesian3(-1.0, -1.0, -1.0), new Matrix4());\n\n/**\n * Updates the voxel primitive.\n *\n * @param {FrameState} frameState\n * @private\n */\nVoxelPrimitive.prototype.update = function (frameState) {\n  const provider = this._provider;\n\n  // Update the custom shader in case it has texture uniforms.\n  this._customShader.update(frameState);\n\n  // Initialize from the ready provider. This only happens once.\n  const context = frameState.context;\n  if (!this._ready) {\n    initFromProvider(this, provider, context);\n    // Set the primitive as ready after the first frame render since the user might set up events subscribed to\n    // the post render event, and the primitive may not be ready for those past the first frame.\n    frameState.afterRender.push(() => {\n      this._ready = true;\n      return true;\n    });\n\n    // Don't render until the next frame after ready is set to true\n    return;\n  }\n  updateVerticalExaggeration(this, frameState);\n\n  // Check if the shape is dirty before updating it. This needs to happen every\n  // frame because the member variables can be modified externally via the\n  // getters.\n  const shapeDirty = checkTransformAndBounds(this, provider);\n  const shape = this._shape;\n  if (shapeDirty) {\n    this._shapeVisible = updateShapeAndTransforms(this, shape, provider);\n    if (checkShapeDefines(this, shape)) {\n      this._shaderDirty = true;\n    }\n  }\n  if (!this._shapeVisible) {\n    return;\n  }\n\n  // Update the traversal and prepare for rendering.\n  const keyframeLocation = getKeyframeLocation(provider.timeIntervalCollection, this._clock);\n  const traversal = this._traversal;\n  const sampleCountOld = traversal._sampleCount;\n  traversal.update(frameState, keyframeLocation, shapeDirty,\n  // recomputeBoundingVolumes\n  this._disableUpdate // pauseUpdate\n  );\n  if (sampleCountOld !== traversal._sampleCount) {\n    this._shaderDirty = true;\n  }\n  if (!traversal.isRenderable(traversal.rootNode)) {\n    return;\n  }\n  if (this._debugDraw) {\n    // Debug draw bounding boxes and other things. Must go after traversal update\n    // because that's what updates the tile bounding boxes.\n    debugDraw(this, frameState);\n  }\n  if (this._disableRender) {\n    return;\n  }\n\n  // Check if log depth changed\n  if (this._useLogDepth !== frameState.useLogDepth) {\n    this._useLogDepth = frameState.useLogDepth;\n    this._shaderDirty = true;\n  }\n\n  // Check if clipping planes changed\n  const clippingPlanesChanged = updateClippingPlanes(this, frameState);\n  if (clippingPlanesChanged) {\n    this._shaderDirty = true;\n  }\n  const leafNodeTexture = traversal.leafNodeTexture;\n  const uniforms = this._uniforms;\n  if (defined(leafNodeTexture)) {\n    uniforms.octreeLeafNodeTexture = traversal.leafNodeTexture;\n    uniforms.octreeLeafNodeTexelSizeUv = Cartesian2.clone(traversal.leafNodeTexelSizeUv, uniforms.octreeLeafNodeTexelSizeUv);\n    uniforms.octreeLeafNodeTilesPerRow = traversal.leafNodeTilesPerRow;\n  }\n\n  // Rebuild shaders\n  if (this._shaderDirty) {\n    buildVoxelDrawCommands(this, context);\n    this._shaderDirty = false;\n  }\n\n  // Calculate the NDC-space AABB to \"scissor\" the fullscreen quad\n  const transformPositionWorldToProjection = context.uniformState.viewProjection;\n  const orientedBoundingBox = shape.orientedBoundingBox;\n  const ndcAabb = orientedBoundingBoxToNdcAabb(orientedBoundingBox, transformPositionWorldToProjection, scratchNdcAabb);\n\n  // If the object is offscreen, don't render it.\n  const offscreen = ndcAabb.x === +1.0 || ndcAabb.y === +1.0 || ndcAabb.z === -1.0 || ndcAabb.w === -1.0;\n  if (offscreen) {\n    return;\n  }\n\n  // Prepare to render: update uniforms that can change every frame\n  // Using a uniform instead of going through RenderState's scissor because the viewport is not accessible here, and the scissor command needs pixel coordinates.\n  uniforms.ndcSpaceAxisAlignedBoundingBox = Cartesian4.clone(ndcAabb, uniforms.ndcSpaceAxisAlignedBoundingBox);\n  const transformPositionViewToWorld = context.uniformState.inverseView;\n  uniforms.transformPositionViewToUv = Matrix4.multiplyTransformation(this._transformPositionWorldToUv, transformPositionViewToWorld, uniforms.transformPositionViewToUv);\n  const transformPositionWorldToView = context.uniformState.view;\n  uniforms.transformPositionUvToView = Matrix4.multiplyTransformation(transformPositionWorldToView, this._transformPositionUvToWorld, uniforms.transformPositionUvToView);\n  const transformDirectionViewToWorld = context.uniformState.inverseViewRotation;\n  uniforms.transformDirectionViewToLocal = Matrix3.multiply(this._transformDirectionWorldToLocal, transformDirectionViewToWorld, uniforms.transformDirectionViewToLocal);\n  uniforms.transformNormalLocalToWorld = Matrix3.clone(this._transformNormalLocalToWorld, uniforms.transformNormalLocalToWorld);\n  const cameraPositionWorld = frameState.camera.positionWC;\n  uniforms.cameraPositionUv = Matrix4.multiplyByPoint(this._transformPositionWorldToUv, cameraPositionWorld, uniforms.cameraPositionUv);\n  uniforms.stepSize = this._stepSizeMultiplier;\n\n  // Render the primitive\n  const command = frameState.passes.pick ? this._drawCommandPick : frameState.passes.pickVoxel ? this._drawCommandPickVoxel : this._drawCommand;\n  command.boundingVolume = shape.boundingSphere;\n  frameState.commandList.push(command);\n};\nconst scratchExaggerationScale = new Cartesian3();\nconst scratchExaggerationCenter = new Cartesian3();\nconst scratchCartographicCenter = new Cartographic();\nconst scratchExaggerationTranslation = new Cartesian3();\n\n/**\n * Update the exaggerated bounds of a primitive to account for vertical exaggeration\n * Currently only applies to Ellipsoid shape type\n * @param {VoxelPrimitive} primitive\n * @param {FrameState} frameState\n * @private\n */\nfunction updateVerticalExaggeration(primitive, frameState) {\n  primitive._exaggeratedMinBounds = Cartesian3.clone(primitive._minBounds, primitive._exaggeratedMinBounds);\n  primitive._exaggeratedMaxBounds = Cartesian3.clone(primitive._maxBounds, primitive._exaggeratedMaxBounds);\n  if (primitive.shape === VoxelShapeType.ELLIPSOID) {\n    // Apply the exaggeration by stretching the height bounds\n    const relativeHeight = frameState.verticalExaggerationRelativeHeight;\n    const exaggeration = frameState.verticalExaggeration;\n    primitive._exaggeratedMinBounds.z = (primitive._minBounds.z - relativeHeight) * exaggeration + relativeHeight;\n    primitive._exaggeratedMaxBounds.z = (primitive._maxBounds.z - relativeHeight) * exaggeration + relativeHeight;\n  } else if (primitive.shape === VoxelShapeType.BOX) {\n    // Apply the exaggeration via the model matrix\n    const exaggerationScale = Cartesian3.fromElements(1.0, 1.0, frameState.verticalExaggeration, scratchExaggerationScale);\n    primitive._exaggeratedModelMatrix = Matrix4.multiplyByScale(primitive._modelMatrix, exaggerationScale, primitive._exaggeratedModelMatrix);\n    primitive._exaggeratedModelMatrix = Matrix4.multiplyByTranslation(primitive._exaggeratedModelMatrix, computeBoxExaggerationTranslation(primitive, frameState), primitive._exaggeratedModelMatrix);\n  }\n}\nfunction computeBoxExaggerationTranslation(primitive, frameState) {\n  // Compute translation based on box center, relative height, and exaggeration\n  const {\n    shapeTransform = Matrix4.IDENTITY,\n    globalTransform = Matrix4.IDENTITY\n  } = primitive._provider;\n\n  // Find the Cartesian position of the center of the OBB\n  const initialCenter = Matrix4.getTranslation(shapeTransform, scratchExaggerationCenter);\n  const intermediateCenter = Matrix4.multiplyByPoint(primitive._modelMatrix, initialCenter, scratchExaggerationCenter);\n  const transformedCenter = Matrix4.multiplyByPoint(globalTransform, intermediateCenter, scratchExaggerationCenter);\n\n  // Find the cartographic height\n  const ellipsoid = Ellipsoid.WGS84;\n  const centerCartographic = ellipsoid.cartesianToCartographic(transformedCenter, scratchCartographicCenter);\n  let centerHeight = 0.0;\n  if (defined(centerCartographic)) {\n    centerHeight = centerCartographic.height;\n  }\n\n  // Find the shift that will put the center in the right position relative\n  // to relativeHeight, after it is scaled by verticalExaggeration\n  const exaggeratedHeight = VerticalExaggeration.getHeight(centerHeight, frameState.verticalExaggeration, frameState.verticalExaggerationRelativeHeight);\n  return Cartesian3.fromElements(0.0, 0.0, (exaggeratedHeight - centerHeight) / frameState.verticalExaggeration, scratchExaggerationTranslation);\n}\n\n/**\n * Initialize primitive properties that are derived from the voxel provider\n * @param {VoxelPrimitive} primitive\n * @param {VoxelProvider} provider\n * @param {Context} context\n * @private\n */\nfunction initFromProvider(primitive, provider, context) {\n  const uniforms = primitive._uniforms;\n  primitive._pickId = context.createPickId({\n    primitive\n  });\n  uniforms.pickColor = Color.clone(primitive._pickId.color, uniforms.pickColor);\n  const {\n    shaderDefines,\n    shaderUniforms: shapeUniforms\n  } = primitive._shape;\n  primitive._shapeDefinesOld = clone(shaderDefines, true);\n\n  // Add shape uniforms to the uniform map\n  const uniformMap = primitive._uniformMap;\n  for (const key in shapeUniforms) {\n    if (shapeUniforms.hasOwnProperty(key)) {\n      const name = `u_${key}`;\n\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(uniformMap[name])) {\n        oneTimeWarning(`VoxelPrimitive: Uniform name \"${name}\" is already defined`);\n      }\n      //>>includeEnd('debug');\n\n      uniformMap[name] = function () {\n        return shapeUniforms[key];\n      };\n    }\n  }\n\n  // Set uniforms that come from the provider.\n  // Note that minBounds and maxBounds can be set dynamically, so their uniforms aren't set here.\n  uniforms.dimensions = Cartesian3.clone(provider.dimensions, uniforms.dimensions);\n  primitive._paddingBefore = Cartesian3.clone(defaultValue(provider.paddingBefore, Cartesian3.ZERO), primitive._paddingBefore);\n  uniforms.paddingBefore = Cartesian3.clone(primitive._paddingBefore, uniforms.paddingBefore);\n  primitive._paddingAfter = Cartesian3.clone(defaultValue(provider.paddingAfter, Cartesian3.ZERO), primitive._paddingBefore);\n  uniforms.paddingAfter = Cartesian3.clone(primitive._paddingAfter, uniforms.paddingAfter);\n\n  // Create the VoxelTraversal, and set related uniforms\n  primitive._traversal = setupTraversal(primitive, provider, context);\n  setTraversalUniforms(primitive._traversal, uniforms);\n}\n\n/**\n * Track changes in provider transform and primitive bounds\n * @param {VoxelPrimitive} primitive\n * @param {VoxelProvider} provider\n * @returns {boolean} Whether any of the transform or bounds changed\n * @private\n */\nfunction checkTransformAndBounds(primitive, provider) {\n  const shapeTransform = defaultValue(provider.shapeTransform, Matrix4.IDENTITY);\n  const globalTransform = defaultValue(provider.globalTransform, Matrix4.IDENTITY);\n\n  // Compound model matrix = global transform * model matrix * shape transform\n  Matrix4.multiplyTransformation(globalTransform, primitive._exaggeratedModelMatrix, primitive._compoundModelMatrix);\n  Matrix4.multiplyTransformation(primitive._compoundModelMatrix, shapeTransform, primitive._compoundModelMatrix);\n  const numChanges = updateBound(primitive, \"_compoundModelMatrix\", \"_compoundModelMatrixOld\") + updateBound(primitive, \"_minBounds\", \"_minBoundsOld\") + updateBound(primitive, \"_maxBounds\", \"_maxBoundsOld\") + updateBound(primitive, \"_exaggeratedMinBounds\", \"_exaggeratedMinBoundsOld\") + updateBound(primitive, \"_exaggeratedMaxBounds\", \"_exaggeratedMaxBoundsOld\") + updateBound(primitive, \"_minClippingBounds\", \"_minClippingBoundsOld\") + updateBound(primitive, \"_maxClippingBounds\", \"_maxClippingBoundsOld\");\n  return numChanges > 0;\n}\n\n/**\n * Compare old and new values of a bound and update the old if it is different.\n * @param {VoxelPrimitive} primitive The primitive with bounds properties\n * @param {string} newBoundKey A key pointing to a bounds property of type Cartesian3 or Matrix4\n * @param {string} oldBoundKey A key pointing to a bounds property of the same type as the property at newBoundKey\n * @returns {number} 1 if the bound value changed, 0 otherwise\n *\n * @private\n */\nfunction updateBound(primitive, newBoundKey, oldBoundKey) {\n  const newBound = primitive[newBoundKey];\n  const oldBound = primitive[oldBoundKey];\n  const changed = !newBound.equals(oldBound);\n  if (changed) {\n    newBound.clone(oldBound);\n  }\n  return changed ? 1 : 0;\n}\n\n/**\n * Update the shape and related transforms\n * @param {VoxelPrimitive} primitive\n * @param {VoxelShape} shape\n * @param {VoxelProvider} provider\n * @returns {boolean} True if the shape is visible\n * @private\n */\nfunction updateShapeAndTransforms(primitive, shape, provider) {\n  const visible = shape.update(primitive._compoundModelMatrix, primitive._exaggeratedMinBounds, primitive._exaggeratedMaxBounds, primitive.minClippingBounds, primitive.maxClippingBounds);\n  if (!visible) {\n    return false;\n  }\n  const transformPositionLocalToWorld = shape.shapeTransform;\n  const transformPositionWorldToLocal = Matrix4.inverse(transformPositionLocalToWorld, scratchTransformPositionWorldToLocal);\n  const rotation = Matrix4.getRotation(transformPositionLocalToWorld, scratchRotation);\n  // Note that inverse(rotation) is the same as transpose(rotation)\n  const scale = Matrix4.getScale(transformPositionLocalToWorld, scratchScale);\n  const maximumScaleComponent = Cartesian3.maximumComponent(scale);\n  const localScale = Cartesian3.divideByScalar(scale, maximumScaleComponent, scratchLocalScale);\n  const rotationAndLocalScale = Matrix3.multiplyByScale(rotation, localScale, scratchRotationAndLocalScale);\n\n  // Set member variables when the shape is dirty\n  primitive._transformPositionWorldToUv = Matrix4.multiplyTransformation(transformPositionLocalToUv, transformPositionWorldToLocal, primitive._transformPositionWorldToUv);\n  primitive._transformPositionUvToWorld = Matrix4.multiplyTransformation(transformPositionLocalToWorld, transformPositionUvToLocal, primitive._transformPositionUvToWorld);\n  primitive._transformDirectionWorldToLocal = Matrix4.getMatrix3(transformPositionWorldToLocal, primitive._transformDirectionWorldToLocal);\n  primitive._transformNormalLocalToWorld = Matrix3.inverseTranspose(rotationAndLocalScale, primitive._transformNormalLocalToWorld);\n  return true;\n}\n\n/**\n * Set up a VoxelTraversal based on dimensions and types from the primitive and provider\n * @param {VoxelPrimitive} primitive\n * @param {VoxelProvider} provider\n * @param {Context} context\n * @returns {VoxelTraversal}\n * @private\n */\nfunction setupTraversal(primitive, provider, context) {\n  const dimensions = Cartesian3.clone(provider.dimensions, scratchDimensions);\n  Cartesian3.add(dimensions, primitive._paddingBefore, dimensions);\n  Cartesian3.add(dimensions, primitive._paddingAfter, dimensions);\n\n  // It's ok for memory byte length to be undefined.\n  // The system will choose a default memory size.\n  const maximumTileCount = provider.maximumTileCount;\n  const maximumTextureMemoryByteLength = defined(maximumTileCount) ? VoxelTraversal.getApproximateTextureMemoryByteLength(maximumTileCount, dimensions, provider.types, provider.componentTypes) : undefined;\n  const keyframeCount = defaultValue(provider.keyframeCount, 1);\n  return new VoxelTraversal(primitive, context, dimensions, provider.types, provider.componentTypes, keyframeCount, maximumTextureMemoryByteLength);\n}\n\n/**\n * Set uniforms that come from the traversal.\n * @param {VoxelTraversal} traversal\n * @param {object} uniforms\n * @private\n */\nfunction setTraversalUniforms(traversal, uniforms) {\n  uniforms.octreeInternalNodeTexture = traversal.internalNodeTexture;\n  uniforms.octreeInternalNodeTexelSizeUv = Cartesian2.clone(traversal.internalNodeTexelSizeUv, uniforms.octreeInternalNodeTexelSizeUv);\n  uniforms.octreeInternalNodeTilesPerRow = traversal.internalNodeTilesPerRow;\n  const megatextures = traversal.megatextures;\n  const megatexture = megatextures[0];\n  const megatextureLength = megatextures.length;\n  uniforms.megatextureTextures = new Array(megatextureLength);\n  for (let i = 0; i < megatextureLength; i++) {\n    uniforms.megatextureTextures[i] = megatextures[i].texture;\n  }\n  uniforms.megatextureSliceDimensions = Cartesian2.clone(megatexture.sliceCountPerRegion, uniforms.megatextureSliceDimensions);\n  uniforms.megatextureTileDimensions = Cartesian2.clone(megatexture.regionCountPerMegatexture, uniforms.megatextureTileDimensions);\n  uniforms.megatextureVoxelSizeUv = Cartesian2.clone(megatexture.voxelSizeUv, uniforms.megatextureVoxelSizeUv);\n  uniforms.megatextureSliceSizeUv = Cartesian2.clone(megatexture.sliceSizeUv, uniforms.megatextureSliceSizeUv);\n  uniforms.megatextureTileSizeUv = Cartesian2.clone(megatexture.regionSizeUv, uniforms.megatextureTileSizeUv);\n}\n\n/**\n * Track changes in shape-related shader defines\n * @param {VoxelPrimitive} primitive\n * @param {VoxelShape} shape\n * @returns {boolean} True if any of the shape defines changed, requiring a shader rebuild\n * @private\n */\nfunction checkShapeDefines(primitive, shape) {\n  const shapeDefines = shape.shaderDefines;\n  const shapeDefinesChanged = Object.keys(shapeDefines).some(key => shapeDefines[key] !== primitive._shapeDefinesOld[key]);\n  if (shapeDefinesChanged) {\n    primitive._shapeDefinesOld = clone(shapeDefines, true);\n  }\n  return shapeDefinesChanged;\n}\n\n/**\n * Find the keyframe location to render at. Doesn't need to be a whole number.\n * @param {TimeIntervalCollection} timeIntervalCollection\n * @param {Clock} clock\n * @returns {number}\n *\n * @private\n */\nfunction getKeyframeLocation(timeIntervalCollection, clock) {\n  if (!defined(timeIntervalCollection) || !defined(clock)) {\n    return 0.0;\n  }\n  let date = clock.currentTime;\n  let timeInterval;\n  let timeIntervalIndex = timeIntervalCollection.indexOf(date);\n  if (timeIntervalIndex >= 0) {\n    timeInterval = timeIntervalCollection.get(timeIntervalIndex);\n  } else {\n    // Date fell outside the range\n    timeIntervalIndex = ~timeIntervalIndex;\n    if (timeIntervalIndex === timeIntervalCollection.length) {\n      // Date past range\n      timeIntervalIndex = timeIntervalCollection.length - 1;\n      timeInterval = timeIntervalCollection.get(timeIntervalIndex);\n      date = timeInterval.stop;\n    } else {\n      // Date before range\n      timeInterval = timeIntervalCollection.get(timeIntervalIndex);\n      date = timeInterval.start;\n    }\n  }\n  // De-lerp between the start and end of the interval\n  const totalSeconds = JulianDate.secondsDifference(timeInterval.stop, timeInterval.start);\n  const secondsDifferenceStart = JulianDate.secondsDifference(date, timeInterval.start);\n  const t = secondsDifferenceStart / totalSeconds;\n  return timeIntervalIndex + t;\n}\n\n/**\n * Update the clipping planes state and associated uniforms\n *\n * @param {VoxelPrimitive} primitive\n * @param {FrameState} frameState\n * @returns {boolean} Whether the clipping planes changed, requiring a shader rebuild\n * @private\n */\nfunction updateClippingPlanes(primitive, frameState) {\n  const clippingPlanes = primitive.clippingPlanes;\n  if (!defined(clippingPlanes)) {\n    return false;\n  }\n  clippingPlanes.update(frameState);\n  const {\n    clippingPlanesState,\n    enabled\n  } = clippingPlanes;\n  if (enabled) {\n    const uniforms = primitive._uniforms;\n    uniforms.clippingPlanesTexture = clippingPlanes.texture;\n\n    // Compute the clipping plane's transformation to uv space and then take the inverse\n    // transpose to properly transform the hessian normal form of the plane.\n\n    // transpose(inverse(worldToUv * clippingPlaneLocalToWorld))\n    // transpose(inverse(clippingPlaneLocalToWorld) * inverse(worldToUv))\n    // transpose(inverse(clippingPlaneLocalToWorld) * uvToWorld)\n\n    uniforms.clippingPlanesMatrix = Matrix4.transpose(Matrix4.multiplyTransformation(Matrix4.inverse(clippingPlanes.modelMatrix, uniforms.clippingPlanesMatrix), primitive._transformPositionUvToWorld, uniforms.clippingPlanesMatrix), uniforms.clippingPlanesMatrix);\n  }\n  if (primitive._clippingPlanesState === clippingPlanesState && primitive._clippingPlanesEnabled === enabled) {\n    return false;\n  }\n  primitive._clippingPlanesState = clippingPlanesState;\n  primitive._clippingPlanesEnabled = enabled;\n  return true;\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see VoxelPrimitive#destroy\n */\nVoxelPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see VoxelPrimitive#isDestroyed\n *\n * @example\n * voxelPrimitive = voxelPrimitive && voxelPrimitive.destroy();\n */\nVoxelPrimitive.prototype.destroy = function () {\n  const drawCommand = this._drawCommand;\n  if (defined(drawCommand)) {\n    drawCommand.shaderProgram = drawCommand.shaderProgram && drawCommand.shaderProgram.destroy();\n  }\n  const drawCommandPick = this._drawCommandPick;\n  if (defined(drawCommandPick)) {\n    drawCommandPick.shaderProgram = drawCommandPick.shaderProgram && drawCommandPick.shaderProgram.destroy();\n  }\n  this._pickId = this._pickId && this._pickId.destroy();\n  this._traversal = this._traversal && this._traversal.destroy();\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n  return destroyObject(this);\n};\nconst corners = new Array(new Cartesian4(-1.0, -1.0, -1.0, 1.0), new Cartesian4(+1.0, -1.0, -1.0, 1.0), new Cartesian4(-1.0, +1.0, -1.0, 1.0), new Cartesian4(+1.0, +1.0, -1.0, 1.0), new Cartesian4(-1.0, -1.0, +1.0, 1.0), new Cartesian4(+1.0, -1.0, +1.0, 1.0), new Cartesian4(-1.0, +1.0, +1.0, 1.0), new Cartesian4(+1.0, +1.0, +1.0, 1.0));\nconst vertexNeighborIndices = new Array(1, 2, 4, 0, 3, 5, 0, 3, 6, 1, 2, 7, 0, 5, 6, 1, 4, 7, 2, 4, 7, 3, 5, 6);\nconst scratchCornersClipSpace = new Array(new Cartesian4(), new Cartesian4(), new Cartesian4(), new Cartesian4(), new Cartesian4(), new Cartesian4(), new Cartesian4(), new Cartesian4());\n\n/**\n * Projects all 8 corners of the oriented bounding box to NDC space and finds the\n * resulting NDC axis aligned bounding box. To avoid projecting a vertex that is\n * behind the near plane, it uses the intersection point of each of the vertex's\n * edges against the near plane as part of the AABB calculation. This is done in\n * clip space prior to perspective division.\n *\n * @function\n *\n * @param {OrientedBoundingBox} orientedBoundingBox\n * @param {Matrix4} worldToProjection\n * @param {Cartesian4} result\n * @returns {Cartesian4}\n *\n * @private\n */\nfunction orientedBoundingBoxToNdcAabb(orientedBoundingBox, worldToProjection, result) {\n  const transformPositionLocalToWorld = Matrix4.fromRotationTranslation(orientedBoundingBox.halfAxes, orientedBoundingBox.center, scratchTransformPositionLocalToWorld);\n  const transformPositionLocalToProjection = Matrix4.multiply(worldToProjection, transformPositionLocalToWorld, scratchTransformPositionLocalToProjection);\n  let ndcMinX = +Number.MAX_VALUE;\n  let ndcMaxX = -Number.MAX_VALUE;\n  let ndcMinY = +Number.MAX_VALUE;\n  let ndcMaxY = -Number.MAX_VALUE;\n  let cornerIndex;\n\n  // Convert all points to clip space\n  const cornersClipSpace = scratchCornersClipSpace;\n  const cornersLength = corners.length;\n  for (cornerIndex = 0; cornerIndex < cornersLength; cornerIndex++) {\n    Matrix4.multiplyByVector(transformPositionLocalToProjection, corners[cornerIndex], cornersClipSpace[cornerIndex]);\n  }\n  for (cornerIndex = 0; cornerIndex < cornersLength; cornerIndex++) {\n    const position = cornersClipSpace[cornerIndex];\n    if (position.z >= -position.w) {\n      // Position is past near plane, so there's no need to clip.\n      const ndcX = position.x / position.w;\n      const ndcY = position.y / position.w;\n      ndcMinX = Math.min(ndcMinX, ndcX);\n      ndcMaxX = Math.max(ndcMaxX, ndcX);\n      ndcMinY = Math.min(ndcMinY, ndcY);\n      ndcMaxY = Math.max(ndcMaxY, ndcY);\n    } else {\n      for (let neighborIndex = 0; neighborIndex < 3; neighborIndex++) {\n        const neighborVertexIndex = vertexNeighborIndices[cornerIndex * 3 + neighborIndex];\n        const neighborPosition = cornersClipSpace[neighborVertexIndex];\n        if (neighborPosition.z >= -neighborPosition.w) {\n          // Position is behind the near plane and neighbor is after, so get intersection point on the near plane.\n          const distanceToPlaneFromPosition = position.z + position.w;\n          const distanceToPlaneFromNeighbor = neighborPosition.z + neighborPosition.w;\n          const t = distanceToPlaneFromPosition / (distanceToPlaneFromPosition - distanceToPlaneFromNeighbor);\n          const intersect = Cartesian4.lerp(position, neighborPosition, t, scratchIntersect);\n          const intersectNdcX = intersect.x / intersect.w;\n          const intersectNdcY = intersect.y / intersect.w;\n          ndcMinX = Math.min(ndcMinX, intersectNdcX);\n          ndcMaxX = Math.max(ndcMaxX, intersectNdcX);\n          ndcMinY = Math.min(ndcMinY, intersectNdcY);\n          ndcMaxY = Math.max(ndcMaxY, intersectNdcY);\n        }\n      }\n    }\n  }\n\n  // Clamp the NDC values to -1 to +1 range even if they extend much further.\n  ndcMinX = CesiumMath.clamp(ndcMinX, -1.0, +1.0);\n  ndcMinY = CesiumMath.clamp(ndcMinY, -1.0, +1.0);\n  ndcMaxX = CesiumMath.clamp(ndcMaxX, -1.0, +1.0);\n  ndcMaxY = CesiumMath.clamp(ndcMaxY, -1.0, +1.0);\n  result = Cartesian4.fromElements(ndcMinX, ndcMinY, ndcMaxX, ndcMaxY, result);\n  return result;\n}\nconst polylineAxisDistance = 30000000.0;\nconst polylineXAxis = new Cartesian3(polylineAxisDistance, 0.0, 0.0);\nconst polylineYAxis = new Cartesian3(0.0, polylineAxisDistance, 0.0);\nconst polylineZAxis = new Cartesian3(0.0, 0.0, polylineAxisDistance);\n\n/**\n * Draws the tile bounding boxes and axes.\n *\n * @function\n *\n * @param {VoxelPrimitive} that\n * @param {FrameState} frameState\n *\n * @private\n */\nfunction debugDraw(that, frameState) {\n  const traversal = that._traversal;\n  const polylines = that._debugPolylines;\n  polylines.removeAll();\n  function makePolylineLineSegment(startPos, endPos, color, thickness) {\n    polylines.add({\n      positions: [startPos, endPos],\n      width: thickness,\n      material: Material.fromType(\"Color\", {\n        color: color\n      })\n    });\n  }\n  function makePolylineBox(orientedBoundingBox, color, thickness) {\n    // Normally would want to use a scratch variable to store the corners, but\n    // polylines don't clone the positions.\n    const corners = orientedBoundingBox.computeCorners();\n    makePolylineLineSegment(corners[0], corners[1], color, thickness);\n    makePolylineLineSegment(corners[2], corners[3], color, thickness);\n    makePolylineLineSegment(corners[4], corners[5], color, thickness);\n    makePolylineLineSegment(corners[6], corners[7], color, thickness);\n    makePolylineLineSegment(corners[0], corners[2], color, thickness);\n    makePolylineLineSegment(corners[4], corners[6], color, thickness);\n    makePolylineLineSegment(corners[1], corners[3], color, thickness);\n    makePolylineLineSegment(corners[5], corners[7], color, thickness);\n    makePolylineLineSegment(corners[0], corners[4], color, thickness);\n    makePolylineLineSegment(corners[2], corners[6], color, thickness);\n    makePolylineLineSegment(corners[1], corners[5], color, thickness);\n    makePolylineLineSegment(corners[3], corners[7], color, thickness);\n  }\n  function drawTile(tile) {\n    if (!traversal.isRenderable(tile)) {\n      return;\n    }\n    const level = tile.level;\n    const startThickness = 5.0;\n    const thickness = Math.max(1.0, startThickness / Math.pow(2.0, level));\n    const colors = [Color.RED, Color.LIME, Color.BLUE];\n    const color = colors[level % 3];\n    makePolylineBox(tile.orientedBoundingBox, color, thickness);\n    if (defined(tile.children)) {\n      for (let i = 0; i < 8; i++) {\n        drawTile(tile.children[i]);\n      }\n    }\n  }\n  makePolylineBox(that._shape.orientedBoundingBox, Color.WHITE, 5.0);\n  drawTile(traversal.rootNode);\n  const axisThickness = 10.0;\n  makePolylineLineSegment(Cartesian3.ZERO, polylineXAxis, Color.RED, axisThickness);\n  makePolylineLineSegment(Cartesian3.ZERO, polylineYAxis, Color.LIME, axisThickness);\n  makePolylineLineSegment(Cartesian3.ZERO, polylineZAxis, Color.BLUE, axisThickness);\n  polylines.update(frameState);\n}\n\n/**\n * The default custom shader used by the primitive.\n *\n * @type {CustomShader}\n * @constant\n * @readonly\n *\n * @private\n */\nVoxelPrimitive.DefaultCustomShader = new CustomShader({\n  fragmentShaderText: `void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material)\n{\n    material.diffuse = vec3(1.0);\n    material.alpha = 1.0;\n}`\n});\nfunction DefaultVoxelProvider() {\n  this.ready = true;\n  this.shape = VoxelShapeType.BOX;\n  this.dimensions = new Cartesian3(1, 1, 1);\n  this.names = [\"data\"];\n  this.types = [MetadataType.SCALAR];\n  this.componentTypes = [MetadataComponentType.FLOAT32];\n  this.maximumTileCount = 1;\n}\nDefaultVoxelProvider.prototype.requestData = function (options) {\n  const tileLevel = defined(options) ? defaultValue(options.tileLevel, 0) : 0;\n  if (tileLevel >= 1) {\n    return undefined;\n  }\n  return Promise.resolve([new Float32Array(1)]);\n};\nVoxelPrimitive.DefaultProvider = new DefaultVoxelProvider();\nexport default VoxelPrimitive;","map":{"version":3,"names":["buildVoxelDrawCommands","Cartesian2","Cartesian3","Cartesian4","CesiumMath","Check","clone","Color","defaultValue","defined","destroyObject","Event","JulianDate","Matrix3","Matrix4","oneTimeWarning","ClippingPlaneCollection","Material","MetadataComponentType","MetadataType","PolylineCollection","VoxelShapeType","VoxelTraversal","CustomShader","Cartographic","Ellipsoid","VerticalExaggeration","VoxelPrimitive","options","EMPTY_OBJECT","_ready","_provider","provider","DefaultProvider","_traversal","undefined","_shape","_shapeVisible","_paddingBefore","_paddingAfter","_minBounds","_minBoundsOld","_maxBounds","_maxBoundsOld","_exaggeratedMinBounds","_exaggeratedMinBoundsOld","_exaggeratedMaxBounds","_exaggeratedMaxBoundsOld","_minClippingBounds","_minClippingBoundsOld","_maxClippingBounds","_maxClippingBoundsOld","_clippingPlanes","_clippingPlanesState","_clippingPlanesEnabled","_modelMatrix","modelMatrix","IDENTITY","_exaggeratedModelMatrix","_compoundModelMatrix","_compoundModelMatrixOld","_customShader","customShader","DefaultCustomShader","_customShaderCompilationEvent","_shaderDirty","_drawCommand","_drawCommandPick","_pickId","_clock","clock","_transformPositionWorldToUv","_transformPositionUvToWorld","_transformDirectionWorldToLocal","_transformNormalLocalToWorld","_nearestSampling","_levelBlendFactor","_stepSizeMultiplier","_depthTest","_useLogDepth","_screenSpaceError","_debugPolylines","_debugDraw","_disableRender","_disableUpdate","_uniforms","octreeInternalNodeTexture","octreeInternalNodeTilesPerRow","octreeInternalNodeTexelSizeUv","octreeLeafNodeTexture","octreeLeafNodeTilesPerRow","octreeLeafNodeTexelSizeUv","megatextureTextures","megatextureSliceDimensions","megatextureTileDimensions","megatextureVoxelSizeUv","megatextureSliceSizeUv","megatextureTileSizeUv","dimensions","paddingBefore","paddingAfter","transformPositionViewToUv","transformPositionUvToView","transformDirectionViewToLocal","transformNormalLocalToWorld","cameraPositionUv","ndcSpaceAxisAlignedBoundingBox","clippingPlanesTexture","clippingPlanesMatrix","stepSize","pickColor","_shapeDefinesOld","_uniformMap","uniforms","uniformMap","key","hasOwnProperty","name","initialize","primitive","shape","shapeType","minBounds","getMinBounds","maxBounds","getMaxBounds","minClippingBounds","maxClippingBounds","checkTransformAndBounds","ShapeConstructor","getShapeConstructor","updateShapeAndTransforms","Object","defineProperties","prototype","ready","get","boundingSphere","orientedBoundingBox","set","typeOf","object","minimumValues","maximumValues","show","bool","disableUpdate","debugDraw","depthTest","nearestSampling","levelBlendFactor","number","clamp","screenSpaceError","clippingPlanes","setOwner","oldCustomShader","oldCustomShaderUniformMap","uniformName","customShaderCompilationEvent","scratchDimensions","scratchIntersect","scratchNdcAabb","scratchScale","scratchLocalScale","scratchRotation","scratchRotationAndLocalScale","scratchTransformPositionWorldToLocal","scratchTransformPositionLocalToWorld","scratchTransformPositionLocalToProjection","transformPositionLocalToUv","fromRotationTranslation","fromUniformScale","transformPositionUvToLocal","update","frameState","context","initFromProvider","afterRender","push","updateVerticalExaggeration","shapeDirty","checkShapeDefines","keyframeLocation","getKeyframeLocation","timeIntervalCollection","traversal","sampleCountOld","_sampleCount","isRenderable","rootNode","useLogDepth","clippingPlanesChanged","updateClippingPlanes","leafNodeTexture","leafNodeTexelSizeUv","leafNodeTilesPerRow","transformPositionWorldToProjection","uniformState","viewProjection","ndcAabb","orientedBoundingBoxToNdcAabb","offscreen","x","y","z","w","transformPositionViewToWorld","inverseView","multiplyTransformation","transformPositionWorldToView","view","transformDirectionViewToWorld","inverseViewRotation","multiply","cameraPositionWorld","camera","positionWC","multiplyByPoint","command","passes","pick","pickVoxel","_drawCommandPickVoxel","boundingVolume","commandList","scratchExaggerationScale","scratchExaggerationCenter","scratchCartographicCenter","scratchExaggerationTranslation","ELLIPSOID","relativeHeight","verticalExaggerationRelativeHeight","exaggeration","verticalExaggeration","BOX","exaggerationScale","fromElements","multiplyByScale","multiplyByTranslation","computeBoxExaggerationTranslation","shapeTransform","globalTransform","initialCenter","getTranslation","intermediateCenter","transformedCenter","ellipsoid","WGS84","centerCartographic","cartesianToCartographic","centerHeight","height","exaggeratedHeight","getHeight","createPickId","color","shaderDefines","shaderUniforms","shapeUniforms","ZERO","setupTraversal","setTraversalUniforms","numChanges","updateBound","newBoundKey","oldBoundKey","newBound","oldBound","changed","equals","visible","transformPositionLocalToWorld","transformPositionWorldToLocal","inverse","rotation","getRotation","scale","getScale","maximumScaleComponent","maximumComponent","localScale","divideByScalar","rotationAndLocalScale","getMatrix3","inverseTranspose","add","maximumTileCount","maximumTextureMemoryByteLength","getApproximateTextureMemoryByteLength","types","componentTypes","keyframeCount","internalNodeTexture","internalNodeTexelSizeUv","internalNodeTilesPerRow","megatextures","megatexture","megatextureLength","length","Array","i","texture","sliceCountPerRegion","regionCountPerMegatexture","voxelSizeUv","sliceSizeUv","regionSizeUv","shapeDefines","shapeDefinesChanged","keys","some","date","currentTime","timeInterval","timeIntervalIndex","indexOf","stop","start","totalSeconds","secondsDifference","secondsDifferenceStart","t","clippingPlanesState","enabled","transpose","isDestroyed","destroy","drawCommand","shaderProgram","drawCommandPick","corners","vertexNeighborIndices","scratchCornersClipSpace","worldToProjection","result","halfAxes","center","transformPositionLocalToProjection","ndcMinX","Number","MAX_VALUE","ndcMaxX","ndcMinY","ndcMaxY","cornerIndex","cornersClipSpace","cornersLength","multiplyByVector","position","ndcX","ndcY","Math","min","max","neighborIndex","neighborVertexIndex","neighborPosition","distanceToPlaneFromPosition","distanceToPlaneFromNeighbor","intersect","lerp","intersectNdcX","intersectNdcY","polylineAxisDistance","polylineXAxis","polylineYAxis","polylineZAxis","that","polylines","removeAll","makePolylineLineSegment","startPos","endPos","thickness","positions","width","material","fromType","makePolylineBox","computeCorners","drawTile","tile","level","startThickness","pow","colors","RED","LIME","BLUE","children","WHITE","axisThickness","fragmentShaderText","DefaultVoxelProvider","names","SCALAR","FLOAT32","requestData","tileLevel","Promise","resolve","Float32Array"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/VoxelPrimitive.js"],"sourcesContent":["import buildVoxelDrawCommands from \"./buildVoxelDrawCommands.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport Material from \"./Material.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport PolylineCollection from \"./PolylineCollection.js\";\nimport VoxelShapeType from \"./VoxelShapeType.js\";\nimport VoxelTraversal from \"./VoxelTraversal.js\";\nimport CustomShader from \"./Model/CustomShader.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport VerticalExaggeration from \"../Core/VerticalExaggeration.js\";\n\n/**\n * A primitive that renders voxel data from a {@link VoxelProvider}.\n *\n * @alias VoxelPrimitive\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {VoxelProvider} [options.provider] The voxel provider that supplies the primitive with tile data.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The model matrix used to transform the primitive.\n * @param {CustomShader} [options.customShader] The custom shader used to style the primitive.\n * @param {Clock} [options.clock] The clock used to control time dynamic behavior.\n *\n * @see VoxelProvider\n * @see Cesium3DTilesVoxelProvider\n * @see VoxelShapeType\n *\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction VoxelPrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._ready = false;\n\n  /**\n   * @type {VoxelProvider}\n   * @private\n   */\n  this._provider = defaultValue(\n    options.provider,\n    VoxelPrimitive.DefaultProvider,\n  );\n\n  /**\n   * This member is not created until the provider and shape are ready.\n   *\n   * @type {VoxelTraversal}\n   * @private\n   */\n  this._traversal = undefined;\n\n  /**\n   * This member is not created until the provider is ready.\n   *\n   * @type {VoxelShape}\n   * @private\n   */\n  this._shape = undefined;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._shapeVisible = false;\n\n  /**\n   * This member is not created until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._paddingBefore = new Cartesian3();\n\n  /**\n   * This member is not created until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._paddingAfter = new Cartesian3();\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the shape is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minBoundsOld = new Cartesian3();\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the shape is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxBoundsOld = new Cartesian3();\n\n  /**\n   * Minimum bounds with vertical exaggeration applied\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._exaggeratedMinBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the shape is dirty.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._exaggeratedMinBoundsOld = new Cartesian3();\n\n  /**\n   * Maximum bounds with vertical exaggeration applied\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._exaggeratedMaxBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the shape is dirty.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._exaggeratedMaxBoundsOld = new Cartesian3();\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minClippingBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the clipping is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._minClippingBoundsOld = new Cartesian3();\n\n  /**\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxClippingBounds = new Cartesian3();\n\n  /**\n   * Used to detect if the clipping is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this._maxClippingBoundsOld = new Cartesian3();\n\n  /**\n   * Clipping planes on the primitive\n   *\n   * @type {ClippingPlaneCollection}\n   * @private\n   */\n  this._clippingPlanes = undefined;\n\n  /**\n   * Keeps track of when the clipping planes change\n   *\n   * @type {number}\n   * @private\n   */\n  this._clippingPlanesState = 0;\n\n  /**\n   * Keeps track of when the clipping planes are enabled / disabled\n   *\n   * @type {boolean}\n   * @private\n   */\n  this._clippingPlanesEnabled = false;\n\n  /**\n   * The primitive's model matrix.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this._modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY),\n  );\n\n  /**\n   * Model matrix with vertical exaggeration applied. Only used for BOX shape type.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this._exaggeratedModelMatrix = Matrix4.clone(this._modelMatrix);\n\n  /**\n   * The primitive's model matrix multiplied by the provider's model matrix.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this._compoundModelMatrix = new Matrix4();\n\n  /**\n   * Used to detect if the shape is dirty.\n   * This member is not known until the provider is ready.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this._compoundModelMatrixOld = new Matrix4();\n\n  /**\n   * @type {CustomShader}\n   * @private\n   */\n  this._customShader = defaultValue(\n    options.customShader,\n    VoxelPrimitive.DefaultCustomShader,\n  );\n\n  /**\n   * @type {Event}\n   * @private\n   */\n  this._customShaderCompilationEvent = new Event();\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._shaderDirty = true;\n\n  /**\n   * @type {DrawCommand}\n   * @private\n   */\n  this._drawCommand = undefined;\n\n  /**\n   * @type {DrawCommand}\n   * @private\n   */\n  this._drawCommandPick = undefined;\n\n  /**\n   * @type {object}\n   * @private\n   */\n  this._pickId = undefined;\n\n  /**\n   * @type {Clock}\n   * @private\n   */\n  this._clock = options.clock;\n\n  // Transforms and other values that are computed when the shape changes\n\n  /**\n   * @type {Matrix4}\n   * @private\n   */\n  this._transformPositionWorldToUv = new Matrix4();\n\n  /**\n   * @type {Matrix4}\n   * @private\n   */\n  this._transformPositionUvToWorld = new Matrix4();\n\n  /**\n   * @type {Matrix3}\n   * @private\n   */\n  this._transformDirectionWorldToLocal = new Matrix3();\n\n  /**\n   * @type {Matrix3}\n   * @private\n   */\n  this._transformNormalLocalToWorld = new Matrix3();\n\n  // Rendering\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._nearestSampling = false;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._levelBlendFactor = 0.0;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._stepSizeMultiplier = 1.0;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._depthTest = true;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._useLogDepth = undefined;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this._screenSpaceError = 4.0; // in pixels\n\n  // Debug / statistics\n  /**\n   * @type {PolylineCollection}\n   * @private\n   */\n  this._debugPolylines = new PolylineCollection();\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._debugDraw = false;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._disableRender = false;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this._disableUpdate = false;\n\n  /**\n   * @type {Object<string, any>}\n   * @private\n   */\n  this._uniforms = {\n    octreeInternalNodeTexture: undefined,\n    octreeInternalNodeTilesPerRow: 0,\n    octreeInternalNodeTexelSizeUv: new Cartesian2(),\n    octreeLeafNodeTexture: undefined,\n    octreeLeafNodeTilesPerRow: 0,\n    octreeLeafNodeTexelSizeUv: new Cartesian2(),\n    megatextureTextures: [],\n    megatextureSliceDimensions: new Cartesian2(),\n    megatextureTileDimensions: new Cartesian2(),\n    megatextureVoxelSizeUv: new Cartesian2(),\n    megatextureSliceSizeUv: new Cartesian2(),\n    megatextureTileSizeUv: new Cartesian2(),\n    dimensions: new Cartesian3(),\n    paddingBefore: new Cartesian3(),\n    paddingAfter: new Cartesian3(),\n    transformPositionViewToUv: new Matrix4(),\n    transformPositionUvToView: new Matrix4(),\n    transformDirectionViewToLocal: new Matrix3(),\n    transformNormalLocalToWorld: new Matrix3(),\n    cameraPositionUv: new Cartesian3(),\n    ndcSpaceAxisAlignedBoundingBox: new Cartesian4(),\n    clippingPlanesTexture: undefined,\n    clippingPlanesMatrix: new Matrix4(),\n    stepSize: 0,\n    pickColor: new Color(),\n  };\n\n  /**\n   * Shape specific shader defines from the previous shape update. Used to detect if the shader needs to be rebuilt.\n   * @type {Object<string, any>}\n   * @private\n   */\n  this._shapeDefinesOld = {};\n\n  /**\n   * Map uniform names to functions that return the uniform values.\n   * @type {Object<string, function():any>}\n   * @private\n   */\n  this._uniformMap = {};\n\n  const uniforms = this._uniforms;\n  const uniformMap = this._uniformMap;\n  for (const key in uniforms) {\n    if (uniforms.hasOwnProperty(key)) {\n      const name = `u_${key}`;\n      uniformMap[name] = function () {\n        return uniforms[key];\n      };\n    }\n  }\n\n  // If the provider fails to initialize the primitive will fail too.\n  const provider = this._provider;\n  initialize(this, provider);\n}\n\nfunction initialize(primitive, provider) {\n  // Set the bounds\n  const {\n    shape: shapeType,\n    minBounds = VoxelShapeType.getMinBounds(shapeType),\n    maxBounds = VoxelShapeType.getMaxBounds(shapeType),\n  } = provider;\n\n  primitive.minBounds = minBounds;\n  primitive.maxBounds = maxBounds;\n  primitive.minClippingBounds = VoxelShapeType.getMinBounds(shapeType);\n  primitive.maxClippingBounds = VoxelShapeType.getMaxBounds(shapeType);\n\n  // Initialize the exaggerated versions of bounds and model matrix\n  primitive._exaggeratedMinBounds = Cartesian3.clone(\n    primitive._minBounds,\n    primitive._exaggeratedMinBounds,\n  );\n  primitive._exaggeratedMaxBounds = Cartesian3.clone(\n    primitive._maxBounds,\n    primitive._exaggeratedMaxBounds,\n  );\n  primitive._exaggeratedModelMatrix = Matrix4.clone(\n    primitive._modelMatrix,\n    primitive._exaggeratedModelMatrix,\n  );\n\n  checkTransformAndBounds(primitive, provider);\n\n  // Create the shape object, and update it so it is valid for VoxelTraversal\n  const ShapeConstructor = VoxelShapeType.getShapeConstructor(shapeType);\n  primitive._shape = new ShapeConstructor();\n  primitive._shapeVisible = updateShapeAndTransforms(\n    primitive,\n    primitive._shape,\n    provider,\n  );\n}\n\nObject.defineProperties(VoxelPrimitive.prototype, {\n  /**\n   * Gets a value indicating whether or not the primitive is ready for use.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets the {@link VoxelProvider} associated with this primitive.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {VoxelProvider}\n   * @readonly\n   */\n  provider: {\n    get: function () {\n      return this._provider;\n    },\n  },\n\n  /**\n   * Gets the bounding sphere.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._shape.boundingSphere;\n    },\n  },\n\n  /**\n   * Gets the oriented bounding box.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {OrientedBoundingBox}\n   * @readonly\n   */\n  orientedBoundingBox: {\n    get: function () {\n      return this._shape.orientedBoundingBox;\n    },\n  },\n\n  /**\n   * Gets the model matrix.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  modelMatrix: {\n    get: function () {\n      return this._modelMatrix;\n    },\n    set: function (modelMatrix) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"modelMatrix\", modelMatrix);\n      //>>includeEnd('debug');\n\n      this._modelMatrix = Matrix4.clone(modelMatrix, this._modelMatrix);\n    },\n  },\n\n  /**\n   * Gets the shape type.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {VoxelShapeType}\n   * @readonly\n   */\n  shape: {\n    get: function () {\n      return this._provider.shape;\n    },\n  },\n\n  /**\n   * Gets the voxel dimensions.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  dimensions: {\n    get: function () {\n      return this._provider.dimensions;\n    },\n  },\n\n  /**\n   * Gets the minimum value per channel of the voxel data.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number[][]}\n   * @readonly\n   */\n  minimumValues: {\n    get: function () {\n      return this._provider.minimumValues;\n    },\n  },\n\n  /**\n   * Gets the maximum value per channel of the voxel data.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number[][]}\n   * @readonly\n   */\n  maximumValues: {\n    get: function () {\n      return this._provider.maximumValues;\n    },\n  },\n\n  /**\n   * Gets or sets whether or not this primitive should be displayed.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return !this._disableRender;\n    },\n    set: function (show) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"show\", show);\n      //>>includeEnd('debug');\n\n      this._disableRender = !show;\n    },\n  },\n\n  /**\n   * Gets or sets whether or not the primitive should update when the view changes.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  disableUpdate: {\n    get: function () {\n      return this._disableUpdate;\n    },\n    set: function (disableUpdate) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"disableUpdate\", disableUpdate);\n      //>>includeEnd('debug');\n\n      this._disableUpdate = disableUpdate;\n    },\n  },\n\n  /**\n   * Gets or sets whether or not to render debug visualizations.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  debugDraw: {\n    get: function () {\n      return this._debugDraw;\n    },\n    set: function (debugDraw) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"debugDraw\", debugDraw);\n      //>>includeEnd('debug');\n\n      this._debugDraw = debugDraw;\n    },\n  },\n\n  /**\n   * Gets or sets whether or not to test against depth when rendering.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  depthTest: {\n    get: function () {\n      return this._depthTest;\n    },\n    set: function (depthTest) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"depthTest\", depthTest);\n      //>>includeEnd('debug');\n\n      if (this._depthTest !== depthTest) {\n        this._depthTest = depthTest;\n        this._shaderDirty = true;\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the nearest sampling.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {boolean}\n   */\n  nearestSampling: {\n    get: function () {\n      return this._nearestSampling;\n    },\n    set: function (nearestSampling) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"nearestSampling\", nearestSampling);\n      //>>includeEnd('debug');\n\n      if (this._nearestSampling !== nearestSampling) {\n        this._nearestSampling = nearestSampling;\n        this._shaderDirty = true;\n      }\n    },\n  },\n\n  /**\n   * Controls how quickly to blend between different levels of the tree.\n   * 0.0 means an instantaneous pop.\n   * 1.0 means a full linear blend.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number}\n   * @private\n   */\n  levelBlendFactor: {\n    get: function () {\n      return this._levelBlendFactor;\n    },\n    set: function (levelBlendFactor) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"levelBlendFactor\", levelBlendFactor);\n      //>>includeEnd('debug');\n\n      this._levelBlendFactor = CesiumMath.clamp(levelBlendFactor, 0.0, 1.0);\n    },\n  },\n\n  /**\n   * Gets or sets the screen space error in pixels. If the screen space size\n   * of a voxel is greater than the screen space error, the tile is subdivided.\n   * Lower screen space error corresponds with higher detail rendering, but could\n   * result in worse performance and higher memory consumption.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number}\n   */\n  screenSpaceError: {\n    get: function () {\n      return this._screenSpaceError;\n    },\n    set: function (screenSpaceError) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"screenSpaceError\", screenSpaceError);\n      //>>includeEnd('debug');\n\n      this._screenSpaceError = screenSpaceError;\n    },\n  },\n\n  /**\n   * Gets or sets the step size multiplier used during raymarching.\n   * The lower the value, the higher the rendering quality, but\n   * also the worse the performance.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {number}\n   */\n  stepSize: {\n    get: function () {\n      return this._stepSizeMultiplier;\n    },\n    set: function (stepSize) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"stepSize\", stepSize);\n      //>>includeEnd('debug');\n\n      this._stepSizeMultiplier = stepSize;\n    },\n  },\n\n  /**\n   * Gets or sets the minimum bounds in the shape's local coordinate system.\n   * Voxel data is stretched or squashed to fit the bounds.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  minBounds: {\n    get: function () {\n      return this._minBounds;\n    },\n    set: function (minBounds) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"minBounds\", minBounds);\n      //>>includeEnd('debug');\n\n      this._minBounds = Cartesian3.clone(minBounds, this._minBounds);\n    },\n  },\n\n  /**\n   * Gets or sets the maximum bounds in the shape's local coordinate system.\n   * Voxel data is stretched or squashed to fit the bounds.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  maxBounds: {\n    get: function () {\n      return this._maxBounds;\n    },\n    set: function (maxBounds) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"maxBounds\", maxBounds);\n      //>>includeEnd('debug');\n\n      this._maxBounds = Cartesian3.clone(maxBounds, this._maxBounds);\n    },\n  },\n\n  /**\n   * Gets or sets the minimum clipping location in the shape's local coordinate system.\n   * Any voxel content outside the range is clipped.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  minClippingBounds: {\n    get: function () {\n      return this._minClippingBounds;\n    },\n    set: function (minClippingBounds) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"minClippingBounds\", minClippingBounds);\n      //>>includeEnd('debug');\n\n      this._minClippingBounds = Cartesian3.clone(\n        minClippingBounds,\n        this._minClippingBounds,\n      );\n    },\n  },\n\n  /**\n   * Gets or sets the maximum clipping location in the shape's local coordinate system.\n   * Any voxel content outside the range is clipped.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  maxClippingBounds: {\n    get: function () {\n      return this._maxClippingBounds;\n    },\n    set: function (maxClippingBounds) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"maxClippingBounds\", maxClippingBounds);\n      //>>includeEnd('debug');\n\n      this._maxClippingBounds = Cartesian3.clone(\n        maxClippingBounds,\n        this._maxClippingBounds,\n      );\n    },\n  },\n\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the primitive.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (clippingPlanes) {\n      // Don't need to check if undefined, it's handled in the setOwner function\n      ClippingPlaneCollection.setOwner(clippingPlanes, this, \"_clippingPlanes\");\n    },\n  },\n\n  /**\n   * Gets or sets the custom shader. If undefined, {@link VoxelPrimitive.DefaultCustomShader} is set.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {CustomShader}\n   */\n  customShader: {\n    get: function () {\n      return this._customShader;\n    },\n    set: function (customShader) {\n      if (this._customShader !== customShader) {\n        // Delete old custom shader entries from the uniform map\n        const uniformMap = this._uniformMap;\n        const oldCustomShader = this._customShader;\n        const oldCustomShaderUniformMap = oldCustomShader.uniformMap;\n        for (const uniformName in oldCustomShaderUniformMap) {\n          if (oldCustomShaderUniformMap.hasOwnProperty(uniformName)) {\n            // If the custom shader was set but the voxel shader was never\n            // built, the custom shader uniforms wouldn't have been added to\n            // the uniform map. But it doesn't matter because the delete\n            // operator ignores if the key doesn't exist.\n            delete uniformMap[uniformName];\n          }\n        }\n\n        if (!defined(customShader)) {\n          this._customShader = VoxelPrimitive.DefaultCustomShader;\n        } else {\n          this._customShader = customShader;\n        }\n        this._shaderDirty = true;\n      }\n    },\n  },\n\n  /**\n   * Gets an event that is raised whenever a custom shader is compiled.\n   *\n   * @memberof VoxelPrimitive.prototype\n   * @type {Event}\n   * @readonly\n   */\n  customShaderCompilationEvent: {\n    get: function () {\n      return this._customShaderCompilationEvent;\n    },\n  },\n});\n\nconst scratchDimensions = new Cartesian3();\nconst scratchIntersect = new Cartesian4();\nconst scratchNdcAabb = new Cartesian4();\nconst scratchScale = new Cartesian3();\nconst scratchLocalScale = new Cartesian3();\nconst scratchRotation = new Matrix3();\nconst scratchRotationAndLocalScale = new Matrix3();\nconst scratchTransformPositionWorldToLocal = new Matrix4();\nconst scratchTransformPositionLocalToWorld = new Matrix4();\nconst scratchTransformPositionLocalToProjection = new Matrix4();\n\nconst transformPositionLocalToUv = Matrix4.fromRotationTranslation(\n  Matrix3.fromUniformScale(0.5, new Matrix3()),\n  new Cartesian3(0.5, 0.5, 0.5),\n  new Matrix4(),\n);\nconst transformPositionUvToLocal = Matrix4.fromRotationTranslation(\n  Matrix3.fromUniformScale(2.0, new Matrix3()),\n  new Cartesian3(-1.0, -1.0, -1.0),\n  new Matrix4(),\n);\n\n/**\n * Updates the voxel primitive.\n *\n * @param {FrameState} frameState\n * @private\n */\nVoxelPrimitive.prototype.update = function (frameState) {\n  const provider = this._provider;\n\n  // Update the custom shader in case it has texture uniforms.\n  this._customShader.update(frameState);\n\n  // Initialize from the ready provider. This only happens once.\n  const context = frameState.context;\n  if (!this._ready) {\n    initFromProvider(this, provider, context);\n    // Set the primitive as ready after the first frame render since the user might set up events subscribed to\n    // the post render event, and the primitive may not be ready for those past the first frame.\n    frameState.afterRender.push(() => {\n      this._ready = true;\n      return true;\n    });\n\n    // Don't render until the next frame after ready is set to true\n    return;\n  }\n\n  updateVerticalExaggeration(this, frameState);\n\n  // Check if the shape is dirty before updating it. This needs to happen every\n  // frame because the member variables can be modified externally via the\n  // getters.\n  const shapeDirty = checkTransformAndBounds(this, provider);\n  const shape = this._shape;\n  if (shapeDirty) {\n    this._shapeVisible = updateShapeAndTransforms(this, shape, provider);\n    if (checkShapeDefines(this, shape)) {\n      this._shaderDirty = true;\n    }\n  }\n  if (!this._shapeVisible) {\n    return;\n  }\n\n  // Update the traversal and prepare for rendering.\n  const keyframeLocation = getKeyframeLocation(\n    provider.timeIntervalCollection,\n    this._clock,\n  );\n\n  const traversal = this._traversal;\n  const sampleCountOld = traversal._sampleCount;\n\n  traversal.update(\n    frameState,\n    keyframeLocation,\n    shapeDirty, // recomputeBoundingVolumes\n    this._disableUpdate, // pauseUpdate\n  );\n\n  if (sampleCountOld !== traversal._sampleCount) {\n    this._shaderDirty = true;\n  }\n\n  if (!traversal.isRenderable(traversal.rootNode)) {\n    return;\n  }\n\n  if (this._debugDraw) {\n    // Debug draw bounding boxes and other things. Must go after traversal update\n    // because that's what updates the tile bounding boxes.\n    debugDraw(this, frameState);\n  }\n\n  if (this._disableRender) {\n    return;\n  }\n\n  // Check if log depth changed\n  if (this._useLogDepth !== frameState.useLogDepth) {\n    this._useLogDepth = frameState.useLogDepth;\n    this._shaderDirty = true;\n  }\n\n  // Check if clipping planes changed\n  const clippingPlanesChanged = updateClippingPlanes(this, frameState);\n  if (clippingPlanesChanged) {\n    this._shaderDirty = true;\n  }\n\n  const leafNodeTexture = traversal.leafNodeTexture;\n  const uniforms = this._uniforms;\n  if (defined(leafNodeTexture)) {\n    uniforms.octreeLeafNodeTexture = traversal.leafNodeTexture;\n    uniforms.octreeLeafNodeTexelSizeUv = Cartesian2.clone(\n      traversal.leafNodeTexelSizeUv,\n      uniforms.octreeLeafNodeTexelSizeUv,\n    );\n    uniforms.octreeLeafNodeTilesPerRow = traversal.leafNodeTilesPerRow;\n  }\n\n  // Rebuild shaders\n  if (this._shaderDirty) {\n    buildVoxelDrawCommands(this, context);\n    this._shaderDirty = false;\n  }\n\n  // Calculate the NDC-space AABB to \"scissor\" the fullscreen quad\n  const transformPositionWorldToProjection =\n    context.uniformState.viewProjection;\n  const orientedBoundingBox = shape.orientedBoundingBox;\n  const ndcAabb = orientedBoundingBoxToNdcAabb(\n    orientedBoundingBox,\n    transformPositionWorldToProjection,\n    scratchNdcAabb,\n  );\n\n  // If the object is offscreen, don't render it.\n  const offscreen =\n    ndcAabb.x === +1.0 ||\n    ndcAabb.y === +1.0 ||\n    ndcAabb.z === -1.0 ||\n    ndcAabb.w === -1.0;\n  if (offscreen) {\n    return;\n  }\n\n  // Prepare to render: update uniforms that can change every frame\n  // Using a uniform instead of going through RenderState's scissor because the viewport is not accessible here, and the scissor command needs pixel coordinates.\n  uniforms.ndcSpaceAxisAlignedBoundingBox = Cartesian4.clone(\n    ndcAabb,\n    uniforms.ndcSpaceAxisAlignedBoundingBox,\n  );\n  const transformPositionViewToWorld = context.uniformState.inverseView;\n  uniforms.transformPositionViewToUv = Matrix4.multiplyTransformation(\n    this._transformPositionWorldToUv,\n    transformPositionViewToWorld,\n    uniforms.transformPositionViewToUv,\n  );\n  const transformPositionWorldToView = context.uniformState.view;\n  uniforms.transformPositionUvToView = Matrix4.multiplyTransformation(\n    transformPositionWorldToView,\n    this._transformPositionUvToWorld,\n    uniforms.transformPositionUvToView,\n  );\n  const transformDirectionViewToWorld =\n    context.uniformState.inverseViewRotation;\n  uniforms.transformDirectionViewToLocal = Matrix3.multiply(\n    this._transformDirectionWorldToLocal,\n    transformDirectionViewToWorld,\n    uniforms.transformDirectionViewToLocal,\n  );\n  uniforms.transformNormalLocalToWorld = Matrix3.clone(\n    this._transformNormalLocalToWorld,\n    uniforms.transformNormalLocalToWorld,\n  );\n  const cameraPositionWorld = frameState.camera.positionWC;\n  uniforms.cameraPositionUv = Matrix4.multiplyByPoint(\n    this._transformPositionWorldToUv,\n    cameraPositionWorld,\n    uniforms.cameraPositionUv,\n  );\n  uniforms.stepSize = this._stepSizeMultiplier;\n\n  // Render the primitive\n  const command = frameState.passes.pick\n    ? this._drawCommandPick\n    : frameState.passes.pickVoxel\n      ? this._drawCommandPickVoxel\n      : this._drawCommand;\n  command.boundingVolume = shape.boundingSphere;\n  frameState.commandList.push(command);\n};\n\nconst scratchExaggerationScale = new Cartesian3();\nconst scratchExaggerationCenter = new Cartesian3();\nconst scratchCartographicCenter = new Cartographic();\nconst scratchExaggerationTranslation = new Cartesian3();\n\n/**\n * Update the exaggerated bounds of a primitive to account for vertical exaggeration\n * Currently only applies to Ellipsoid shape type\n * @param {VoxelPrimitive} primitive\n * @param {FrameState} frameState\n * @private\n */\nfunction updateVerticalExaggeration(primitive, frameState) {\n  primitive._exaggeratedMinBounds = Cartesian3.clone(\n    primitive._minBounds,\n    primitive._exaggeratedMinBounds,\n  );\n  primitive._exaggeratedMaxBounds = Cartesian3.clone(\n    primitive._maxBounds,\n    primitive._exaggeratedMaxBounds,\n  );\n\n  if (primitive.shape === VoxelShapeType.ELLIPSOID) {\n    // Apply the exaggeration by stretching the height bounds\n    const relativeHeight = frameState.verticalExaggerationRelativeHeight;\n    const exaggeration = frameState.verticalExaggeration;\n    primitive._exaggeratedMinBounds.z =\n      (primitive._minBounds.z - relativeHeight) * exaggeration + relativeHeight;\n    primitive._exaggeratedMaxBounds.z =\n      (primitive._maxBounds.z - relativeHeight) * exaggeration + relativeHeight;\n  } else if (primitive.shape === VoxelShapeType.BOX) {\n    // Apply the exaggeration via the model matrix\n    const exaggerationScale = Cartesian3.fromElements(\n      1.0,\n      1.0,\n      frameState.verticalExaggeration,\n      scratchExaggerationScale,\n    );\n    primitive._exaggeratedModelMatrix = Matrix4.multiplyByScale(\n      primitive._modelMatrix,\n      exaggerationScale,\n      primitive._exaggeratedModelMatrix,\n    );\n    primitive._exaggeratedModelMatrix = Matrix4.multiplyByTranslation(\n      primitive._exaggeratedModelMatrix,\n      computeBoxExaggerationTranslation(primitive, frameState),\n      primitive._exaggeratedModelMatrix,\n    );\n  }\n}\n\nfunction computeBoxExaggerationTranslation(primitive, frameState) {\n  // Compute translation based on box center, relative height, and exaggeration\n  const {\n    shapeTransform = Matrix4.IDENTITY,\n    globalTransform = Matrix4.IDENTITY,\n  } = primitive._provider;\n\n  // Find the Cartesian position of the center of the OBB\n  const initialCenter = Matrix4.getTranslation(\n    shapeTransform,\n    scratchExaggerationCenter,\n  );\n  const intermediateCenter = Matrix4.multiplyByPoint(\n    primitive._modelMatrix,\n    initialCenter,\n    scratchExaggerationCenter,\n  );\n  const transformedCenter = Matrix4.multiplyByPoint(\n    globalTransform,\n    intermediateCenter,\n    scratchExaggerationCenter,\n  );\n\n  // Find the cartographic height\n  const ellipsoid = Ellipsoid.WGS84;\n  const centerCartographic = ellipsoid.cartesianToCartographic(\n    transformedCenter,\n    scratchCartographicCenter,\n  );\n\n  let centerHeight = 0.0;\n  if (defined(centerCartographic)) {\n    centerHeight = centerCartographic.height;\n  }\n\n  // Find the shift that will put the center in the right position relative\n  // to relativeHeight, after it is scaled by verticalExaggeration\n  const exaggeratedHeight = VerticalExaggeration.getHeight(\n    centerHeight,\n    frameState.verticalExaggeration,\n    frameState.verticalExaggerationRelativeHeight,\n  );\n\n  return Cartesian3.fromElements(\n    0.0,\n    0.0,\n    (exaggeratedHeight - centerHeight) / frameState.verticalExaggeration,\n    scratchExaggerationTranslation,\n  );\n}\n\n/**\n * Initialize primitive properties that are derived from the voxel provider\n * @param {VoxelPrimitive} primitive\n * @param {VoxelProvider} provider\n * @param {Context} context\n * @private\n */\nfunction initFromProvider(primitive, provider, context) {\n  const uniforms = primitive._uniforms;\n\n  primitive._pickId = context.createPickId({ primitive });\n  uniforms.pickColor = Color.clone(primitive._pickId.color, uniforms.pickColor);\n\n  const { shaderDefines, shaderUniforms: shapeUniforms } = primitive._shape;\n  primitive._shapeDefinesOld = clone(shaderDefines, true);\n\n  // Add shape uniforms to the uniform map\n  const uniformMap = primitive._uniformMap;\n  for (const key in shapeUniforms) {\n    if (shapeUniforms.hasOwnProperty(key)) {\n      const name = `u_${key}`;\n\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(uniformMap[name])) {\n        oneTimeWarning(\n          `VoxelPrimitive: Uniform name \"${name}\" is already defined`,\n        );\n      }\n      //>>includeEnd('debug');\n\n      uniformMap[name] = function () {\n        return shapeUniforms[key];\n      };\n    }\n  }\n\n  // Set uniforms that come from the provider.\n  // Note that minBounds and maxBounds can be set dynamically, so their uniforms aren't set here.\n  uniforms.dimensions = Cartesian3.clone(\n    provider.dimensions,\n    uniforms.dimensions,\n  );\n  primitive._paddingBefore = Cartesian3.clone(\n    defaultValue(provider.paddingBefore, Cartesian3.ZERO),\n    primitive._paddingBefore,\n  );\n  uniforms.paddingBefore = Cartesian3.clone(\n    primitive._paddingBefore,\n    uniforms.paddingBefore,\n  );\n  primitive._paddingAfter = Cartesian3.clone(\n    defaultValue(provider.paddingAfter, Cartesian3.ZERO),\n    primitive._paddingBefore,\n  );\n  uniforms.paddingAfter = Cartesian3.clone(\n    primitive._paddingAfter,\n    uniforms.paddingAfter,\n  );\n\n  // Create the VoxelTraversal, and set related uniforms\n  primitive._traversal = setupTraversal(primitive, provider, context);\n  setTraversalUniforms(primitive._traversal, uniforms);\n}\n\n/**\n * Track changes in provider transform and primitive bounds\n * @param {VoxelPrimitive} primitive\n * @param {VoxelProvider} provider\n * @returns {boolean} Whether any of the transform or bounds changed\n * @private\n */\nfunction checkTransformAndBounds(primitive, provider) {\n  const shapeTransform = defaultValue(\n    provider.shapeTransform,\n    Matrix4.IDENTITY,\n  );\n  const globalTransform = defaultValue(\n    provider.globalTransform,\n    Matrix4.IDENTITY,\n  );\n\n  // Compound model matrix = global transform * model matrix * shape transform\n  Matrix4.multiplyTransformation(\n    globalTransform,\n    primitive._exaggeratedModelMatrix,\n    primitive._compoundModelMatrix,\n  );\n  Matrix4.multiplyTransformation(\n    primitive._compoundModelMatrix,\n    shapeTransform,\n    primitive._compoundModelMatrix,\n  );\n  const numChanges =\n    updateBound(primitive, \"_compoundModelMatrix\", \"_compoundModelMatrixOld\") +\n    updateBound(primitive, \"_minBounds\", \"_minBoundsOld\") +\n    updateBound(primitive, \"_maxBounds\", \"_maxBoundsOld\") +\n    updateBound(\n      primitive,\n      \"_exaggeratedMinBounds\",\n      \"_exaggeratedMinBoundsOld\",\n    ) +\n    updateBound(\n      primitive,\n      \"_exaggeratedMaxBounds\",\n      \"_exaggeratedMaxBoundsOld\",\n    ) +\n    updateBound(primitive, \"_minClippingBounds\", \"_minClippingBoundsOld\") +\n    updateBound(primitive, \"_maxClippingBounds\", \"_maxClippingBoundsOld\");\n  return numChanges > 0;\n}\n\n/**\n * Compare old and new values of a bound and update the old if it is different.\n * @param {VoxelPrimitive} primitive The primitive with bounds properties\n * @param {string} newBoundKey A key pointing to a bounds property of type Cartesian3 or Matrix4\n * @param {string} oldBoundKey A key pointing to a bounds property of the same type as the property at newBoundKey\n * @returns {number} 1 if the bound value changed, 0 otherwise\n *\n * @private\n */\nfunction updateBound(primitive, newBoundKey, oldBoundKey) {\n  const newBound = primitive[newBoundKey];\n  const oldBound = primitive[oldBoundKey];\n\n  const changed = !newBound.equals(oldBound);\n  if (changed) {\n    newBound.clone(oldBound);\n  }\n  return changed ? 1 : 0;\n}\n\n/**\n * Update the shape and related transforms\n * @param {VoxelPrimitive} primitive\n * @param {VoxelShape} shape\n * @param {VoxelProvider} provider\n * @returns {boolean} True if the shape is visible\n * @private\n */\nfunction updateShapeAndTransforms(primitive, shape, provider) {\n  const visible = shape.update(\n    primitive._compoundModelMatrix,\n    primitive._exaggeratedMinBounds,\n    primitive._exaggeratedMaxBounds,\n    primitive.minClippingBounds,\n    primitive.maxClippingBounds,\n  );\n  if (!visible) {\n    return false;\n  }\n\n  const transformPositionLocalToWorld = shape.shapeTransform;\n  const transformPositionWorldToLocal = Matrix4.inverse(\n    transformPositionLocalToWorld,\n    scratchTransformPositionWorldToLocal,\n  );\n  const rotation = Matrix4.getRotation(\n    transformPositionLocalToWorld,\n    scratchRotation,\n  );\n  // Note that inverse(rotation) is the same as transpose(rotation)\n  const scale = Matrix4.getScale(transformPositionLocalToWorld, scratchScale);\n  const maximumScaleComponent = Cartesian3.maximumComponent(scale);\n  const localScale = Cartesian3.divideByScalar(\n    scale,\n    maximumScaleComponent,\n    scratchLocalScale,\n  );\n  const rotationAndLocalScale = Matrix3.multiplyByScale(\n    rotation,\n    localScale,\n    scratchRotationAndLocalScale,\n  );\n\n  // Set member variables when the shape is dirty\n  primitive._transformPositionWorldToUv = Matrix4.multiplyTransformation(\n    transformPositionLocalToUv,\n    transformPositionWorldToLocal,\n    primitive._transformPositionWorldToUv,\n  );\n  primitive._transformPositionUvToWorld = Matrix4.multiplyTransformation(\n    transformPositionLocalToWorld,\n    transformPositionUvToLocal,\n    primitive._transformPositionUvToWorld,\n  );\n  primitive._transformDirectionWorldToLocal = Matrix4.getMatrix3(\n    transformPositionWorldToLocal,\n    primitive._transformDirectionWorldToLocal,\n  );\n  primitive._transformNormalLocalToWorld = Matrix3.inverseTranspose(\n    rotationAndLocalScale,\n    primitive._transformNormalLocalToWorld,\n  );\n\n  return true;\n}\n\n/**\n * Set up a VoxelTraversal based on dimensions and types from the primitive and provider\n * @param {VoxelPrimitive} primitive\n * @param {VoxelProvider} provider\n * @param {Context} context\n * @returns {VoxelTraversal}\n * @private\n */\nfunction setupTraversal(primitive, provider, context) {\n  const dimensions = Cartesian3.clone(provider.dimensions, scratchDimensions);\n  Cartesian3.add(dimensions, primitive._paddingBefore, dimensions);\n  Cartesian3.add(dimensions, primitive._paddingAfter, dimensions);\n\n  // It's ok for memory byte length to be undefined.\n  // The system will choose a default memory size.\n  const maximumTileCount = provider.maximumTileCount;\n  const maximumTextureMemoryByteLength = defined(maximumTileCount)\n    ? VoxelTraversal.getApproximateTextureMemoryByteLength(\n        maximumTileCount,\n        dimensions,\n        provider.types,\n        provider.componentTypes,\n      )\n    : undefined;\n\n  const keyframeCount = defaultValue(provider.keyframeCount, 1);\n\n  return new VoxelTraversal(\n    primitive,\n    context,\n    dimensions,\n    provider.types,\n    provider.componentTypes,\n    keyframeCount,\n    maximumTextureMemoryByteLength,\n  );\n}\n\n/**\n * Set uniforms that come from the traversal.\n * @param {VoxelTraversal} traversal\n * @param {object} uniforms\n * @private\n */\nfunction setTraversalUniforms(traversal, uniforms) {\n  uniforms.octreeInternalNodeTexture = traversal.internalNodeTexture;\n  uniforms.octreeInternalNodeTexelSizeUv = Cartesian2.clone(\n    traversal.internalNodeTexelSizeUv,\n    uniforms.octreeInternalNodeTexelSizeUv,\n  );\n  uniforms.octreeInternalNodeTilesPerRow = traversal.internalNodeTilesPerRow;\n\n  const megatextures = traversal.megatextures;\n  const megatexture = megatextures[0];\n  const megatextureLength = megatextures.length;\n  uniforms.megatextureTextures = new Array(megatextureLength);\n  for (let i = 0; i < megatextureLength; i++) {\n    uniforms.megatextureTextures[i] = megatextures[i].texture;\n  }\n\n  uniforms.megatextureSliceDimensions = Cartesian2.clone(\n    megatexture.sliceCountPerRegion,\n    uniforms.megatextureSliceDimensions,\n  );\n  uniforms.megatextureTileDimensions = Cartesian2.clone(\n    megatexture.regionCountPerMegatexture,\n    uniforms.megatextureTileDimensions,\n  );\n  uniforms.megatextureVoxelSizeUv = Cartesian2.clone(\n    megatexture.voxelSizeUv,\n    uniforms.megatextureVoxelSizeUv,\n  );\n  uniforms.megatextureSliceSizeUv = Cartesian2.clone(\n    megatexture.sliceSizeUv,\n    uniforms.megatextureSliceSizeUv,\n  );\n  uniforms.megatextureTileSizeUv = Cartesian2.clone(\n    megatexture.regionSizeUv,\n    uniforms.megatextureTileSizeUv,\n  );\n}\n\n/**\n * Track changes in shape-related shader defines\n * @param {VoxelPrimitive} primitive\n * @param {VoxelShape} shape\n * @returns {boolean} True if any of the shape defines changed, requiring a shader rebuild\n * @private\n */\nfunction checkShapeDefines(primitive, shape) {\n  const shapeDefines = shape.shaderDefines;\n  const shapeDefinesChanged = Object.keys(shapeDefines).some(\n    (key) => shapeDefines[key] !== primitive._shapeDefinesOld[key],\n  );\n  if (shapeDefinesChanged) {\n    primitive._shapeDefinesOld = clone(shapeDefines, true);\n  }\n  return shapeDefinesChanged;\n}\n\n/**\n * Find the keyframe location to render at. Doesn't need to be a whole number.\n * @param {TimeIntervalCollection} timeIntervalCollection\n * @param {Clock} clock\n * @returns {number}\n *\n * @private\n */\nfunction getKeyframeLocation(timeIntervalCollection, clock) {\n  if (!defined(timeIntervalCollection) || !defined(clock)) {\n    return 0.0;\n  }\n  let date = clock.currentTime;\n  let timeInterval;\n  let timeIntervalIndex = timeIntervalCollection.indexOf(date);\n  if (timeIntervalIndex >= 0) {\n    timeInterval = timeIntervalCollection.get(timeIntervalIndex);\n  } else {\n    // Date fell outside the range\n    timeIntervalIndex = ~timeIntervalIndex;\n    if (timeIntervalIndex === timeIntervalCollection.length) {\n      // Date past range\n      timeIntervalIndex = timeIntervalCollection.length - 1;\n      timeInterval = timeIntervalCollection.get(timeIntervalIndex);\n      date = timeInterval.stop;\n    } else {\n      // Date before range\n      timeInterval = timeIntervalCollection.get(timeIntervalIndex);\n      date = timeInterval.start;\n    }\n  }\n  // De-lerp between the start and end of the interval\n  const totalSeconds = JulianDate.secondsDifference(\n    timeInterval.stop,\n    timeInterval.start,\n  );\n  const secondsDifferenceStart = JulianDate.secondsDifference(\n    date,\n    timeInterval.start,\n  );\n  const t = secondsDifferenceStart / totalSeconds;\n\n  return timeIntervalIndex + t;\n}\n\n/**\n * Update the clipping planes state and associated uniforms\n *\n * @param {VoxelPrimitive} primitive\n * @param {FrameState} frameState\n * @returns {boolean} Whether the clipping planes changed, requiring a shader rebuild\n * @private\n */\nfunction updateClippingPlanes(primitive, frameState) {\n  const clippingPlanes = primitive.clippingPlanes;\n  if (!defined(clippingPlanes)) {\n    return false;\n  }\n\n  clippingPlanes.update(frameState);\n\n  const { clippingPlanesState, enabled } = clippingPlanes;\n\n  if (enabled) {\n    const uniforms = primitive._uniforms;\n    uniforms.clippingPlanesTexture = clippingPlanes.texture;\n\n    // Compute the clipping plane's transformation to uv space and then take the inverse\n    // transpose to properly transform the hessian normal form of the plane.\n\n    // transpose(inverse(worldToUv * clippingPlaneLocalToWorld))\n    // transpose(inverse(clippingPlaneLocalToWorld) * inverse(worldToUv))\n    // transpose(inverse(clippingPlaneLocalToWorld) * uvToWorld)\n\n    uniforms.clippingPlanesMatrix = Matrix4.transpose(\n      Matrix4.multiplyTransformation(\n        Matrix4.inverse(\n          clippingPlanes.modelMatrix,\n          uniforms.clippingPlanesMatrix,\n        ),\n        primitive._transformPositionUvToWorld,\n        uniforms.clippingPlanesMatrix,\n      ),\n      uniforms.clippingPlanesMatrix,\n    );\n  }\n\n  if (\n    primitive._clippingPlanesState === clippingPlanesState &&\n    primitive._clippingPlanesEnabled === enabled\n  ) {\n    return false;\n  }\n  primitive._clippingPlanesState = clippingPlanesState;\n  primitive._clippingPlanesEnabled = enabled;\n\n  return true;\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see VoxelPrimitive#destroy\n */\nVoxelPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see VoxelPrimitive#isDestroyed\n *\n * @example\n * voxelPrimitive = voxelPrimitive && voxelPrimitive.destroy();\n */\nVoxelPrimitive.prototype.destroy = function () {\n  const drawCommand = this._drawCommand;\n  if (defined(drawCommand)) {\n    drawCommand.shaderProgram =\n      drawCommand.shaderProgram && drawCommand.shaderProgram.destroy();\n  }\n  const drawCommandPick = this._drawCommandPick;\n  if (defined(drawCommandPick)) {\n    drawCommandPick.shaderProgram =\n      drawCommandPick.shaderProgram && drawCommandPick.shaderProgram.destroy();\n  }\n\n  this._pickId = this._pickId && this._pickId.destroy();\n  this._traversal = this._traversal && this._traversal.destroy();\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n\n  return destroyObject(this);\n};\n\nconst corners = new Array(\n  new Cartesian4(-1.0, -1.0, -1.0, 1.0),\n  new Cartesian4(+1.0, -1.0, -1.0, 1.0),\n  new Cartesian4(-1.0, +1.0, -1.0, 1.0),\n  new Cartesian4(+1.0, +1.0, -1.0, 1.0),\n  new Cartesian4(-1.0, -1.0, +1.0, 1.0),\n  new Cartesian4(+1.0, -1.0, +1.0, 1.0),\n  new Cartesian4(-1.0, +1.0, +1.0, 1.0),\n  new Cartesian4(+1.0, +1.0, +1.0, 1.0),\n);\nconst vertexNeighborIndices = new Array(\n  1,\n  2,\n  4,\n  0,\n  3,\n  5,\n  0,\n  3,\n  6,\n  1,\n  2,\n  7,\n  0,\n  5,\n  6,\n  1,\n  4,\n  7,\n  2,\n  4,\n  7,\n  3,\n  5,\n  6,\n);\n\nconst scratchCornersClipSpace = new Array(\n  new Cartesian4(),\n  new Cartesian4(),\n  new Cartesian4(),\n  new Cartesian4(),\n  new Cartesian4(),\n  new Cartesian4(),\n  new Cartesian4(),\n  new Cartesian4(),\n);\n\n/**\n * Projects all 8 corners of the oriented bounding box to NDC space and finds the\n * resulting NDC axis aligned bounding box. To avoid projecting a vertex that is\n * behind the near plane, it uses the intersection point of each of the vertex's\n * edges against the near plane as part of the AABB calculation. This is done in\n * clip space prior to perspective division.\n *\n * @function\n *\n * @param {OrientedBoundingBox} orientedBoundingBox\n * @param {Matrix4} worldToProjection\n * @param {Cartesian4} result\n * @returns {Cartesian4}\n *\n * @private\n */\nfunction orientedBoundingBoxToNdcAabb(\n  orientedBoundingBox,\n  worldToProjection,\n  result,\n) {\n  const transformPositionLocalToWorld = Matrix4.fromRotationTranslation(\n    orientedBoundingBox.halfAxes,\n    orientedBoundingBox.center,\n    scratchTransformPositionLocalToWorld,\n  );\n  const transformPositionLocalToProjection = Matrix4.multiply(\n    worldToProjection,\n    transformPositionLocalToWorld,\n    scratchTransformPositionLocalToProjection,\n  );\n\n  let ndcMinX = +Number.MAX_VALUE;\n  let ndcMaxX = -Number.MAX_VALUE;\n  let ndcMinY = +Number.MAX_VALUE;\n  let ndcMaxY = -Number.MAX_VALUE;\n  let cornerIndex;\n\n  // Convert all points to clip space\n  const cornersClipSpace = scratchCornersClipSpace;\n  const cornersLength = corners.length;\n  for (cornerIndex = 0; cornerIndex < cornersLength; cornerIndex++) {\n    Matrix4.multiplyByVector(\n      transformPositionLocalToProjection,\n      corners[cornerIndex],\n      cornersClipSpace[cornerIndex],\n    );\n  }\n\n  for (cornerIndex = 0; cornerIndex < cornersLength; cornerIndex++) {\n    const position = cornersClipSpace[cornerIndex];\n    if (position.z >= -position.w) {\n      // Position is past near plane, so there's no need to clip.\n      const ndcX = position.x / position.w;\n      const ndcY = position.y / position.w;\n      ndcMinX = Math.min(ndcMinX, ndcX);\n      ndcMaxX = Math.max(ndcMaxX, ndcX);\n      ndcMinY = Math.min(ndcMinY, ndcY);\n      ndcMaxY = Math.max(ndcMaxY, ndcY);\n    } else {\n      for (let neighborIndex = 0; neighborIndex < 3; neighborIndex++) {\n        const neighborVertexIndex =\n          vertexNeighborIndices[cornerIndex * 3 + neighborIndex];\n        const neighborPosition = cornersClipSpace[neighborVertexIndex];\n        if (neighborPosition.z >= -neighborPosition.w) {\n          // Position is behind the near plane and neighbor is after, so get intersection point on the near plane.\n          const distanceToPlaneFromPosition = position.z + position.w;\n          const distanceToPlaneFromNeighbor =\n            neighborPosition.z + neighborPosition.w;\n          const t =\n            distanceToPlaneFromPosition /\n            (distanceToPlaneFromPosition - distanceToPlaneFromNeighbor);\n\n          const intersect = Cartesian4.lerp(\n            position,\n            neighborPosition,\n            t,\n            scratchIntersect,\n          );\n          const intersectNdcX = intersect.x / intersect.w;\n          const intersectNdcY = intersect.y / intersect.w;\n          ndcMinX = Math.min(ndcMinX, intersectNdcX);\n          ndcMaxX = Math.max(ndcMaxX, intersectNdcX);\n          ndcMinY = Math.min(ndcMinY, intersectNdcY);\n          ndcMaxY = Math.max(ndcMaxY, intersectNdcY);\n        }\n      }\n    }\n  }\n\n  // Clamp the NDC values to -1 to +1 range even if they extend much further.\n  ndcMinX = CesiumMath.clamp(ndcMinX, -1.0, +1.0);\n  ndcMinY = CesiumMath.clamp(ndcMinY, -1.0, +1.0);\n  ndcMaxX = CesiumMath.clamp(ndcMaxX, -1.0, +1.0);\n  ndcMaxY = CesiumMath.clamp(ndcMaxY, -1.0, +1.0);\n  result = Cartesian4.fromElements(ndcMinX, ndcMinY, ndcMaxX, ndcMaxY, result);\n\n  return result;\n}\n\nconst polylineAxisDistance = 30000000.0;\nconst polylineXAxis = new Cartesian3(polylineAxisDistance, 0.0, 0.0);\nconst polylineYAxis = new Cartesian3(0.0, polylineAxisDistance, 0.0);\nconst polylineZAxis = new Cartesian3(0.0, 0.0, polylineAxisDistance);\n\n/**\n * Draws the tile bounding boxes and axes.\n *\n * @function\n *\n * @param {VoxelPrimitive} that\n * @param {FrameState} frameState\n *\n * @private\n */\nfunction debugDraw(that, frameState) {\n  const traversal = that._traversal;\n  const polylines = that._debugPolylines;\n  polylines.removeAll();\n\n  function makePolylineLineSegment(startPos, endPos, color, thickness) {\n    polylines.add({\n      positions: [startPos, endPos],\n      width: thickness,\n      material: Material.fromType(\"Color\", {\n        color: color,\n      }),\n    });\n  }\n\n  function makePolylineBox(orientedBoundingBox, color, thickness) {\n    // Normally would want to use a scratch variable to store the corners, but\n    // polylines don't clone the positions.\n    const corners = orientedBoundingBox.computeCorners();\n    makePolylineLineSegment(corners[0], corners[1], color, thickness);\n    makePolylineLineSegment(corners[2], corners[3], color, thickness);\n    makePolylineLineSegment(corners[4], corners[5], color, thickness);\n    makePolylineLineSegment(corners[6], corners[7], color, thickness);\n    makePolylineLineSegment(corners[0], corners[2], color, thickness);\n    makePolylineLineSegment(corners[4], corners[6], color, thickness);\n    makePolylineLineSegment(corners[1], corners[3], color, thickness);\n    makePolylineLineSegment(corners[5], corners[7], color, thickness);\n    makePolylineLineSegment(corners[0], corners[4], color, thickness);\n    makePolylineLineSegment(corners[2], corners[6], color, thickness);\n    makePolylineLineSegment(corners[1], corners[5], color, thickness);\n    makePolylineLineSegment(corners[3], corners[7], color, thickness);\n  }\n\n  function drawTile(tile) {\n    if (!traversal.isRenderable(tile)) {\n      return;\n    }\n\n    const level = tile.level;\n    const startThickness = 5.0;\n    const thickness = Math.max(1.0, startThickness / Math.pow(2.0, level));\n    const colors = [Color.RED, Color.LIME, Color.BLUE];\n    const color = colors[level % 3];\n\n    makePolylineBox(tile.orientedBoundingBox, color, thickness);\n\n    if (defined(tile.children)) {\n      for (let i = 0; i < 8; i++) {\n        drawTile(tile.children[i]);\n      }\n    }\n  }\n\n  makePolylineBox(that._shape.orientedBoundingBox, Color.WHITE, 5.0);\n\n  drawTile(traversal.rootNode);\n\n  const axisThickness = 10.0;\n  makePolylineLineSegment(\n    Cartesian3.ZERO,\n    polylineXAxis,\n    Color.RED,\n    axisThickness,\n  );\n  makePolylineLineSegment(\n    Cartesian3.ZERO,\n    polylineYAxis,\n    Color.LIME,\n    axisThickness,\n  );\n  makePolylineLineSegment(\n    Cartesian3.ZERO,\n    polylineZAxis,\n    Color.BLUE,\n    axisThickness,\n  );\n\n  polylines.update(frameState);\n}\n\n/**\n * The default custom shader used by the primitive.\n *\n * @type {CustomShader}\n * @constant\n * @readonly\n *\n * @private\n */\nVoxelPrimitive.DefaultCustomShader = new CustomShader({\n  fragmentShaderText: `void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material)\n{\n    material.diffuse = vec3(1.0);\n    material.alpha = 1.0;\n}`,\n});\n\nfunction DefaultVoxelProvider() {\n  this.ready = true;\n  this.shape = VoxelShapeType.BOX;\n  this.dimensions = new Cartesian3(1, 1, 1);\n  this.names = [\"data\"];\n  this.types = [MetadataType.SCALAR];\n  this.componentTypes = [MetadataComponentType.FLOAT32];\n  this.maximumTileCount = 1;\n}\n\nDefaultVoxelProvider.prototype.requestData = function (options) {\n  const tileLevel = defined(options) ? defaultValue(options.tileLevel, 0) : 0;\n  if (tileLevel >= 1) {\n    return undefined;\n  }\n\n  return Promise.resolve([new Float32Array(1)]);\n};\n\nVoxelPrimitive.DefaultProvider = new DefaultVoxelProvider();\n\nexport default VoxelPrimitive;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}