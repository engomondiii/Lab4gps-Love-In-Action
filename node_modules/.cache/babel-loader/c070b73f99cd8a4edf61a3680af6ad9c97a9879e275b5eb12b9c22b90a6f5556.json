{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport Cesium3DTileFeatureTable from \"./Cesium3DTileFeatureTable.js\";\nimport VertexAttributeSemantic from \"./VertexAttributeSemantic.js\";\n\n/**\n * Handles parsing of a Point Cloud\n *\n * @namespace PntsParser\n * @private\n */\nconst PntsParser = {};\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\n/**\n * Parses the contents of a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/PointCloud|Point Cloud}.\n *\n * @private\n *\n * @param {*} arrayBuffer The array buffer containing the pnts\n * @param {*} [byteOffset=0] The byte offset of the beginning of the pnts in the array buffer\n * @returns {object} An object containing a parsed representation of the point cloud\n */\nPntsParser.parse = function (arrayBuffer, byteOffset) {\n  byteOffset = defaultValue(byteOffset, 0);\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic\n\n  const version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(`Only Point Cloud tile version 1 is supported.  Version ${version} is not.`);\n  }\n  byteOffset += sizeOfUint32;\n\n  // Skip byteLength\n  byteOffset += sizeOfUint32;\n  const featureTableJsonByteLength = view.getUint32(byteOffset, true);\n  if (featureTableJsonByteLength === 0) {\n    throw new RuntimeError(\"Feature table must have a byte length greater than zero\");\n  }\n  byteOffset += sizeOfUint32;\n  const featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const featureTableJson = getJsonFromTypedArray(uint8Array, byteOffset, featureTableJsonByteLength);\n  byteOffset += featureTableJsonByteLength;\n  const featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);\n  byteOffset += featureTableBinaryByteLength;\n\n  // Get the batch table JSON and binary\n  let batchTableJson;\n  let batchTableBinary;\n  if (batchTableJsonByteLength > 0) {\n    // Has a batch table JSON\n    batchTableJson = getJsonFromTypedArray(uint8Array, byteOffset, batchTableJsonByteLength);\n    byteOffset += batchTableJsonByteLength;\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n  const featureTable = new Cesium3DTileFeatureTable(featureTableJson, featureTableBinary);\n  const pointsLength = featureTable.getGlobalProperty(\"POINTS_LENGTH\");\n  featureTable.featuresLength = pointsLength;\n  if (!defined(pointsLength)) {\n    throw new RuntimeError(\"Feature table global property: POINTS_LENGTH must be defined\");\n  }\n  let rtcCenter = featureTable.getGlobalProperty(\"RTC_CENTER\", ComponentDatatype.FLOAT, 3);\n  if (defined(rtcCenter)) {\n    rtcCenter = Cartesian3.unpack(rtcCenter);\n  }\n\n  // Start with the draco compressed properties and add in uncompressed\n  // properties.\n  const parsedContent = parseDracoProperties(featureTable, batchTableJson);\n  parsedContent.rtcCenter = rtcCenter;\n  parsedContent.pointsLength = pointsLength;\n  if (!parsedContent.hasPositions) {\n    const positions = parsePositions(featureTable);\n    parsedContent.positions = positions;\n    parsedContent.hasPositions = parsedContent.hasPositions || defined(positions);\n  }\n  if (!parsedContent.hasPositions) {\n    throw new RuntimeError(\"Either POSITION or POSITION_QUANTIZED must be defined.\");\n  }\n  if (!parsedContent.hasNormals) {\n    const normals = parseNormals(featureTable);\n    parsedContent.normals = normals;\n    parsedContent.hasNormals = parsedContent.hasNormals || defined(normals);\n  }\n  if (!parsedContent.hasColors) {\n    const colors = parseColors(featureTable);\n    parsedContent.colors = colors;\n    parsedContent.hasColors = parsedContent.hasColors || defined(colors);\n    parsedContent.hasConstantColor = defined(parsedContent.constantColor);\n    parsedContent.isTranslucent = defined(colors) && colors.isTranslucent;\n  }\n  if (!parsedContent.hasBatchIds) {\n    const batchIds = parseBatchIds(featureTable);\n    parsedContent.batchIds = batchIds;\n    parsedContent.hasBatchIds = parsedContent.hasBatchIds || defined(batchIds);\n  }\n  if (parsedContent.hasBatchIds) {\n    const batchLength = featureTable.getGlobalProperty(\"BATCH_LENGTH\");\n    if (!defined(batchLength)) {\n      throw new RuntimeError(\"Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.\");\n    }\n    parsedContent.batchLength = batchLength;\n  }\n  if (defined(batchTableBinary)) {\n    // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n    batchTableBinary = new Uint8Array(batchTableBinary);\n    parsedContent.batchTableJson = batchTableJson;\n    parsedContent.batchTableBinary = batchTableBinary;\n  }\n  return parsedContent;\n};\nfunction parseDracoProperties(featureTable, batchTableJson) {\n  const featureTableJson = featureTable.json;\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n  const featureTableDraco = defined(featureTableJson.extensions) ? featureTableJson.extensions[\"3DTILES_draco_point_compression\"] : undefined;\n  const batchTableDraco = defined(batchTableJson) && defined(batchTableJson.extensions) ? batchTableJson.extensions[\"3DTILES_draco_point_compression\"] : undefined;\n  if (defined(batchTableDraco)) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n  let hasPositions;\n  let hasColors;\n  let hasNormals;\n  let hasBatchIds;\n  let isTranslucent;\n  if (defined(featureTableDraco)) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!defined(dracoFeatureTableProperties) || !defined(dracoByteOffset) || !defined(dracoByteLength)) {\n      throw new RuntimeError(\"Draco properties, byteOffset, and byteLength must be defined\");\n    }\n    dracoBuffer = featureTable.buffer.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);\n    hasPositions = defined(dracoFeatureTableProperties.POSITION);\n    hasColors = defined(dracoFeatureTableProperties.RGB) || defined(dracoFeatureTableProperties.RGBA);\n    hasNormals = defined(dracoFeatureTableProperties.NORMAL);\n    hasBatchIds = defined(dracoFeatureTableProperties.BATCH_ID);\n    isTranslucent = defined(dracoFeatureTableProperties.RGBA);\n  }\n  let draco;\n  if (defined(dracoBuffer)) {\n    draco = {\n      buffer: dracoBuffer,\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      properties: combine(dracoFeatureTableProperties, dracoBatchTableProperties),\n      dequantizeInShader: true\n    };\n  }\n  return {\n    draco: draco,\n    hasPositions: hasPositions,\n    hasColors: hasColors,\n    isTranslucent: isTranslucent,\n    hasNormals: hasNormals,\n    hasBatchIds: hasBatchIds\n  };\n}\nfunction parsePositions(featureTable) {\n  const featureTableJson = featureTable.json;\n  let positions;\n  if (defined(featureTableJson.POSITION)) {\n    positions = featureTable.getPropertyArray(\"POSITION\", ComponentDatatype.FLOAT, 3);\n    return {\n      name: VertexAttributeSemantic.POSITION,\n      semantic: VertexAttributeSemantic.POSITION,\n      typedArray: positions,\n      isQuantized: false,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3\n    };\n  } else if (defined(featureTableJson.POSITION_QUANTIZED)) {\n    positions = featureTable.getPropertyArray(\"POSITION_QUANTIZED\", ComponentDatatype.UNSIGNED_SHORT, 3);\n    const quantizedVolumeScale = featureTable.getGlobalProperty(\"QUANTIZED_VOLUME_SCALE\", ComponentDatatype.FLOAT, 3);\n    if (!defined(quantizedVolumeScale)) {\n      throw new RuntimeError(\"Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\");\n    }\n    const quantizedRange = (1 << 16) - 1;\n    const quantizedVolumeOffset = featureTable.getGlobalProperty(\"QUANTIZED_VOLUME_OFFSET\", ComponentDatatype.FLOAT, 3);\n    if (!defined(quantizedVolumeOffset)) {\n      throw new RuntimeError(\"Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\");\n    }\n    return {\n      name: VertexAttributeSemantic.POSITION,\n      semantic: VertexAttributeSemantic.POSITION,\n      typedArray: positions,\n      isQuantized: true,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      quantizedRange: quantizedRange,\n      quantizedVolumeOffset: Cartesian3.unpack(quantizedVolumeOffset),\n      quantizedVolumeScale: Cartesian3.unpack(quantizedVolumeScale),\n      quantizedComponentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n      quantizedType: AttributeType.VEC3\n    };\n  }\n}\nfunction parseColors(featureTable) {\n  const featureTableJson = featureTable.json;\n  let colors;\n  if (defined(featureTableJson.RGBA)) {\n    colors = featureTable.getPropertyArray(\"RGBA\", ComponentDatatype.UNSIGNED_BYTE, 4);\n    return {\n      name: VertexAttributeSemantic.COLOR,\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: colors,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC4,\n      normalized: true,\n      isRGB565: false,\n      isTranslucent: true\n    };\n  } else if (defined(featureTableJson.RGB)) {\n    colors = featureTable.getPropertyArray(\"RGB\", ComponentDatatype.UNSIGNED_BYTE, 3);\n    return {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: colors,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC3,\n      normalized: true,\n      isRGB565: false,\n      isTranslucent: false\n    };\n  } else if (defined(featureTableJson.RGB565)) {\n    colors = featureTable.getPropertyArray(\"RGB565\", ComponentDatatype.UNSIGNED_SHORT, 1);\n    return {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: colors,\n      // These settings are for the Model implementation\n      // which decodes on the CPU and uploads a VEC3 of float colors.\n      // PointCloud does the decoding on the GPU so uploads a\n      // UNSIGNED_SHORT instead.\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      normalized: false,\n      isRGB565: true,\n      isTranslucent: false\n    };\n  } else if (defined(featureTableJson.CONSTANT_RGBA)) {\n    const constantRGBA = featureTable.getGlobalProperty(\"CONSTANT_RGBA\", ComponentDatatype.UNSIGNED_BYTE, 4);\n    const alpha = constantRGBA[3];\n    const constantColor = Color.fromBytes(constantRGBA[0], constantRGBA[1], constantRGBA[2], alpha);\n    const isTranslucent = alpha < 255;\n    return {\n      name: VertexAttributeSemantic.COLOR,\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      constantColor: constantColor,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC4,\n      isQuantized: false,\n      isTranslucent: isTranslucent\n    };\n  }\n  return undefined;\n}\nfunction parseNormals(featureTable) {\n  const featureTableJson = featureTable.json;\n  let normals;\n  if (defined(featureTableJson.NORMAL)) {\n    normals = featureTable.getPropertyArray(\"NORMAL\", ComponentDatatype.FLOAT, 3);\n    return {\n      name: VertexAttributeSemantic.NORMAL,\n      semantic: VertexAttributeSemantic.NORMAL,\n      typedArray: normals,\n      octEncoded: false,\n      octEncodedZXY: false,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3\n    };\n  } else if (defined(featureTableJson.NORMAL_OCT16P)) {\n    normals = featureTable.getPropertyArray(\"NORMAL_OCT16P\", ComponentDatatype.UNSIGNED_BYTE, 2);\n    const quantizationBits = 8;\n    return {\n      name: VertexAttributeSemantic.NORMAL,\n      semantic: VertexAttributeSemantic.NORMAL,\n      typedArray: normals,\n      octEncoded: true,\n      octEncodedZXY: false,\n      quantizedRange: (1 << quantizationBits) - 1,\n      quantizedType: AttributeType.VEC2,\n      quantizedComponentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3\n    };\n  }\n  return undefined;\n}\nfunction parseBatchIds(featureTable) {\n  const featureTableJson = featureTable.json;\n  if (defined(featureTableJson.BATCH_ID)) {\n    const batchIds = featureTable.getPropertyArray(\"BATCH_ID\", ComponentDatatype.UNSIGNED_SHORT, 1);\n    return {\n      name: VertexAttributeSemantic.FEATURE_ID,\n      semantic: VertexAttributeSemantic.FEATURE_ID,\n      setIndex: 0,\n      typedArray: batchIds,\n      componentDatatype: ComponentDatatype.fromTypedArray(batchIds),\n      type: AttributeType.SCALAR\n    };\n  }\n  return undefined;\n}\nexport default PntsParser;","map":{"version":3,"names":["Cartesian3","Check","Color","combine","ComponentDatatype","defaultValue","defined","getJsonFromTypedArray","RuntimeError","AttributeType","Cesium3DTileFeatureTable","VertexAttributeSemantic","PntsParser","sizeOfUint32","Uint32Array","BYTES_PER_ELEMENT","parse","arrayBuffer","byteOffset","uint8Array","Uint8Array","view","DataView","version","getUint32","featureTableJsonByteLength","featureTableBinaryByteLength","batchTableJsonByteLength","batchTableBinaryByteLength","featureTableJson","featureTableBinary","batchTableJson","batchTableBinary","featureTable","pointsLength","getGlobalProperty","featuresLength","rtcCenter","FLOAT","unpack","parsedContent","parseDracoProperties","hasPositions","positions","parsePositions","hasNormals","normals","parseNormals","hasColors","colors","parseColors","hasConstantColor","constantColor","isTranslucent","hasBatchIds","batchIds","parseBatchIds","batchLength","json","dracoBuffer","dracoFeatureTableProperties","dracoBatchTableProperties","featureTableDraco","extensions","undefined","batchTableDraco","properties","dracoByteOffset","dracoByteLength","byteLength","buffer","slice","POSITION","RGB","RGBA","NORMAL","BATCH_ID","draco","featureTableProperties","batchTableProperties","dequantizeInShader","getPropertyArray","name","semantic","typedArray","isQuantized","componentDatatype","type","VEC3","POSITION_QUANTIZED","UNSIGNED_SHORT","quantizedVolumeScale","quantizedRange","quantizedVolumeOffset","quantizedComponentDatatype","quantizedType","UNSIGNED_BYTE","COLOR","setIndex","VEC4","normalized","isRGB565","RGB565","CONSTANT_RGBA","constantRGBA","alpha","fromBytes","octEncoded","octEncodedZXY","NORMAL_OCT16P","quantizationBits","VEC2","FEATURE_ID","fromTypedArray","SCALAR"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/PntsParser.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport Cesium3DTileFeatureTable from \"./Cesium3DTileFeatureTable.js\";\nimport VertexAttributeSemantic from \"./VertexAttributeSemantic.js\";\n\n/**\n * Handles parsing of a Point Cloud\n *\n * @namespace PntsParser\n * @private\n */\nconst PntsParser = {};\n\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\n/**\n * Parses the contents of a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/PointCloud|Point Cloud}.\n *\n * @private\n *\n * @param {*} arrayBuffer The array buffer containing the pnts\n * @param {*} [byteOffset=0] The byte offset of the beginning of the pnts in the array buffer\n * @returns {object} An object containing a parsed representation of the point cloud\n */\nPntsParser.parse = function (arrayBuffer, byteOffset) {\n  byteOffset = defaultValue(byteOffset, 0);\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic\n\n  const version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(\n      `Only Point Cloud tile version 1 is supported.  Version ${version} is not.`,\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  // Skip byteLength\n  byteOffset += sizeOfUint32;\n\n  const featureTableJsonByteLength = view.getUint32(byteOffset, true);\n  if (featureTableJsonByteLength === 0) {\n    throw new RuntimeError(\n      \"Feature table must have a byte length greater than zero\",\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  const featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  const batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  const featureTableJson = getJsonFromTypedArray(\n    uint8Array,\n    byteOffset,\n    featureTableJsonByteLength,\n  );\n  byteOffset += featureTableJsonByteLength;\n\n  const featureTableBinary = new Uint8Array(\n    arrayBuffer,\n    byteOffset,\n    featureTableBinaryByteLength,\n  );\n  byteOffset += featureTableBinaryByteLength;\n\n  // Get the batch table JSON and binary\n  let batchTableJson;\n  let batchTableBinary;\n  if (batchTableJsonByteLength > 0) {\n    // Has a batch table JSON\n    batchTableJson = getJsonFromTypedArray(\n      uint8Array,\n      byteOffset,\n      batchTableJsonByteLength,\n    );\n    byteOffset += batchTableJsonByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(\n        arrayBuffer,\n        byteOffset,\n        batchTableBinaryByteLength,\n      );\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  const featureTable = new Cesium3DTileFeatureTable(\n    featureTableJson,\n    featureTableBinary,\n  );\n\n  const pointsLength = featureTable.getGlobalProperty(\"POINTS_LENGTH\");\n  featureTable.featuresLength = pointsLength;\n\n  if (!defined(pointsLength)) {\n    throw new RuntimeError(\n      \"Feature table global property: POINTS_LENGTH must be defined\",\n    );\n  }\n\n  let rtcCenter = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3,\n  );\n  if (defined(rtcCenter)) {\n    rtcCenter = Cartesian3.unpack(rtcCenter);\n  }\n\n  // Start with the draco compressed properties and add in uncompressed\n  // properties.\n  const parsedContent = parseDracoProperties(featureTable, batchTableJson);\n  parsedContent.rtcCenter = rtcCenter;\n  parsedContent.pointsLength = pointsLength;\n\n  if (!parsedContent.hasPositions) {\n    const positions = parsePositions(featureTable);\n    parsedContent.positions = positions;\n    parsedContent.hasPositions =\n      parsedContent.hasPositions || defined(positions);\n  }\n\n  if (!parsedContent.hasPositions) {\n    throw new RuntimeError(\n      \"Either POSITION or POSITION_QUANTIZED must be defined.\",\n    );\n  }\n\n  if (!parsedContent.hasNormals) {\n    const normals = parseNormals(featureTable);\n    parsedContent.normals = normals;\n    parsedContent.hasNormals = parsedContent.hasNormals || defined(normals);\n  }\n\n  if (!parsedContent.hasColors) {\n    const colors = parseColors(featureTable);\n    parsedContent.colors = colors;\n    parsedContent.hasColors = parsedContent.hasColors || defined(colors);\n    parsedContent.hasConstantColor = defined(parsedContent.constantColor);\n    parsedContent.isTranslucent = defined(colors) && colors.isTranslucent;\n  }\n\n  if (!parsedContent.hasBatchIds) {\n    const batchIds = parseBatchIds(featureTable);\n    parsedContent.batchIds = batchIds;\n    parsedContent.hasBatchIds = parsedContent.hasBatchIds || defined(batchIds);\n  }\n\n  if (parsedContent.hasBatchIds) {\n    const batchLength = featureTable.getGlobalProperty(\"BATCH_LENGTH\");\n    if (!defined(batchLength)) {\n      throw new RuntimeError(\n        \"Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.\",\n      );\n    }\n    parsedContent.batchLength = batchLength;\n  }\n\n  if (defined(batchTableBinary)) {\n    // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n    batchTableBinary = new Uint8Array(batchTableBinary);\n    parsedContent.batchTableJson = batchTableJson;\n    parsedContent.batchTableBinary = batchTableBinary;\n  }\n\n  return parsedContent;\n};\n\nfunction parseDracoProperties(featureTable, batchTableJson) {\n  const featureTableJson = featureTable.json;\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n\n  const featureTableDraco = defined(featureTableJson.extensions)\n    ? featureTableJson.extensions[\"3DTILES_draco_point_compression\"]\n    : undefined;\n  const batchTableDraco =\n    defined(batchTableJson) && defined(batchTableJson.extensions)\n      ? batchTableJson.extensions[\"3DTILES_draco_point_compression\"]\n      : undefined;\n\n  if (defined(batchTableDraco)) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  let hasPositions;\n  let hasColors;\n  let hasNormals;\n  let hasBatchIds;\n  let isTranslucent;\n  if (defined(featureTableDraco)) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (\n      !defined(dracoFeatureTableProperties) ||\n      !defined(dracoByteOffset) ||\n      !defined(dracoByteLength)\n    ) {\n      throw new RuntimeError(\n        \"Draco properties, byteOffset, and byteLength must be defined\",\n      );\n    }\n    dracoBuffer = featureTable.buffer.slice(\n      dracoByteOffset,\n      dracoByteOffset + dracoByteLength,\n    );\n    hasPositions = defined(dracoFeatureTableProperties.POSITION);\n    hasColors =\n      defined(dracoFeatureTableProperties.RGB) ||\n      defined(dracoFeatureTableProperties.RGBA);\n    hasNormals = defined(dracoFeatureTableProperties.NORMAL);\n    hasBatchIds = defined(dracoFeatureTableProperties.BATCH_ID);\n    isTranslucent = defined(dracoFeatureTableProperties.RGBA);\n  }\n\n  let draco;\n  if (defined(dracoBuffer)) {\n    draco = {\n      buffer: dracoBuffer,\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      properties: combine(\n        dracoFeatureTableProperties,\n        dracoBatchTableProperties,\n      ),\n      dequantizeInShader: true,\n    };\n  }\n\n  return {\n    draco: draco,\n    hasPositions: hasPositions,\n    hasColors: hasColors,\n    isTranslucent: isTranslucent,\n    hasNormals: hasNormals,\n    hasBatchIds: hasBatchIds,\n  };\n}\n\nfunction parsePositions(featureTable) {\n  const featureTableJson = featureTable.json;\n\n  let positions;\n  if (defined(featureTableJson.POSITION)) {\n    positions = featureTable.getPropertyArray(\n      \"POSITION\",\n      ComponentDatatype.FLOAT,\n      3,\n    );\n\n    return {\n      name: VertexAttributeSemantic.POSITION,\n      semantic: VertexAttributeSemantic.POSITION,\n      typedArray: positions,\n      isQuantized: false,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n    };\n  } else if (defined(featureTableJson.POSITION_QUANTIZED)) {\n    positions = featureTable.getPropertyArray(\n      \"POSITION_QUANTIZED\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      3,\n    );\n\n    const quantizedVolumeScale = featureTable.getGlobalProperty(\n      \"QUANTIZED_VOLUME_SCALE\",\n      ComponentDatatype.FLOAT,\n      3,\n    );\n    if (!defined(quantizedVolumeScale)) {\n      throw new RuntimeError(\n        \"Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\",\n      );\n    }\n    const quantizedRange = (1 << 16) - 1;\n\n    const quantizedVolumeOffset = featureTable.getGlobalProperty(\n      \"QUANTIZED_VOLUME_OFFSET\",\n      ComponentDatatype.FLOAT,\n      3,\n    );\n    if (!defined(quantizedVolumeOffset)) {\n      throw new RuntimeError(\n        \"Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\",\n      );\n    }\n\n    return {\n      name: VertexAttributeSemantic.POSITION,\n      semantic: VertexAttributeSemantic.POSITION,\n      typedArray: positions,\n      isQuantized: true,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      quantizedRange: quantizedRange,\n      quantizedVolumeOffset: Cartesian3.unpack(quantizedVolumeOffset),\n      quantizedVolumeScale: Cartesian3.unpack(quantizedVolumeScale),\n      quantizedComponentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n      quantizedType: AttributeType.VEC3,\n    };\n  }\n}\n\nfunction parseColors(featureTable) {\n  const featureTableJson = featureTable.json;\n\n  let colors;\n  if (defined(featureTableJson.RGBA)) {\n    colors = featureTable.getPropertyArray(\n      \"RGBA\",\n      ComponentDatatype.UNSIGNED_BYTE,\n      4,\n    );\n    return {\n      name: VertexAttributeSemantic.COLOR,\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: colors,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC4,\n      normalized: true,\n      isRGB565: false,\n      isTranslucent: true,\n    };\n  } else if (defined(featureTableJson.RGB)) {\n    colors = featureTable.getPropertyArray(\n      \"RGB\",\n      ComponentDatatype.UNSIGNED_BYTE,\n      3,\n    );\n    return {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: colors,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC3,\n      normalized: true,\n      isRGB565: false,\n      isTranslucent: false,\n    };\n  } else if (defined(featureTableJson.RGB565)) {\n    colors = featureTable.getPropertyArray(\n      \"RGB565\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      1,\n    );\n    return {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: colors,\n      // These settings are for the Model implementation\n      // which decodes on the CPU and uploads a VEC3 of float colors.\n      // PointCloud does the decoding on the GPU so uploads a\n      // UNSIGNED_SHORT instead.\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      normalized: false,\n      isRGB565: true,\n      isTranslucent: false,\n    };\n  } else if (defined(featureTableJson.CONSTANT_RGBA)) {\n    const constantRGBA = featureTable.getGlobalProperty(\n      \"CONSTANT_RGBA\",\n      ComponentDatatype.UNSIGNED_BYTE,\n      4,\n    );\n\n    const alpha = constantRGBA[3];\n    const constantColor = Color.fromBytes(\n      constantRGBA[0],\n      constantRGBA[1],\n      constantRGBA[2],\n      alpha,\n    );\n\n    const isTranslucent = alpha < 255;\n    return {\n      name: VertexAttributeSemantic.COLOR,\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      constantColor: constantColor,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC4,\n      isQuantized: false,\n      isTranslucent: isTranslucent,\n    };\n  }\n\n  return undefined;\n}\n\nfunction parseNormals(featureTable) {\n  const featureTableJson = featureTable.json;\n  let normals;\n  if (defined(featureTableJson.NORMAL)) {\n    normals = featureTable.getPropertyArray(\n      \"NORMAL\",\n      ComponentDatatype.FLOAT,\n      3,\n    );\n    return {\n      name: VertexAttributeSemantic.NORMAL,\n      semantic: VertexAttributeSemantic.NORMAL,\n      typedArray: normals,\n      octEncoded: false,\n      octEncodedZXY: false,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n    };\n  } else if (defined(featureTableJson.NORMAL_OCT16P)) {\n    normals = featureTable.getPropertyArray(\n      \"NORMAL_OCT16P\",\n      ComponentDatatype.UNSIGNED_BYTE,\n      2,\n    );\n    const quantizationBits = 8;\n    return {\n      name: VertexAttributeSemantic.NORMAL,\n      semantic: VertexAttributeSemantic.NORMAL,\n      typedArray: normals,\n      octEncoded: true,\n      octEncodedZXY: false,\n      quantizedRange: (1 << quantizationBits) - 1,\n      quantizedType: AttributeType.VEC2,\n      quantizedComponentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n    };\n  }\n\n  return undefined;\n}\n\nfunction parseBatchIds(featureTable) {\n  const featureTableJson = featureTable.json;\n  if (defined(featureTableJson.BATCH_ID)) {\n    const batchIds = featureTable.getPropertyArray(\n      \"BATCH_ID\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      1,\n    );\n    return {\n      name: VertexAttributeSemantic.FEATURE_ID,\n      semantic: VertexAttributeSemantic.FEATURE_ID,\n      setIndex: 0,\n      typedArray: batchIds,\n      componentDatatype: ComponentDatatype.fromTypedArray(batchIds),\n      type: AttributeType.SCALAR,\n    };\n  }\n\n  return undefined;\n}\n\nexport default PntsParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}