{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport ManagedArray from \"../Core/ManagedArray.js\";\nimport Cesium3DTileRefine from \"./Cesium3DTileRefine.js\";\nimport Cesium3DTilesetTraversal from \"./Cesium3DTilesetTraversal.js\";\n\n/**\n * Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n * A tile does not refine until all children are loaded.\n * This is the traditional replacement refinement approach and is called the base traversal.\n *\n * @alias Cesium3DTilesetBaseTraversal\n * @constructor\n *\n * @private\n */\nfunction Cesium3DTilesetBaseTraversal() {}\nconst traversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0\n};\nconst emptyTraversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0\n};\n\n/**\n * Traverses a {@link Cesium3DTileset} to determine which tiles to load and render.\n *\n * @private\n * @param {Cesium3DTileset} tileset\n * @param {FrameState} frameState\n */\nCesium3DTilesetBaseTraversal.selectTiles = function (tileset, frameState) {\n  tileset._requestedTiles.length = 0;\n  if (tileset.debugFreezeFrame) {\n    return;\n  }\n  tileset._selectedTiles.length = 0;\n  tileset._selectedTilesToStyle.length = 0;\n  tileset._emptyTiles.length = 0;\n  tileset.hasMixedContent = false;\n  const root = tileset.root;\n  Cesium3DTilesetTraversal.updateTile(root, frameState);\n  if (!root.isVisible) {\n    return;\n  }\n  if (root.getScreenSpaceError(frameState, true) <= tileset.memoryAdjustedScreenSpaceError) {\n    return;\n  }\n  executeTraversal(root, frameState);\n  traversal.stack.trim(traversal.stackMaximumLength);\n  emptyTraversal.stack.trim(emptyTraversal.stackMaximumLength);\n\n  // Update the priority for any requests found during traversal\n  // Update after traversal so that min and max values can be used to normalize priority values\n  const requestedTiles = tileset._requestedTiles;\n  for (let i = 0; i < requestedTiles.length; ++i) {\n    requestedTiles[i].updatePriority();\n  }\n};\n\n/**\n * Mark a tile as selected if it has content available.\n *\n * @private\n * @param {Cesium3DTile} tile\n * @param {FrameState} frameState\n */\nfunction selectDesiredTile(tile, frameState) {\n  if (tile.contentAvailable) {\n    Cesium3DTilesetTraversal.selectTile(tile, frameState);\n  }\n}\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @param {ManagedArray} stack\n * @param {FrameState} frameState\n * @returns {boolean}\n */\nfunction updateAndPushChildren(tile, stack, frameState) {\n  const replace = tile.refine === Cesium3DTileRefine.REPLACE;\n  const {\n    tileset,\n    children\n  } = tile;\n  const {\n    updateTile,\n    loadTile,\n    touchTile\n  } = Cesium3DTilesetTraversal;\n  for (let i = 0; i < children.length; ++i) {\n    updateTile(children[i], frameState);\n  }\n\n  // Sort by distance to take advantage of early Z and reduce artifacts for skipLevelOfDetail\n  children.sort(Cesium3DTilesetTraversal.sortChildrenByDistanceToCamera);\n\n  // For traditional replacement refinement only refine if all children are loaded.\n  // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n  const checkRefines = replace && tile.hasRenderableContent;\n  let refines = true;\n  let anyChildrenVisible = false;\n\n  // Determining min child\n  let minIndex = -1;\n  let minimumPriority = Number.MAX_VALUE;\n  for (let i = 0; i < children.length; ++i) {\n    const child = children[i];\n    if (child.isVisible) {\n      stack.push(child);\n      if (child._foveatedFactor < minimumPriority) {\n        minIndex = i;\n        minimumPriority = child._foveatedFactor;\n      }\n      anyChildrenVisible = true;\n    } else if (checkRefines || tileset.loadSiblings) {\n      // Keep non-visible children loaded since they are still needed before the parent can refine.\n      // Or loadSiblings is true so always load tiles regardless of visibility.\n      if (child._foveatedFactor < minimumPriority) {\n        minIndex = i;\n        minimumPriority = child._foveatedFactor;\n      }\n      loadTile(child, frameState);\n      touchTile(child, frameState);\n    }\n    if (checkRefines) {\n      let childRefines;\n      if (!child._inRequestVolume) {\n        childRefines = false;\n      } else if (!child.hasRenderableContent) {\n        childRefines = executeEmptyTraversal(child, frameState);\n      } else {\n        childRefines = child.contentAvailable;\n      }\n      refines = refines && childRefines;\n    }\n  }\n  if (!anyChildrenVisible) {\n    refines = false;\n  }\n  if (minIndex !== -1 && replace) {\n    // An ancestor will hold the _foveatedFactor and _distanceToCamera for descendants between itself and its highest priority descendant. Siblings of a min children along the way use this ancestor as their priority holder as well.\n    // Priority of all tiles that refer to the _foveatedFactor and _distanceToCamera stored in the common ancestor will be differentiated based on their _depth.\n    const minPriorityChild = children[minIndex];\n    minPriorityChild._wasMinPriorityChild = true;\n    const priorityHolder = (tile._wasMinPriorityChild || tile === tileset.root) && minimumPriority <= tile._priorityHolder._foveatedFactor ? tile._priorityHolder : tile; // This is where priority dependency chains are wired up or started anew.\n    priorityHolder._foveatedFactor = Math.min(minPriorityChild._foveatedFactor, priorityHolder._foveatedFactor);\n    priorityHolder._distanceToCamera = Math.min(minPriorityChild._distanceToCamera, priorityHolder._distanceToCamera);\n    for (let i = 0; i < children.length; ++i) {\n      children[i]._priorityHolder = priorityHolder;\n    }\n  }\n  return refines;\n}\n\n/**\n * Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n * A tile does not refine until all children are loaded.\n * This is the traditional replacement refinement approach and is called the base traversal.\n *\n * @private\n * @param {Cesium3DTile} root\n * @param {FrameState} frameState\n */\nfunction executeTraversal(root, frameState) {\n  const {\n    tileset\n  } = root;\n  const {\n    canTraverse,\n    loadTile,\n    visitTile,\n    touchTile\n  } = Cesium3DTilesetTraversal;\n  const stack = traversal.stack;\n  stack.push(root);\n  while (stack.length > 0) {\n    traversal.stackMaximumLength = Math.max(traversal.stackMaximumLength, stack.length);\n    const tile = stack.pop();\n    const parent = tile.parent;\n    const parentRefines = !defined(parent) || parent._refines;\n    tile._refines = canTraverse(tile) ? updateAndPushChildren(tile, stack, frameState) && parentRefines : false;\n    const stoppedRefining = !tile._refines && parentRefines;\n    if (!tile.hasRenderableContent) {\n      // Add empty tile just to show its debug bounding volume\n      // If the tile has tileset content load the external tileset\n      tileset._emptyTiles.push(tile);\n      loadTile(tile, frameState);\n      if (stoppedRefining) {\n        selectDesiredTile(tile, frameState);\n      }\n    } else if (tile.refine === Cesium3DTileRefine.ADD) {\n      // Additive tiles are always loaded and selected\n      selectDesiredTile(tile, frameState);\n      loadTile(tile, frameState);\n    } else if (tile.refine === Cesium3DTileRefine.REPLACE) {\n      loadTile(tile, frameState);\n      if (stoppedRefining) {\n        selectDesiredTile(tile, frameState);\n      }\n    }\n    visitTile(tile, frameState);\n    touchTile(tile, frameState);\n  }\n}\n\n/**\n * Depth-first traversal that checks if all nearest descendants with content are loaded.\n * Ignores visibility.\n *\n * @private\n * @param {Cesium3DTile} root\n * @param {FrameState} frameState\n * @returns {boolean}\n */\nfunction executeEmptyTraversal(root, frameState) {\n  const {\n    canTraverse,\n    updateTile,\n    loadTile,\n    touchTile\n  } = Cesium3DTilesetTraversal;\n  let allDescendantsLoaded = true;\n  const stack = emptyTraversal.stack;\n  stack.push(root);\n  while (stack.length > 0) {\n    emptyTraversal.stackMaximumLength = Math.max(emptyTraversal.stackMaximumLength, stack.length);\n    const tile = stack.pop();\n    const children = tile.children;\n    const childrenLength = children.length;\n\n    // Only traverse if the tile is empty - traversal stops at descendants with content\n    const traverse = !tile.hasRenderableContent && canTraverse(tile);\n\n    // Traversal stops but the tile does not have content yet\n    // There will be holes if the parent tries to refine to its children, so don't refine\n    if (!traverse && !tile.contentAvailable) {\n      allDescendantsLoaded = false;\n    }\n    updateTile(tile, frameState);\n    if (!tile.isVisible) {\n      // Load tiles that aren't visible since they are still needed for the parent to refine\n      loadTile(tile, frameState);\n      touchTile(tile, frameState);\n    }\n    if (traverse) {\n      for (let i = 0; i < childrenLength; ++i) {\n        const child = children[i];\n        stack.push(child);\n      }\n    }\n  }\n  return root.hasEmptyContent || allDescendantsLoaded;\n}\nexport default Cesium3DTilesetBaseTraversal;","map":{"version":3,"names":["defined","ManagedArray","Cesium3DTileRefine","Cesium3DTilesetTraversal","Cesium3DTilesetBaseTraversal","traversal","stack","stackMaximumLength","emptyTraversal","selectTiles","tileset","frameState","_requestedTiles","length","debugFreezeFrame","_selectedTiles","_selectedTilesToStyle","_emptyTiles","hasMixedContent","root","updateTile","isVisible","getScreenSpaceError","memoryAdjustedScreenSpaceError","executeTraversal","trim","requestedTiles","i","updatePriority","selectDesiredTile","tile","contentAvailable","selectTile","updateAndPushChildren","replace","refine","REPLACE","children","loadTile","touchTile","sort","sortChildrenByDistanceToCamera","checkRefines","hasRenderableContent","refines","anyChildrenVisible","minIndex","minimumPriority","Number","MAX_VALUE","child","push","_foveatedFactor","loadSiblings","childRefines","_inRequestVolume","executeEmptyTraversal","minPriorityChild","_wasMinPriorityChild","priorityHolder","_priorityHolder","Math","min","_distanceToCamera","canTraverse","visitTile","max","pop","parent","parentRefines","_refines","stoppedRefining","ADD","allDescendantsLoaded","childrenLength","traverse","hasEmptyContent"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Cesium3DTilesetBaseTraversal.js"],"sourcesContent":["import defined from \"../Core/defined.js\";\nimport ManagedArray from \"../Core/ManagedArray.js\";\nimport Cesium3DTileRefine from \"./Cesium3DTileRefine.js\";\nimport Cesium3DTilesetTraversal from \"./Cesium3DTilesetTraversal.js\";\n\n/**\n * Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n * A tile does not refine until all children are loaded.\n * This is the traditional replacement refinement approach and is called the base traversal.\n *\n * @alias Cesium3DTilesetBaseTraversal\n * @constructor\n *\n * @private\n */\nfunction Cesium3DTilesetBaseTraversal() {}\n\nconst traversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0,\n};\n\nconst emptyTraversal = {\n  stack: new ManagedArray(),\n  stackMaximumLength: 0,\n};\n\n/**\n * Traverses a {@link Cesium3DTileset} to determine which tiles to load and render.\n *\n * @private\n * @param {Cesium3DTileset} tileset\n * @param {FrameState} frameState\n */\nCesium3DTilesetBaseTraversal.selectTiles = function (tileset, frameState) {\n  tileset._requestedTiles.length = 0;\n\n  if (tileset.debugFreezeFrame) {\n    return;\n  }\n\n  tileset._selectedTiles.length = 0;\n  tileset._selectedTilesToStyle.length = 0;\n  tileset._emptyTiles.length = 0;\n  tileset.hasMixedContent = false;\n\n  const root = tileset.root;\n  Cesium3DTilesetTraversal.updateTile(root, frameState);\n\n  if (!root.isVisible) {\n    return;\n  }\n\n  if (\n    root.getScreenSpaceError(frameState, true) <=\n    tileset.memoryAdjustedScreenSpaceError\n  ) {\n    return;\n  }\n\n  executeTraversal(root, frameState);\n\n  traversal.stack.trim(traversal.stackMaximumLength);\n  emptyTraversal.stack.trim(emptyTraversal.stackMaximumLength);\n\n  // Update the priority for any requests found during traversal\n  // Update after traversal so that min and max values can be used to normalize priority values\n  const requestedTiles = tileset._requestedTiles;\n  for (let i = 0; i < requestedTiles.length; ++i) {\n    requestedTiles[i].updatePriority();\n  }\n};\n\n/**\n * Mark a tile as selected if it has content available.\n *\n * @private\n * @param {Cesium3DTile} tile\n * @param {FrameState} frameState\n */\nfunction selectDesiredTile(tile, frameState) {\n  if (tile.contentAvailable) {\n    Cesium3DTilesetTraversal.selectTile(tile, frameState);\n  }\n}\n\n/**\n * @private\n * @param {Cesium3DTile} tile\n * @param {ManagedArray} stack\n * @param {FrameState} frameState\n * @returns {boolean}\n */\nfunction updateAndPushChildren(tile, stack, frameState) {\n  const replace = tile.refine === Cesium3DTileRefine.REPLACE;\n  const { tileset, children } = tile;\n  const { updateTile, loadTile, touchTile } = Cesium3DTilesetTraversal;\n\n  for (let i = 0; i < children.length; ++i) {\n    updateTile(children[i], frameState);\n  }\n\n  // Sort by distance to take advantage of early Z and reduce artifacts for skipLevelOfDetail\n  children.sort(Cesium3DTilesetTraversal.sortChildrenByDistanceToCamera);\n\n  // For traditional replacement refinement only refine if all children are loaded.\n  // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n  const checkRefines = replace && tile.hasRenderableContent;\n  let refines = true;\n\n  let anyChildrenVisible = false;\n\n  // Determining min child\n  let minIndex = -1;\n  let minimumPriority = Number.MAX_VALUE;\n\n  for (let i = 0; i < children.length; ++i) {\n    const child = children[i];\n    if (child.isVisible) {\n      stack.push(child);\n      if (child._foveatedFactor < minimumPriority) {\n        minIndex = i;\n        minimumPriority = child._foveatedFactor;\n      }\n      anyChildrenVisible = true;\n    } else if (checkRefines || tileset.loadSiblings) {\n      // Keep non-visible children loaded since they are still needed before the parent can refine.\n      // Or loadSiblings is true so always load tiles regardless of visibility.\n      if (child._foveatedFactor < minimumPriority) {\n        minIndex = i;\n        minimumPriority = child._foveatedFactor;\n      }\n      loadTile(child, frameState);\n      touchTile(child, frameState);\n    }\n    if (checkRefines) {\n      let childRefines;\n      if (!child._inRequestVolume) {\n        childRefines = false;\n      } else if (!child.hasRenderableContent) {\n        childRefines = executeEmptyTraversal(child, frameState);\n      } else {\n        childRefines = child.contentAvailable;\n      }\n      refines = refines && childRefines;\n    }\n  }\n\n  if (!anyChildrenVisible) {\n    refines = false;\n  }\n\n  if (minIndex !== -1 && replace) {\n    // An ancestor will hold the _foveatedFactor and _distanceToCamera for descendants between itself and its highest priority descendant. Siblings of a min children along the way use this ancestor as their priority holder as well.\n    // Priority of all tiles that refer to the _foveatedFactor and _distanceToCamera stored in the common ancestor will be differentiated based on their _depth.\n    const minPriorityChild = children[minIndex];\n    minPriorityChild._wasMinPriorityChild = true;\n    const priorityHolder =\n      (tile._wasMinPriorityChild || tile === tileset.root) &&\n      minimumPriority <= tile._priorityHolder._foveatedFactor\n        ? tile._priorityHolder\n        : tile; // This is where priority dependency chains are wired up or started anew.\n    priorityHolder._foveatedFactor = Math.min(\n      minPriorityChild._foveatedFactor,\n      priorityHolder._foveatedFactor,\n    );\n    priorityHolder._distanceToCamera = Math.min(\n      minPriorityChild._distanceToCamera,\n      priorityHolder._distanceToCamera,\n    );\n\n    for (let i = 0; i < children.length; ++i) {\n      children[i]._priorityHolder = priorityHolder;\n    }\n  }\n\n  return refines;\n}\n\n/**\n * Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n * A tile does not refine until all children are loaded.\n * This is the traditional replacement refinement approach and is called the base traversal.\n *\n * @private\n * @param {Cesium3DTile} root\n * @param {FrameState} frameState\n */\nfunction executeTraversal(root, frameState) {\n  const { tileset } = root;\n\n  const { canTraverse, loadTile, visitTile, touchTile } =\n    Cesium3DTilesetTraversal;\n  const stack = traversal.stack;\n  stack.push(root);\n\n  while (stack.length > 0) {\n    traversal.stackMaximumLength = Math.max(\n      traversal.stackMaximumLength,\n      stack.length,\n    );\n\n    const tile = stack.pop();\n\n    const parent = tile.parent;\n    const parentRefines = !defined(parent) || parent._refines;\n\n    tile._refines = canTraverse(tile)\n      ? updateAndPushChildren(tile, stack, frameState) && parentRefines\n      : false;\n\n    const stoppedRefining = !tile._refines && parentRefines;\n\n    if (!tile.hasRenderableContent) {\n      // Add empty tile just to show its debug bounding volume\n      // If the tile has tileset content load the external tileset\n      tileset._emptyTiles.push(tile);\n      loadTile(tile, frameState);\n      if (stoppedRefining) {\n        selectDesiredTile(tile, frameState);\n      }\n    } else if (tile.refine === Cesium3DTileRefine.ADD) {\n      // Additive tiles are always loaded and selected\n      selectDesiredTile(tile, frameState);\n      loadTile(tile, frameState);\n    } else if (tile.refine === Cesium3DTileRefine.REPLACE) {\n      loadTile(tile, frameState);\n      if (stoppedRefining) {\n        selectDesiredTile(tile, frameState);\n      }\n    }\n\n    visitTile(tile, frameState);\n    touchTile(tile, frameState);\n  }\n}\n\n/**\n * Depth-first traversal that checks if all nearest descendants with content are loaded.\n * Ignores visibility.\n *\n * @private\n * @param {Cesium3DTile} root\n * @param {FrameState} frameState\n * @returns {boolean}\n */\nfunction executeEmptyTraversal(root, frameState) {\n  const { canTraverse, updateTile, loadTile, touchTile } =\n    Cesium3DTilesetTraversal;\n  let allDescendantsLoaded = true;\n  const stack = emptyTraversal.stack;\n  stack.push(root);\n\n  while (stack.length > 0) {\n    emptyTraversal.stackMaximumLength = Math.max(\n      emptyTraversal.stackMaximumLength,\n      stack.length,\n    );\n\n    const tile = stack.pop();\n    const children = tile.children;\n    const childrenLength = children.length;\n\n    // Only traverse if the tile is empty - traversal stops at descendants with content\n    const traverse = !tile.hasRenderableContent && canTraverse(tile);\n\n    // Traversal stops but the tile does not have content yet\n    // There will be holes if the parent tries to refine to its children, so don't refine\n    if (!traverse && !tile.contentAvailable) {\n      allDescendantsLoaded = false;\n    }\n\n    updateTile(tile, frameState);\n    if (!tile.isVisible) {\n      // Load tiles that aren't visible since they are still needed for the parent to refine\n      loadTile(tile, frameState);\n      touchTile(tile, frameState);\n    }\n\n    if (traverse) {\n      for (let i = 0; i < childrenLength; ++i) {\n        const child = children[i];\n        stack.push(child);\n      }\n    }\n  }\n\n  return root.hasEmptyContent || allDescendantsLoaded;\n}\n\nexport default Cesium3DTilesetBaseTraversal;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}