{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport GeometryInstanceAttribute from \"../Core/GeometryInstanceAttribute.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ShadowVolumeAppearanceFS from \"../Shaders/ShadowVolumeAppearanceFS.js\";\n\n/**\n * Creates shaders for a ClassificationPrimitive to use a given Appearance, as well as for picking.\n *\n * @param {boolean} extentsCulling Discard fragments outside the instance's texture coordinate extents.\n * @param {boolean} planarExtents If true, texture coordinates will be computed using planes instead of spherical coordinates.\n * @param {Appearance} appearance An Appearance to be used with a ClassificationPrimitive via GroundPrimitive.\n * @private\n */\nfunction ShadowVolumeAppearance(extentsCulling, planarExtents, appearance) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"extentsCulling\", extentsCulling);\n  Check.typeOf.bool(\"planarExtents\", planarExtents);\n  Check.typeOf.object(\"appearance\", appearance);\n  //>>includeEnd('debug');\n\n  this._projectionExtentDefines = {\n    eastMostYhighDefine: \"\",\n    eastMostYlowDefine: \"\",\n    westMostYhighDefine: \"\",\n    westMostYlowDefine: \"\"\n  };\n\n  // Compute shader dependencies\n  const colorShaderDependencies = new ShaderDependencies();\n  colorShaderDependencies.requiresTextureCoordinates = extentsCulling;\n  colorShaderDependencies.requiresEC = !appearance.flat;\n  const pickShaderDependencies = new ShaderDependencies();\n  pickShaderDependencies.requiresTextureCoordinates = extentsCulling;\n  if (appearance instanceof PerInstanceColorAppearance) {\n    // PerInstanceColorAppearance doesn't have material.shaderSource, instead it has its own vertex and fragment shaders\n    colorShaderDependencies.requiresNormalEC = !appearance.flat;\n  } else {\n    // Scan material source for what hookups are needed. Assume czm_materialInput materialInput.\n    const materialShaderSource = `${appearance.material.shaderSource}\\n${appearance.fragmentShaderSource}`;\n    colorShaderDependencies.normalEC = materialShaderSource.indexOf(\"materialInput.normalEC\") !== -1 || materialShaderSource.indexOf(\"czm_getDefaultMaterial\") !== -1;\n    colorShaderDependencies.positionToEyeEC = materialShaderSource.indexOf(\"materialInput.positionToEyeEC\") !== -1;\n    colorShaderDependencies.tangentToEyeMatrix = materialShaderSource.indexOf(\"materialInput.tangentToEyeMatrix\") !== -1;\n    colorShaderDependencies.st = materialShaderSource.indexOf(\"materialInput.st\") !== -1;\n  }\n  this._colorShaderDependencies = colorShaderDependencies;\n  this._pickShaderDependencies = pickShaderDependencies;\n  this._appearance = appearance;\n  this._extentsCulling = extentsCulling;\n  this._planarExtents = planarExtents;\n}\n\n/**\n * Create the fragment shader for a ClassificationPrimitive's color pass when rendering for color.\n *\n * @param {boolean} columbusView2D Whether the shader will be used for Columbus View or 2D.\n * @returns {ShaderSource} Shader source for the fragment shader.\n */\nShadowVolumeAppearance.prototype.createFragmentShader = function (columbusView2D) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  //>>includeEnd('debug');\n\n  const appearance = this._appearance;\n  const dependencies = this._colorShaderDependencies;\n  const defines = [];\n  if (!columbusView2D && !this._planarExtents) {\n    defines.push(\"SPHERICAL\");\n  }\n  if (dependencies.requiresEC) {\n    defines.push(\"REQUIRES_EC\");\n  }\n  if (dependencies.requiresWC) {\n    defines.push(\"REQUIRES_WC\");\n  }\n  if (dependencies.requiresTextureCoordinates) {\n    defines.push(\"TEXTURE_COORDINATES\");\n  }\n  if (this._extentsCulling) {\n    defines.push(\"CULL_FRAGMENTS\");\n  }\n  if (dependencies.requiresNormalEC) {\n    defines.push(\"NORMAL_EC\");\n  }\n  if (appearance instanceof PerInstanceColorAppearance) {\n    defines.push(\"PER_INSTANCE_COLOR\");\n  }\n\n  // Material inputs. Use of parameters in the material is different\n  // from requirement of the parameters in the overall shader, for example,\n  // texture coordinates may be used for fragment culling but not for the material itself.\n  if (dependencies.normalEC) {\n    defines.push(\"USES_NORMAL_EC\");\n  }\n  if (dependencies.positionToEyeEC) {\n    defines.push(\"USES_POSITION_TO_EYE_EC\");\n  }\n  if (dependencies.tangentToEyeMatrix) {\n    defines.push(\"USES_TANGENT_TO_EYE\");\n  }\n  if (dependencies.st) {\n    defines.push(\"USES_ST\");\n  }\n  if (appearance.flat) {\n    defines.push(\"FLAT\");\n  }\n  let materialSource = \"\";\n  if (!(appearance instanceof PerInstanceColorAppearance)) {\n    materialSource = appearance.material.shaderSource;\n  }\n  return new ShaderSource({\n    defines: defines,\n    sources: [materialSource, ShadowVolumeAppearanceFS]\n  });\n};\nShadowVolumeAppearance.prototype.createPickFragmentShader = function (columbusView2D) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  //>>includeEnd('debug');\n\n  const dependencies = this._pickShaderDependencies;\n  const defines = [\"PICK\"];\n  if (!columbusView2D && !this._planarExtents) {\n    defines.push(\"SPHERICAL\");\n  }\n  if (dependencies.requiresEC) {\n    defines.push(\"REQUIRES_EC\");\n  }\n  if (dependencies.requiresWC) {\n    defines.push(\"REQUIRES_WC\");\n  }\n  if (dependencies.requiresTextureCoordinates) {\n    defines.push(\"TEXTURE_COORDINATES\");\n  }\n  if (this._extentsCulling) {\n    defines.push(\"CULL_FRAGMENTS\");\n  }\n  return new ShaderSource({\n    defines: defines,\n    sources: [ShadowVolumeAppearanceFS],\n    pickColorQualifier: \"in\"\n  });\n};\n\n/**\n * Create the vertex shader for a ClassificationPrimitive's color pass on the final of 3 shadow volume passes\n *\n * @param {string[]} defines External defines to pass to the vertex shader.\n * @param {string} vertexShaderSource ShadowVolumeAppearanceVS with any required modifications for computing position.\n * @param {boolean} columbusView2D Whether the shader will be used for Columbus View or 2D.\n * @param {MapProjection} mapProjection Current scene's map projection.\n * @returns {string} Shader source for the vertex shader.\n */\nShadowVolumeAppearance.prototype.createVertexShader = function (defines, vertexShaderSource, columbusView2D, mapProjection) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"defines\", defines);\n  Check.typeOf.string(\"vertexShaderSource\", vertexShaderSource);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  Check.defined(\"mapProjection\", mapProjection);\n  //>>includeEnd('debug');\n  return createShadowVolumeAppearanceVS(this._colorShaderDependencies, this._planarExtents, columbusView2D, defines, vertexShaderSource, this._appearance, mapProjection, this._projectionExtentDefines);\n};\n\n/**\n * Create the vertex shader for a ClassificationPrimitive's pick pass on the final of 3 shadow volume passes\n *\n * @param {string[]} defines External defines to pass to the vertex shader.\n * @param {string} vertexShaderSource ShadowVolumeAppearanceVS with any required modifications for computing position and picking.\n * @param {boolean} columbusView2D Whether the shader will be used for Columbus View or 2D.\n * @param {MapProjection} mapProjection Current scene's map projection.\n * @returns {string} Shader source for the vertex shader.\n */\nShadowVolumeAppearance.prototype.createPickVertexShader = function (defines, vertexShaderSource, columbusView2D, mapProjection) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"defines\", defines);\n  Check.typeOf.string(\"vertexShaderSource\", vertexShaderSource);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  Check.defined(\"mapProjection\", mapProjection);\n  //>>includeEnd('debug');\n  return createShadowVolumeAppearanceVS(this._pickShaderDependencies, this._planarExtents, columbusView2D, defines, vertexShaderSource, undefined, mapProjection, this._projectionExtentDefines);\n};\nconst longitudeExtentsCartesianScratch = new Cartesian3();\nconst longitudeExtentsCartographicScratch = new Cartographic();\nconst longitudeExtentsEncodeScratch = {\n  high: 0.0,\n  low: 0.0\n};\nfunction createShadowVolumeAppearanceVS(shaderDependencies, planarExtents, columbusView2D, defines, vertexShaderSource, appearance, mapProjection, projectionExtentDefines) {\n  const allDefines = defines.slice();\n  if (projectionExtentDefines.eastMostYhighDefine === \"\") {\n    const eastMostCartographic = longitudeExtentsCartographicScratch;\n    eastMostCartographic.longitude = CesiumMath.PI;\n    eastMostCartographic.latitude = 0.0;\n    eastMostCartographic.height = 0.0;\n    const eastMostCartesian = mapProjection.project(eastMostCartographic, longitudeExtentsCartesianScratch);\n    let encoded = EncodedCartesian3.encode(eastMostCartesian.x, longitudeExtentsEncodeScratch);\n    projectionExtentDefines.eastMostYhighDefine = `EAST_MOST_X_HIGH ${encoded.high.toFixed(`${encoded.high}`.length + 1)}`;\n    projectionExtentDefines.eastMostYlowDefine = `EAST_MOST_X_LOW ${encoded.low.toFixed(`${encoded.low}`.length + 1)}`;\n    const westMostCartographic = longitudeExtentsCartographicScratch;\n    westMostCartographic.longitude = -CesiumMath.PI;\n    westMostCartographic.latitude = 0.0;\n    westMostCartographic.height = 0.0;\n    const westMostCartesian = mapProjection.project(westMostCartographic, longitudeExtentsCartesianScratch);\n    encoded = EncodedCartesian3.encode(westMostCartesian.x, longitudeExtentsEncodeScratch);\n    projectionExtentDefines.westMostYhighDefine = `WEST_MOST_X_HIGH ${encoded.high.toFixed(`${encoded.high}`.length + 1)}`;\n    projectionExtentDefines.westMostYlowDefine = `WEST_MOST_X_LOW ${encoded.low.toFixed(`${encoded.low}`.length + 1)}`;\n  }\n  if (columbusView2D) {\n    allDefines.push(projectionExtentDefines.eastMostYhighDefine);\n    allDefines.push(projectionExtentDefines.eastMostYlowDefine);\n    allDefines.push(projectionExtentDefines.westMostYhighDefine);\n    allDefines.push(projectionExtentDefines.westMostYlowDefine);\n  }\n  if (defined(appearance) && appearance instanceof PerInstanceColorAppearance) {\n    allDefines.push(\"PER_INSTANCE_COLOR\");\n  }\n  if (shaderDependencies.requiresTextureCoordinates) {\n    allDefines.push(\"TEXTURE_COORDINATES\");\n    if (!(planarExtents || columbusView2D)) {\n      allDefines.push(\"SPHERICAL\");\n    }\n    if (columbusView2D) {\n      allDefines.push(\"COLUMBUS_VIEW_2D\");\n    }\n  }\n  return new ShaderSource({\n    defines: allDefines,\n    sources: [vertexShaderSource]\n  });\n}\n\n/**\n * Tracks shader dependencies.\n * @private\n */\nfunction ShaderDependencies() {\n  this._requiresEC = false;\n  this._requiresWC = false; // depends on eye coordinates, needed for material and for phong\n  this._requiresNormalEC = false; // depends on eye coordinates, needed for material\n  this._requiresTextureCoordinates = false; // depends on world coordinates, needed for material and for culling\n\n  this._usesNormalEC = false;\n  this._usesPositionToEyeEC = false;\n  this._usesTangentToEyeMat = false;\n  this._usesSt = false;\n}\nObject.defineProperties(ShaderDependencies.prototype, {\n  // Set when assessing final shading (flat vs. phong) and culling using computed texture coordinates\n  requiresEC: {\n    get: function () {\n      return this._requiresEC;\n    },\n    set: function (value) {\n      this._requiresEC = value || this._requiresEC;\n    }\n  },\n  requiresWC: {\n    get: function () {\n      return this._requiresWC;\n    },\n    set: function (value) {\n      this._requiresWC = value || this._requiresWC;\n      this.requiresEC = this._requiresWC;\n    }\n  },\n  requiresNormalEC: {\n    get: function () {\n      return this._requiresNormalEC;\n    },\n    set: function (value) {\n      this._requiresNormalEC = value || this._requiresNormalEC;\n      this.requiresEC = this._requiresNormalEC;\n    }\n  },\n  requiresTextureCoordinates: {\n    get: function () {\n      return this._requiresTextureCoordinates;\n    },\n    set: function (value) {\n      this._requiresTextureCoordinates = value || this._requiresTextureCoordinates;\n      this.requiresWC = this._requiresTextureCoordinates;\n    }\n  },\n  // Get/Set when assessing material hookups\n  normalEC: {\n    set: function (value) {\n      this.requiresNormalEC = value;\n      this._usesNormalEC = value;\n    },\n    get: function () {\n      return this._usesNormalEC;\n    }\n  },\n  tangentToEyeMatrix: {\n    set: function (value) {\n      this.requiresWC = value;\n      this.requiresNormalEC = value;\n      this._usesTangentToEyeMat = value;\n    },\n    get: function () {\n      return this._usesTangentToEyeMat;\n    }\n  },\n  positionToEyeEC: {\n    set: function (value) {\n      this.requiresEC = value;\n      this._usesPositionToEyeEC = value;\n    },\n    get: function () {\n      return this._usesPositionToEyeEC;\n    }\n  },\n  st: {\n    set: function (value) {\n      this.requiresTextureCoordinates = value;\n      this._usesSt = value;\n    },\n    get: function () {\n      return this._usesSt;\n    }\n  }\n});\nfunction pointLineDistance(point1, point2, point) {\n  return Math.abs((point2.y - point1.y) * point.x - (point2.x - point1.x) * point.y + point2.x * point1.y - point2.y * point1.x) / Cartesian2.distance(point2, point1);\n}\nconst points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2(), new Cartesian2()];\n\n// textureCoordinateRotationPoints form 2 lines in the computed UV space that remap to desired texture coordinates.\n// This allows simulation of baked texture coordinates for EllipseGeometry, RectangleGeometry, and PolygonGeometry.\nfunction addTextureCoordinateRotationAttributes(attributes, textureCoordinateRotationPoints) {\n  const points2D = points2DScratch;\n  const minXYCorner = Cartesian2.unpack(textureCoordinateRotationPoints, 0, points2D[0]);\n  const maxYCorner = Cartesian2.unpack(textureCoordinateRotationPoints, 2, points2D[1]);\n  const maxXCorner = Cartesian2.unpack(textureCoordinateRotationPoints, 4, points2D[2]);\n  attributes.uMaxVmax = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: [maxYCorner.x, maxYCorner.y, maxXCorner.x, maxXCorner.y]\n  });\n  const inverseExtentX = 1.0 / pointLineDistance(minXYCorner, maxYCorner, maxXCorner);\n  const inverseExtentY = 1.0 / pointLineDistance(minXYCorner, maxXCorner, maxYCorner);\n  attributes.uvMinAndExtents = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: [minXYCorner.x, minXYCorner.y, inverseExtentX, inverseExtentY]\n  });\n}\nconst cartographicScratch = new Cartographic();\nconst cornerScratch = new Cartesian3();\nconst northWestScratch = new Cartesian3();\nconst southEastScratch = new Cartesian3();\nconst highLowScratch = {\n  high: 0.0,\n  low: 0.0\n};\nfunction add2DTextureCoordinateAttributes(rectangle, projection, attributes) {\n  // Compute corner positions in double precision\n  const carto = cartographicScratch;\n  carto.height = 0.0;\n  carto.longitude = rectangle.west;\n  carto.latitude = rectangle.south;\n  const southWestCorner = projection.project(carto, cornerScratch);\n  carto.latitude = rectangle.north;\n  const northWest = projection.project(carto, northWestScratch);\n  carto.longitude = rectangle.east;\n  carto.latitude = rectangle.south;\n  const southEast = projection.project(carto, southEastScratch);\n\n  // Since these positions are all in the 2D plane, there's a lot of zeros\n  // and a lot of repetition. So we only need to encode 4 values.\n  // Encode:\n  // x: x value for southWestCorner\n  // y: y value for southWestCorner\n  // z: y value for northWest\n  // w: x value for southEast\n\n  const valuesHigh = [0, 0, 0, 0];\n  const valuesLow = [0, 0, 0, 0];\n  let encoded = EncodedCartesian3.encode(southWestCorner.x, highLowScratch);\n  valuesHigh[0] = encoded.high;\n  valuesLow[0] = encoded.low;\n  encoded = EncodedCartesian3.encode(southWestCorner.y, highLowScratch);\n  valuesHigh[1] = encoded.high;\n  valuesLow[1] = encoded.low;\n  encoded = EncodedCartesian3.encode(northWest.y, highLowScratch);\n  valuesHigh[2] = encoded.high;\n  valuesLow[2] = encoded.low;\n  encoded = EncodedCartesian3.encode(southEast.x, highLowScratch);\n  valuesHigh[3] = encoded.high;\n  valuesLow[3] = encoded.low;\n  attributes.planes2D_HIGH = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: valuesHigh\n  });\n  attributes.planes2D_LOW = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: valuesLow\n  });\n}\nconst enuMatrixScratch = new Matrix4();\nconst inverseEnuScratch = new Matrix4();\nconst rectanglePointCartesianScratch = new Cartesian3();\nconst rectangleCenterScratch = new Cartographic();\nconst pointsCartographicScratch = [new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic()];\n/**\n * When computing planes to bound the rectangle,\n * need to factor in \"bulge\" and other distortion.\n * Flatten the ellipsoid-centered corners and edge-centers of the rectangle\n * into the plane of the local ENU system, compute bounds in 2D, and\n * project back to ellipsoid-centered.\n *\n * @private\n */\nfunction computeRectangleBounds(rectangle, ellipsoid, height, southWestCornerResult, eastVectorResult, northVectorResult) {\n  // Compute center of rectangle\n  const centerCartographic = Rectangle.center(rectangle, rectangleCenterScratch);\n  centerCartographic.height = height;\n  const centerCartesian = Cartographic.toCartesian(centerCartographic, ellipsoid, rectanglePointCartesianScratch);\n  const enuMatrix = Transforms.eastNorthUpToFixedFrame(centerCartesian, ellipsoid, enuMatrixScratch);\n  const inverseEnu = Matrix4.inverse(enuMatrix, inverseEnuScratch);\n  const west = rectangle.west;\n  const east = rectangle.east;\n  const north = rectangle.north;\n  const south = rectangle.south;\n  const cartographics = pointsCartographicScratch;\n  cartographics[0].latitude = south;\n  cartographics[0].longitude = west;\n  cartographics[1].latitude = north;\n  cartographics[1].longitude = west;\n  cartographics[2].latitude = north;\n  cartographics[2].longitude = east;\n  cartographics[3].latitude = south;\n  cartographics[3].longitude = east;\n  const longitudeCenter = (west + east) * 0.5;\n  const latitudeCenter = (north + south) * 0.5;\n  cartographics[4].latitude = south;\n  cartographics[4].longitude = longitudeCenter;\n  cartographics[5].latitude = north;\n  cartographics[5].longitude = longitudeCenter;\n  cartographics[6].latitude = latitudeCenter;\n  cartographics[6].longitude = west;\n  cartographics[7].latitude = latitudeCenter;\n  cartographics[7].longitude = east;\n  let minX = Number.POSITIVE_INFINITY;\n  let maxX = Number.NEGATIVE_INFINITY;\n  let minY = Number.POSITIVE_INFINITY;\n  let maxY = Number.NEGATIVE_INFINITY;\n  for (let i = 0; i < 8; i++) {\n    cartographics[i].height = height;\n    const pointCartesian = Cartographic.toCartesian(cartographics[i], ellipsoid, rectanglePointCartesianScratch);\n    Matrix4.multiplyByPoint(inverseEnu, pointCartesian, pointCartesian);\n    pointCartesian.z = 0.0; // flatten into XY plane of ENU coordinate system\n    minX = Math.min(minX, pointCartesian.x);\n    maxX = Math.max(maxX, pointCartesian.x);\n    minY = Math.min(minY, pointCartesian.y);\n    maxY = Math.max(maxY, pointCartesian.y);\n  }\n  const southWestCorner = southWestCornerResult;\n  southWestCorner.x = minX;\n  southWestCorner.y = minY;\n  southWestCorner.z = 0.0;\n  Matrix4.multiplyByPoint(enuMatrix, southWestCorner, southWestCorner);\n  const southEastCorner = eastVectorResult;\n  southEastCorner.x = maxX;\n  southEastCorner.y = minY;\n  southEastCorner.z = 0.0;\n  Matrix4.multiplyByPoint(enuMatrix, southEastCorner, southEastCorner);\n  // make eastward vector\n  Cartesian3.subtract(southEastCorner, southWestCorner, eastVectorResult);\n  const northWestCorner = northVectorResult;\n  northWestCorner.x = minX;\n  northWestCorner.y = maxY;\n  northWestCorner.z = 0.0;\n  Matrix4.multiplyByPoint(enuMatrix, northWestCorner, northWestCorner);\n  // make eastward vector\n  Cartesian3.subtract(northWestCorner, southWestCorner, northVectorResult);\n}\nconst eastwardScratch = new Cartesian3();\nconst northwardScratch = new Cartesian3();\nconst encodeScratch = new EncodedCartesian3();\n/**\n * Gets an attributes object containing:\n * - 3 high-precision points as 6 GeometryInstanceAttributes. These points are used to compute eye-space planes.\n * - 1 texture coordinate rotation GeometryInstanceAttributes\n * - 2 GeometryInstanceAttributes used to compute high-precision points in 2D and Columbus View.\n *   These points are used to compute eye-space planes like above.\n *\n * Used to compute texture coordinates for small-area ClassificationPrimitives with materials or multiple non-overlapping instances.\n *\n * @see ShadowVolumeAppearance\n * @private\n *\n * @param {Rectangle} boundingRectangle Rectangle object that the points will approximately bound\n * @param {number[]} textureCoordinateRotationPoints Points in the computed texture coordinate system for remapping texture coordinates\n * @param {Ellipsoid} ellipsoid Ellipsoid for converting Rectangle points to world coordinates\n * @param {MapProjection} projection The MapProjection used for 2D and Columbus View.\n * @param {number} [height=0] The maximum height for the shadow volume.\n * @returns {object} An attributes dictionary containing planar texture coordinate attributes.\n */\nShadowVolumeAppearance.getPlanarTextureCoordinateAttributes = function (boundingRectangle, textureCoordinateRotationPoints, ellipsoid, projection, height) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundingRectangle\", boundingRectangle);\n  Check.defined(\"textureCoordinateRotationPoints\", textureCoordinateRotationPoints);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.typeOf.object(\"projection\", projection);\n  //>>includeEnd('debug');\n\n  const corner = cornerScratch;\n  const eastward = eastwardScratch;\n  const northward = northwardScratch;\n  computeRectangleBounds(boundingRectangle, ellipsoid, defaultValue(height, 0.0), corner, eastward, northward);\n  const attributes = {};\n  addTextureCoordinateRotationAttributes(attributes, textureCoordinateRotationPoints);\n  const encoded = EncodedCartesian3.fromCartesian(corner, encodeScratch);\n  attributes.southWest_HIGH = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(encoded.high, [0, 0, 0])\n  });\n  attributes.southWest_LOW = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(encoded.low, [0, 0, 0])\n  });\n  attributes.eastward = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(eastward, [0, 0, 0])\n  });\n  attributes.northward = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(northward, [0, 0, 0])\n  });\n  add2DTextureCoordinateAttributes(boundingRectangle, projection, attributes);\n  return attributes;\n};\nconst spherePointScratch = new Cartesian3();\nfunction latLongToSpherical(latitude, longitude, ellipsoid, result) {\n  const cartographic = cartographicScratch;\n  cartographic.latitude = latitude;\n  cartographic.longitude = longitude;\n  cartographic.height = 0.0;\n  const spherePoint = Cartographic.toCartesian(cartographic, ellipsoid, spherePointScratch);\n\n  // Project into plane with vertical for latitude\n  const magXY = Math.sqrt(spherePoint.x * spherePoint.x + spherePoint.y * spherePoint.y);\n\n  // Use fastApproximateAtan2 for alignment with shader\n  const sphereLatitude = CesiumMath.fastApproximateAtan2(magXY, spherePoint.z);\n  const sphereLongitude = CesiumMath.fastApproximateAtan2(spherePoint.x, spherePoint.y);\n  result.x = sphereLatitude;\n  result.y = sphereLongitude;\n  return result;\n}\nconst sphericalScratch = new Cartesian2();\n/**\n * Gets an attributes object containing:\n * - the southwest corner of a rectangular area in spherical coordinates, as well as the inverse of the latitude/longitude range.\n *   These are computed using the same atan2 approximation used in the shader.\n * - 1 texture coordinate rotation GeometryInstanceAttributes\n * - 2 GeometryInstanceAttributes used to compute high-precision points in 2D and Columbus View.\n *   These points are used to compute eye-space planes like above.\n *\n * Used when computing texture coordinates for large-area ClassificationPrimitives with materials or\n * multiple non-overlapping instances.\n * @see ShadowVolumeAppearance\n * @private\n *\n * @param {Rectangle} boundingRectangle Rectangle object that the spherical extents will approximately bound\n * @param {number[]} textureCoordinateRotationPoints Points in the computed texture coordinate system for remapping texture coordinates\n * @param {Ellipsoid} ellipsoid Ellipsoid for converting Rectangle points to world coordinates\n * @param {MapProjection} projection The MapProjection used for 2D and Columbus View.\n * @returns {object} An attributes dictionary containing spherical texture coordinate attributes.\n */\nShadowVolumeAppearance.getSphericalExtentGeometryInstanceAttributes = function (boundingRectangle, textureCoordinateRotationPoints, ellipsoid, projection) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundingRectangle\", boundingRectangle);\n  Check.defined(\"textureCoordinateRotationPoints\", textureCoordinateRotationPoints);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.typeOf.object(\"projection\", projection);\n  //>>includeEnd('debug');\n\n  // rectangle cartographic coords !== spherical because it's on an ellipsoid\n  const southWestExtents = latLongToSpherical(boundingRectangle.south, boundingRectangle.west, ellipsoid, sphericalScratch);\n  let south = southWestExtents.x;\n  let west = southWestExtents.y;\n  const northEastExtents = latLongToSpherical(boundingRectangle.north, boundingRectangle.east, ellipsoid, sphericalScratch);\n  let north = northEastExtents.x;\n  let east = northEastExtents.y;\n\n  // If the bounding rectangle crosses the IDL, rotate the spherical extents so the cross no longer happens.\n  // This rotation must happen in the shader too.\n  let rotationRadians = 0.0;\n  if (west > east) {\n    rotationRadians = CesiumMath.PI - west;\n    west = -CesiumMath.PI;\n    east += rotationRadians;\n  }\n\n  // Slightly pad extents to avoid floating point error when fragment culling at edges.\n  south -= CesiumMath.EPSILON5;\n  west -= CesiumMath.EPSILON5;\n  north += CesiumMath.EPSILON5;\n  east += CesiumMath.EPSILON5;\n  const longitudeRangeInverse = 1.0 / (east - west);\n  const latitudeRangeInverse = 1.0 / (north - south);\n  const attributes = {\n    sphericalExtents: new GeometryInstanceAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 4,\n      normalize: false,\n      value: [south, west, latitudeRangeInverse, longitudeRangeInverse]\n    }),\n    longitudeRotation: new GeometryInstanceAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 1,\n      normalize: false,\n      value: [rotationRadians]\n    })\n  };\n  addTextureCoordinateRotationAttributes(attributes, textureCoordinateRotationPoints);\n  add2DTextureCoordinateAttributes(boundingRectangle, projection, attributes);\n  return attributes;\n};\nShadowVolumeAppearance.hasAttributesForTextureCoordinatePlanes = function (attributes) {\n  return defined(attributes.southWest_HIGH) && defined(attributes.southWest_LOW) && defined(attributes.northward) && defined(attributes.eastward) && defined(attributes.planes2D_HIGH) && defined(attributes.planes2D_LOW) && defined(attributes.uMaxVmax) && defined(attributes.uvMinAndExtents);\n};\nShadowVolumeAppearance.hasAttributesForSphericalExtents = function (attributes) {\n  return defined(attributes.sphericalExtents) && defined(attributes.longitudeRotation) && defined(attributes.planes2D_HIGH) && defined(attributes.planes2D_LOW) && defined(attributes.uMaxVmax) && defined(attributes.uvMinAndExtents);\n};\nfunction shouldUseSpherical(rectangle) {\n  return Math.max(rectangle.width, rectangle.height) > ShadowVolumeAppearance.MAX_WIDTH_FOR_PLANAR_EXTENTS;\n}\n\n/**\n * Computes whether the given rectangle is wide enough that texture coordinates\n * over its area should be computed using spherical extents instead of distance to planes.\n *\n * @param {Rectangle} rectangle A rectangle\n * @private\n */\nShadowVolumeAppearance.shouldUseSphericalCoordinates = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  return shouldUseSpherical(rectangle);\n};\n\n/**\n * Texture coordinates for ground primitives are computed either using spherical coordinates for large areas or\n * using distance from planes for small areas.\n *\n * @type {number}\n * @constant\n * @private\n */\nShadowVolumeAppearance.MAX_WIDTH_FOR_PLANAR_EXTENTS = CesiumMath.toRadians(1.0);\nexport default ShadowVolumeAppearance;","map":{"version":3,"names":["Cartesian2","Cartesian3","Cartographic","Check","ComponentDatatype","defaultValue","defined","EncodedCartesian3","GeometryInstanceAttribute","CesiumMath","Matrix4","Rectangle","Transforms","ShaderSource","PerInstanceColorAppearance","ShadowVolumeAppearanceFS","ShadowVolumeAppearance","extentsCulling","planarExtents","appearance","typeOf","bool","object","_projectionExtentDefines","eastMostYhighDefine","eastMostYlowDefine","westMostYhighDefine","westMostYlowDefine","colorShaderDependencies","ShaderDependencies","requiresTextureCoordinates","requiresEC","flat","pickShaderDependencies","requiresNormalEC","materialShaderSource","material","shaderSource","fragmentShaderSource","normalEC","indexOf","positionToEyeEC","tangentToEyeMatrix","st","_colorShaderDependencies","_pickShaderDependencies","_appearance","_extentsCulling","_planarExtents","prototype","createFragmentShader","columbusView2D","dependencies","defines","push","requiresWC","materialSource","sources","createPickFragmentShader","pickColorQualifier","createVertexShader","vertexShaderSource","mapProjection","string","createShadowVolumeAppearanceVS","createPickVertexShader","undefined","longitudeExtentsCartesianScratch","longitudeExtentsCartographicScratch","longitudeExtentsEncodeScratch","high","low","shaderDependencies","projectionExtentDefines","allDefines","slice","eastMostCartographic","longitude","PI","latitude","height","eastMostCartesian","project","encoded","encode","x","toFixed","length","westMostCartographic","westMostCartesian","_requiresEC","_requiresWC","_requiresNormalEC","_requiresTextureCoordinates","_usesNormalEC","_usesPositionToEyeEC","_usesTangentToEyeMat","_usesSt","Object","defineProperties","get","set","value","pointLineDistance","point1","point2","point","Math","abs","y","distance","points2DScratch","addTextureCoordinateRotationAttributes","attributes","textureCoordinateRotationPoints","points2D","minXYCorner","unpack","maxYCorner","maxXCorner","uMaxVmax","componentDatatype","FLOAT","componentsPerAttribute","normalize","inverseExtentX","inverseExtentY","uvMinAndExtents","cartographicScratch","cornerScratch","northWestScratch","southEastScratch","highLowScratch","add2DTextureCoordinateAttributes","rectangle","projection","carto","west","south","southWestCorner","north","northWest","east","southEast","valuesHigh","valuesLow","planes2D_HIGH","planes2D_LOW","enuMatrixScratch","inverseEnuScratch","rectanglePointCartesianScratch","rectangleCenterScratch","pointsCartographicScratch","computeRectangleBounds","ellipsoid","southWestCornerResult","eastVectorResult","northVectorResult","centerCartographic","center","centerCartesian","toCartesian","enuMatrix","eastNorthUpToFixedFrame","inverseEnu","inverse","cartographics","longitudeCenter","latitudeCenter","minX","Number","POSITIVE_INFINITY","maxX","NEGATIVE_INFINITY","minY","maxY","i","pointCartesian","multiplyByPoint","z","min","max","southEastCorner","subtract","northWestCorner","eastwardScratch","northwardScratch","encodeScratch","getPlanarTextureCoordinateAttributes","boundingRectangle","corner","eastward","northward","fromCartesian","southWest_HIGH","pack","southWest_LOW","spherePointScratch","latLongToSpherical","result","cartographic","spherePoint","magXY","sqrt","sphereLatitude","fastApproximateAtan2","sphereLongitude","sphericalScratch","getSphericalExtentGeometryInstanceAttributes","southWestExtents","northEastExtents","rotationRadians","EPSILON5","longitudeRangeInverse","latitudeRangeInverse","sphericalExtents","longitudeRotation","hasAttributesForTextureCoordinatePlanes","hasAttributesForSphericalExtents","shouldUseSpherical","width","MAX_WIDTH_FOR_PLANAR_EXTENTS","shouldUseSphericalCoordinates","toRadians"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/ShadowVolumeAppearance.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport GeometryInstanceAttribute from \"../Core/GeometryInstanceAttribute.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ShadowVolumeAppearanceFS from \"../Shaders/ShadowVolumeAppearanceFS.js\";\n\n/**\n * Creates shaders for a ClassificationPrimitive to use a given Appearance, as well as for picking.\n *\n * @param {boolean} extentsCulling Discard fragments outside the instance's texture coordinate extents.\n * @param {boolean} planarExtents If true, texture coordinates will be computed using planes instead of spherical coordinates.\n * @param {Appearance} appearance An Appearance to be used with a ClassificationPrimitive via GroundPrimitive.\n * @private\n */\nfunction ShadowVolumeAppearance(extentsCulling, planarExtents, appearance) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"extentsCulling\", extentsCulling);\n  Check.typeOf.bool(\"planarExtents\", planarExtents);\n  Check.typeOf.object(\"appearance\", appearance);\n  //>>includeEnd('debug');\n\n  this._projectionExtentDefines = {\n    eastMostYhighDefine: \"\",\n    eastMostYlowDefine: \"\",\n    westMostYhighDefine: \"\",\n    westMostYlowDefine: \"\",\n  };\n\n  // Compute shader dependencies\n  const colorShaderDependencies = new ShaderDependencies();\n  colorShaderDependencies.requiresTextureCoordinates = extentsCulling;\n  colorShaderDependencies.requiresEC = !appearance.flat;\n\n  const pickShaderDependencies = new ShaderDependencies();\n  pickShaderDependencies.requiresTextureCoordinates = extentsCulling;\n\n  if (appearance instanceof PerInstanceColorAppearance) {\n    // PerInstanceColorAppearance doesn't have material.shaderSource, instead it has its own vertex and fragment shaders\n    colorShaderDependencies.requiresNormalEC = !appearance.flat;\n  } else {\n    // Scan material source for what hookups are needed. Assume czm_materialInput materialInput.\n    const materialShaderSource = `${appearance.material.shaderSource}\\n${appearance.fragmentShaderSource}`;\n\n    colorShaderDependencies.normalEC =\n      materialShaderSource.indexOf(\"materialInput.normalEC\") !== -1 ||\n      materialShaderSource.indexOf(\"czm_getDefaultMaterial\") !== -1;\n    colorShaderDependencies.positionToEyeEC =\n      materialShaderSource.indexOf(\"materialInput.positionToEyeEC\") !== -1;\n    colorShaderDependencies.tangentToEyeMatrix =\n      materialShaderSource.indexOf(\"materialInput.tangentToEyeMatrix\") !== -1;\n    colorShaderDependencies.st =\n      materialShaderSource.indexOf(\"materialInput.st\") !== -1;\n  }\n\n  this._colorShaderDependencies = colorShaderDependencies;\n  this._pickShaderDependencies = pickShaderDependencies;\n  this._appearance = appearance;\n  this._extentsCulling = extentsCulling;\n  this._planarExtents = planarExtents;\n}\n\n/**\n * Create the fragment shader for a ClassificationPrimitive's color pass when rendering for color.\n *\n * @param {boolean} columbusView2D Whether the shader will be used for Columbus View or 2D.\n * @returns {ShaderSource} Shader source for the fragment shader.\n */\nShadowVolumeAppearance.prototype.createFragmentShader = function (\n  columbusView2D,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  //>>includeEnd('debug');\n\n  const appearance = this._appearance;\n  const dependencies = this._colorShaderDependencies;\n\n  const defines = [];\n  if (!columbusView2D && !this._planarExtents) {\n    defines.push(\"SPHERICAL\");\n  }\n  if (dependencies.requiresEC) {\n    defines.push(\"REQUIRES_EC\");\n  }\n  if (dependencies.requiresWC) {\n    defines.push(\"REQUIRES_WC\");\n  }\n  if (dependencies.requiresTextureCoordinates) {\n    defines.push(\"TEXTURE_COORDINATES\");\n  }\n  if (this._extentsCulling) {\n    defines.push(\"CULL_FRAGMENTS\");\n  }\n  if (dependencies.requiresNormalEC) {\n    defines.push(\"NORMAL_EC\");\n  }\n  if (appearance instanceof PerInstanceColorAppearance) {\n    defines.push(\"PER_INSTANCE_COLOR\");\n  }\n\n  // Material inputs. Use of parameters in the material is different\n  // from requirement of the parameters in the overall shader, for example,\n  // texture coordinates may be used for fragment culling but not for the material itself.\n  if (dependencies.normalEC) {\n    defines.push(\"USES_NORMAL_EC\");\n  }\n  if (dependencies.positionToEyeEC) {\n    defines.push(\"USES_POSITION_TO_EYE_EC\");\n  }\n  if (dependencies.tangentToEyeMatrix) {\n    defines.push(\"USES_TANGENT_TO_EYE\");\n  }\n  if (dependencies.st) {\n    defines.push(\"USES_ST\");\n  }\n\n  if (appearance.flat) {\n    defines.push(\"FLAT\");\n  }\n\n  let materialSource = \"\";\n  if (!(appearance instanceof PerInstanceColorAppearance)) {\n    materialSource = appearance.material.shaderSource;\n  }\n\n  return new ShaderSource({\n    defines: defines,\n    sources: [materialSource, ShadowVolumeAppearanceFS],\n  });\n};\n\nShadowVolumeAppearance.prototype.createPickFragmentShader = function (\n  columbusView2D,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  //>>includeEnd('debug');\n\n  const dependencies = this._pickShaderDependencies;\n\n  const defines = [\"PICK\"];\n  if (!columbusView2D && !this._planarExtents) {\n    defines.push(\"SPHERICAL\");\n  }\n  if (dependencies.requiresEC) {\n    defines.push(\"REQUIRES_EC\");\n  }\n  if (dependencies.requiresWC) {\n    defines.push(\"REQUIRES_WC\");\n  }\n  if (dependencies.requiresTextureCoordinates) {\n    defines.push(\"TEXTURE_COORDINATES\");\n  }\n  if (this._extentsCulling) {\n    defines.push(\"CULL_FRAGMENTS\");\n  }\n  return new ShaderSource({\n    defines: defines,\n    sources: [ShadowVolumeAppearanceFS],\n    pickColorQualifier: \"in\",\n  });\n};\n\n/**\n * Create the vertex shader for a ClassificationPrimitive's color pass on the final of 3 shadow volume passes\n *\n * @param {string[]} defines External defines to pass to the vertex shader.\n * @param {string} vertexShaderSource ShadowVolumeAppearanceVS with any required modifications for computing position.\n * @param {boolean} columbusView2D Whether the shader will be used for Columbus View or 2D.\n * @param {MapProjection} mapProjection Current scene's map projection.\n * @returns {string} Shader source for the vertex shader.\n */\nShadowVolumeAppearance.prototype.createVertexShader = function (\n  defines,\n  vertexShaderSource,\n  columbusView2D,\n  mapProjection,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"defines\", defines);\n  Check.typeOf.string(\"vertexShaderSource\", vertexShaderSource);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  Check.defined(\"mapProjection\", mapProjection);\n  //>>includeEnd('debug');\n  return createShadowVolumeAppearanceVS(\n    this._colorShaderDependencies,\n    this._planarExtents,\n    columbusView2D,\n    defines,\n    vertexShaderSource,\n    this._appearance,\n    mapProjection,\n    this._projectionExtentDefines,\n  );\n};\n\n/**\n * Create the vertex shader for a ClassificationPrimitive's pick pass on the final of 3 shadow volume passes\n *\n * @param {string[]} defines External defines to pass to the vertex shader.\n * @param {string} vertexShaderSource ShadowVolumeAppearanceVS with any required modifications for computing position and picking.\n * @param {boolean} columbusView2D Whether the shader will be used for Columbus View or 2D.\n * @param {MapProjection} mapProjection Current scene's map projection.\n * @returns {string} Shader source for the vertex shader.\n */\nShadowVolumeAppearance.prototype.createPickVertexShader = function (\n  defines,\n  vertexShaderSource,\n  columbusView2D,\n  mapProjection,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"defines\", defines);\n  Check.typeOf.string(\"vertexShaderSource\", vertexShaderSource);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  Check.defined(\"mapProjection\", mapProjection);\n  //>>includeEnd('debug');\n  return createShadowVolumeAppearanceVS(\n    this._pickShaderDependencies,\n    this._planarExtents,\n    columbusView2D,\n    defines,\n    vertexShaderSource,\n    undefined,\n    mapProjection,\n    this._projectionExtentDefines,\n  );\n};\n\nconst longitudeExtentsCartesianScratch = new Cartesian3();\nconst longitudeExtentsCartographicScratch = new Cartographic();\nconst longitudeExtentsEncodeScratch = {\n  high: 0.0,\n  low: 0.0,\n};\nfunction createShadowVolumeAppearanceVS(\n  shaderDependencies,\n  planarExtents,\n  columbusView2D,\n  defines,\n  vertexShaderSource,\n  appearance,\n  mapProjection,\n  projectionExtentDefines,\n) {\n  const allDefines = defines.slice();\n\n  if (projectionExtentDefines.eastMostYhighDefine === \"\") {\n    const eastMostCartographic = longitudeExtentsCartographicScratch;\n    eastMostCartographic.longitude = CesiumMath.PI;\n    eastMostCartographic.latitude = 0.0;\n    eastMostCartographic.height = 0.0;\n    const eastMostCartesian = mapProjection.project(\n      eastMostCartographic,\n      longitudeExtentsCartesianScratch,\n    );\n    let encoded = EncodedCartesian3.encode(\n      eastMostCartesian.x,\n      longitudeExtentsEncodeScratch,\n    );\n    projectionExtentDefines.eastMostYhighDefine = `EAST_MOST_X_HIGH ${encoded.high.toFixed(\n      `${encoded.high}`.length + 1,\n    )}`;\n    projectionExtentDefines.eastMostYlowDefine = `EAST_MOST_X_LOW ${encoded.low.toFixed(\n      `${encoded.low}`.length + 1,\n    )}`;\n\n    const westMostCartographic = longitudeExtentsCartographicScratch;\n    westMostCartographic.longitude = -CesiumMath.PI;\n    westMostCartographic.latitude = 0.0;\n    westMostCartographic.height = 0.0;\n    const westMostCartesian = mapProjection.project(\n      westMostCartographic,\n      longitudeExtentsCartesianScratch,\n    );\n    encoded = EncodedCartesian3.encode(\n      westMostCartesian.x,\n      longitudeExtentsEncodeScratch,\n    );\n    projectionExtentDefines.westMostYhighDefine = `WEST_MOST_X_HIGH ${encoded.high.toFixed(\n      `${encoded.high}`.length + 1,\n    )}`;\n    projectionExtentDefines.westMostYlowDefine = `WEST_MOST_X_LOW ${encoded.low.toFixed(\n      `${encoded.low}`.length + 1,\n    )}`;\n  }\n\n  if (columbusView2D) {\n    allDefines.push(projectionExtentDefines.eastMostYhighDefine);\n    allDefines.push(projectionExtentDefines.eastMostYlowDefine);\n    allDefines.push(projectionExtentDefines.westMostYhighDefine);\n    allDefines.push(projectionExtentDefines.westMostYlowDefine);\n  }\n\n  if (defined(appearance) && appearance instanceof PerInstanceColorAppearance) {\n    allDefines.push(\"PER_INSTANCE_COLOR\");\n  }\n  if (shaderDependencies.requiresTextureCoordinates) {\n    allDefines.push(\"TEXTURE_COORDINATES\");\n    if (!(planarExtents || columbusView2D)) {\n      allDefines.push(\"SPHERICAL\");\n    }\n    if (columbusView2D) {\n      allDefines.push(\"COLUMBUS_VIEW_2D\");\n    }\n  }\n\n  return new ShaderSource({\n    defines: allDefines,\n    sources: [vertexShaderSource],\n  });\n}\n\n/**\n * Tracks shader dependencies.\n * @private\n */\nfunction ShaderDependencies() {\n  this._requiresEC = false;\n  this._requiresWC = false; // depends on eye coordinates, needed for material and for phong\n  this._requiresNormalEC = false; // depends on eye coordinates, needed for material\n  this._requiresTextureCoordinates = false; // depends on world coordinates, needed for material and for culling\n\n  this._usesNormalEC = false;\n  this._usesPositionToEyeEC = false;\n  this._usesTangentToEyeMat = false;\n  this._usesSt = false;\n}\n\nObject.defineProperties(ShaderDependencies.prototype, {\n  // Set when assessing final shading (flat vs. phong) and culling using computed texture coordinates\n  requiresEC: {\n    get: function () {\n      return this._requiresEC;\n    },\n    set: function (value) {\n      this._requiresEC = value || this._requiresEC;\n    },\n  },\n  requiresWC: {\n    get: function () {\n      return this._requiresWC;\n    },\n    set: function (value) {\n      this._requiresWC = value || this._requiresWC;\n      this.requiresEC = this._requiresWC;\n    },\n  },\n  requiresNormalEC: {\n    get: function () {\n      return this._requiresNormalEC;\n    },\n    set: function (value) {\n      this._requiresNormalEC = value || this._requiresNormalEC;\n      this.requiresEC = this._requiresNormalEC;\n    },\n  },\n  requiresTextureCoordinates: {\n    get: function () {\n      return this._requiresTextureCoordinates;\n    },\n    set: function (value) {\n      this._requiresTextureCoordinates =\n        value || this._requiresTextureCoordinates;\n      this.requiresWC = this._requiresTextureCoordinates;\n    },\n  },\n  // Get/Set when assessing material hookups\n  normalEC: {\n    set: function (value) {\n      this.requiresNormalEC = value;\n      this._usesNormalEC = value;\n    },\n    get: function () {\n      return this._usesNormalEC;\n    },\n  },\n  tangentToEyeMatrix: {\n    set: function (value) {\n      this.requiresWC = value;\n      this.requiresNormalEC = value;\n      this._usesTangentToEyeMat = value;\n    },\n    get: function () {\n      return this._usesTangentToEyeMat;\n    },\n  },\n  positionToEyeEC: {\n    set: function (value) {\n      this.requiresEC = value;\n      this._usesPositionToEyeEC = value;\n    },\n    get: function () {\n      return this._usesPositionToEyeEC;\n    },\n  },\n  st: {\n    set: function (value) {\n      this.requiresTextureCoordinates = value;\n      this._usesSt = value;\n    },\n    get: function () {\n      return this._usesSt;\n    },\n  },\n});\n\nfunction pointLineDistance(point1, point2, point) {\n  return (\n    Math.abs(\n      (point2.y - point1.y) * point.x -\n        (point2.x - point1.x) * point.y +\n        point2.x * point1.y -\n        point2.y * point1.x,\n    ) / Cartesian2.distance(point2, point1)\n  );\n}\n\nconst points2DScratch = [\n  new Cartesian2(),\n  new Cartesian2(),\n  new Cartesian2(),\n  new Cartesian2(),\n];\n\n// textureCoordinateRotationPoints form 2 lines in the computed UV space that remap to desired texture coordinates.\n// This allows simulation of baked texture coordinates for EllipseGeometry, RectangleGeometry, and PolygonGeometry.\nfunction addTextureCoordinateRotationAttributes(\n  attributes,\n  textureCoordinateRotationPoints,\n) {\n  const points2D = points2DScratch;\n\n  const minXYCorner = Cartesian2.unpack(\n    textureCoordinateRotationPoints,\n    0,\n    points2D[0],\n  );\n  const maxYCorner = Cartesian2.unpack(\n    textureCoordinateRotationPoints,\n    2,\n    points2D[1],\n  );\n  const maxXCorner = Cartesian2.unpack(\n    textureCoordinateRotationPoints,\n    4,\n    points2D[2],\n  );\n\n  attributes.uMaxVmax = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: [maxYCorner.x, maxYCorner.y, maxXCorner.x, maxXCorner.y],\n  });\n\n  const inverseExtentX =\n    1.0 / pointLineDistance(minXYCorner, maxYCorner, maxXCorner);\n  const inverseExtentY =\n    1.0 / pointLineDistance(minXYCorner, maxXCorner, maxYCorner);\n\n  attributes.uvMinAndExtents = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: [minXYCorner.x, minXYCorner.y, inverseExtentX, inverseExtentY],\n  });\n}\n\nconst cartographicScratch = new Cartographic();\nconst cornerScratch = new Cartesian3();\nconst northWestScratch = new Cartesian3();\nconst southEastScratch = new Cartesian3();\nconst highLowScratch = { high: 0.0, low: 0.0 };\nfunction add2DTextureCoordinateAttributes(rectangle, projection, attributes) {\n  // Compute corner positions in double precision\n  const carto = cartographicScratch;\n  carto.height = 0.0;\n\n  carto.longitude = rectangle.west;\n  carto.latitude = rectangle.south;\n\n  const southWestCorner = projection.project(carto, cornerScratch);\n\n  carto.latitude = rectangle.north;\n  const northWest = projection.project(carto, northWestScratch);\n\n  carto.longitude = rectangle.east;\n  carto.latitude = rectangle.south;\n  const southEast = projection.project(carto, southEastScratch);\n\n  // Since these positions are all in the 2D plane, there's a lot of zeros\n  // and a lot of repetition. So we only need to encode 4 values.\n  // Encode:\n  // x: x value for southWestCorner\n  // y: y value for southWestCorner\n  // z: y value for northWest\n  // w: x value for southEast\n\n  const valuesHigh = [0, 0, 0, 0];\n  const valuesLow = [0, 0, 0, 0];\n  let encoded = EncodedCartesian3.encode(southWestCorner.x, highLowScratch);\n  valuesHigh[0] = encoded.high;\n  valuesLow[0] = encoded.low;\n\n  encoded = EncodedCartesian3.encode(southWestCorner.y, highLowScratch);\n  valuesHigh[1] = encoded.high;\n  valuesLow[1] = encoded.low;\n\n  encoded = EncodedCartesian3.encode(northWest.y, highLowScratch);\n  valuesHigh[2] = encoded.high;\n  valuesLow[2] = encoded.low;\n\n  encoded = EncodedCartesian3.encode(southEast.x, highLowScratch);\n  valuesHigh[3] = encoded.high;\n  valuesLow[3] = encoded.low;\n\n  attributes.planes2D_HIGH = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: valuesHigh,\n  });\n\n  attributes.planes2D_LOW = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: valuesLow,\n  });\n}\n\nconst enuMatrixScratch = new Matrix4();\nconst inverseEnuScratch = new Matrix4();\nconst rectanglePointCartesianScratch = new Cartesian3();\nconst rectangleCenterScratch = new Cartographic();\nconst pointsCartographicScratch = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\n/**\n * When computing planes to bound the rectangle,\n * need to factor in \"bulge\" and other distortion.\n * Flatten the ellipsoid-centered corners and edge-centers of the rectangle\n * into the plane of the local ENU system, compute bounds in 2D, and\n * project back to ellipsoid-centered.\n *\n * @private\n */\nfunction computeRectangleBounds(\n  rectangle,\n  ellipsoid,\n  height,\n  southWestCornerResult,\n  eastVectorResult,\n  northVectorResult,\n) {\n  // Compute center of rectangle\n  const centerCartographic = Rectangle.center(\n    rectangle,\n    rectangleCenterScratch,\n  );\n  centerCartographic.height = height;\n  const centerCartesian = Cartographic.toCartesian(\n    centerCartographic,\n    ellipsoid,\n    rectanglePointCartesianScratch,\n  );\n  const enuMatrix = Transforms.eastNorthUpToFixedFrame(\n    centerCartesian,\n    ellipsoid,\n    enuMatrixScratch,\n  );\n  const inverseEnu = Matrix4.inverse(enuMatrix, inverseEnuScratch);\n\n  const west = rectangle.west;\n  const east = rectangle.east;\n  const north = rectangle.north;\n  const south = rectangle.south;\n\n  const cartographics = pointsCartographicScratch;\n  cartographics[0].latitude = south;\n  cartographics[0].longitude = west;\n  cartographics[1].latitude = north;\n  cartographics[1].longitude = west;\n  cartographics[2].latitude = north;\n  cartographics[2].longitude = east;\n  cartographics[3].latitude = south;\n  cartographics[3].longitude = east;\n\n  const longitudeCenter = (west + east) * 0.5;\n  const latitudeCenter = (north + south) * 0.5;\n\n  cartographics[4].latitude = south;\n  cartographics[4].longitude = longitudeCenter;\n  cartographics[5].latitude = north;\n  cartographics[5].longitude = longitudeCenter;\n  cartographics[6].latitude = latitudeCenter;\n  cartographics[6].longitude = west;\n  cartographics[7].latitude = latitudeCenter;\n  cartographics[7].longitude = east;\n\n  let minX = Number.POSITIVE_INFINITY;\n  let maxX = Number.NEGATIVE_INFINITY;\n  let minY = Number.POSITIVE_INFINITY;\n  let maxY = Number.NEGATIVE_INFINITY;\n  for (let i = 0; i < 8; i++) {\n    cartographics[i].height = height;\n    const pointCartesian = Cartographic.toCartesian(\n      cartographics[i],\n      ellipsoid,\n      rectanglePointCartesianScratch,\n    );\n    Matrix4.multiplyByPoint(inverseEnu, pointCartesian, pointCartesian);\n    pointCartesian.z = 0.0; // flatten into XY plane of ENU coordinate system\n    minX = Math.min(minX, pointCartesian.x);\n    maxX = Math.max(maxX, pointCartesian.x);\n    minY = Math.min(minY, pointCartesian.y);\n    maxY = Math.max(maxY, pointCartesian.y);\n  }\n\n  const southWestCorner = southWestCornerResult;\n  southWestCorner.x = minX;\n  southWestCorner.y = minY;\n  southWestCorner.z = 0.0;\n  Matrix4.multiplyByPoint(enuMatrix, southWestCorner, southWestCorner);\n\n  const southEastCorner = eastVectorResult;\n  southEastCorner.x = maxX;\n  southEastCorner.y = minY;\n  southEastCorner.z = 0.0;\n  Matrix4.multiplyByPoint(enuMatrix, southEastCorner, southEastCorner);\n  // make eastward vector\n  Cartesian3.subtract(southEastCorner, southWestCorner, eastVectorResult);\n\n  const northWestCorner = northVectorResult;\n  northWestCorner.x = minX;\n  northWestCorner.y = maxY;\n  northWestCorner.z = 0.0;\n  Matrix4.multiplyByPoint(enuMatrix, northWestCorner, northWestCorner);\n  // make eastward vector\n  Cartesian3.subtract(northWestCorner, southWestCorner, northVectorResult);\n}\n\nconst eastwardScratch = new Cartesian3();\nconst northwardScratch = new Cartesian3();\nconst encodeScratch = new EncodedCartesian3();\n/**\n * Gets an attributes object containing:\n * - 3 high-precision points as 6 GeometryInstanceAttributes. These points are used to compute eye-space planes.\n * - 1 texture coordinate rotation GeometryInstanceAttributes\n * - 2 GeometryInstanceAttributes used to compute high-precision points in 2D and Columbus View.\n *   These points are used to compute eye-space planes like above.\n *\n * Used to compute texture coordinates for small-area ClassificationPrimitives with materials or multiple non-overlapping instances.\n *\n * @see ShadowVolumeAppearance\n * @private\n *\n * @param {Rectangle} boundingRectangle Rectangle object that the points will approximately bound\n * @param {number[]} textureCoordinateRotationPoints Points in the computed texture coordinate system for remapping texture coordinates\n * @param {Ellipsoid} ellipsoid Ellipsoid for converting Rectangle points to world coordinates\n * @param {MapProjection} projection The MapProjection used for 2D and Columbus View.\n * @param {number} [height=0] The maximum height for the shadow volume.\n * @returns {object} An attributes dictionary containing planar texture coordinate attributes.\n */\nShadowVolumeAppearance.getPlanarTextureCoordinateAttributes = function (\n  boundingRectangle,\n  textureCoordinateRotationPoints,\n  ellipsoid,\n  projection,\n  height,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundingRectangle\", boundingRectangle);\n  Check.defined(\n    \"textureCoordinateRotationPoints\",\n    textureCoordinateRotationPoints,\n  );\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.typeOf.object(\"projection\", projection);\n  //>>includeEnd('debug');\n\n  const corner = cornerScratch;\n  const eastward = eastwardScratch;\n  const northward = northwardScratch;\n  computeRectangleBounds(\n    boundingRectangle,\n    ellipsoid,\n    defaultValue(height, 0.0),\n    corner,\n    eastward,\n    northward,\n  );\n\n  const attributes = {};\n  addTextureCoordinateRotationAttributes(\n    attributes,\n    textureCoordinateRotationPoints,\n  );\n\n  const encoded = EncodedCartesian3.fromCartesian(corner, encodeScratch);\n\n  attributes.southWest_HIGH = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(encoded.high, [0, 0, 0]),\n  });\n  attributes.southWest_LOW = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(encoded.low, [0, 0, 0]),\n  });\n  attributes.eastward = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(eastward, [0, 0, 0]),\n  });\n  attributes.northward = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(northward, [0, 0, 0]),\n  });\n\n  add2DTextureCoordinateAttributes(boundingRectangle, projection, attributes);\n  return attributes;\n};\n\nconst spherePointScratch = new Cartesian3();\nfunction latLongToSpherical(latitude, longitude, ellipsoid, result) {\n  const cartographic = cartographicScratch;\n  cartographic.latitude = latitude;\n  cartographic.longitude = longitude;\n  cartographic.height = 0.0;\n\n  const spherePoint = Cartographic.toCartesian(\n    cartographic,\n    ellipsoid,\n    spherePointScratch,\n  );\n\n  // Project into plane with vertical for latitude\n  const magXY = Math.sqrt(\n    spherePoint.x * spherePoint.x + spherePoint.y * spherePoint.y,\n  );\n\n  // Use fastApproximateAtan2 for alignment with shader\n  const sphereLatitude = CesiumMath.fastApproximateAtan2(magXY, spherePoint.z);\n  const sphereLongitude = CesiumMath.fastApproximateAtan2(\n    spherePoint.x,\n    spherePoint.y,\n  );\n\n  result.x = sphereLatitude;\n  result.y = sphereLongitude;\n\n  return result;\n}\n\nconst sphericalScratch = new Cartesian2();\n/**\n * Gets an attributes object containing:\n * - the southwest corner of a rectangular area in spherical coordinates, as well as the inverse of the latitude/longitude range.\n *   These are computed using the same atan2 approximation used in the shader.\n * - 1 texture coordinate rotation GeometryInstanceAttributes\n * - 2 GeometryInstanceAttributes used to compute high-precision points in 2D and Columbus View.\n *   These points are used to compute eye-space planes like above.\n *\n * Used when computing texture coordinates for large-area ClassificationPrimitives with materials or\n * multiple non-overlapping instances.\n * @see ShadowVolumeAppearance\n * @private\n *\n * @param {Rectangle} boundingRectangle Rectangle object that the spherical extents will approximately bound\n * @param {number[]} textureCoordinateRotationPoints Points in the computed texture coordinate system for remapping texture coordinates\n * @param {Ellipsoid} ellipsoid Ellipsoid for converting Rectangle points to world coordinates\n * @param {MapProjection} projection The MapProjection used for 2D and Columbus View.\n * @returns {object} An attributes dictionary containing spherical texture coordinate attributes.\n */\nShadowVolumeAppearance.getSphericalExtentGeometryInstanceAttributes = function (\n  boundingRectangle,\n  textureCoordinateRotationPoints,\n  ellipsoid,\n  projection,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundingRectangle\", boundingRectangle);\n  Check.defined(\n    \"textureCoordinateRotationPoints\",\n    textureCoordinateRotationPoints,\n  );\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.typeOf.object(\"projection\", projection);\n  //>>includeEnd('debug');\n\n  // rectangle cartographic coords !== spherical because it's on an ellipsoid\n  const southWestExtents = latLongToSpherical(\n    boundingRectangle.south,\n    boundingRectangle.west,\n    ellipsoid,\n    sphericalScratch,\n  );\n\n  let south = southWestExtents.x;\n  let west = southWestExtents.y;\n\n  const northEastExtents = latLongToSpherical(\n    boundingRectangle.north,\n    boundingRectangle.east,\n    ellipsoid,\n    sphericalScratch,\n  );\n  let north = northEastExtents.x;\n  let east = northEastExtents.y;\n\n  // If the bounding rectangle crosses the IDL, rotate the spherical extents so the cross no longer happens.\n  // This rotation must happen in the shader too.\n  let rotationRadians = 0.0;\n  if (west > east) {\n    rotationRadians = CesiumMath.PI - west;\n    west = -CesiumMath.PI;\n    east += rotationRadians;\n  }\n\n  // Slightly pad extents to avoid floating point error when fragment culling at edges.\n  south -= CesiumMath.EPSILON5;\n  west -= CesiumMath.EPSILON5;\n  north += CesiumMath.EPSILON5;\n  east += CesiumMath.EPSILON5;\n\n  const longitudeRangeInverse = 1.0 / (east - west);\n  const latitudeRangeInverse = 1.0 / (north - south);\n\n  const attributes = {\n    sphericalExtents: new GeometryInstanceAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 4,\n      normalize: false,\n      value: [south, west, latitudeRangeInverse, longitudeRangeInverse],\n    }),\n    longitudeRotation: new GeometryInstanceAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 1,\n      normalize: false,\n      value: [rotationRadians],\n    }),\n  };\n\n  addTextureCoordinateRotationAttributes(\n    attributes,\n    textureCoordinateRotationPoints,\n  );\n  add2DTextureCoordinateAttributes(boundingRectangle, projection, attributes);\n  return attributes;\n};\n\nShadowVolumeAppearance.hasAttributesForTextureCoordinatePlanes = function (\n  attributes,\n) {\n  return (\n    defined(attributes.southWest_HIGH) &&\n    defined(attributes.southWest_LOW) &&\n    defined(attributes.northward) &&\n    defined(attributes.eastward) &&\n    defined(attributes.planes2D_HIGH) &&\n    defined(attributes.planes2D_LOW) &&\n    defined(attributes.uMaxVmax) &&\n    defined(attributes.uvMinAndExtents)\n  );\n};\n\nShadowVolumeAppearance.hasAttributesForSphericalExtents = function (\n  attributes,\n) {\n  return (\n    defined(attributes.sphericalExtents) &&\n    defined(attributes.longitudeRotation) &&\n    defined(attributes.planes2D_HIGH) &&\n    defined(attributes.planes2D_LOW) &&\n    defined(attributes.uMaxVmax) &&\n    defined(attributes.uvMinAndExtents)\n  );\n};\n\nfunction shouldUseSpherical(rectangle) {\n  return (\n    Math.max(rectangle.width, rectangle.height) >\n    ShadowVolumeAppearance.MAX_WIDTH_FOR_PLANAR_EXTENTS\n  );\n}\n\n/**\n * Computes whether the given rectangle is wide enough that texture coordinates\n * over its area should be computed using spherical extents instead of distance to planes.\n *\n * @param {Rectangle} rectangle A rectangle\n * @private\n */\nShadowVolumeAppearance.shouldUseSphericalCoordinates = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  return shouldUseSpherical(rectangle);\n};\n\n/**\n * Texture coordinates for ground primitives are computed either using spherical coordinates for large areas or\n * using distance from planes for small areas.\n *\n * @type {number}\n * @constant\n * @private\n */\nShadowVolumeAppearance.MAX_WIDTH_FOR_PLANAR_EXTENTS = CesiumMath.toRadians(1.0);\nexport default ShadowVolumeAppearance;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}