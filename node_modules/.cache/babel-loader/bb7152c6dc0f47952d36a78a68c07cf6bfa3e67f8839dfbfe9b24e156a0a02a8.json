{"ast":null,"code":"import AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Color from \"../../Core/Color.js\";\nimport Check from \"../../Core/Check.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\nimport MersenneTwister from \"mersenne-twister\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport AlphaMode from \"../AlphaMode.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport Axis from \"../Axis.js\";\nimport parseBatchTable from \"../parseBatchTable.js\";\nimport DracoLoader from \"../DracoLoader.js\";\nimport StructuralMetadata from \"../StructuralMetadata.js\";\nimport ResourceLoader from \"../ResourceLoader.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport PntsParser from \"../PntsParser.js\";\nimport ResourceLoaderState from \"../ResourceLoaderState.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nconst Components = ModelComponents.Components;\nconst Scene = ModelComponents.Scene;\nconst Node = ModelComponents.Node;\nconst Primitive = ModelComponents.Primitive;\nconst Attribute = ModelComponents.Attribute;\nconst Quantization = ModelComponents.Quantization;\nconst FeatureIdAttribute = ModelComponents.FeatureIdAttribute;\nconst Material = ModelComponents.Material;\nconst MetallicRoughness = ModelComponents.MetallicRoughness;\n\n/**\n * Loads a .pnts point cloud and transcodes it into a {@link ModelComponents}\n *\n * @alias PntsLoader\n * @constructor\n * @augments ResourceLoader\n * @private\n *\n * @param {object} options An object containing the following properties\n * @param {ArrayBuffer} options.arrayBuffer The array buffer of the pnts contents\n * @param {number} [options.byteOffset] The byte offset to the beginning of the pnts contents in the array buffer\n * @param {boolean} [options.loadAttributesFor2D=false] If true, load the positions buffer as a typed array for accurately projecting models to 2D.\n */\nfunction PntsLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const arrayBuffer = options.arrayBuffer;\n  const byteOffset = defaultValue(options.byteOffset, 0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  this._arrayBuffer = arrayBuffer;\n  this._byteOffset = byteOffset;\n  this._loadAttributesFor2D = defaultValue(options.loadAttributesFor2D, false);\n  this._parsedContent = undefined;\n  this._decodePromise = undefined;\n  this._decodedAttributes = undefined;\n  this._promise = undefined;\n  this._error = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._buffers = [];\n\n  // The batch table object contains a json and a binary component access using keys of the same name.\n  this._components = undefined;\n  this._transform = Matrix4.IDENTITY;\n}\nif (defined(Object.create)) {\n  PntsLoader.prototype = Object.create(ResourceLoader.prototype);\n  PntsLoader.prototype.constructor = PntsLoader;\n}\nObject.defineProperties(PntsLoader.prototype, {\n  /**\n   * The cache key of the resource\n   *\n   * @memberof PntsLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    }\n  },\n  /**\n   * The loaded components.\n   *\n   * @memberof PntsLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    }\n  },\n  /**\n   * A world-space transform to apply to the primitives.\n   * See {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/PointCloud#global-semantics}\n   *\n   * @memberof PntsLoader.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   * @private\n   */\n  transform: {\n    get: function () {\n      return this._transform;\n    }\n  }\n});\n\n/**\n * Loads the resource.\n * @returns {Promise<PntsLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nPntsLoader.prototype.load = function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n  this._parsedContent = PntsParser.parse(this._arrayBuffer, this._byteOffset);\n  this._state = ResourceLoaderState.PROCESSING;\n  this._promise = Promise.resolve(this);\n};\nPntsLoader.prototype.process = function (frameState) {\n  if (defined(this._error)) {\n    const error = this._error;\n    this._error = undefined;\n    throw error;\n  }\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n  if (this._state === ResourceLoaderState.PROCESSING) {\n    if (defined(this._decodePromise)) {\n      return false;\n    }\n    this._decodePromise = decodeDraco(this, frameState.context);\n  }\n  return false;\n};\nfunction decodeDraco(loader, context) {\n  const parsedContent = loader._parsedContent;\n  const draco = parsedContent.draco;\n  let decodePromise;\n  if (!defined(draco)) {\n    // The draco extension wasn't present,\n    decodePromise = Promise.resolve();\n  } else {\n    decodePromise = DracoLoader.decodePointCloud(draco, context);\n  }\n  if (!defined(decodePromise)) {\n    // Could not schedule Draco decoding this frame.\n    return;\n  }\n  loader._decodePromise = decodePromise;\n  return decodePromise.then(function (decodeDracoResult) {\n    if (loader.isDestroyed()) {\n      return;\n    }\n    if (defined(decodeDracoResult)) {\n      processDracoAttributes(loader, draco, decodeDracoResult);\n    }\n    makeComponents(loader, context);\n    loader._state = ResourceLoaderState.READY;\n    return loader;\n  }).catch(function (error) {\n    loader.unload();\n    loader._state = ResourceLoaderState.FAILED;\n    const errorMessage = \"Failed to load Draco pnts\";\n    // This error will be thrown next time process is called;\n    loader._error = loader.getError(errorMessage, error);\n  });\n}\nfunction processDracoAttributes(loader, draco, result) {\n  loader._state = ResourceLoaderState.READY;\n  const parsedContent = loader._parsedContent;\n  let attribute;\n  if (defined(result.POSITION)) {\n    attribute = {\n      name: \"POSITION\",\n      semantic: VertexAttributeSemantic.POSITION,\n      typedArray: result.POSITION.array,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      isQuantized: false\n    };\n    if (defined(result.POSITION.data.quantization)) {\n      // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n      // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n      const quantization = result.POSITION.data.quantization;\n      const range = quantization.range;\n      const quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n      const quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n      const quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n      attribute.isQuantized = true;\n      attribute.quantizedRange = quantizedRange;\n      attribute.quantizedVolumeOffset = quantizedVolumeOffset;\n      attribute.quantizedVolumeScale = quantizedVolumeScale;\n      attribute.quantizedComponentDatatype = quantizedRange <= 255 ? ComponentDatatype.UNSIGNED_BYTE : ComponentDatatype.UNSIGNED_SHORT;\n      attribute.quantizedType = AttributeType.VEC3;\n    }\n    parsedContent.positions = attribute;\n  }\n  if (defined(result.NORMAL)) {\n    attribute = {\n      name: \"NORMAL\",\n      semantic: VertexAttributeSemantic.NORMAL,\n      typedArray: result.NORMAL.array,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      isQuantized: false,\n      octEncoded: false,\n      octEncodedZXY: false\n    };\n    if (defined(result.NORMAL.data.quantization)) {\n      const octEncodedRange = (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n      attribute.quantizedRange = octEncodedRange;\n      attribute.octEncoded = true;\n      attribute.octEncodedZXY = true;\n      attribute.quantizedComponentDatatype = ComponentDatatype.UNSIGNED_BYTE;\n      attribute.quantizedType = AttributeType.VEC2;\n    }\n    parsedContent.normals = attribute;\n  }\n  if (defined(result.RGBA)) {\n    parsedContent.colors = {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: result.RGBA.array,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC4,\n      normalized: true,\n      isTranslucent: true\n    };\n  } else if (defined(result.RGB)) {\n    parsedContent.colors = {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: result.RGB.array,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC3,\n      normalized: true,\n      isTranslucent: false\n    };\n  }\n\n  // Transcode Batch ID (3D Tiles 1.0) -> Feature ID (3D Tiles Next)\n  if (defined(result.BATCH_ID)) {\n    const batchIds = result.BATCH_ID.array;\n    parsedContent.batchIds = {\n      name: \"_FEATURE_ID\",\n      semantic: VertexAttributeSemantic.FEATURE_ID,\n      setIndex: 0,\n      typedArray: batchIds,\n      componentDatatype: ComponentDatatype.fromTypedArray(batchIds),\n      type: AttributeType.SCALAR\n    };\n  }\n  let batchTableJson = parsedContent.batchTableJson;\n  const batchTableProperties = draco.batchTableProperties;\n  for (const name in batchTableProperties) {\n    if (batchTableProperties.hasOwnProperty(name)) {\n      const property = result[name];\n      if (!defined(batchTableJson)) {\n        batchTableJson = {};\n      }\n      parsedContent.hasDracoBatchTable = true;\n      const data = property.data;\n      batchTableJson[name] = {\n        byteOffset: data.byteOffset,\n        // Draco returns the results like glTF values, but here\n        // we want to transcode to a batch table. It's redundant\n        // but necessary to use parseBatchTable()\n        type: transcodeAttributeType(data.componentsPerAttribute),\n        componentType: transcodeComponentType(data.componentDatatype),\n        // Each property is stored as a separate typed array, so\n        // store it here. parseBatchTable() will check for this\n        // instead of the entire binary body.\n        typedArray: property.array\n      };\n    }\n  }\n  parsedContent.batchTableJson = batchTableJson;\n}\nfunction transcodeAttributeType(componentsPerAttribute) {\n  switch (componentsPerAttribute) {\n    case 1:\n      return \"SCALAR\";\n    case 2:\n      return \"VEC2\";\n    case 3:\n      return \"VEC3\";\n    case 4:\n      return \"VEC4\";\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"componentsPerAttribute must be a number from 1-4\");\n    //>>includeEnd('debug');\n  }\n}\nfunction transcodeComponentType(value) {\n  switch (value) {\n    case WebGLConstants.BYTE:\n      return \"BYTE\";\n    case WebGLConstants.UNSIGNED_BYTE:\n      return \"UNSIGNED_BYTE\";\n    case WebGLConstants.SHORT:\n      return \"SHORT\";\n    case WebGLConstants.UNSIGNED_SHORT:\n      return \"UNSIGNED_SHORT\";\n    case WebGLConstants.INT:\n      return \"INT\";\n    case WebGLConstants.UNSIGNED_INT:\n      return \"UNSIGNED_INT\";\n    case WebGLConstants.DOUBLE:\n      return \"DOUBLE\";\n    case WebGLConstants.FLOAT:\n      return \"FLOAT\";\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"value is not a valid WebGL constant\");\n    //>>includeEnd('debug');\n  }\n}\nfunction makeAttribute(loader, attributeInfo, context) {\n  let typedArray = attributeInfo.typedArray;\n  let quantization;\n  if (attributeInfo.octEncoded) {\n    quantization = new Quantization();\n    quantization.octEncoded = attributeInfo.octEncoded;\n    quantization.octEncodedZXY = attributeInfo.octEncodedZXY;\n    quantization.normalizationRange = attributeInfo.quantizedRange;\n    quantization.type = attributeInfo.quantizedType;\n    quantization.componentDatatype = attributeInfo.quantizedComponentDatatype;\n  }\n  if (attributeInfo.isQuantized) {\n    quantization = new Quantization();\n    const normalizationRange = attributeInfo.quantizedRange;\n    quantization.normalizationRange = normalizationRange;\n    // volume offset sometimes requires 64-bit precision so this is handled\n    // in the components.transform matrix.\n    quantization.quantizedVolumeOffset = Cartesian3.ZERO;\n    const quantizedVolumeDimensions = attributeInfo.quantizedVolumeScale;\n    quantization.quantizedVolumeDimensions = quantizedVolumeDimensions;\n    quantization.quantizedVolumeStepSize = Cartesian3.divideByScalar(quantizedVolumeDimensions, normalizationRange, new Cartesian3());\n    quantization.componentDatatype = attributeInfo.quantizedComponentDatatype;\n    quantization.type = attributeInfo.quantizedType;\n  }\n  const attribute = new Attribute();\n  attribute.name = attributeInfo.name;\n  attribute.semantic = attributeInfo.semantic;\n  attribute.setIndex = attributeInfo.setIndex;\n  attribute.componentDatatype = attributeInfo.componentDatatype;\n  attribute.type = attributeInfo.type;\n  attribute.normalized = defaultValue(attributeInfo.normalized, false);\n  attribute.min = attributeInfo.min;\n  attribute.max = attributeInfo.max;\n  attribute.quantization = quantization;\n  if (attributeInfo.isRGB565) {\n    typedArray = AttributeCompression.decodeRGB565(typedArray);\n  }\n  if (defined(attributeInfo.constantColor)) {\n    const packedColor = new Array(4);\n    attribute.constant = Color.pack(attributeInfo.constantColor, packedColor);\n  } else {\n    const buffer = Buffer.createVertexBuffer({\n      typedArray: typedArray,\n      context: context,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    buffer.vertexArrayDestroyable = false;\n    loader._buffers.push(buffer);\n    attribute.buffer = buffer;\n  }\n  const loadAttributesFor2D = loader._loadAttributesFor2D;\n  if (attribute.semantic === VertexAttributeSemantic.POSITION && loadAttributesFor2D) {\n    attribute.typedArray = typedArray;\n  }\n  return attribute;\n}\nlet randomNumberGenerator;\nlet randomValues;\nfunction getRandomValues(samplesLength) {\n  // Use same random values across all runs\n  if (!defined(randomValues)) {\n    // Use MersenneTwister directly to avoid interfering with CesiumMath.nextRandomNumber()\n    // See https://github.com/CesiumGS/cesium/issues/9730\n    randomNumberGenerator = new MersenneTwister(0);\n    randomValues = new Array(samplesLength);\n    for (let i = 0; i < samplesLength; ++i) {\n      randomValues[i] = randomNumberGenerator.random();\n    }\n  }\n  return randomValues;\n}\nconst scratchMin = new Cartesian3();\nconst scratchMax = new Cartesian3();\nconst scratchPosition = new Cartesian3();\nfunction computeApproximateExtrema(positions) {\n  const positionsArray = positions.typedArray;\n  const maximumSamplesLength = 20;\n  const pointsLength = positionsArray.length / 3;\n  const samplesLength = Math.min(pointsLength, maximumSamplesLength);\n  const randomValues = getRandomValues(maximumSamplesLength);\n  const maxValue = Number.MAX_VALUE;\n  const minValue = -Number.MAX_VALUE;\n  let min = Cartesian3.fromElements(maxValue, maxValue, maxValue, scratchMin);\n  let max = Cartesian3.fromElements(minValue, minValue, minValue, scratchMax);\n  let i;\n  let index;\n  let position;\n  if (positions.isQuantized) {\n    // The quantized volume offset is not used here since it will become part of\n    // the model matrix.\n    min = Cartesian3.ZERO;\n    max = positions.quantizedVolumeScale;\n  } else {\n    for (i = 0; i < samplesLength; ++i) {\n      index = Math.floor(randomValues[i] * pointsLength);\n      position = Cartesian3.unpack(positionsArray, index * 3, scratchPosition);\n      Cartesian3.minimumByComponent(min, position, min);\n      Cartesian3.maximumByComponent(max, position, max);\n    }\n  }\n  positions.min = Cartesian3.clone(min);\n  positions.max = Cartesian3.clone(max);\n}\n\n// By default, point clouds are rendered as dark gray.\nconst defaultColorAttribute = {\n  name: VertexAttributeSemantic.COLOR,\n  semantic: VertexAttributeSemantic.COLOR,\n  setIndex: 0,\n  constantColor: Color.DARKGRAY,\n  componentDatatype: ComponentDatatype.FLOAT,\n  type: AttributeType.VEC4,\n  isQuantized: false,\n  isTranslucent: false\n};\nfunction makeAttributes(loader, parsedContent, context) {\n  const attributes = [];\n  let attribute;\n  const positions = parsedContent.positions;\n  if (defined(positions)) {\n    computeApproximateExtrema(positions);\n    attribute = makeAttribute(loader, positions, context);\n    attribute.count = parsedContent.pointsLength;\n    attributes.push(attribute);\n  }\n  if (defined(parsedContent.normals)) {\n    attribute = makeAttribute(loader, parsedContent.normals, context);\n    attributes.push(attribute);\n  }\n  if (defined(parsedContent.colors)) {\n    attribute = makeAttribute(loader, parsedContent.colors, context);\n    attributes.push(attribute);\n  } else {\n    attribute = makeAttribute(loader, defaultColorAttribute, context);\n    attributes.push(attribute);\n  }\n  if (defined(parsedContent.batchIds)) {\n    attribute = makeAttribute(loader, parsedContent.batchIds, context);\n    attributes.push(attribute);\n  }\n  return attributes;\n}\nfunction makeStructuralMetadata(parsedContent, customAttributeOutput) {\n  const batchLength = parsedContent.batchLength;\n  const pointsLength = parsedContent.pointsLength;\n  const batchTableBinary = parsedContent.batchTableBinary;\n\n  // If there are batch IDs, parse as a property table. Otherwise, parse\n  // as property attributes.\n  const parseAsPropertyAttributes = !defined(parsedContent.batchIds);\n  if (defined(batchTableBinary) || parsedContent.hasDracoBatchTable) {\n    const count = defaultValue(batchLength, pointsLength);\n    return parseBatchTable({\n      count: count,\n      batchTable: parsedContent.batchTableJson,\n      binaryBody: batchTableBinary,\n      parseAsPropertyAttributes: parseAsPropertyAttributes,\n      customAttributeOutput: customAttributeOutput\n    });\n  }\n  return new StructuralMetadata({\n    schema: {},\n    propertyTables: []\n  });\n}\nfunction makeComponents(loader, context) {\n  const parsedContent = loader._parsedContent;\n  const metallicRoughness = new MetallicRoughness();\n  metallicRoughness.metallicFactor = 0;\n  metallicRoughness.roughnessFactor = 0.9;\n  const material = new Material();\n  material.metallicRoughness = metallicRoughness;\n  const colors = parsedContent.colors;\n  if (defined(colors) && colors.isTranslucent) {\n    material.alphaMode = AlphaMode.BLEND;\n  }\n\n  // Render point clouds as unlit, unless normals are present, in which case\n  // render as a PBR material.\n  const isUnlit = !defined(parsedContent.normals);\n  material.unlit = isUnlit;\n  const primitive = new Primitive();\n  primitive.attributes = makeAttributes(loader, parsedContent, context);\n  primitive.primitiveType = PrimitiveType.POINTS;\n  primitive.material = material;\n  if (defined(parsedContent.batchIds)) {\n    const featureIdAttribute = new FeatureIdAttribute();\n    featureIdAttribute.propertyTableId = 0;\n    featureIdAttribute.setIndex = 0;\n    featureIdAttribute.positionalLabel = \"featureId_0\";\n    primitive.featureIds.push(featureIdAttribute);\n  }\n  const node = new Node();\n  node.index = 0;\n  node.primitives = [primitive];\n  const scene = new Scene();\n  scene.nodes = [node];\n  scene.upAxis = Axis.Z;\n  scene.forwardAxis = Axis.X;\n  const components = new Components();\n  components.scene = scene;\n  components.nodes = [node];\n\n  // Per-point features will be parsed as property attributes and handled on\n  // the GPU since CPU styling would be too expensive. However, if batch IDs\n  // exist, features will be parsed as a property table.\n  //\n  // Property attributes refer to a custom attribute that will\n  // store the values; such attributes will be populated in this array\n  // as needed.\n  const customAttributeOutput = [];\n  components.structuralMetadata = makeStructuralMetadata(parsedContent, customAttributeOutput);\n  if (customAttributeOutput.length > 0) {\n    addPropertyAttributesToPrimitive(loader, primitive, customAttributeOutput, context);\n  }\n  if (defined(parsedContent.rtcCenter)) {\n    components.transform = Matrix4.multiplyByTranslation(components.transform, parsedContent.rtcCenter, components.transform);\n  }\n  const positions = parsedContent.positions;\n  if (defined(positions) && positions.isQuantized) {\n    // The volume offset is sometimes in ECEF, so this is applied here rather\n    // than the dequantization shader to avoid jitter\n    components.transform = Matrix4.multiplyByTranslation(components.transform, positions.quantizedVolumeOffset, components.transform);\n  }\n  loader._components = components;\n\n  // Free the parsed content and array buffer so we don't hold onto the large arrays.\n  loader._parsedContent = undefined;\n  loader._arrayBuffer = undefined;\n}\nfunction addPropertyAttributesToPrimitive(loader, primitive, customAttributes, context) {\n  const attributes = primitive.attributes;\n  const length = customAttributes.length;\n  for (let i = 0; i < length; i++) {\n    const customAttribute = customAttributes[i];\n\n    // Upload the typed array to the GPU and free the CPU copy.\n    const buffer = Buffer.createVertexBuffer({\n      typedArray: customAttribute.typedArray,\n      context: context,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    buffer.vertexArrayDestroyable = false;\n    loader._buffers.push(buffer);\n    customAttribute.buffer = buffer;\n    customAttribute.typedArray = undefined;\n    attributes.push(customAttribute);\n  }\n\n  // The batch table is always transcoded as a single property attribute, so\n  // it will always be index 0\n  primitive.propertyAttributeIds = [0];\n}\nPntsLoader.prototype.unload = function () {\n  const buffers = this._buffers;\n  for (let i = 0; i < buffers.length; i++) {\n    buffers[i].destroy();\n  }\n  buffers.length = 0;\n  this._components = undefined;\n  this._parsedContent = undefined;\n  this._arrayBuffer = undefined;\n};\nexport default PntsLoader;","map":{"version":3,"names":["AttributeCompression","Cartesian3","Color","Check","ComponentDatatype","defaultValue","defined","DeveloperError","Matrix4","PrimitiveType","WebGLConstants","MersenneTwister","Buffer","BufferUsage","AlphaMode","AttributeType","Axis","parseBatchTable","DracoLoader","StructuralMetadata","ResourceLoader","ModelComponents","PntsParser","ResourceLoaderState","VertexAttributeSemantic","Components","Scene","Node","Primitive","Attribute","Quantization","FeatureIdAttribute","Material","MetallicRoughness","PntsLoader","options","EMPTY_OBJECT","arrayBuffer","byteOffset","typeOf","object","_arrayBuffer","_byteOffset","_loadAttributesFor2D","loadAttributesFor2D","_parsedContent","undefined","_decodePromise","_decodedAttributes","_promise","_error","_state","UNLOADED","_buffers","_components","_transform","IDENTITY","Object","create","prototype","constructor","defineProperties","cacheKey","get","components","transform","load","parse","PROCESSING","Promise","resolve","process","frameState","error","READY","decodeDraco","context","loader","parsedContent","draco","decodePromise","decodePointCloud","then","decodeDracoResult","isDestroyed","processDracoAttributes","makeComponents","catch","unload","FAILED","errorMessage","getError","result","attribute","POSITION","name","semantic","typedArray","array","componentDatatype","FLOAT","type","VEC3","isQuantized","data","quantization","range","quantizedVolumeScale","fromElements","quantizedVolumeOffset","unpack","minValues","quantizedRange","quantizationBits","quantizedComponentDatatype","UNSIGNED_BYTE","UNSIGNED_SHORT","quantizedType","positions","NORMAL","octEncoded","octEncodedZXY","octEncodedRange","VEC2","normals","RGBA","colors","COLOR","setIndex","VEC4","normalized","isTranslucent","RGB","BATCH_ID","batchIds","FEATURE_ID","fromTypedArray","SCALAR","batchTableJson","batchTableProperties","hasOwnProperty","property","hasDracoBatchTable","transcodeAttributeType","componentsPerAttribute","componentType","transcodeComponentType","value","BYTE","SHORT","INT","UNSIGNED_INT","DOUBLE","makeAttribute","attributeInfo","normalizationRange","ZERO","quantizedVolumeDimensions","quantizedVolumeStepSize","divideByScalar","min","max","isRGB565","decodeRGB565","constantColor","packedColor","Array","constant","pack","buffer","createVertexBuffer","usage","STATIC_DRAW","vertexArrayDestroyable","push","randomNumberGenerator","randomValues","getRandomValues","samplesLength","i","random","scratchMin","scratchMax","scratchPosition","computeApproximateExtrema","positionsArray","maximumSamplesLength","pointsLength","length","Math","maxValue","Number","MAX_VALUE","minValue","index","position","floor","minimumByComponent","maximumByComponent","clone","defaultColorAttribute","DARKGRAY","makeAttributes","attributes","count","makeStructuralMetadata","customAttributeOutput","batchLength","batchTableBinary","parseAsPropertyAttributes","batchTable","binaryBody","schema","propertyTables","metallicRoughness","metallicFactor","roughnessFactor","material","alphaMode","BLEND","isUnlit","unlit","primitive","primitiveType","POINTS","featureIdAttribute","propertyTableId","positionalLabel","featureIds","node","primitives","scene","nodes","upAxis","Z","forwardAxis","X","structuralMetadata","addPropertyAttributesToPrimitive","rtcCenter","multiplyByTranslation","customAttributes","customAttribute","propertyAttributeIds","buffers","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Model/PntsLoader.js"],"sourcesContent":["import AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Color from \"../../Core/Color.js\";\nimport Check from \"../../Core/Check.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\nimport MersenneTwister from \"mersenne-twister\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport AlphaMode from \"../AlphaMode.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport Axis from \"../Axis.js\";\nimport parseBatchTable from \"../parseBatchTable.js\";\nimport DracoLoader from \"../DracoLoader.js\";\nimport StructuralMetadata from \"../StructuralMetadata.js\";\nimport ResourceLoader from \"../ResourceLoader.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport PntsParser from \"../PntsParser.js\";\nimport ResourceLoaderState from \"../ResourceLoaderState.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\nconst Components = ModelComponents.Components;\nconst Scene = ModelComponents.Scene;\nconst Node = ModelComponents.Node;\nconst Primitive = ModelComponents.Primitive;\nconst Attribute = ModelComponents.Attribute;\nconst Quantization = ModelComponents.Quantization;\nconst FeatureIdAttribute = ModelComponents.FeatureIdAttribute;\nconst Material = ModelComponents.Material;\nconst MetallicRoughness = ModelComponents.MetallicRoughness;\n\n/**\n * Loads a .pnts point cloud and transcodes it into a {@link ModelComponents}\n *\n * @alias PntsLoader\n * @constructor\n * @augments ResourceLoader\n * @private\n *\n * @param {object} options An object containing the following properties\n * @param {ArrayBuffer} options.arrayBuffer The array buffer of the pnts contents\n * @param {number} [options.byteOffset] The byte offset to the beginning of the pnts contents in the array buffer\n * @param {boolean} [options.loadAttributesFor2D=false] If true, load the positions buffer as a typed array for accurately projecting models to 2D.\n */\nfunction PntsLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const arrayBuffer = options.arrayBuffer;\n  const byteOffset = defaultValue(options.byteOffset, 0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  this._arrayBuffer = arrayBuffer;\n  this._byteOffset = byteOffset;\n  this._loadAttributesFor2D = defaultValue(options.loadAttributesFor2D, false);\n\n  this._parsedContent = undefined;\n  this._decodePromise = undefined;\n  this._decodedAttributes = undefined;\n\n  this._promise = undefined;\n  this._error = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._buffers = [];\n\n  // The batch table object contains a json and a binary component access using keys of the same name.\n  this._components = undefined;\n  this._transform = Matrix4.IDENTITY;\n}\n\nif (defined(Object.create)) {\n  PntsLoader.prototype = Object.create(ResourceLoader.prototype);\n  PntsLoader.prototype.constructor = PntsLoader;\n}\n\nObject.defineProperties(PntsLoader.prototype, {\n  /**\n   * The cache key of the resource\n   *\n   * @memberof PntsLoader.prototype\n   *\n   * @type {string}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * The loaded components.\n   *\n   * @memberof PntsLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n\n  /**\n   * A world-space transform to apply to the primitives.\n   * See {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/PointCloud#global-semantics}\n   *\n   * @memberof PntsLoader.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   * @private\n   */\n  transform: {\n    get: function () {\n      return this._transform;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise<PntsLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nPntsLoader.prototype.load = function () {\n  if (defined(this._promise)) {\n    return this._promise;\n  }\n\n  this._parsedContent = PntsParser.parse(this._arrayBuffer, this._byteOffset);\n  this._state = ResourceLoaderState.PROCESSING;\n\n  this._promise = Promise.resolve(this);\n};\n\nPntsLoader.prototype.process = function (frameState) {\n  if (defined(this._error)) {\n    const error = this._error;\n    this._error = undefined;\n    throw error;\n  }\n\n  if (this._state === ResourceLoaderState.READY) {\n    return true;\n  }\n\n  if (this._state === ResourceLoaderState.PROCESSING) {\n    if (defined(this._decodePromise)) {\n      return false;\n    }\n\n    this._decodePromise = decodeDraco(this, frameState.context);\n  }\n\n  return false;\n};\n\nfunction decodeDraco(loader, context) {\n  const parsedContent = loader._parsedContent;\n  const draco = parsedContent.draco;\n\n  let decodePromise;\n  if (!defined(draco)) {\n    // The draco extension wasn't present,\n    decodePromise = Promise.resolve();\n  } else {\n    decodePromise = DracoLoader.decodePointCloud(draco, context);\n  }\n\n  if (!defined(decodePromise)) {\n    // Could not schedule Draco decoding this frame.\n    return;\n  }\n\n  loader._decodePromise = decodePromise;\n  return decodePromise\n    .then(function (decodeDracoResult) {\n      if (loader.isDestroyed()) {\n        return;\n      }\n\n      if (defined(decodeDracoResult)) {\n        processDracoAttributes(loader, draco, decodeDracoResult);\n      }\n      makeComponents(loader, context);\n      loader._state = ResourceLoaderState.READY;\n      return loader;\n    })\n    .catch(function (error) {\n      loader.unload();\n      loader._state = ResourceLoaderState.FAILED;\n      const errorMessage = \"Failed to load Draco pnts\";\n      // This error will be thrown next time process is called;\n      loader._error = loader.getError(errorMessage, error);\n    });\n}\n\nfunction processDracoAttributes(loader, draco, result) {\n  loader._state = ResourceLoaderState.READY;\n  const parsedContent = loader._parsedContent;\n\n  let attribute;\n  if (defined(result.POSITION)) {\n    attribute = {\n      name: \"POSITION\",\n      semantic: VertexAttributeSemantic.POSITION,\n      typedArray: result.POSITION.array,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      isQuantized: false,\n    };\n\n    if (defined(result.POSITION.data.quantization)) {\n      // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n      // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n      const quantization = result.POSITION.data.quantization;\n      const range = quantization.range;\n      const quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n      const quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n      const quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n\n      attribute.isQuantized = true;\n      attribute.quantizedRange = quantizedRange;\n      attribute.quantizedVolumeOffset = quantizedVolumeOffset;\n      attribute.quantizedVolumeScale = quantizedVolumeScale;\n      attribute.quantizedComponentDatatype =\n        quantizedRange <= 255\n          ? ComponentDatatype.UNSIGNED_BYTE\n          : ComponentDatatype.UNSIGNED_SHORT;\n      attribute.quantizedType = AttributeType.VEC3;\n    }\n\n    parsedContent.positions = attribute;\n  }\n\n  if (defined(result.NORMAL)) {\n    attribute = {\n      name: \"NORMAL\",\n      semantic: VertexAttributeSemantic.NORMAL,\n      typedArray: result.NORMAL.array,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      isQuantized: false,\n      octEncoded: false,\n      octEncodedZXY: false,\n    };\n\n    if (defined(result.NORMAL.data.quantization)) {\n      const octEncodedRange =\n        (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n      attribute.quantizedRange = octEncodedRange;\n      attribute.octEncoded = true;\n      attribute.octEncodedZXY = true;\n      attribute.quantizedComponentDatatype = ComponentDatatype.UNSIGNED_BYTE;\n      attribute.quantizedType = AttributeType.VEC2;\n    }\n\n    parsedContent.normals = attribute;\n  }\n\n  if (defined(result.RGBA)) {\n    parsedContent.colors = {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: result.RGBA.array,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC4,\n      normalized: true,\n      isTranslucent: true,\n    };\n  } else if (defined(result.RGB)) {\n    parsedContent.colors = {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: result.RGB.array,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC3,\n      normalized: true,\n      isTranslucent: false,\n    };\n  }\n\n  // Transcode Batch ID (3D Tiles 1.0) -> Feature ID (3D Tiles Next)\n  if (defined(result.BATCH_ID)) {\n    const batchIds = result.BATCH_ID.array;\n    parsedContent.batchIds = {\n      name: \"_FEATURE_ID\",\n      semantic: VertexAttributeSemantic.FEATURE_ID,\n      setIndex: 0,\n      typedArray: batchIds,\n      componentDatatype: ComponentDatatype.fromTypedArray(batchIds),\n      type: AttributeType.SCALAR,\n    };\n  }\n\n  let batchTableJson = parsedContent.batchTableJson;\n\n  const batchTableProperties = draco.batchTableProperties;\n  for (const name in batchTableProperties) {\n    if (batchTableProperties.hasOwnProperty(name)) {\n      const property = result[name];\n\n      if (!defined(batchTableJson)) {\n        batchTableJson = {};\n      }\n\n      parsedContent.hasDracoBatchTable = true;\n\n      const data = property.data;\n      batchTableJson[name] = {\n        byteOffset: data.byteOffset,\n        // Draco returns the results like glTF values, but here\n        // we want to transcode to a batch table. It's redundant\n        // but necessary to use parseBatchTable()\n        type: transcodeAttributeType(data.componentsPerAttribute),\n        componentType: transcodeComponentType(data.componentDatatype),\n        // Each property is stored as a separate typed array, so\n        // store it here. parseBatchTable() will check for this\n        // instead of the entire binary body.\n        typedArray: property.array,\n      };\n    }\n  }\n  parsedContent.batchTableJson = batchTableJson;\n}\n\nfunction transcodeAttributeType(componentsPerAttribute) {\n  switch (componentsPerAttribute) {\n    case 1:\n      return \"SCALAR\";\n    case 2:\n      return \"VEC2\";\n    case 3:\n      return \"VEC3\";\n    case 4:\n      return \"VEC4\";\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\n        \"componentsPerAttribute must be a number from 1-4\",\n      );\n    //>>includeEnd('debug');\n  }\n}\n\nfunction transcodeComponentType(value) {\n  switch (value) {\n    case WebGLConstants.BYTE:\n      return \"BYTE\";\n    case WebGLConstants.UNSIGNED_BYTE:\n      return \"UNSIGNED_BYTE\";\n    case WebGLConstants.SHORT:\n      return \"SHORT\";\n    case WebGLConstants.UNSIGNED_SHORT:\n      return \"UNSIGNED_SHORT\";\n    case WebGLConstants.INT:\n      return \"INT\";\n    case WebGLConstants.UNSIGNED_INT:\n      return \"UNSIGNED_INT\";\n    case WebGLConstants.DOUBLE:\n      return \"DOUBLE\";\n    case WebGLConstants.FLOAT:\n      return \"FLOAT\";\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"value is not a valid WebGL constant\");\n    //>>includeEnd('debug');\n  }\n}\n\nfunction makeAttribute(loader, attributeInfo, context) {\n  let typedArray = attributeInfo.typedArray;\n  let quantization;\n  if (attributeInfo.octEncoded) {\n    quantization = new Quantization();\n    quantization.octEncoded = attributeInfo.octEncoded;\n    quantization.octEncodedZXY = attributeInfo.octEncodedZXY;\n    quantization.normalizationRange = attributeInfo.quantizedRange;\n    quantization.type = attributeInfo.quantizedType;\n    quantization.componentDatatype = attributeInfo.quantizedComponentDatatype;\n  }\n  if (attributeInfo.isQuantized) {\n    quantization = new Quantization();\n    const normalizationRange = attributeInfo.quantizedRange;\n    quantization.normalizationRange = normalizationRange;\n    // volume offset sometimes requires 64-bit precision so this is handled\n    // in the components.transform matrix.\n    quantization.quantizedVolumeOffset = Cartesian3.ZERO;\n    const quantizedVolumeDimensions = attributeInfo.quantizedVolumeScale;\n    quantization.quantizedVolumeDimensions = quantizedVolumeDimensions;\n    quantization.quantizedVolumeStepSize = Cartesian3.divideByScalar(\n      quantizedVolumeDimensions,\n      normalizationRange,\n      new Cartesian3(),\n    );\n    quantization.componentDatatype = attributeInfo.quantizedComponentDatatype;\n    quantization.type = attributeInfo.quantizedType;\n  }\n\n  const attribute = new Attribute();\n  attribute.name = attributeInfo.name;\n  attribute.semantic = attributeInfo.semantic;\n  attribute.setIndex = attributeInfo.setIndex;\n  attribute.componentDatatype = attributeInfo.componentDatatype;\n  attribute.type = attributeInfo.type;\n  attribute.normalized = defaultValue(attributeInfo.normalized, false);\n  attribute.min = attributeInfo.min;\n  attribute.max = attributeInfo.max;\n  attribute.quantization = quantization;\n\n  if (attributeInfo.isRGB565) {\n    typedArray = AttributeCompression.decodeRGB565(typedArray);\n  }\n\n  if (defined(attributeInfo.constantColor)) {\n    const packedColor = new Array(4);\n    attribute.constant = Color.pack(attributeInfo.constantColor, packedColor);\n  } else {\n    const buffer = Buffer.createVertexBuffer({\n      typedArray: typedArray,\n      context: context,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    buffer.vertexArrayDestroyable = false;\n    loader._buffers.push(buffer);\n    attribute.buffer = buffer;\n  }\n\n  const loadAttributesFor2D = loader._loadAttributesFor2D;\n  if (\n    attribute.semantic === VertexAttributeSemantic.POSITION &&\n    loadAttributesFor2D\n  ) {\n    attribute.typedArray = typedArray;\n  }\n\n  return attribute;\n}\n\nlet randomNumberGenerator;\nlet randomValues;\n\nfunction getRandomValues(samplesLength) {\n  // Use same random values across all runs\n  if (!defined(randomValues)) {\n    // Use MersenneTwister directly to avoid interfering with CesiumMath.nextRandomNumber()\n    // See https://github.com/CesiumGS/cesium/issues/9730\n    randomNumberGenerator = new MersenneTwister(0);\n    randomValues = new Array(samplesLength);\n    for (let i = 0; i < samplesLength; ++i) {\n      randomValues[i] = randomNumberGenerator.random();\n    }\n  }\n  return randomValues;\n}\n\nconst scratchMin = new Cartesian3();\nconst scratchMax = new Cartesian3();\nconst scratchPosition = new Cartesian3();\nfunction computeApproximateExtrema(positions) {\n  const positionsArray = positions.typedArray;\n  const maximumSamplesLength = 20;\n  const pointsLength = positionsArray.length / 3;\n  const samplesLength = Math.min(pointsLength, maximumSamplesLength);\n  const randomValues = getRandomValues(maximumSamplesLength);\n  const maxValue = Number.MAX_VALUE;\n  const minValue = -Number.MAX_VALUE;\n  let min = Cartesian3.fromElements(maxValue, maxValue, maxValue, scratchMin);\n  let max = Cartesian3.fromElements(minValue, minValue, minValue, scratchMax);\n  let i;\n  let index;\n  let position;\n  if (positions.isQuantized) {\n    // The quantized volume offset is not used here since it will become part of\n    // the model matrix.\n    min = Cartesian3.ZERO;\n    max = positions.quantizedVolumeScale;\n  } else {\n    for (i = 0; i < samplesLength; ++i) {\n      index = Math.floor(randomValues[i] * pointsLength);\n      position = Cartesian3.unpack(positionsArray, index * 3, scratchPosition);\n\n      Cartesian3.minimumByComponent(min, position, min);\n      Cartesian3.maximumByComponent(max, position, max);\n    }\n  }\n\n  positions.min = Cartesian3.clone(min);\n  positions.max = Cartesian3.clone(max);\n}\n\n// By default, point clouds are rendered as dark gray.\nconst defaultColorAttribute = {\n  name: VertexAttributeSemantic.COLOR,\n  semantic: VertexAttributeSemantic.COLOR,\n  setIndex: 0,\n  constantColor: Color.DARKGRAY,\n  componentDatatype: ComponentDatatype.FLOAT,\n  type: AttributeType.VEC4,\n  isQuantized: false,\n  isTranslucent: false,\n};\n\nfunction makeAttributes(loader, parsedContent, context) {\n  const attributes = [];\n  let attribute;\n  const positions = parsedContent.positions;\n  if (defined(positions)) {\n    computeApproximateExtrema(positions);\n    attribute = makeAttribute(loader, positions, context);\n    attribute.count = parsedContent.pointsLength;\n    attributes.push(attribute);\n  }\n\n  if (defined(parsedContent.normals)) {\n    attribute = makeAttribute(loader, parsedContent.normals, context);\n    attributes.push(attribute);\n  }\n\n  if (defined(parsedContent.colors)) {\n    attribute = makeAttribute(loader, parsedContent.colors, context);\n    attributes.push(attribute);\n  } else {\n    attribute = makeAttribute(loader, defaultColorAttribute, context);\n    attributes.push(attribute);\n  }\n\n  if (defined(parsedContent.batchIds)) {\n    attribute = makeAttribute(loader, parsedContent.batchIds, context);\n    attributes.push(attribute);\n  }\n\n  return attributes;\n}\n\nfunction makeStructuralMetadata(parsedContent, customAttributeOutput) {\n  const batchLength = parsedContent.batchLength;\n  const pointsLength = parsedContent.pointsLength;\n  const batchTableBinary = parsedContent.batchTableBinary;\n\n  // If there are batch IDs, parse as a property table. Otherwise, parse\n  // as property attributes.\n  const parseAsPropertyAttributes = !defined(parsedContent.batchIds);\n\n  if (defined(batchTableBinary) || parsedContent.hasDracoBatchTable) {\n    const count = defaultValue(batchLength, pointsLength);\n    return parseBatchTable({\n      count: count,\n      batchTable: parsedContent.batchTableJson,\n      binaryBody: batchTableBinary,\n      parseAsPropertyAttributes: parseAsPropertyAttributes,\n      customAttributeOutput: customAttributeOutput,\n    });\n  }\n\n  return new StructuralMetadata({\n    schema: {},\n    propertyTables: [],\n  });\n}\n\nfunction makeComponents(loader, context) {\n  const parsedContent = loader._parsedContent;\n\n  const metallicRoughness = new MetallicRoughness();\n  metallicRoughness.metallicFactor = 0;\n  metallicRoughness.roughnessFactor = 0.9;\n\n  const material = new Material();\n  material.metallicRoughness = metallicRoughness;\n\n  const colors = parsedContent.colors;\n  if (defined(colors) && colors.isTranslucent) {\n    material.alphaMode = AlphaMode.BLEND;\n  }\n\n  // Render point clouds as unlit, unless normals are present, in which case\n  // render as a PBR material.\n  const isUnlit = !defined(parsedContent.normals);\n  material.unlit = isUnlit;\n\n  const primitive = new Primitive();\n  primitive.attributes = makeAttributes(loader, parsedContent, context);\n  primitive.primitiveType = PrimitiveType.POINTS;\n  primitive.material = material;\n\n  if (defined(parsedContent.batchIds)) {\n    const featureIdAttribute = new FeatureIdAttribute();\n    featureIdAttribute.propertyTableId = 0;\n    featureIdAttribute.setIndex = 0;\n    featureIdAttribute.positionalLabel = \"featureId_0\";\n    primitive.featureIds.push(featureIdAttribute);\n  }\n\n  const node = new Node();\n  node.index = 0;\n  node.primitives = [primitive];\n\n  const scene = new Scene();\n  scene.nodes = [node];\n  scene.upAxis = Axis.Z;\n  scene.forwardAxis = Axis.X;\n\n  const components = new Components();\n  components.scene = scene;\n  components.nodes = [node];\n\n  // Per-point features will be parsed as property attributes and handled on\n  // the GPU since CPU styling would be too expensive. However, if batch IDs\n  // exist, features will be parsed as a property table.\n  //\n  // Property attributes refer to a custom attribute that will\n  // store the values; such attributes will be populated in this array\n  // as needed.\n  const customAttributeOutput = [];\n  components.structuralMetadata = makeStructuralMetadata(\n    parsedContent,\n    customAttributeOutput,\n  );\n\n  if (customAttributeOutput.length > 0) {\n    addPropertyAttributesToPrimitive(\n      loader,\n      primitive,\n      customAttributeOutput,\n      context,\n    );\n  }\n\n  if (defined(parsedContent.rtcCenter)) {\n    components.transform = Matrix4.multiplyByTranslation(\n      components.transform,\n      parsedContent.rtcCenter,\n      components.transform,\n    );\n  }\n\n  const positions = parsedContent.positions;\n  if (defined(positions) && positions.isQuantized) {\n    // The volume offset is sometimes in ECEF, so this is applied here rather\n    // than the dequantization shader to avoid jitter\n    components.transform = Matrix4.multiplyByTranslation(\n      components.transform,\n      positions.quantizedVolumeOffset,\n      components.transform,\n    );\n  }\n\n  loader._components = components;\n\n  // Free the parsed content and array buffer so we don't hold onto the large arrays.\n  loader._parsedContent = undefined;\n  loader._arrayBuffer = undefined;\n}\n\nfunction addPropertyAttributesToPrimitive(\n  loader,\n  primitive,\n  customAttributes,\n  context,\n) {\n  const attributes = primitive.attributes;\n\n  const length = customAttributes.length;\n  for (let i = 0; i < length; i++) {\n    const customAttribute = customAttributes[i];\n\n    // Upload the typed array to the GPU and free the CPU copy.\n    const buffer = Buffer.createVertexBuffer({\n      typedArray: customAttribute.typedArray,\n      context: context,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    buffer.vertexArrayDestroyable = false;\n    loader._buffers.push(buffer);\n    customAttribute.buffer = buffer;\n    customAttribute.typedArray = undefined;\n\n    attributes.push(customAttribute);\n  }\n\n  // The batch table is always transcoded as a single property attribute, so\n  // it will always be index 0\n  primitive.propertyAttributeIds = [0];\n}\n\nPntsLoader.prototype.unload = function () {\n  const buffers = this._buffers;\n  for (let i = 0; i < buffers.length; i++) {\n    buffers[i].destroy();\n  }\n  buffers.length = 0;\n\n  this._components = undefined;\n  this._parsedContent = undefined;\n  this._arrayBuffer = undefined;\n};\n\nexport default PntsLoader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}