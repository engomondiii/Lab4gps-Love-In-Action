{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport GeometryAttributes from \"../Core/GeometryAttributes.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nfunction transformToWorldCoordinates(instances, primitiveModelMatrix, scene3DOnly) {\n  let toWorld = !scene3DOnly;\n  const length = instances.length;\n  let i;\n  if (!toWorld && length > 1) {\n    const modelMatrix = instances[0].modelMatrix;\n    for (i = 1; i < length; ++i) {\n      if (!Matrix4.equals(modelMatrix, instances[i].modelMatrix)) {\n        toWorld = true;\n        break;\n      }\n    }\n  }\n  if (toWorld) {\n    for (i = 0; i < length; ++i) {\n      if (defined(instances[i].geometry)) {\n        GeometryPipeline.transformToWorldCoordinates(instances[i]);\n      }\n    }\n  } else {\n    // Leave geometry in local coordinate system; auto update model-matrix.\n    Matrix4.multiplyTransformation(primitiveModelMatrix, instances[0].modelMatrix, primitiveModelMatrix);\n  }\n}\nfunction addGeometryBatchId(geometry, batchId) {\n  const attributes = geometry.attributes;\n  const positionAttr = attributes.position;\n  const numberOfComponents = positionAttr.values.length / positionAttr.componentsPerAttribute;\n  attributes.batchId = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 1,\n    values: new Float32Array(numberOfComponents)\n  });\n  const values = attributes.batchId.values;\n  for (let j = 0; j < numberOfComponents; ++j) {\n    values[j] = batchId;\n  }\n}\nfunction addBatchIds(instances) {\n  const length = instances.length;\n  for (let i = 0; i < length; ++i) {\n    const instance = instances[i];\n    if (defined(instance.geometry)) {\n      addGeometryBatchId(instance.geometry, i);\n    } else if (defined(instance.westHemisphereGeometry) && defined(instance.eastHemisphereGeometry)) {\n      addGeometryBatchId(instance.westHemisphereGeometry, i);\n      addGeometryBatchId(instance.eastHemisphereGeometry, i);\n    }\n  }\n}\nfunction geometryPipeline(parameters) {\n  const instances = parameters.instances;\n  const projection = parameters.projection;\n  const uintIndexSupport = parameters.elementIndexUintSupported;\n  const scene3DOnly = parameters.scene3DOnly;\n  const vertexCacheOptimize = parameters.vertexCacheOptimize;\n  const compressVertices = parameters.compressVertices;\n  const modelMatrix = parameters.modelMatrix;\n  let i;\n  let geometry;\n  let primitiveType;\n  let length = instances.length;\n  for (i = 0; i < length; ++i) {\n    if (defined(instances[i].geometry)) {\n      primitiveType = instances[i].geometry.primitiveType;\n      break;\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  for (i = 1; i < length; ++i) {\n    if (defined(instances[i].geometry) && instances[i].geometry.primitiveType !== primitiveType) {\n      throw new DeveloperError(\"All instance geometries must have the same primitiveType.\");\n    }\n  }\n  //>>includeEnd('debug');\n\n  // Unify to world coordinates before combining.\n  transformToWorldCoordinates(instances, modelMatrix, scene3DOnly);\n\n  // Clip to IDL\n  if (!scene3DOnly) {\n    for (i = 0; i < length; ++i) {\n      if (defined(instances[i].geometry)) {\n        GeometryPipeline.splitLongitude(instances[i]);\n      }\n    }\n  }\n  addBatchIds(instances);\n\n  // Optimize for vertex shader caches\n  if (vertexCacheOptimize) {\n    for (i = 0; i < length; ++i) {\n      const instance = instances[i];\n      if (defined(instance.geometry)) {\n        GeometryPipeline.reorderForPostVertexCache(instance.geometry);\n        GeometryPipeline.reorderForPreVertexCache(instance.geometry);\n      } else if (defined(instance.westHemisphereGeometry) && defined(instance.eastHemisphereGeometry)) {\n        GeometryPipeline.reorderForPostVertexCache(instance.westHemisphereGeometry);\n        GeometryPipeline.reorderForPreVertexCache(instance.westHemisphereGeometry);\n        GeometryPipeline.reorderForPostVertexCache(instance.eastHemisphereGeometry);\n        GeometryPipeline.reorderForPreVertexCache(instance.eastHemisphereGeometry);\n      }\n    }\n  }\n\n  // Combine into single geometry for better rendering performance.\n  let geometries = GeometryPipeline.combineInstances(instances);\n  length = geometries.length;\n  for (i = 0; i < length; ++i) {\n    geometry = geometries[i];\n\n    // Split positions for GPU RTE\n    const attributes = geometry.attributes;\n    if (!scene3DOnly) {\n      for (const name in attributes) {\n        if (attributes.hasOwnProperty(name) && attributes[name].componentDatatype === ComponentDatatype.DOUBLE) {\n          const name3D = `${name}3D`;\n          const name2D = `${name}2D`;\n\n          // Compute 2D positions\n          GeometryPipeline.projectTo2D(geometry, name, name3D, name2D, projection);\n          if (defined(geometry.boundingSphere) && name === \"position\") {\n            geometry.boundingSphereCV = BoundingSphere.fromVertices(geometry.attributes.position2D.values);\n          }\n          GeometryPipeline.encodeAttribute(geometry, name3D, `${name3D}High`, `${name3D}Low`);\n          GeometryPipeline.encodeAttribute(geometry, name2D, `${name2D}High`, `${name2D}Low`);\n        }\n      }\n    } else {\n      for (const name in attributes) {\n        if (attributes.hasOwnProperty(name) && attributes[name].componentDatatype === ComponentDatatype.DOUBLE) {\n          GeometryPipeline.encodeAttribute(geometry, name, `${name}3DHigh`, `${name}3DLow`);\n        }\n      }\n    }\n\n    // oct encode and pack normals, compress texture coordinates\n    if (compressVertices) {\n      GeometryPipeline.compressVertices(geometry);\n    }\n  }\n  if (!uintIndexSupport) {\n    // Break into multiple geometries to fit within unsigned short indices if needed\n    let splitGeometries = [];\n    length = geometries.length;\n    for (i = 0; i < length; ++i) {\n      geometry = geometries[i];\n      splitGeometries = splitGeometries.concat(GeometryPipeline.fitToUnsignedShortIndices(geometry));\n    }\n    geometries = splitGeometries;\n  }\n  return geometries;\n}\nfunction createPickOffsets(instances, geometryName, geometries, pickOffsets) {\n  let offset;\n  let indexCount;\n  let geometryIndex;\n  const offsetIndex = pickOffsets.length - 1;\n  if (offsetIndex >= 0) {\n    const pickOffset = pickOffsets[offsetIndex];\n    offset = pickOffset.offset + pickOffset.count;\n    geometryIndex = pickOffset.index;\n    indexCount = geometries[geometryIndex].indices.length;\n  } else {\n    offset = 0;\n    geometryIndex = 0;\n    indexCount = geometries[geometryIndex].indices.length;\n  }\n  const length = instances.length;\n  for (let i = 0; i < length; ++i) {\n    const instance = instances[i];\n    const geometry = instance[geometryName];\n    if (!defined(geometry)) {\n      continue;\n    }\n    const count = geometry.indices.length;\n    if (offset + count > indexCount) {\n      offset = 0;\n      indexCount = geometries[++geometryIndex].indices.length;\n    }\n    pickOffsets.push({\n      index: geometryIndex,\n      offset: offset,\n      count: count\n    });\n    offset += count;\n  }\n}\nfunction createInstancePickOffsets(instances, geometries) {\n  const pickOffsets = [];\n  createPickOffsets(instances, \"geometry\", geometries, pickOffsets);\n  createPickOffsets(instances, \"westHemisphereGeometry\", geometries, pickOffsets);\n  createPickOffsets(instances, \"eastHemisphereGeometry\", geometries, pickOffsets);\n  return pickOffsets;\n}\n\n/**\n * @private\n */\nconst PrimitivePipeline = {};\n\n/**\n * @private\n */\nPrimitivePipeline.combineGeometry = function (parameters) {\n  let geometries;\n  let attributeLocations;\n  const instances = parameters.instances;\n  const length = instances.length;\n  let pickOffsets;\n  let offsetInstanceExtend;\n  let hasOffset = false;\n  if (length > 0) {\n    geometries = geometryPipeline(parameters);\n    if (geometries.length > 0) {\n      attributeLocations = GeometryPipeline.createAttributeLocations(geometries[0]);\n      if (parameters.createPickOffsets) {\n        pickOffsets = createInstancePickOffsets(instances, geometries);\n      }\n    }\n    if (defined(instances[0].attributes) && defined(instances[0].attributes.offset)) {\n      offsetInstanceExtend = new Array(length);\n      hasOffset = true;\n    }\n  }\n  const boundingSpheres = new Array(length);\n  const boundingSpheresCV = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    const instance = instances[i];\n    const geometry = instance.geometry;\n    if (defined(geometry)) {\n      boundingSpheres[i] = geometry.boundingSphere;\n      boundingSpheresCV[i] = geometry.boundingSphereCV;\n      if (hasOffset) {\n        offsetInstanceExtend[i] = instance.geometry.offsetAttribute;\n      }\n    }\n    const eastHemisphereGeometry = instance.eastHemisphereGeometry;\n    const westHemisphereGeometry = instance.westHemisphereGeometry;\n    if (defined(eastHemisphereGeometry) && defined(westHemisphereGeometry)) {\n      if (defined(eastHemisphereGeometry.boundingSphere) && defined(westHemisphereGeometry.boundingSphere)) {\n        boundingSpheres[i] = BoundingSphere.union(eastHemisphereGeometry.boundingSphere, westHemisphereGeometry.boundingSphere);\n      }\n      if (defined(eastHemisphereGeometry.boundingSphereCV) && defined(westHemisphereGeometry.boundingSphereCV)) {\n        boundingSpheresCV[i] = BoundingSphere.union(eastHemisphereGeometry.boundingSphereCV, westHemisphereGeometry.boundingSphereCV);\n      }\n    }\n  }\n  return {\n    geometries: geometries,\n    modelMatrix: parameters.modelMatrix,\n    attributeLocations: attributeLocations,\n    pickOffsets: pickOffsets,\n    offsetInstanceExtend: offsetInstanceExtend,\n    boundingSpheres: boundingSpheres,\n    boundingSpheresCV: boundingSpheresCV\n  };\n};\nfunction transferGeometry(geometry, transferableObjects) {\n  const attributes = geometry.attributes;\n  for (const name in attributes) {\n    if (attributes.hasOwnProperty(name)) {\n      const attribute = attributes[name];\n      if (defined(attribute) && defined(attribute.values)) {\n        transferableObjects.push(attribute.values.buffer);\n      }\n    }\n  }\n  if (defined(geometry.indices)) {\n    transferableObjects.push(geometry.indices.buffer);\n  }\n}\nfunction transferGeometries(geometries, transferableObjects) {\n  const length = geometries.length;\n  for (let i = 0; i < length; ++i) {\n    transferGeometry(geometries[i], transferableObjects);\n  }\n}\n\n// This function was created by simplifying packCreateGeometryResults into a count-only operation.\nfunction countCreateGeometryResults(items) {\n  let count = 1;\n  const length = items.length;\n  for (let i = 0; i < length; i++) {\n    const geometry = items[i];\n    ++count;\n    if (!defined(geometry)) {\n      continue;\n    }\n    const attributes = geometry.attributes;\n    count += 7 + 2 * BoundingSphere.packedLength + (defined(geometry.indices) ? geometry.indices.length : 0);\n    for (const property in attributes) {\n      if (attributes.hasOwnProperty(property) && defined(attributes[property])) {\n        const attribute = attributes[property];\n        count += 5 + attribute.values.length;\n      }\n    }\n  }\n  return count;\n}\n\n/**\n * @private\n */\nPrimitivePipeline.packCreateGeometryResults = function (items, transferableObjects) {\n  const packedData = new Float64Array(countCreateGeometryResults(items));\n  const stringTable = [];\n  const stringHash = {};\n  const length = items.length;\n  let count = 0;\n  packedData[count++] = length;\n  for (let i = 0; i < length; i++) {\n    const geometry = items[i];\n    const validGeometry = defined(geometry);\n    packedData[count++] = validGeometry ? 1.0 : 0.0;\n    if (!validGeometry) {\n      continue;\n    }\n    packedData[count++] = geometry.primitiveType;\n    packedData[count++] = geometry.geometryType;\n    packedData[count++] = defaultValue(geometry.offsetAttribute, -1);\n    const validBoundingSphere = defined(geometry.boundingSphere) ? 1.0 : 0.0;\n    packedData[count++] = validBoundingSphere;\n    if (validBoundingSphere) {\n      BoundingSphere.pack(geometry.boundingSphere, packedData, count);\n    }\n    count += BoundingSphere.packedLength;\n    const validBoundingSphereCV = defined(geometry.boundingSphereCV) ? 1.0 : 0.0;\n    packedData[count++] = validBoundingSphereCV;\n    if (validBoundingSphereCV) {\n      BoundingSphere.pack(geometry.boundingSphereCV, packedData, count);\n    }\n    count += BoundingSphere.packedLength;\n    const attributes = geometry.attributes;\n    const attributesToWrite = [];\n    for (const property in attributes) {\n      if (attributes.hasOwnProperty(property) && defined(attributes[property])) {\n        attributesToWrite.push(property);\n        if (!defined(stringHash[property])) {\n          stringHash[property] = stringTable.length;\n          stringTable.push(property);\n        }\n      }\n    }\n    packedData[count++] = attributesToWrite.length;\n    for (let q = 0; q < attributesToWrite.length; q++) {\n      const name = attributesToWrite[q];\n      const attribute = attributes[name];\n      packedData[count++] = stringHash[name];\n      packedData[count++] = attribute.componentDatatype;\n      packedData[count++] = attribute.componentsPerAttribute;\n      packedData[count++] = attribute.normalize ? 1 : 0;\n      packedData[count++] = attribute.values.length;\n      packedData.set(attribute.values, count);\n      count += attribute.values.length;\n    }\n    const indicesLength = defined(geometry.indices) ? geometry.indices.length : 0;\n    packedData[count++] = indicesLength;\n    if (indicesLength > 0) {\n      packedData.set(geometry.indices, count);\n      count += indicesLength;\n    }\n  }\n  transferableObjects.push(packedData.buffer);\n  return {\n    stringTable: stringTable,\n    packedData: packedData\n  };\n};\n\n/**\n * @private\n */\nPrimitivePipeline.unpackCreateGeometryResults = function (createGeometryResult) {\n  const stringTable = createGeometryResult.stringTable;\n  const packedGeometry = createGeometryResult.packedData;\n  let i;\n  const result = new Array(packedGeometry[0]);\n  let resultIndex = 0;\n  let packedGeometryIndex = 1;\n  while (packedGeometryIndex < packedGeometry.length) {\n    const valid = packedGeometry[packedGeometryIndex++] === 1.0;\n    if (!valid) {\n      result[resultIndex++] = undefined;\n      continue;\n    }\n    const primitiveType = packedGeometry[packedGeometryIndex++];\n    const geometryType = packedGeometry[packedGeometryIndex++];\n    let offsetAttribute = packedGeometry[packedGeometryIndex++];\n    if (offsetAttribute === -1) {\n      offsetAttribute = undefined;\n    }\n    let boundingSphere;\n    let boundingSphereCV;\n    const validBoundingSphere = packedGeometry[packedGeometryIndex++] === 1.0;\n    if (validBoundingSphere) {\n      boundingSphere = BoundingSphere.unpack(packedGeometry, packedGeometryIndex);\n    }\n    packedGeometryIndex += BoundingSphere.packedLength;\n    const validBoundingSphereCV = packedGeometry[packedGeometryIndex++] === 1.0;\n    if (validBoundingSphereCV) {\n      boundingSphereCV = BoundingSphere.unpack(packedGeometry, packedGeometryIndex);\n    }\n    packedGeometryIndex += BoundingSphere.packedLength;\n    let length;\n    let values;\n    let componentsPerAttribute;\n    const attributes = new GeometryAttributes();\n    const numAttributes = packedGeometry[packedGeometryIndex++];\n    for (i = 0; i < numAttributes; i++) {\n      const name = stringTable[packedGeometry[packedGeometryIndex++]];\n      const componentDatatype = packedGeometry[packedGeometryIndex++];\n      componentsPerAttribute = packedGeometry[packedGeometryIndex++];\n      const normalize = packedGeometry[packedGeometryIndex++] !== 0;\n      length = packedGeometry[packedGeometryIndex++];\n      values = ComponentDatatype.createTypedArray(componentDatatype, length);\n      for (let valuesIndex = 0; valuesIndex < length; valuesIndex++) {\n        values[valuesIndex] = packedGeometry[packedGeometryIndex++];\n      }\n      attributes[name] = new GeometryAttribute({\n        componentDatatype: componentDatatype,\n        componentsPerAttribute: componentsPerAttribute,\n        normalize: normalize,\n        values: values\n      });\n    }\n    let indices;\n    length = packedGeometry[packedGeometryIndex++];\n    if (length > 0) {\n      const numberOfVertices = values.length / componentsPerAttribute;\n      indices = IndexDatatype.createTypedArray(numberOfVertices, length);\n      for (i = 0; i < length; i++) {\n        indices[i] = packedGeometry[packedGeometryIndex++];\n      }\n    }\n    result[resultIndex++] = new Geometry({\n      primitiveType: primitiveType,\n      geometryType: geometryType,\n      boundingSphere: boundingSphere,\n      boundingSphereCV: boundingSphereCV,\n      indices: indices,\n      attributes: attributes,\n      offsetAttribute: offsetAttribute\n    });\n  }\n  return result;\n};\nfunction packInstancesForCombine(instances, transferableObjects) {\n  const length = instances.length;\n  const packedData = new Float64Array(1 + length * 19);\n  let count = 0;\n  packedData[count++] = length;\n  for (let i = 0; i < length; i++) {\n    const instance = instances[i];\n    Matrix4.pack(instance.modelMatrix, packedData, count);\n    count += Matrix4.packedLength;\n    if (defined(instance.attributes) && defined(instance.attributes.offset)) {\n      const values = instance.attributes.offset.value;\n      packedData[count] = values[0];\n      packedData[count + 1] = values[1];\n      packedData[count + 2] = values[2];\n    }\n    count += 3;\n  }\n  transferableObjects.push(packedData.buffer);\n  return packedData;\n}\nfunction unpackInstancesForCombine(data) {\n  const packedInstances = data;\n  const result = new Array(packedInstances[0]);\n  let count = 0;\n  let i = 1;\n  while (i < packedInstances.length) {\n    const modelMatrix = Matrix4.unpack(packedInstances, i);\n    let attributes;\n    i += Matrix4.packedLength;\n    if (defined(packedInstances[i])) {\n      attributes = {\n        offset: new OffsetGeometryInstanceAttribute(packedInstances[i], packedInstances[i + 1], packedInstances[i + 2])\n      };\n    }\n    i += 3;\n    result[count++] = {\n      modelMatrix: modelMatrix,\n      attributes: attributes\n    };\n  }\n  return result;\n}\n\n/**\n * @private\n */\nPrimitivePipeline.packCombineGeometryParameters = function (parameters, transferableObjects) {\n  const createGeometryResults = parameters.createGeometryResults;\n  const length = createGeometryResults.length;\n  for (let i = 0; i < length; i++) {\n    transferableObjects.push(createGeometryResults[i].packedData.buffer);\n  }\n  return {\n    createGeometryResults: parameters.createGeometryResults,\n    packedInstances: packInstancesForCombine(parameters.instances, transferableObjects),\n    ellipsoid: parameters.ellipsoid,\n    isGeographic: parameters.projection instanceof GeographicProjection,\n    elementIndexUintSupported: parameters.elementIndexUintSupported,\n    scene3DOnly: parameters.scene3DOnly,\n    vertexCacheOptimize: parameters.vertexCacheOptimize,\n    compressVertices: parameters.compressVertices,\n    modelMatrix: parameters.modelMatrix,\n    createPickOffsets: parameters.createPickOffsets\n  };\n};\n\n/**\n * @private\n */\nPrimitivePipeline.unpackCombineGeometryParameters = function (packedParameters) {\n  const instances = unpackInstancesForCombine(packedParameters.packedInstances);\n  const createGeometryResults = packedParameters.createGeometryResults;\n  const length = createGeometryResults.length;\n  let instanceIndex = 0;\n  for (let resultIndex = 0; resultIndex < length; resultIndex++) {\n    const geometries = PrimitivePipeline.unpackCreateGeometryResults(createGeometryResults[resultIndex]);\n    const geometriesLength = geometries.length;\n    for (let geometryIndex = 0; geometryIndex < geometriesLength; geometryIndex++) {\n      const geometry = geometries[geometryIndex];\n      const instance = instances[instanceIndex];\n      instance.geometry = geometry;\n      ++instanceIndex;\n    }\n  }\n  const ellipsoid = Ellipsoid.clone(packedParameters.ellipsoid);\n  const projection = packedParameters.isGeographic ? new GeographicProjection(ellipsoid) : new WebMercatorProjection(ellipsoid);\n  return {\n    instances: instances,\n    ellipsoid: ellipsoid,\n    projection: projection,\n    elementIndexUintSupported: packedParameters.elementIndexUintSupported,\n    scene3DOnly: packedParameters.scene3DOnly,\n    vertexCacheOptimize: packedParameters.vertexCacheOptimize,\n    compressVertices: packedParameters.compressVertices,\n    modelMatrix: Matrix4.clone(packedParameters.modelMatrix),\n    createPickOffsets: packedParameters.createPickOffsets\n  };\n};\nfunction packBoundingSpheres(boundingSpheres) {\n  const length = boundingSpheres.length;\n  const bufferLength = 1 + (BoundingSphere.packedLength + 1) * length;\n  const buffer = new Float32Array(bufferLength);\n  let bufferIndex = 0;\n  buffer[bufferIndex++] = length;\n  for (let i = 0; i < length; ++i) {\n    const bs = boundingSpheres[i];\n    if (!defined(bs)) {\n      buffer[bufferIndex++] = 0.0;\n    } else {\n      buffer[bufferIndex++] = 1.0;\n      BoundingSphere.pack(boundingSpheres[i], buffer, bufferIndex);\n    }\n    bufferIndex += BoundingSphere.packedLength;\n  }\n  return buffer;\n}\nfunction unpackBoundingSpheres(buffer) {\n  const result = new Array(buffer[0]);\n  let count = 0;\n  let i = 1;\n  while (i < buffer.length) {\n    if (buffer[i++] === 1.0) {\n      result[count] = BoundingSphere.unpack(buffer, i);\n    }\n    ++count;\n    i += BoundingSphere.packedLength;\n  }\n  return result;\n}\n\n/**\n * @private\n */\nPrimitivePipeline.packCombineGeometryResults = function (results, transferableObjects) {\n  if (defined(results.geometries)) {\n    transferGeometries(results.geometries, transferableObjects);\n  }\n  const packedBoundingSpheres = packBoundingSpheres(results.boundingSpheres);\n  const packedBoundingSpheresCV = packBoundingSpheres(results.boundingSpheresCV);\n  transferableObjects.push(packedBoundingSpheres.buffer, packedBoundingSpheresCV.buffer);\n  return {\n    geometries: results.geometries,\n    attributeLocations: results.attributeLocations,\n    modelMatrix: results.modelMatrix,\n    pickOffsets: results.pickOffsets,\n    offsetInstanceExtend: results.offsetInstanceExtend,\n    boundingSpheres: packedBoundingSpheres,\n    boundingSpheresCV: packedBoundingSpheresCV\n  };\n};\n\n/**\n * @private\n */\nPrimitivePipeline.unpackCombineGeometryResults = function (packedResult) {\n  return {\n    geometries: packedResult.geometries,\n    attributeLocations: packedResult.attributeLocations,\n    modelMatrix: packedResult.modelMatrix,\n    pickOffsets: packedResult.pickOffsets,\n    offsetInstanceExtend: packedResult.offsetInstanceExtend,\n    boundingSpheres: unpackBoundingSpheres(packedResult.boundingSpheres),\n    boundingSpheresCV: unpackBoundingSpheres(packedResult.boundingSpheresCV)\n  };\n};\nexport default PrimitivePipeline;","map":{"version":3,"names":["BoundingSphere","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","GeographicProjection","Geometry","GeometryAttribute","GeometryAttributes","GeometryPipeline","IndexDatatype","Matrix4","OffsetGeometryInstanceAttribute","WebMercatorProjection","transformToWorldCoordinates","instances","primitiveModelMatrix","scene3DOnly","toWorld","length","i","modelMatrix","equals","geometry","multiplyTransformation","addGeometryBatchId","batchId","attributes","positionAttr","position","numberOfComponents","values","componentsPerAttribute","componentDatatype","FLOAT","Float32Array","j","addBatchIds","instance","westHemisphereGeometry","eastHemisphereGeometry","geometryPipeline","parameters","projection","uintIndexSupport","elementIndexUintSupported","vertexCacheOptimize","compressVertices","primitiveType","splitLongitude","reorderForPostVertexCache","reorderForPreVertexCache","geometries","combineInstances","name","hasOwnProperty","DOUBLE","name3D","name2D","projectTo2D","boundingSphere","boundingSphereCV","fromVertices","position2D","encodeAttribute","splitGeometries","concat","fitToUnsignedShortIndices","createPickOffsets","geometryName","pickOffsets","offset","indexCount","geometryIndex","offsetIndex","pickOffset","count","index","indices","push","createInstancePickOffsets","PrimitivePipeline","combineGeometry","attributeLocations","offsetInstanceExtend","hasOffset","createAttributeLocations","Array","boundingSpheres","boundingSpheresCV","offsetAttribute","union","transferGeometry","transferableObjects","attribute","buffer","transferGeometries","countCreateGeometryResults","items","packedLength","property","packCreateGeometryResults","packedData","Float64Array","stringTable","stringHash","validGeometry","geometryType","validBoundingSphere","pack","validBoundingSphereCV","attributesToWrite","q","normalize","set","indicesLength","unpackCreateGeometryResults","createGeometryResult","packedGeometry","result","resultIndex","packedGeometryIndex","valid","undefined","unpack","numAttributes","createTypedArray","valuesIndex","numberOfVertices","packInstancesForCombine","value","unpackInstancesForCombine","data","packedInstances","packCombineGeometryParameters","createGeometryResults","ellipsoid","isGeographic","unpackCombineGeometryParameters","packedParameters","instanceIndex","geometriesLength","clone","packBoundingSpheres","bufferLength","bufferIndex","bs","unpackBoundingSpheres","packCombineGeometryResults","results","packedBoundingSpheres","packedBoundingSpheresCV","unpackCombineGeometryResults","packedResult"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/PrimitivePipeline.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport GeometryAttributes from \"../Core/GeometryAttributes.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\n\nfunction transformToWorldCoordinates(\n  instances,\n  primitiveModelMatrix,\n  scene3DOnly,\n) {\n  let toWorld = !scene3DOnly;\n  const length = instances.length;\n  let i;\n\n  if (!toWorld && length > 1) {\n    const modelMatrix = instances[0].modelMatrix;\n\n    for (i = 1; i < length; ++i) {\n      if (!Matrix4.equals(modelMatrix, instances[i].modelMatrix)) {\n        toWorld = true;\n        break;\n      }\n    }\n  }\n\n  if (toWorld) {\n    for (i = 0; i < length; ++i) {\n      if (defined(instances[i].geometry)) {\n        GeometryPipeline.transformToWorldCoordinates(instances[i]);\n      }\n    }\n  } else {\n    // Leave geometry in local coordinate system; auto update model-matrix.\n    Matrix4.multiplyTransformation(\n      primitiveModelMatrix,\n      instances[0].modelMatrix,\n      primitiveModelMatrix,\n    );\n  }\n}\n\nfunction addGeometryBatchId(geometry, batchId) {\n  const attributes = geometry.attributes;\n  const positionAttr = attributes.position;\n  const numberOfComponents =\n    positionAttr.values.length / positionAttr.componentsPerAttribute;\n\n  attributes.batchId = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 1,\n    values: new Float32Array(numberOfComponents),\n  });\n\n  const values = attributes.batchId.values;\n  for (let j = 0; j < numberOfComponents; ++j) {\n    values[j] = batchId;\n  }\n}\n\nfunction addBatchIds(instances) {\n  const length = instances.length;\n\n  for (let i = 0; i < length; ++i) {\n    const instance = instances[i];\n    if (defined(instance.geometry)) {\n      addGeometryBatchId(instance.geometry, i);\n    } else if (\n      defined(instance.westHemisphereGeometry) &&\n      defined(instance.eastHemisphereGeometry)\n    ) {\n      addGeometryBatchId(instance.westHemisphereGeometry, i);\n      addGeometryBatchId(instance.eastHemisphereGeometry, i);\n    }\n  }\n}\n\nfunction geometryPipeline(parameters) {\n  const instances = parameters.instances;\n  const projection = parameters.projection;\n  const uintIndexSupport = parameters.elementIndexUintSupported;\n  const scene3DOnly = parameters.scene3DOnly;\n  const vertexCacheOptimize = parameters.vertexCacheOptimize;\n  const compressVertices = parameters.compressVertices;\n  const modelMatrix = parameters.modelMatrix;\n\n  let i;\n  let geometry;\n  let primitiveType;\n  let length = instances.length;\n\n  for (i = 0; i < length; ++i) {\n    if (defined(instances[i].geometry)) {\n      primitiveType = instances[i].geometry.primitiveType;\n      break;\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  for (i = 1; i < length; ++i) {\n    if (\n      defined(instances[i].geometry) &&\n      instances[i].geometry.primitiveType !== primitiveType\n    ) {\n      throw new DeveloperError(\n        \"All instance geometries must have the same primitiveType.\",\n      );\n    }\n  }\n  //>>includeEnd('debug');\n\n  // Unify to world coordinates before combining.\n  transformToWorldCoordinates(instances, modelMatrix, scene3DOnly);\n\n  // Clip to IDL\n  if (!scene3DOnly) {\n    for (i = 0; i < length; ++i) {\n      if (defined(instances[i].geometry)) {\n        GeometryPipeline.splitLongitude(instances[i]);\n      }\n    }\n  }\n\n  addBatchIds(instances);\n\n  // Optimize for vertex shader caches\n  if (vertexCacheOptimize) {\n    for (i = 0; i < length; ++i) {\n      const instance = instances[i];\n      if (defined(instance.geometry)) {\n        GeometryPipeline.reorderForPostVertexCache(instance.geometry);\n        GeometryPipeline.reorderForPreVertexCache(instance.geometry);\n      } else if (\n        defined(instance.westHemisphereGeometry) &&\n        defined(instance.eastHemisphereGeometry)\n      ) {\n        GeometryPipeline.reorderForPostVertexCache(\n          instance.westHemisphereGeometry,\n        );\n        GeometryPipeline.reorderForPreVertexCache(\n          instance.westHemisphereGeometry,\n        );\n\n        GeometryPipeline.reorderForPostVertexCache(\n          instance.eastHemisphereGeometry,\n        );\n        GeometryPipeline.reorderForPreVertexCache(\n          instance.eastHemisphereGeometry,\n        );\n      }\n    }\n  }\n\n  // Combine into single geometry for better rendering performance.\n  let geometries = GeometryPipeline.combineInstances(instances);\n\n  length = geometries.length;\n  for (i = 0; i < length; ++i) {\n    geometry = geometries[i];\n\n    // Split positions for GPU RTE\n    const attributes = geometry.attributes;\n    if (!scene3DOnly) {\n      for (const name in attributes) {\n        if (\n          attributes.hasOwnProperty(name) &&\n          attributes[name].componentDatatype === ComponentDatatype.DOUBLE\n        ) {\n          const name3D = `${name}3D`;\n          const name2D = `${name}2D`;\n\n          // Compute 2D positions\n          GeometryPipeline.projectTo2D(\n            geometry,\n            name,\n            name3D,\n            name2D,\n            projection,\n          );\n          if (defined(geometry.boundingSphere) && name === \"position\") {\n            geometry.boundingSphereCV = BoundingSphere.fromVertices(\n              geometry.attributes.position2D.values,\n            );\n          }\n\n          GeometryPipeline.encodeAttribute(\n            geometry,\n            name3D,\n            `${name3D}High`,\n            `${name3D}Low`,\n          );\n          GeometryPipeline.encodeAttribute(\n            geometry,\n            name2D,\n            `${name2D}High`,\n            `${name2D}Low`,\n          );\n        }\n      }\n    } else {\n      for (const name in attributes) {\n        if (\n          attributes.hasOwnProperty(name) &&\n          attributes[name].componentDatatype === ComponentDatatype.DOUBLE\n        ) {\n          GeometryPipeline.encodeAttribute(\n            geometry,\n            name,\n            `${name}3DHigh`,\n            `${name}3DLow`,\n          );\n        }\n      }\n    }\n\n    // oct encode and pack normals, compress texture coordinates\n    if (compressVertices) {\n      GeometryPipeline.compressVertices(geometry);\n    }\n  }\n\n  if (!uintIndexSupport) {\n    // Break into multiple geometries to fit within unsigned short indices if needed\n    let splitGeometries = [];\n    length = geometries.length;\n    for (i = 0; i < length; ++i) {\n      geometry = geometries[i];\n      splitGeometries = splitGeometries.concat(\n        GeometryPipeline.fitToUnsignedShortIndices(geometry),\n      );\n    }\n\n    geometries = splitGeometries;\n  }\n\n  return geometries;\n}\n\nfunction createPickOffsets(instances, geometryName, geometries, pickOffsets) {\n  let offset;\n  let indexCount;\n  let geometryIndex;\n\n  const offsetIndex = pickOffsets.length - 1;\n  if (offsetIndex >= 0) {\n    const pickOffset = pickOffsets[offsetIndex];\n    offset = pickOffset.offset + pickOffset.count;\n    geometryIndex = pickOffset.index;\n    indexCount = geometries[geometryIndex].indices.length;\n  } else {\n    offset = 0;\n    geometryIndex = 0;\n    indexCount = geometries[geometryIndex].indices.length;\n  }\n\n  const length = instances.length;\n  for (let i = 0; i < length; ++i) {\n    const instance = instances[i];\n    const geometry = instance[geometryName];\n    if (!defined(geometry)) {\n      continue;\n    }\n\n    const count = geometry.indices.length;\n\n    if (offset + count > indexCount) {\n      offset = 0;\n      indexCount = geometries[++geometryIndex].indices.length;\n    }\n\n    pickOffsets.push({\n      index: geometryIndex,\n      offset: offset,\n      count: count,\n    });\n    offset += count;\n  }\n}\n\nfunction createInstancePickOffsets(instances, geometries) {\n  const pickOffsets = [];\n  createPickOffsets(instances, \"geometry\", geometries, pickOffsets);\n  createPickOffsets(\n    instances,\n    \"westHemisphereGeometry\",\n    geometries,\n    pickOffsets,\n  );\n  createPickOffsets(\n    instances,\n    \"eastHemisphereGeometry\",\n    geometries,\n    pickOffsets,\n  );\n  return pickOffsets;\n}\n\n/**\n * @private\n */\nconst PrimitivePipeline = {};\n\n/**\n * @private\n */\nPrimitivePipeline.combineGeometry = function (parameters) {\n  let geometries;\n  let attributeLocations;\n  const instances = parameters.instances;\n  const length = instances.length;\n  let pickOffsets;\n\n  let offsetInstanceExtend;\n  let hasOffset = false;\n  if (length > 0) {\n    geometries = geometryPipeline(parameters);\n    if (geometries.length > 0) {\n      attributeLocations = GeometryPipeline.createAttributeLocations(\n        geometries[0],\n      );\n      if (parameters.createPickOffsets) {\n        pickOffsets = createInstancePickOffsets(instances, geometries);\n      }\n    }\n    if (\n      defined(instances[0].attributes) &&\n      defined(instances[0].attributes.offset)\n    ) {\n      offsetInstanceExtend = new Array(length);\n      hasOffset = true;\n    }\n  }\n\n  const boundingSpheres = new Array(length);\n  const boundingSpheresCV = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    const instance = instances[i];\n    const geometry = instance.geometry;\n    if (defined(geometry)) {\n      boundingSpheres[i] = geometry.boundingSphere;\n      boundingSpheresCV[i] = geometry.boundingSphereCV;\n      if (hasOffset) {\n        offsetInstanceExtend[i] = instance.geometry.offsetAttribute;\n      }\n    }\n\n    const eastHemisphereGeometry = instance.eastHemisphereGeometry;\n    const westHemisphereGeometry = instance.westHemisphereGeometry;\n    if (defined(eastHemisphereGeometry) && defined(westHemisphereGeometry)) {\n      if (\n        defined(eastHemisphereGeometry.boundingSphere) &&\n        defined(westHemisphereGeometry.boundingSphere)\n      ) {\n        boundingSpheres[i] = BoundingSphere.union(\n          eastHemisphereGeometry.boundingSphere,\n          westHemisphereGeometry.boundingSphere,\n        );\n      }\n      if (\n        defined(eastHemisphereGeometry.boundingSphereCV) &&\n        defined(westHemisphereGeometry.boundingSphereCV)\n      ) {\n        boundingSpheresCV[i] = BoundingSphere.union(\n          eastHemisphereGeometry.boundingSphereCV,\n          westHemisphereGeometry.boundingSphereCV,\n        );\n      }\n    }\n  }\n\n  return {\n    geometries: geometries,\n    modelMatrix: parameters.modelMatrix,\n    attributeLocations: attributeLocations,\n    pickOffsets: pickOffsets,\n    offsetInstanceExtend: offsetInstanceExtend,\n    boundingSpheres: boundingSpheres,\n    boundingSpheresCV: boundingSpheresCV,\n  };\n};\n\nfunction transferGeometry(geometry, transferableObjects) {\n  const attributes = geometry.attributes;\n  for (const name in attributes) {\n    if (attributes.hasOwnProperty(name)) {\n      const attribute = attributes[name];\n\n      if (defined(attribute) && defined(attribute.values)) {\n        transferableObjects.push(attribute.values.buffer);\n      }\n    }\n  }\n\n  if (defined(geometry.indices)) {\n    transferableObjects.push(geometry.indices.buffer);\n  }\n}\n\nfunction transferGeometries(geometries, transferableObjects) {\n  const length = geometries.length;\n  for (let i = 0; i < length; ++i) {\n    transferGeometry(geometries[i], transferableObjects);\n  }\n}\n\n// This function was created by simplifying packCreateGeometryResults into a count-only operation.\nfunction countCreateGeometryResults(items) {\n  let count = 1;\n  const length = items.length;\n  for (let i = 0; i < length; i++) {\n    const geometry = items[i];\n    ++count;\n\n    if (!defined(geometry)) {\n      continue;\n    }\n\n    const attributes = geometry.attributes;\n\n    count +=\n      7 +\n      2 * BoundingSphere.packedLength +\n      (defined(geometry.indices) ? geometry.indices.length : 0);\n\n    for (const property in attributes) {\n      if (\n        attributes.hasOwnProperty(property) &&\n        defined(attributes[property])\n      ) {\n        const attribute = attributes[property];\n        count += 5 + attribute.values.length;\n      }\n    }\n  }\n\n  return count;\n}\n\n/**\n * @private\n */\nPrimitivePipeline.packCreateGeometryResults = function (\n  items,\n  transferableObjects,\n) {\n  const packedData = new Float64Array(countCreateGeometryResults(items));\n  const stringTable = [];\n  const stringHash = {};\n\n  const length = items.length;\n  let count = 0;\n  packedData[count++] = length;\n  for (let i = 0; i < length; i++) {\n    const geometry = items[i];\n\n    const validGeometry = defined(geometry);\n    packedData[count++] = validGeometry ? 1.0 : 0.0;\n\n    if (!validGeometry) {\n      continue;\n    }\n\n    packedData[count++] = geometry.primitiveType;\n    packedData[count++] = geometry.geometryType;\n    packedData[count++] = defaultValue(geometry.offsetAttribute, -1);\n\n    const validBoundingSphere = defined(geometry.boundingSphere) ? 1.0 : 0.0;\n    packedData[count++] = validBoundingSphere;\n    if (validBoundingSphere) {\n      BoundingSphere.pack(geometry.boundingSphere, packedData, count);\n    }\n\n    count += BoundingSphere.packedLength;\n\n    const validBoundingSphereCV = defined(geometry.boundingSphereCV)\n      ? 1.0\n      : 0.0;\n    packedData[count++] = validBoundingSphereCV;\n    if (validBoundingSphereCV) {\n      BoundingSphere.pack(geometry.boundingSphereCV, packedData, count);\n    }\n\n    count += BoundingSphere.packedLength;\n\n    const attributes = geometry.attributes;\n    const attributesToWrite = [];\n    for (const property in attributes) {\n      if (\n        attributes.hasOwnProperty(property) &&\n        defined(attributes[property])\n      ) {\n        attributesToWrite.push(property);\n        if (!defined(stringHash[property])) {\n          stringHash[property] = stringTable.length;\n          stringTable.push(property);\n        }\n      }\n    }\n\n    packedData[count++] = attributesToWrite.length;\n    for (let q = 0; q < attributesToWrite.length; q++) {\n      const name = attributesToWrite[q];\n      const attribute = attributes[name];\n      packedData[count++] = stringHash[name];\n      packedData[count++] = attribute.componentDatatype;\n      packedData[count++] = attribute.componentsPerAttribute;\n      packedData[count++] = attribute.normalize ? 1 : 0;\n      packedData[count++] = attribute.values.length;\n      packedData.set(attribute.values, count);\n      count += attribute.values.length;\n    }\n\n    const indicesLength = defined(geometry.indices)\n      ? geometry.indices.length\n      : 0;\n    packedData[count++] = indicesLength;\n\n    if (indicesLength > 0) {\n      packedData.set(geometry.indices, count);\n      count += indicesLength;\n    }\n  }\n\n  transferableObjects.push(packedData.buffer);\n\n  return {\n    stringTable: stringTable,\n    packedData: packedData,\n  };\n};\n\n/**\n * @private\n */\nPrimitivePipeline.unpackCreateGeometryResults = function (\n  createGeometryResult,\n) {\n  const stringTable = createGeometryResult.stringTable;\n  const packedGeometry = createGeometryResult.packedData;\n\n  let i;\n  const result = new Array(packedGeometry[0]);\n  let resultIndex = 0;\n\n  let packedGeometryIndex = 1;\n  while (packedGeometryIndex < packedGeometry.length) {\n    const valid = packedGeometry[packedGeometryIndex++] === 1.0;\n    if (!valid) {\n      result[resultIndex++] = undefined;\n      continue;\n    }\n\n    const primitiveType = packedGeometry[packedGeometryIndex++];\n    const geometryType = packedGeometry[packedGeometryIndex++];\n    let offsetAttribute = packedGeometry[packedGeometryIndex++];\n    if (offsetAttribute === -1) {\n      offsetAttribute = undefined;\n    }\n\n    let boundingSphere;\n    let boundingSphereCV;\n\n    const validBoundingSphere = packedGeometry[packedGeometryIndex++] === 1.0;\n    if (validBoundingSphere) {\n      boundingSphere = BoundingSphere.unpack(\n        packedGeometry,\n        packedGeometryIndex,\n      );\n    }\n\n    packedGeometryIndex += BoundingSphere.packedLength;\n\n    const validBoundingSphereCV = packedGeometry[packedGeometryIndex++] === 1.0;\n    if (validBoundingSphereCV) {\n      boundingSphereCV = BoundingSphere.unpack(\n        packedGeometry,\n        packedGeometryIndex,\n      );\n    }\n\n    packedGeometryIndex += BoundingSphere.packedLength;\n\n    let length;\n    let values;\n    let componentsPerAttribute;\n    const attributes = new GeometryAttributes();\n    const numAttributes = packedGeometry[packedGeometryIndex++];\n    for (i = 0; i < numAttributes; i++) {\n      const name = stringTable[packedGeometry[packedGeometryIndex++]];\n      const componentDatatype = packedGeometry[packedGeometryIndex++];\n      componentsPerAttribute = packedGeometry[packedGeometryIndex++];\n      const normalize = packedGeometry[packedGeometryIndex++] !== 0;\n\n      length = packedGeometry[packedGeometryIndex++];\n      values = ComponentDatatype.createTypedArray(componentDatatype, length);\n      for (let valuesIndex = 0; valuesIndex < length; valuesIndex++) {\n        values[valuesIndex] = packedGeometry[packedGeometryIndex++];\n      }\n\n      attributes[name] = new GeometryAttribute({\n        componentDatatype: componentDatatype,\n        componentsPerAttribute: componentsPerAttribute,\n        normalize: normalize,\n        values: values,\n      });\n    }\n\n    let indices;\n    length = packedGeometry[packedGeometryIndex++];\n\n    if (length > 0) {\n      const numberOfVertices = values.length / componentsPerAttribute;\n      indices = IndexDatatype.createTypedArray(numberOfVertices, length);\n      for (i = 0; i < length; i++) {\n        indices[i] = packedGeometry[packedGeometryIndex++];\n      }\n    }\n\n    result[resultIndex++] = new Geometry({\n      primitiveType: primitiveType,\n      geometryType: geometryType,\n      boundingSphere: boundingSphere,\n      boundingSphereCV: boundingSphereCV,\n      indices: indices,\n      attributes: attributes,\n      offsetAttribute: offsetAttribute,\n    });\n  }\n\n  return result;\n};\n\nfunction packInstancesForCombine(instances, transferableObjects) {\n  const length = instances.length;\n  const packedData = new Float64Array(1 + length * 19);\n  let count = 0;\n  packedData[count++] = length;\n  for (let i = 0; i < length; i++) {\n    const instance = instances[i];\n    Matrix4.pack(instance.modelMatrix, packedData, count);\n    count += Matrix4.packedLength;\n    if (defined(instance.attributes) && defined(instance.attributes.offset)) {\n      const values = instance.attributes.offset.value;\n      packedData[count] = values[0];\n      packedData[count + 1] = values[1];\n      packedData[count + 2] = values[2];\n    }\n    count += 3;\n  }\n  transferableObjects.push(packedData.buffer);\n\n  return packedData;\n}\n\nfunction unpackInstancesForCombine(data) {\n  const packedInstances = data;\n  const result = new Array(packedInstances[0]);\n  let count = 0;\n\n  let i = 1;\n  while (i < packedInstances.length) {\n    const modelMatrix = Matrix4.unpack(packedInstances, i);\n    let attributes;\n    i += Matrix4.packedLength;\n    if (defined(packedInstances[i])) {\n      attributes = {\n        offset: new OffsetGeometryInstanceAttribute(\n          packedInstances[i],\n          packedInstances[i + 1],\n          packedInstances[i + 2],\n        ),\n      };\n    }\n    i += 3;\n\n    result[count++] = {\n      modelMatrix: modelMatrix,\n      attributes: attributes,\n    };\n  }\n\n  return result;\n}\n\n/**\n * @private\n */\nPrimitivePipeline.packCombineGeometryParameters = function (\n  parameters,\n  transferableObjects,\n) {\n  const createGeometryResults = parameters.createGeometryResults;\n  const length = createGeometryResults.length;\n\n  for (let i = 0; i < length; i++) {\n    transferableObjects.push(createGeometryResults[i].packedData.buffer);\n  }\n\n  return {\n    createGeometryResults: parameters.createGeometryResults,\n    packedInstances: packInstancesForCombine(\n      parameters.instances,\n      transferableObjects,\n    ),\n    ellipsoid: parameters.ellipsoid,\n    isGeographic: parameters.projection instanceof GeographicProjection,\n    elementIndexUintSupported: parameters.elementIndexUintSupported,\n    scene3DOnly: parameters.scene3DOnly,\n    vertexCacheOptimize: parameters.vertexCacheOptimize,\n    compressVertices: parameters.compressVertices,\n    modelMatrix: parameters.modelMatrix,\n    createPickOffsets: parameters.createPickOffsets,\n  };\n};\n\n/**\n * @private\n */\nPrimitivePipeline.unpackCombineGeometryParameters = function (\n  packedParameters,\n) {\n  const instances = unpackInstancesForCombine(packedParameters.packedInstances);\n  const createGeometryResults = packedParameters.createGeometryResults;\n  const length = createGeometryResults.length;\n  let instanceIndex = 0;\n\n  for (let resultIndex = 0; resultIndex < length; resultIndex++) {\n    const geometries = PrimitivePipeline.unpackCreateGeometryResults(\n      createGeometryResults[resultIndex],\n    );\n    const geometriesLength = geometries.length;\n    for (\n      let geometryIndex = 0;\n      geometryIndex < geometriesLength;\n      geometryIndex++\n    ) {\n      const geometry = geometries[geometryIndex];\n      const instance = instances[instanceIndex];\n      instance.geometry = geometry;\n      ++instanceIndex;\n    }\n  }\n\n  const ellipsoid = Ellipsoid.clone(packedParameters.ellipsoid);\n  const projection = packedParameters.isGeographic\n    ? new GeographicProjection(ellipsoid)\n    : new WebMercatorProjection(ellipsoid);\n\n  return {\n    instances: instances,\n    ellipsoid: ellipsoid,\n    projection: projection,\n    elementIndexUintSupported: packedParameters.elementIndexUintSupported,\n    scene3DOnly: packedParameters.scene3DOnly,\n    vertexCacheOptimize: packedParameters.vertexCacheOptimize,\n    compressVertices: packedParameters.compressVertices,\n    modelMatrix: Matrix4.clone(packedParameters.modelMatrix),\n    createPickOffsets: packedParameters.createPickOffsets,\n  };\n};\n\nfunction packBoundingSpheres(boundingSpheres) {\n  const length = boundingSpheres.length;\n  const bufferLength = 1 + (BoundingSphere.packedLength + 1) * length;\n  const buffer = new Float32Array(bufferLength);\n\n  let bufferIndex = 0;\n  buffer[bufferIndex++] = length;\n\n  for (let i = 0; i < length; ++i) {\n    const bs = boundingSpheres[i];\n    if (!defined(bs)) {\n      buffer[bufferIndex++] = 0.0;\n    } else {\n      buffer[bufferIndex++] = 1.0;\n      BoundingSphere.pack(boundingSpheres[i], buffer, bufferIndex);\n    }\n    bufferIndex += BoundingSphere.packedLength;\n  }\n\n  return buffer;\n}\n\nfunction unpackBoundingSpheres(buffer) {\n  const result = new Array(buffer[0]);\n  let count = 0;\n\n  let i = 1;\n  while (i < buffer.length) {\n    if (buffer[i++] === 1.0) {\n      result[count] = BoundingSphere.unpack(buffer, i);\n    }\n    ++count;\n    i += BoundingSphere.packedLength;\n  }\n\n  return result;\n}\n\n/**\n * @private\n */\nPrimitivePipeline.packCombineGeometryResults = function (\n  results,\n  transferableObjects,\n) {\n  if (defined(results.geometries)) {\n    transferGeometries(results.geometries, transferableObjects);\n  }\n\n  const packedBoundingSpheres = packBoundingSpheres(results.boundingSpheres);\n  const packedBoundingSpheresCV = packBoundingSpheres(\n    results.boundingSpheresCV,\n  );\n  transferableObjects.push(\n    packedBoundingSpheres.buffer,\n    packedBoundingSpheresCV.buffer,\n  );\n\n  return {\n    geometries: results.geometries,\n    attributeLocations: results.attributeLocations,\n    modelMatrix: results.modelMatrix,\n    pickOffsets: results.pickOffsets,\n    offsetInstanceExtend: results.offsetInstanceExtend,\n    boundingSpheres: packedBoundingSpheres,\n    boundingSpheresCV: packedBoundingSpheresCV,\n  };\n};\n\n/**\n * @private\n */\nPrimitivePipeline.unpackCombineGeometryResults = function (packedResult) {\n  return {\n    geometries: packedResult.geometries,\n    attributeLocations: packedResult.attributeLocations,\n    modelMatrix: packedResult.modelMatrix,\n    pickOffsets: packedResult.pickOffsets,\n    offsetInstanceExtend: packedResult.offsetInstanceExtend,\n    boundingSpheres: unpackBoundingSpheres(packedResult.boundingSpheres),\n    boundingSpheresCV: unpackBoundingSpheres(packedResult.boundingSpheresCV),\n  };\n};\nexport default PrimitivePipeline;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}