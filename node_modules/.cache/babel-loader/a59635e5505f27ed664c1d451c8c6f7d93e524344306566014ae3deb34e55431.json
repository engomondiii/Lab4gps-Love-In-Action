{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRange from \"../Core/HeadingPitchRange.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport TrackingReferenceFrame from \"../Core/TrackingReferenceFrame.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport VelocityVectorProperty from \"./VelocityVectorProperty.js\";\nconst updateTransformMatrix3Scratch1 = new Matrix3();\nconst updateTransformMatrix3Scratch2 = new Matrix3();\nconst updateTransformMatrix3Scratch3 = new Matrix3();\nconst updateTransformMatrix4Scratch = new Matrix4();\nconst updateTransformCartesian3Scratch1 = new Cartesian3();\nconst updateTransformCartesian3Scratch2 = new Cartesian3();\nconst updateTransformCartesian3Scratch3 = new Cartesian3();\nconst updateTransformCartesian3Scratch4 = new Cartesian3();\nconst updateTransformCartesian3Scratch5 = new Cartesian3();\nconst updateTransformCartesian3Scratch6 = new Cartesian3();\nconst updateTransformOrientationScratch = new Quaternion();\nconst velocityScratch = new Cartesian3();\nconst rotationScratch = new Matrix3();\nconst deltaTime = new JulianDate();\nconst northUpAxisFactor = 1.25; // times ellipsoid's maximum radius\n\nfunction updateTransform(that, camera, updateLookAt, saveCamera, positionProperty, velocityProperty, orientationProperty, trackingReferenceFrame, time, ellipsoid) {\n  const mode = that.scene.mode;\n  let cartesian = positionProperty.getValue(time, that._lastCartesian);\n  if (defined(cartesian)) {\n    let hasBasis = false;\n    let invertVelocity = false;\n    let xBasis;\n    let yBasis;\n    let zBasis;\n    if (mode === SceneMode.SCENE3D) {\n      // The time delta was determined based on how fast satellites move compared to vehicles near the surface.\n      // Slower moving vehicles will most likely default to east-north-up, while faster ones will be VVLH.\n      JulianDate.addSeconds(time, 0.001, deltaTime);\n      let deltaCartesian = positionProperty.getValue(deltaTime, updateTransformCartesian3Scratch1);\n\n      // If no valid position at (time + 0.001), sample at (time - 0.001) and invert the vector\n      if (!defined(deltaCartesian)) {\n        JulianDate.addSeconds(time, -0.001, deltaTime);\n        deltaCartesian = positionProperty.getValue(deltaTime, updateTransformCartesian3Scratch1);\n        invertVelocity = true;\n      }\n      if (defined(deltaCartesian)) {\n        let toInertial = Transforms.computeFixedToIcrfMatrix(time, updateTransformMatrix3Scratch1);\n        let toInertialDelta = Transforms.computeFixedToIcrfMatrix(deltaTime, updateTransformMatrix3Scratch2);\n        let toFixed;\n        if (!defined(toInertial) || !defined(toInertialDelta)) {\n          toFixed = Transforms.computeTemeToPseudoFixedMatrix(time, updateTransformMatrix3Scratch3);\n          toInertial = Matrix3.transpose(toFixed, updateTransformMatrix3Scratch1);\n          toInertialDelta = Transforms.computeTemeToPseudoFixedMatrix(deltaTime, updateTransformMatrix3Scratch2);\n          Matrix3.transpose(toInertialDelta, toInertialDelta);\n        } else {\n          toFixed = Matrix3.transpose(toInertial, updateTransformMatrix3Scratch3);\n        }\n        const inertialCartesian = Matrix3.multiplyByVector(toInertial, cartesian, updateTransformCartesian3Scratch5);\n        const inertialDeltaCartesian = Matrix3.multiplyByVector(toInertialDelta, deltaCartesian, updateTransformCartesian3Scratch6);\n        Cartesian3.subtract(inertialCartesian, inertialDeltaCartesian, updateTransformCartesian3Scratch4);\n        const inertialVelocity = Cartesian3.magnitude(updateTransformCartesian3Scratch4) * 1000.0; // meters/sec\n\n        const mu = CesiumMath.GRAVITATIONALPARAMETER; // m^3 / sec^2\n        const semiMajorAxis = -mu / (inertialVelocity * inertialVelocity - 2 * mu / Cartesian3.magnitude(inertialCartesian));\n        if (semiMajorAxis < 0 || semiMajorAxis > northUpAxisFactor * ellipsoid.maximumRadius) {\n          // North-up viewing from deep space.\n\n          // X along the nadir\n          xBasis = updateTransformCartesian3Scratch2;\n          Cartesian3.normalize(cartesian, xBasis);\n          Cartesian3.negate(xBasis, xBasis);\n\n          // Z is North\n          zBasis = Cartesian3.clone(Cartesian3.UNIT_Z, updateTransformCartesian3Scratch3);\n\n          // Y is along the cross of z and x (right handed basis / in the direction of motion)\n          yBasis = Cartesian3.cross(zBasis, xBasis, updateTransformCartesian3Scratch1);\n          if (Cartesian3.magnitude(yBasis) > CesiumMath.EPSILON7) {\n            Cartesian3.normalize(xBasis, xBasis);\n            Cartesian3.normalize(yBasis, yBasis);\n            zBasis = Cartesian3.cross(xBasis, yBasis, updateTransformCartesian3Scratch3);\n            Cartesian3.normalize(zBasis, zBasis);\n            hasBasis = true;\n          }\n        } else if (!Cartesian3.equalsEpsilon(cartesian, deltaCartesian, CesiumMath.EPSILON7)) {\n          // Approximation of VVLH (Vehicle Velocity Local Horizontal) with the Z-axis flipped.\n\n          // Z along the position\n          zBasis = updateTransformCartesian3Scratch2;\n          Cartesian3.normalize(inertialCartesian, zBasis);\n          Cartesian3.normalize(inertialDeltaCartesian, inertialDeltaCartesian);\n\n          // Y is along the angular momentum vector (e.g. \"orbit normal\")\n          yBasis = Cartesian3.cross(zBasis, inertialDeltaCartesian, updateTransformCartesian3Scratch3);\n          if (invertVelocity) {\n            yBasis = Cartesian3.multiplyByScalar(yBasis, -1, yBasis);\n          }\n          if (!Cartesian3.equalsEpsilon(yBasis, Cartesian3.ZERO, CesiumMath.EPSILON7)) {\n            // X is along the cross of y and z (right handed basis / in the direction of motion)\n            xBasis = Cartesian3.cross(yBasis, zBasis, updateTransformCartesian3Scratch1);\n            Matrix3.multiplyByVector(toFixed, xBasis, xBasis);\n            Matrix3.multiplyByVector(toFixed, yBasis, yBasis);\n            Matrix3.multiplyByVector(toFixed, zBasis, zBasis);\n            Cartesian3.normalize(xBasis, xBasis);\n            Cartesian3.normalize(yBasis, yBasis);\n            Cartesian3.normalize(zBasis, zBasis);\n            hasBasis = true;\n          }\n        }\n      }\n    }\n    if (defined(that.boundingSphere)) {\n      cartesian = that.boundingSphere.center;\n    }\n    let position;\n    let direction;\n    let up;\n    if (saveCamera) {\n      position = Cartesian3.clone(camera.position, updateTransformCartesian3Scratch4);\n      direction = Cartesian3.clone(camera.direction, updateTransformCartesian3Scratch5);\n      up = Cartesian3.clone(camera.up, updateTransformCartesian3Scratch6);\n    }\n    const transform = updateTransformMatrix4Scratch;\n    let orientation;\n    if (defined(orientationProperty)) {\n      orientation = orientationProperty.getValue(time, updateTransformOrientationScratch);\n    }\n    const velocity = velocityProperty.getValue(time, velocityScratch);\n    if (trackingReferenceFrame === TrackingReferenceFrame.INERTIAL && defined(orientation)) {\n      Matrix4.fromTranslationQuaternionRotationScale(cartesian, orientation, Cartesian3.ONE, transform);\n    } else if (trackingReferenceFrame === TrackingReferenceFrame.VELOCITY && defined(velocity)) {\n      const rotation = Transforms.rotationMatrixFromPositionVelocity(cartesian, velocity, ellipsoid, rotationScratch);\n      Matrix4.fromRotationTranslation(rotation, cartesian, transform);\n    } else if (trackingReferenceFrame === TrackingReferenceFrame.ENU || !hasBasis) {\n      Transforms.eastNorthUpToFixedFrame(cartesian, ellipsoid, transform);\n    } else {\n      transform[0] = xBasis.x;\n      transform[1] = xBasis.y;\n      transform[2] = xBasis.z;\n      transform[3] = 0.0;\n      transform[4] = yBasis.x;\n      transform[5] = yBasis.y;\n      transform[6] = yBasis.z;\n      transform[7] = 0.0;\n      transform[8] = zBasis.x;\n      transform[9] = zBasis.y;\n      transform[10] = zBasis.z;\n      transform[11] = 0.0;\n      transform[12] = cartesian.x;\n      transform[13] = cartesian.y;\n      transform[14] = cartesian.z;\n      transform[15] = 0.0;\n    }\n    camera._setTransform(transform);\n    if (saveCamera) {\n      Cartesian3.clone(position, camera.position);\n      Cartesian3.clone(direction, camera.direction);\n      Cartesian3.clone(up, camera.up);\n      Cartesian3.cross(direction, up, camera.right);\n    }\n  }\n  if (updateLookAt) {\n    const offset = mode === SceneMode.SCENE2D || Cartesian3.equals(that._offset3D, Cartesian3.ZERO) ? undefined : that._offset3D;\n    camera.lookAtTransform(camera.transform, offset);\n  }\n}\n\n/**\n * A utility object for tracking an entity with the camera.\n * @alias EntityView\n * @constructor\n *\n * @param {Entity} entity The entity to track with the camera.\n * @param {Scene} scene The scene to use.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to use for orienting the camera.\n */\nfunction EntityView(entity, scene, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"entity\", entity);\n  Check.defined(\"scene\", scene);\n  //>>includeEnd('debug');\n\n  /**\n   * The entity to track with the camera.\n   * @type {Entity}\n   */\n  this.entity = entity;\n\n  /**\n   * The scene in which to track the object.\n   * @type {Scene}\n   */\n  this.scene = scene;\n\n  /**\n   * The ellipsoid to use for orienting the camera.\n   * @type {Ellipsoid}\n   */\n  this.ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n\n  /**\n   * The bounding sphere of the object.\n   * @type {BoundingSphere}\n   */\n  this.boundingSphere = undefined;\n\n  // Shadow copies of the objects so we can detect changes.\n  this._lastEntity = undefined;\n  this._mode = undefined;\n  this._lastCartesian = new Cartesian3();\n  this._defaultOffset3D = undefined;\n  this._velocityProperty = new VelocityVectorProperty(entity.position, true);\n  this._offset3D = new Cartesian3();\n}\n\n// STATIC properties defined here, not per-instance.\nObject.defineProperties(EntityView, {\n  /**\n   * Gets or sets a camera offset that will be used to\n   * initialize subsequent EntityViews.\n   * @memberof EntityView\n   * @type {Cartesian3}\n   */\n  defaultOffset3D: {\n    get: function () {\n      return this._defaultOffset3D;\n    },\n    set: function (vector) {\n      this._defaultOffset3D = Cartesian3.clone(vector, new Cartesian3());\n    }\n  }\n});\n\n// Initialize the static property.\nEntityView.defaultOffset3D = new Cartesian3(-14000, 3500, 3500);\nconst scratchHeadingPitchRange = new HeadingPitchRange();\nconst scratchCartesian = new Cartesian3();\n\n/**\n * Should be called each animation frame to update the camera\n * to the latest settings.\n * @param {JulianDate} time The current animation time.\n * @param {BoundingSphere} [boundingSphere] bounding sphere of the object.\n */\nEntityView.prototype.update = function (time, boundingSphere) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  const scene = this.scene;\n  const ellipsoid = this.ellipsoid;\n  const sceneMode = scene.mode;\n  if (sceneMode === SceneMode.MORPHING) {\n    return;\n  }\n  const entity = this.entity;\n  const trackingReferenceFrame = entity.trackingReferenceFrame;\n  const positionProperty = entity.position;\n  if (!defined(positionProperty)) {\n    return;\n  }\n  const velocityProperty = this._velocityProperty;\n  const orientationProperty = entity.orientation;\n  const objectChanged = entity !== this._lastEntity;\n  const sceneModeChanged = sceneMode !== this._mode;\n  const camera = scene.camera;\n  let updateLookAt = objectChanged || sceneModeChanged;\n  let saveCamera = true;\n  if (objectChanged) {\n    const viewFromProperty = entity.viewFrom;\n    const hasViewFrom = defined(viewFromProperty);\n    if (!hasViewFrom && defined(boundingSphere)) {\n      // The default HPR is not ideal for high altitude objects so\n      // we scale the pitch as we get further from the earth for a more\n      // downward view.\n      scratchHeadingPitchRange.pitch = -CesiumMath.PI_OVER_FOUR;\n      scratchHeadingPitchRange.range = 0;\n      const position = positionProperty.getValue(time, scratchCartesian);\n      if (defined(position)) {\n        const factor = 2 - 1 / Math.max(1, Cartesian3.magnitude(position) / ellipsoid.maximumRadius);\n        scratchHeadingPitchRange.pitch *= factor;\n      }\n      camera.viewBoundingSphere(boundingSphere, scratchHeadingPitchRange);\n      this.boundingSphere = boundingSphere;\n      updateLookAt = false;\n      saveCamera = false;\n    } else if (!hasViewFrom || !defined(viewFromProperty.getValue(time, this._offset3D))) {\n      Cartesian3.clone(EntityView._defaultOffset3D, this._offset3D);\n    }\n  } else if (!sceneModeChanged && this._mode !== SceneMode.SCENE2D) {\n    Cartesian3.clone(camera.position, this._offset3D);\n  }\n  this._lastEntity = entity;\n  this._mode = sceneMode;\n  updateTransform(this, camera, updateLookAt, saveCamera, positionProperty, velocityProperty, orientationProperty, trackingReferenceFrame, time, ellipsoid);\n};\nexport default EntityView;","map":{"version":3,"names":["Cartesian3","Check","defaultValue","defined","Ellipsoid","HeadingPitchRange","JulianDate","CesiumMath","Matrix3","Matrix4","Quaternion","TrackingReferenceFrame","Transforms","SceneMode","VelocityVectorProperty","updateTransformMatrix3Scratch1","updateTransformMatrix3Scratch2","updateTransformMatrix3Scratch3","updateTransformMatrix4Scratch","updateTransformCartesian3Scratch1","updateTransformCartesian3Scratch2","updateTransformCartesian3Scratch3","updateTransformCartesian3Scratch4","updateTransformCartesian3Scratch5","updateTransformCartesian3Scratch6","updateTransformOrientationScratch","velocityScratch","rotationScratch","deltaTime","northUpAxisFactor","updateTransform","that","camera","updateLookAt","saveCamera","positionProperty","velocityProperty","orientationProperty","trackingReferenceFrame","time","ellipsoid","mode","scene","cartesian","getValue","_lastCartesian","hasBasis","invertVelocity","xBasis","yBasis","zBasis","SCENE3D","addSeconds","deltaCartesian","toInertial","computeFixedToIcrfMatrix","toInertialDelta","toFixed","computeTemeToPseudoFixedMatrix","transpose","inertialCartesian","multiplyByVector","inertialDeltaCartesian","subtract","inertialVelocity","magnitude","mu","GRAVITATIONALPARAMETER","semiMajorAxis","maximumRadius","normalize","negate","clone","UNIT_Z","cross","EPSILON7","equalsEpsilon","multiplyByScalar","ZERO","boundingSphere","center","position","direction","up","transform","orientation","velocity","INERTIAL","fromTranslationQuaternionRotationScale","ONE","VELOCITY","rotation","rotationMatrixFromPositionVelocity","fromRotationTranslation","ENU","eastNorthUpToFixedFrame","x","y","z","_setTransform","right","offset","SCENE2D","equals","_offset3D","undefined","lookAtTransform","EntityView","entity","default","_lastEntity","_mode","_defaultOffset3D","_velocityProperty","Object","defineProperties","defaultOffset3D","get","set","vector","scratchHeadingPitchRange","scratchCartesian","prototype","update","sceneMode","MORPHING","objectChanged","sceneModeChanged","viewFromProperty","viewFrom","hasViewFrom","pitch","PI_OVER_FOUR","range","factor","Math","max","viewBoundingSphere"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/DataSources/EntityView.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRange from \"../Core/HeadingPitchRange.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport TrackingReferenceFrame from \"../Core/TrackingReferenceFrame.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport VelocityVectorProperty from \"./VelocityVectorProperty.js\";\n\nconst updateTransformMatrix3Scratch1 = new Matrix3();\nconst updateTransformMatrix3Scratch2 = new Matrix3();\nconst updateTransformMatrix3Scratch3 = new Matrix3();\nconst updateTransformMatrix4Scratch = new Matrix4();\nconst updateTransformCartesian3Scratch1 = new Cartesian3();\nconst updateTransformCartesian3Scratch2 = new Cartesian3();\nconst updateTransformCartesian3Scratch3 = new Cartesian3();\nconst updateTransformCartesian3Scratch4 = new Cartesian3();\nconst updateTransformCartesian3Scratch5 = new Cartesian3();\nconst updateTransformCartesian3Scratch6 = new Cartesian3();\nconst updateTransformOrientationScratch = new Quaternion();\nconst velocityScratch = new Cartesian3();\nconst rotationScratch = new Matrix3();\nconst deltaTime = new JulianDate();\nconst northUpAxisFactor = 1.25; // times ellipsoid's maximum radius\n\nfunction updateTransform(\n  that,\n  camera,\n  updateLookAt,\n  saveCamera,\n  positionProperty,\n  velocityProperty,\n  orientationProperty,\n  trackingReferenceFrame,\n  time,\n  ellipsoid,\n) {\n  const mode = that.scene.mode;\n  let cartesian = positionProperty.getValue(time, that._lastCartesian);\n  if (defined(cartesian)) {\n    let hasBasis = false;\n    let invertVelocity = false;\n    let xBasis;\n    let yBasis;\n    let zBasis;\n\n    if (mode === SceneMode.SCENE3D) {\n      // The time delta was determined based on how fast satellites move compared to vehicles near the surface.\n      // Slower moving vehicles will most likely default to east-north-up, while faster ones will be VVLH.\n      JulianDate.addSeconds(time, 0.001, deltaTime);\n      let deltaCartesian = positionProperty.getValue(\n        deltaTime,\n        updateTransformCartesian3Scratch1,\n      );\n\n      // If no valid position at (time + 0.001), sample at (time - 0.001) and invert the vector\n      if (!defined(deltaCartesian)) {\n        JulianDate.addSeconds(time, -0.001, deltaTime);\n        deltaCartesian = positionProperty.getValue(\n          deltaTime,\n          updateTransformCartesian3Scratch1,\n        );\n        invertVelocity = true;\n      }\n\n      if (defined(deltaCartesian)) {\n        let toInertial = Transforms.computeFixedToIcrfMatrix(\n          time,\n          updateTransformMatrix3Scratch1,\n        );\n        let toInertialDelta = Transforms.computeFixedToIcrfMatrix(\n          deltaTime,\n          updateTransformMatrix3Scratch2,\n        );\n        let toFixed;\n\n        if (!defined(toInertial) || !defined(toInertialDelta)) {\n          toFixed = Transforms.computeTemeToPseudoFixedMatrix(\n            time,\n            updateTransformMatrix3Scratch3,\n          );\n          toInertial = Matrix3.transpose(\n            toFixed,\n            updateTransformMatrix3Scratch1,\n          );\n          toInertialDelta = Transforms.computeTemeToPseudoFixedMatrix(\n            deltaTime,\n            updateTransformMatrix3Scratch2,\n          );\n          Matrix3.transpose(toInertialDelta, toInertialDelta);\n        } else {\n          toFixed = Matrix3.transpose(\n            toInertial,\n            updateTransformMatrix3Scratch3,\n          );\n        }\n\n        const inertialCartesian = Matrix3.multiplyByVector(\n          toInertial,\n          cartesian,\n          updateTransformCartesian3Scratch5,\n        );\n        const inertialDeltaCartesian = Matrix3.multiplyByVector(\n          toInertialDelta,\n          deltaCartesian,\n          updateTransformCartesian3Scratch6,\n        );\n\n        Cartesian3.subtract(\n          inertialCartesian,\n          inertialDeltaCartesian,\n          updateTransformCartesian3Scratch4,\n        );\n        const inertialVelocity =\n          Cartesian3.magnitude(updateTransformCartesian3Scratch4) * 1000.0; // meters/sec\n\n        const mu = CesiumMath.GRAVITATIONALPARAMETER; // m^3 / sec^2\n        const semiMajorAxis =\n          -mu /\n          (inertialVelocity * inertialVelocity -\n            (2 * mu) / Cartesian3.magnitude(inertialCartesian));\n\n        if (\n          semiMajorAxis < 0 ||\n          semiMajorAxis > northUpAxisFactor * ellipsoid.maximumRadius\n        ) {\n          // North-up viewing from deep space.\n\n          // X along the nadir\n          xBasis = updateTransformCartesian3Scratch2;\n          Cartesian3.normalize(cartesian, xBasis);\n          Cartesian3.negate(xBasis, xBasis);\n\n          // Z is North\n          zBasis = Cartesian3.clone(\n            Cartesian3.UNIT_Z,\n            updateTransformCartesian3Scratch3,\n          );\n\n          // Y is along the cross of z and x (right handed basis / in the direction of motion)\n          yBasis = Cartesian3.cross(\n            zBasis,\n            xBasis,\n            updateTransformCartesian3Scratch1,\n          );\n          if (Cartesian3.magnitude(yBasis) > CesiumMath.EPSILON7) {\n            Cartesian3.normalize(xBasis, xBasis);\n            Cartesian3.normalize(yBasis, yBasis);\n\n            zBasis = Cartesian3.cross(\n              xBasis,\n              yBasis,\n              updateTransformCartesian3Scratch3,\n            );\n            Cartesian3.normalize(zBasis, zBasis);\n\n            hasBasis = true;\n          }\n        } else if (\n          !Cartesian3.equalsEpsilon(\n            cartesian,\n            deltaCartesian,\n            CesiumMath.EPSILON7,\n          )\n        ) {\n          // Approximation of VVLH (Vehicle Velocity Local Horizontal) with the Z-axis flipped.\n\n          // Z along the position\n          zBasis = updateTransformCartesian3Scratch2;\n          Cartesian3.normalize(inertialCartesian, zBasis);\n          Cartesian3.normalize(inertialDeltaCartesian, inertialDeltaCartesian);\n\n          // Y is along the angular momentum vector (e.g. \"orbit normal\")\n          yBasis = Cartesian3.cross(\n            zBasis,\n            inertialDeltaCartesian,\n            updateTransformCartesian3Scratch3,\n          );\n\n          if (invertVelocity) {\n            yBasis = Cartesian3.multiplyByScalar(yBasis, -1, yBasis);\n          }\n\n          if (\n            !Cartesian3.equalsEpsilon(\n              yBasis,\n              Cartesian3.ZERO,\n              CesiumMath.EPSILON7,\n            )\n          ) {\n            // X is along the cross of y and z (right handed basis / in the direction of motion)\n            xBasis = Cartesian3.cross(\n              yBasis,\n              zBasis,\n              updateTransformCartesian3Scratch1,\n            );\n\n            Matrix3.multiplyByVector(toFixed, xBasis, xBasis);\n            Matrix3.multiplyByVector(toFixed, yBasis, yBasis);\n            Matrix3.multiplyByVector(toFixed, zBasis, zBasis);\n\n            Cartesian3.normalize(xBasis, xBasis);\n            Cartesian3.normalize(yBasis, yBasis);\n            Cartesian3.normalize(zBasis, zBasis);\n\n            hasBasis = true;\n          }\n        }\n      }\n    }\n\n    if (defined(that.boundingSphere)) {\n      cartesian = that.boundingSphere.center;\n    }\n\n    let position;\n    let direction;\n    let up;\n\n    if (saveCamera) {\n      position = Cartesian3.clone(\n        camera.position,\n        updateTransformCartesian3Scratch4,\n      );\n      direction = Cartesian3.clone(\n        camera.direction,\n        updateTransformCartesian3Scratch5,\n      );\n      up = Cartesian3.clone(camera.up, updateTransformCartesian3Scratch6);\n    }\n\n    const transform = updateTransformMatrix4Scratch;\n\n    let orientation;\n    if (defined(orientationProperty)) {\n      orientation = orientationProperty.getValue(\n        time,\n        updateTransformOrientationScratch,\n      );\n    }\n\n    const velocity = velocityProperty.getValue(time, velocityScratch);\n\n    if (\n      trackingReferenceFrame === TrackingReferenceFrame.INERTIAL &&\n      defined(orientation)\n    ) {\n      Matrix4.fromTranslationQuaternionRotationScale(\n        cartesian,\n        orientation,\n        Cartesian3.ONE,\n        transform,\n      );\n    } else if (\n      trackingReferenceFrame === TrackingReferenceFrame.VELOCITY &&\n      defined(velocity)\n    ) {\n      const rotation = Transforms.rotationMatrixFromPositionVelocity(\n        cartesian,\n        velocity,\n        ellipsoid,\n        rotationScratch,\n      );\n      Matrix4.fromRotationTranslation(rotation, cartesian, transform);\n    } else if (\n      trackingReferenceFrame === TrackingReferenceFrame.ENU ||\n      !hasBasis\n    ) {\n      Transforms.eastNorthUpToFixedFrame(cartesian, ellipsoid, transform);\n    } else {\n      transform[0] = xBasis.x;\n      transform[1] = xBasis.y;\n      transform[2] = xBasis.z;\n      transform[3] = 0.0;\n      transform[4] = yBasis.x;\n      transform[5] = yBasis.y;\n      transform[6] = yBasis.z;\n      transform[7] = 0.0;\n      transform[8] = zBasis.x;\n      transform[9] = zBasis.y;\n      transform[10] = zBasis.z;\n      transform[11] = 0.0;\n      transform[12] = cartesian.x;\n      transform[13] = cartesian.y;\n      transform[14] = cartesian.z;\n      transform[15] = 0.0;\n    }\n\n    camera._setTransform(transform);\n\n    if (saveCamera) {\n      Cartesian3.clone(position, camera.position);\n      Cartesian3.clone(direction, camera.direction);\n      Cartesian3.clone(up, camera.up);\n      Cartesian3.cross(direction, up, camera.right);\n    }\n  }\n\n  if (updateLookAt) {\n    const offset =\n      mode === SceneMode.SCENE2D ||\n      Cartesian3.equals(that._offset3D, Cartesian3.ZERO)\n        ? undefined\n        : that._offset3D;\n    camera.lookAtTransform(camera.transform, offset);\n  }\n}\n\n/**\n * A utility object for tracking an entity with the camera.\n * @alias EntityView\n * @constructor\n *\n * @param {Entity} entity The entity to track with the camera.\n * @param {Scene} scene The scene to use.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid to use for orienting the camera.\n */\nfunction EntityView(entity, scene, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"entity\", entity);\n  Check.defined(\"scene\", scene);\n  //>>includeEnd('debug');\n\n  /**\n   * The entity to track with the camera.\n   * @type {Entity}\n   */\n  this.entity = entity;\n\n  /**\n   * The scene in which to track the object.\n   * @type {Scene}\n   */\n  this.scene = scene;\n\n  /**\n   * The ellipsoid to use for orienting the camera.\n   * @type {Ellipsoid}\n   */\n  this.ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n\n  /**\n   * The bounding sphere of the object.\n   * @type {BoundingSphere}\n   */\n  this.boundingSphere = undefined;\n\n  // Shadow copies of the objects so we can detect changes.\n  this._lastEntity = undefined;\n  this._mode = undefined;\n\n  this._lastCartesian = new Cartesian3();\n  this._defaultOffset3D = undefined;\n\n  this._velocityProperty = new VelocityVectorProperty(entity.position, true);\n\n  this._offset3D = new Cartesian3();\n}\n\n// STATIC properties defined here, not per-instance.\nObject.defineProperties(EntityView, {\n  /**\n   * Gets or sets a camera offset that will be used to\n   * initialize subsequent EntityViews.\n   * @memberof EntityView\n   * @type {Cartesian3}\n   */\n  defaultOffset3D: {\n    get: function () {\n      return this._defaultOffset3D;\n    },\n    set: function (vector) {\n      this._defaultOffset3D = Cartesian3.clone(vector, new Cartesian3());\n    },\n  },\n});\n\n// Initialize the static property.\nEntityView.defaultOffset3D = new Cartesian3(-14000, 3500, 3500);\n\nconst scratchHeadingPitchRange = new HeadingPitchRange();\nconst scratchCartesian = new Cartesian3();\n\n/**\n * Should be called each animation frame to update the camera\n * to the latest settings.\n * @param {JulianDate} time The current animation time.\n * @param {BoundingSphere} [boundingSphere] bounding sphere of the object.\n */\nEntityView.prototype.update = function (time, boundingSphere) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  const scene = this.scene;\n  const ellipsoid = this.ellipsoid;\n  const sceneMode = scene.mode;\n  if (sceneMode === SceneMode.MORPHING) {\n    return;\n  }\n\n  const entity = this.entity;\n  const trackingReferenceFrame = entity.trackingReferenceFrame;\n  const positionProperty = entity.position;\n  if (!defined(positionProperty)) {\n    return;\n  }\n  const velocityProperty = this._velocityProperty;\n  const orientationProperty = entity.orientation;\n  const objectChanged = entity !== this._lastEntity;\n  const sceneModeChanged = sceneMode !== this._mode;\n\n  const camera = scene.camera;\n\n  let updateLookAt = objectChanged || sceneModeChanged;\n  let saveCamera = true;\n\n  if (objectChanged) {\n    const viewFromProperty = entity.viewFrom;\n    const hasViewFrom = defined(viewFromProperty);\n\n    if (!hasViewFrom && defined(boundingSphere)) {\n      // The default HPR is not ideal for high altitude objects so\n      // we scale the pitch as we get further from the earth for a more\n      // downward view.\n      scratchHeadingPitchRange.pitch = -CesiumMath.PI_OVER_FOUR;\n      scratchHeadingPitchRange.range = 0;\n      const position = positionProperty.getValue(time, scratchCartesian);\n      if (defined(position)) {\n        const factor =\n          2 -\n          1 /\n            Math.max(\n              1,\n              Cartesian3.magnitude(position) / ellipsoid.maximumRadius,\n            );\n        scratchHeadingPitchRange.pitch *= factor;\n      }\n\n      camera.viewBoundingSphere(boundingSphere, scratchHeadingPitchRange);\n      this.boundingSphere = boundingSphere;\n      updateLookAt = false;\n      saveCamera = false;\n    } else if (\n      !hasViewFrom ||\n      !defined(viewFromProperty.getValue(time, this._offset3D))\n    ) {\n      Cartesian3.clone(EntityView._defaultOffset3D, this._offset3D);\n    }\n  } else if (!sceneModeChanged && this._mode !== SceneMode.SCENE2D) {\n    Cartesian3.clone(camera.position, this._offset3D);\n  }\n\n  this._lastEntity = entity;\n  this._mode = sceneMode;\n\n  updateTransform(\n    this,\n    camera,\n    updateLookAt,\n    saveCamera,\n    positionProperty,\n    velocityProperty,\n    orientationProperty,\n    trackingReferenceFrame,\n    time,\n    ellipsoid,\n  );\n};\nexport default EntityView;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}