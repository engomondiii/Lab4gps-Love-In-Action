{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\n\n/**\n * An object that manages color, show/hide and picking textures for a batch\n * table or feature table.\n *\n * @param {object} options Object with the following properties:\n * @param {number} featuresLength The number of features in the batch table or feature table\n * @param {Cesium3DTileContent|ModelFeatureTable} owner The owner of this batch texture. For 3D Tiles, this will be a {@link Cesium3DTileContent}. For glTF models, this will be a {@link ModelFeatureTable}.\n * @param {object} [statistics] The statistics object to update with information about the batch texture.\n * @param {Function} [colorChangedCallback] A callback function that is called whenever the color of a feature changes.\n *\n * @alias BatchTexture\n * @constructor\n *\n * @private\n */\nfunction BatchTexture(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.featuresLength\", options.featuresLength);\n  Check.typeOf.object(\"options.owner\", options.owner);\n  //>>includeEnd('debug');\n\n  this._id = createGuid();\n  const featuresLength = options.featuresLength;\n\n  // PERFORMANCE_IDEA: These parallel arrays probably generate cache misses in get/set color/show\n  // and use A LOT of memory.  How can we use less memory?\n  this._showAlphaProperties = undefined; // [Show (0 or 255), Alpha (0 to 255)] property for each feature\n  this._batchValues = undefined; // Per-feature RGBA (A is based on the color's alpha and feature's show property)\n\n  this._batchValuesDirty = false;\n  this._batchTexture = undefined;\n  this._defaultTexture = undefined;\n  this._pickTexture = undefined;\n  this._pickIds = [];\n\n  // Dimensions for batch and pick textures\n  let textureDimensions;\n  let textureStep;\n  if (featuresLength > 0) {\n    // PERFORMANCE_IDEA: this can waste memory in the last row in the uncommon case\n    // when more than one row is needed (e.g., > 16K features in one tile)\n    const width = Math.min(featuresLength, ContextLimits.maximumTextureSize);\n    const height = Math.ceil(featuresLength / ContextLimits.maximumTextureSize);\n    const stepX = 1.0 / width;\n    const centerX = stepX * 0.5;\n    const stepY = 1.0 / height;\n    const centerY = stepY * 0.5;\n    textureDimensions = new Cartesian2(width, height);\n    textureStep = new Cartesian4(stepX, centerX, stepY, centerY);\n  }\n  this._translucentFeaturesLength = 0;\n  this._featuresLength = featuresLength;\n  this._textureDimensions = textureDimensions;\n  this._textureStep = textureStep;\n  this._owner = options.owner;\n  this._statistics = options.statistics;\n  this._colorChangedCallback = options.colorChangedCallback;\n}\nObject.defineProperties(BatchTexture.prototype, {\n  /**\n   * Number of features that are translucent\n   *\n   * @memberof BatchTexture.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  translucentFeaturesLength: {\n    get: function () {\n      return this._translucentFeaturesLength;\n    }\n  },\n  /**\n   * Total size of all GPU resources used by this batch texture.\n   *\n   * @memberof BatchTexture.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  byteLength: {\n    get: function () {\n      let memory = 0;\n      if (defined(this._pickTexture)) {\n        memory += this._pickTexture.sizeInBytes;\n      }\n      if (defined(this._batchTexture)) {\n        memory += this._batchTexture.sizeInBytes;\n      }\n      return memory;\n    }\n  },\n  /**\n   * Dimensions of the underlying batch texture.\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Cartesian2}\n   * @readonly\n   * @private\n   */\n  textureDimensions: {\n    get: function () {\n      return this._textureDimensions;\n    }\n  },\n  /**\n   * Size of each texture and distance from side to center of a texel in\n   * each direction. Stored as (stepX, centerX, stepY, centerY)\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Cartesian4}\n   * @readonly\n   * @private\n   */\n  textureStep: {\n    get: function () {\n      return this._textureStep;\n    }\n  },\n  /**\n   * The underlying texture used for styling. The texels are accessed\n   * by batch ID, and the value is the color of this feature after accounting\n   * for show/hide settings.\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  batchTexture: {\n    get: function () {\n      return this._batchTexture;\n    }\n  },\n  /**\n   * The default texture to use when there are no batch values\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  defaultTexture: {\n    get: function () {\n      return this._defaultTexture;\n    }\n  },\n  /**\n   * The underlying texture used for picking. The texels are accessed by\n   * batch ID, and the value is the pick color.\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  pickTexture: {\n    get: function () {\n      return this._pickTexture;\n    }\n  }\n});\nBatchTexture.DEFAULT_COLOR_VALUE = Color.WHITE;\nBatchTexture.DEFAULT_SHOW_VALUE = true;\nfunction getByteLength(batchTexture) {\n  const dimensions = batchTexture._textureDimensions;\n  return dimensions.x * dimensions.y * 4;\n}\nfunction getBatchValues(batchTexture) {\n  if (!defined(batchTexture._batchValues)) {\n    // Default batch texture to RGBA = 255: white highlight (RGB) and show/alpha = true/255 (A).\n    const byteLength = getByteLength(batchTexture);\n    const bytes = new Uint8Array(byteLength).fill(255);\n    batchTexture._batchValues = bytes;\n  }\n  return batchTexture._batchValues;\n}\nfunction getShowAlphaProperties(batchTexture) {\n  if (!defined(batchTexture._showAlphaProperties)) {\n    const byteLength = 2 * batchTexture._featuresLength;\n    const bytes = new Uint8Array(byteLength).fill(255);\n    // [Show = true, Alpha = 255]\n    batchTexture._showAlphaProperties = bytes;\n  }\n  return batchTexture._showAlphaProperties;\n}\nfunction checkBatchId(batchId, featuresLength) {\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(`batchId is required and between zero and featuresLength - 1 (${featuresLength}` - +\").\");\n  }\n}\n\n/**\n * Set whether a feature is visible.\n *\n * @param {number} batchId the ID of the feature\n * @param {boolean} show <code>true</code> if the feature should be shown, <code>false</code> otherwise\n * @private\n */\nBatchTexture.prototype.setShow = function (batchId, show) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this._featuresLength);\n  Check.typeOf.bool(\"show\", show);\n  //>>includeEnd('debug');\n\n  if (show && !defined(this._showAlphaProperties)) {\n    // Avoid allocating since the default is show = true\n    return;\n  }\n  const showAlphaProperties = getShowAlphaProperties(this);\n  const propertyOffset = batchId * 2;\n  const newShow = show ? 255 : 0;\n  if (showAlphaProperties[propertyOffset] !== newShow) {\n    showAlphaProperties[propertyOffset] = newShow;\n    const batchValues = getBatchValues(this);\n\n    // Compute alpha used in the shader based on show and color.alpha properties\n    const offset = batchId * 4 + 3;\n    batchValues[offset] = show ? showAlphaProperties[propertyOffset + 1] : 0;\n    this._batchValuesDirty = true;\n  }\n};\n\n/**\n * Set the show for all features at once.\n *\n * @param {boolean} show <code>true</code> if the feature should be shown, <code>false</code> otherwise\n * @private\n */\nBatchTexture.prototype.setAllShow = function (show) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"show\", show);\n  //>>includeEnd('debug');\n\n  const featuresLength = this._featuresLength;\n  for (let i = 0; i < featuresLength; ++i) {\n    this.setShow(i, show);\n  }\n};\n\n/**\n * Check the current show value for a feature\n *\n * @param {number} batchId the ID of the feature\n * @return {boolean} <code>true</code> if the feature is shown, or <code>false</code> otherwise\n * @private\n */\nBatchTexture.prototype.getShow = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this._featuresLength);\n  //>>includeEnd('debug');\n\n  if (!defined(this._showAlphaProperties)) {\n    // Avoid allocating since the default is show = true\n    return true;\n  }\n  const offset = batchId * 2;\n  return this._showAlphaProperties[offset] === 255;\n};\nconst scratchColorBytes = new Array(4);\n\n/**\n * Set the styling color of a feature\n *\n * @param {number} batchId the ID of the feature\n * @param {Color} color the color to assign to this feature.\n *\n * @private\n */\nBatchTexture.prototype.setColor = function (batchId, color) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this._featuresLength);\n  Check.typeOf.object(\"color\", color);\n  //>>includeEnd('debug');\n\n  if (Color.equals(color, BatchTexture.DEFAULT_COLOR_VALUE) && !defined(this._batchValues)) {\n    // Avoid allocating since the default is white\n    return;\n  }\n  const newColor = color.toBytes(scratchColorBytes);\n  const newAlpha = newColor[3];\n  const batchValues = getBatchValues(this);\n  const offset = batchId * 4;\n  const showAlphaProperties = getShowAlphaProperties(this);\n  const propertyOffset = batchId * 2;\n  if (batchValues[offset] !== newColor[0] || batchValues[offset + 1] !== newColor[1] || batchValues[offset + 2] !== newColor[2] || showAlphaProperties[propertyOffset + 1] !== newAlpha) {\n    batchValues[offset] = newColor[0];\n    batchValues[offset + 1] = newColor[1];\n    batchValues[offset + 2] = newColor[2];\n    const wasTranslucent = showAlphaProperties[propertyOffset + 1] !== 255;\n\n    // Compute alpha used in the shader based on show and color.alpha properties\n    const show = showAlphaProperties[propertyOffset] !== 0;\n    batchValues[offset + 3] = show ? newAlpha : 0;\n    showAlphaProperties[propertyOffset + 1] = newAlpha;\n\n    // Track number of translucent features so we know if this tile needs\n    // opaque commands, translucent commands, or both for rendering.\n    const isTranslucent = newAlpha !== 255;\n    if (isTranslucent && !wasTranslucent) {\n      ++this._translucentFeaturesLength;\n    } else if (!isTranslucent && wasTranslucent) {\n      --this._translucentFeaturesLength;\n    }\n    this._batchValuesDirty = true;\n    if (defined(this._colorChangedCallback)) {\n      this._colorChangedCallback(batchId, color);\n    }\n  }\n};\n\n/**\n * Set the styling color for all features at once\n *\n * @param {Color} color the color to assign to all features.\n *\n * @private\n */\nBatchTexture.prototype.setAllColor = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"color\", color);\n  //>>includeEnd('debug');\n\n  const featuresLength = this._featuresLength;\n  for (let i = 0; i < featuresLength; ++i) {\n    this.setColor(i, color);\n  }\n};\n\n/**\n * Get the current color of a feature\n *\n * @param {number} batchId The ID of the feature\n * @param {Color} result A color object where the result will be stored.\n * @return {Color} The color assigned to the selected feature\n *\n * @private\n */\nBatchTexture.prototype.getColor = function (batchId, result) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this._featuresLength);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  if (!defined(this._batchValues)) {\n    return Color.clone(BatchTexture.DEFAULT_COLOR_VALUE, result);\n  }\n  const batchValues = this._batchValues;\n  const offset = batchId * 4;\n  const showAlphaProperties = this._showAlphaProperties;\n  const propertyOffset = batchId * 2;\n  return Color.fromBytes(batchValues[offset], batchValues[offset + 1], batchValues[offset + 2], showAlphaProperties[propertyOffset + 1], result);\n};\n\n/**\n * Get the pick color of a feature. This feature is an RGBA encoding of the\n * pick ID.\n *\n * @param {number} batchId The ID of the feature\n * @return {PickId} The picking color assigned to this feature\n *\n * @private\n */\nBatchTexture.prototype.getPickColor = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this._featuresLength);\n  //>>includeEnd('debug');\n  return this._pickIds[batchId];\n};\nfunction createTexture(batchTexture, context, bytes) {\n  const dimensions = batchTexture._textureDimensions;\n  return new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    source: {\n      width: dimensions.x,\n      height: dimensions.y,\n      arrayBufferView: bytes\n    },\n    flipY: false,\n    sampler: Sampler.NEAREST\n  });\n}\nfunction createPickTexture(batchTexture, context) {\n  const featuresLength = batchTexture._featuresLength;\n  if (!defined(batchTexture._pickTexture) && featuresLength > 0) {\n    const pickIds = batchTexture._pickIds;\n    const byteLength = getByteLength(batchTexture);\n    const bytes = new Uint8Array(byteLength);\n    const owner = batchTexture._owner;\n    const statistics = batchTexture._statistics;\n\n    // PERFORMANCE_IDEA: we could skip the pick texture completely by allocating\n    // a continuous range of pickIds and then converting the base pickId + batchId\n    // to RGBA in the shader.  The only consider is precision issues, which might\n    // not be an issue in WebGL 2.\n    for (let i = 0; i < featuresLength; ++i) {\n      const pickId = context.createPickId(owner.getFeature(i));\n      pickIds.push(pickId);\n      const pickColor = pickId.color;\n      const offset = i * 4;\n      bytes[offset] = Color.floatToByte(pickColor.red);\n      bytes[offset + 1] = Color.floatToByte(pickColor.green);\n      bytes[offset + 2] = Color.floatToByte(pickColor.blue);\n      bytes[offset + 3] = Color.floatToByte(pickColor.alpha);\n    }\n    batchTexture._pickTexture = createTexture(batchTexture, context, bytes);\n\n    // Make sure the tileset statistics are updated the frame when the pick\n    // texture is created.\n    if (defined(statistics)) {\n      statistics.batchTableByteLength += batchTexture._pickTexture.sizeInBytes;\n    }\n  }\n}\nfunction updateBatchTexture(batchTexture) {\n  const dimensions = batchTexture._textureDimensions;\n  // PERFORMANCE_IDEA: Instead of rewriting the entire texture, use fine-grained\n  // texture updates when less than, for example, 10%, of the values changed.  Or\n  // even just optimize the common case when one feature show/color changed.\n  batchTexture._batchTexture.copyFrom({\n    source: {\n      width: dimensions.x,\n      height: dimensions.y,\n      arrayBufferView: batchTexture._batchValues\n    }\n  });\n}\nBatchTexture.prototype.update = function (tileset, frameState) {\n  const context = frameState.context;\n  this._defaultTexture = context.defaultTexture;\n  const passes = frameState.passes;\n  if (passes.pick || passes.postProcess) {\n    createPickTexture(this, context);\n  }\n  if (this._batchValuesDirty) {\n    this._batchValuesDirty = false;\n\n    // Create batch texture on-demand\n    if (!defined(this._batchTexture)) {\n      this._batchTexture = createTexture(this, context, this._batchValues);\n\n      // Make sure the tileset statistics are updated the frame when the\n      // batch texture is created.\n      if (defined(this._statistics)) {\n        this._statistics.batchTableByteLength += this._batchTexture.sizeInBytes;\n      }\n    }\n    updateBatchTexture(this); // Apply per-feature show/color updates\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see BatchTexture#destroy\n * @private\n */\nBatchTexture.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see BatchTexture#isDestroyed\n * @private\n */\nBatchTexture.prototype.destroy = function () {\n  this._batchTexture = this._batchTexture && this._batchTexture.destroy();\n  this._pickTexture = this._pickTexture && this._pickTexture.destroy();\n  const pickIds = this._pickIds;\n  const length = pickIds.length;\n  for (let i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n  return destroyObject(this);\n};\nexport default BatchTexture;","map":{"version":3,"names":["Cartesian2","Cartesian4","Check","Color","createGuid","defined","destroyObject","DeveloperError","PixelFormat","ContextLimits","PixelDatatype","Sampler","Texture","BatchTexture","options","typeOf","number","featuresLength","object","owner","_id","_showAlphaProperties","undefined","_batchValues","_batchValuesDirty","_batchTexture","_defaultTexture","_pickTexture","_pickIds","textureDimensions","textureStep","width","Math","min","maximumTextureSize","height","ceil","stepX","centerX","stepY","centerY","_translucentFeaturesLength","_featuresLength","_textureDimensions","_textureStep","_owner","_statistics","statistics","_colorChangedCallback","colorChangedCallback","Object","defineProperties","prototype","translucentFeaturesLength","get","byteLength","memory","sizeInBytes","batchTexture","defaultTexture","pickTexture","DEFAULT_COLOR_VALUE","WHITE","DEFAULT_SHOW_VALUE","getByteLength","dimensions","x","y","getBatchValues","bytes","Uint8Array","fill","getShowAlphaProperties","checkBatchId","batchId","setShow","show","bool","showAlphaProperties","propertyOffset","newShow","batchValues","offset","setAllShow","i","getShow","scratchColorBytes","Array","setColor","color","equals","newColor","toBytes","newAlpha","wasTranslucent","isTranslucent","setAllColor","getColor","result","clone","fromBytes","getPickColor","createTexture","context","pixelFormat","RGBA","pixelDatatype","UNSIGNED_BYTE","source","arrayBufferView","flipY","sampler","NEAREST","createPickTexture","pickIds","pickId","createPickId","getFeature","push","pickColor","floatToByte","red","green","blue","alpha","batchTableByteLength","updateBatchTexture","copyFrom","update","tileset","frameState","passes","pick","postProcess","isDestroyed","destroy","length"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/BatchTexture.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\n\n/**\n * An object that manages color, show/hide and picking textures for a batch\n * table or feature table.\n *\n * @param {object} options Object with the following properties:\n * @param {number} featuresLength The number of features in the batch table or feature table\n * @param {Cesium3DTileContent|ModelFeatureTable} owner The owner of this batch texture. For 3D Tiles, this will be a {@link Cesium3DTileContent}. For glTF models, this will be a {@link ModelFeatureTable}.\n * @param {object} [statistics] The statistics object to update with information about the batch texture.\n * @param {Function} [colorChangedCallback] A callback function that is called whenever the color of a feature changes.\n *\n * @alias BatchTexture\n * @constructor\n *\n * @private\n */\nfunction BatchTexture(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.featuresLength\", options.featuresLength);\n  Check.typeOf.object(\"options.owner\", options.owner);\n  //>>includeEnd('debug');\n\n  this._id = createGuid();\n\n  const featuresLength = options.featuresLength;\n\n  // PERFORMANCE_IDEA: These parallel arrays probably generate cache misses in get/set color/show\n  // and use A LOT of memory.  How can we use less memory?\n  this._showAlphaProperties = undefined; // [Show (0 or 255), Alpha (0 to 255)] property for each feature\n  this._batchValues = undefined; // Per-feature RGBA (A is based on the color's alpha and feature's show property)\n\n  this._batchValuesDirty = false;\n  this._batchTexture = undefined;\n  this._defaultTexture = undefined;\n\n  this._pickTexture = undefined;\n  this._pickIds = [];\n\n  // Dimensions for batch and pick textures\n  let textureDimensions;\n  let textureStep;\n\n  if (featuresLength > 0) {\n    // PERFORMANCE_IDEA: this can waste memory in the last row in the uncommon case\n    // when more than one row is needed (e.g., > 16K features in one tile)\n    const width = Math.min(featuresLength, ContextLimits.maximumTextureSize);\n    const height = Math.ceil(featuresLength / ContextLimits.maximumTextureSize);\n    const stepX = 1.0 / width;\n    const centerX = stepX * 0.5;\n    const stepY = 1.0 / height;\n    const centerY = stepY * 0.5;\n\n    textureDimensions = new Cartesian2(width, height);\n    textureStep = new Cartesian4(stepX, centerX, stepY, centerY);\n  }\n\n  this._translucentFeaturesLength = 0;\n  this._featuresLength = featuresLength;\n  this._textureDimensions = textureDimensions;\n  this._textureStep = textureStep;\n  this._owner = options.owner;\n  this._statistics = options.statistics;\n  this._colorChangedCallback = options.colorChangedCallback;\n}\n\nObject.defineProperties(BatchTexture.prototype, {\n  /**\n   * Number of features that are translucent\n   *\n   * @memberof BatchTexture.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  translucentFeaturesLength: {\n    get: function () {\n      return this._translucentFeaturesLength;\n    },\n  },\n\n  /**\n   * Total size of all GPU resources used by this batch texture.\n   *\n   * @memberof BatchTexture.prototype\n   * @type {number}\n   * @readonly\n   * @private\n   */\n  byteLength: {\n    get: function () {\n      let memory = 0;\n      if (defined(this._pickTexture)) {\n        memory += this._pickTexture.sizeInBytes;\n      }\n      if (defined(this._batchTexture)) {\n        memory += this._batchTexture.sizeInBytes;\n      }\n      return memory;\n    },\n  },\n\n  /**\n   * Dimensions of the underlying batch texture.\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Cartesian2}\n   * @readonly\n   * @private\n   */\n  textureDimensions: {\n    get: function () {\n      return this._textureDimensions;\n    },\n  },\n\n  /**\n   * Size of each texture and distance from side to center of a texel in\n   * each direction. Stored as (stepX, centerX, stepY, centerY)\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Cartesian4}\n   * @readonly\n   * @private\n   */\n  textureStep: {\n    get: function () {\n      return this._textureStep;\n    },\n  },\n\n  /**\n   * The underlying texture used for styling. The texels are accessed\n   * by batch ID, and the value is the color of this feature after accounting\n   * for show/hide settings.\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  batchTexture: {\n    get: function () {\n      return this._batchTexture;\n    },\n  },\n\n  /**\n   * The default texture to use when there are no batch values\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  defaultTexture: {\n    get: function () {\n      return this._defaultTexture;\n    },\n  },\n\n  /**\n   * The underlying texture used for picking. The texels are accessed by\n   * batch ID, and the value is the pick color.\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  pickTexture: {\n    get: function () {\n      return this._pickTexture;\n    },\n  },\n});\n\nBatchTexture.DEFAULT_COLOR_VALUE = Color.WHITE;\nBatchTexture.DEFAULT_SHOW_VALUE = true;\n\nfunction getByteLength(batchTexture) {\n  const dimensions = batchTexture._textureDimensions;\n  return dimensions.x * dimensions.y * 4;\n}\n\nfunction getBatchValues(batchTexture) {\n  if (!defined(batchTexture._batchValues)) {\n    // Default batch texture to RGBA = 255: white highlight (RGB) and show/alpha = true/255 (A).\n    const byteLength = getByteLength(batchTexture);\n    const bytes = new Uint8Array(byteLength).fill(255);\n    batchTexture._batchValues = bytes;\n  }\n\n  return batchTexture._batchValues;\n}\n\nfunction getShowAlphaProperties(batchTexture) {\n  if (!defined(batchTexture._showAlphaProperties)) {\n    const byteLength = 2 * batchTexture._featuresLength;\n    const bytes = new Uint8Array(byteLength).fill(255);\n    // [Show = true, Alpha = 255]\n    batchTexture._showAlphaProperties = bytes;\n  }\n  return batchTexture._showAlphaProperties;\n}\n\nfunction checkBatchId(batchId, featuresLength) {\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(\n      `batchId is required and between zero and featuresLength - 1 (${featuresLength}` -\n        +\").\",\n    );\n  }\n}\n\n/**\n * Set whether a feature is visible.\n *\n * @param {number} batchId the ID of the feature\n * @param {boolean} show <code>true</code> if the feature should be shown, <code>false</code> otherwise\n * @private\n */\nBatchTexture.prototype.setShow = function (batchId, show) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this._featuresLength);\n  Check.typeOf.bool(\"show\", show);\n  //>>includeEnd('debug');\n\n  if (show && !defined(this._showAlphaProperties)) {\n    // Avoid allocating since the default is show = true\n    return;\n  }\n\n  const showAlphaProperties = getShowAlphaProperties(this);\n  const propertyOffset = batchId * 2;\n\n  const newShow = show ? 255 : 0;\n  if (showAlphaProperties[propertyOffset] !== newShow) {\n    showAlphaProperties[propertyOffset] = newShow;\n\n    const batchValues = getBatchValues(this);\n\n    // Compute alpha used in the shader based on show and color.alpha properties\n    const offset = batchId * 4 + 3;\n    batchValues[offset] = show ? showAlphaProperties[propertyOffset + 1] : 0;\n\n    this._batchValuesDirty = true;\n  }\n};\n\n/**\n * Set the show for all features at once.\n *\n * @param {boolean} show <code>true</code> if the feature should be shown, <code>false</code> otherwise\n * @private\n */\nBatchTexture.prototype.setAllShow = function (show) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"show\", show);\n  //>>includeEnd('debug');\n\n  const featuresLength = this._featuresLength;\n  for (let i = 0; i < featuresLength; ++i) {\n    this.setShow(i, show);\n  }\n};\n\n/**\n * Check the current show value for a feature\n *\n * @param {number} batchId the ID of the feature\n * @return {boolean} <code>true</code> if the feature is shown, or <code>false</code> otherwise\n * @private\n */\nBatchTexture.prototype.getShow = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this._featuresLength);\n  //>>includeEnd('debug');\n\n  if (!defined(this._showAlphaProperties)) {\n    // Avoid allocating since the default is show = true\n    return true;\n  }\n\n  const offset = batchId * 2;\n  return this._showAlphaProperties[offset] === 255;\n};\n\nconst scratchColorBytes = new Array(4);\n\n/**\n * Set the styling color of a feature\n *\n * @param {number} batchId the ID of the feature\n * @param {Color} color the color to assign to this feature.\n *\n * @private\n */\nBatchTexture.prototype.setColor = function (batchId, color) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this._featuresLength);\n  Check.typeOf.object(\"color\", color);\n  //>>includeEnd('debug');\n\n  if (\n    Color.equals(color, BatchTexture.DEFAULT_COLOR_VALUE) &&\n    !defined(this._batchValues)\n  ) {\n    // Avoid allocating since the default is white\n    return;\n  }\n\n  const newColor = color.toBytes(scratchColorBytes);\n  const newAlpha = newColor[3];\n\n  const batchValues = getBatchValues(this);\n  const offset = batchId * 4;\n\n  const showAlphaProperties = getShowAlphaProperties(this);\n  const propertyOffset = batchId * 2;\n\n  if (\n    batchValues[offset] !== newColor[0] ||\n    batchValues[offset + 1] !== newColor[1] ||\n    batchValues[offset + 2] !== newColor[2] ||\n    showAlphaProperties[propertyOffset + 1] !== newAlpha\n  ) {\n    batchValues[offset] = newColor[0];\n    batchValues[offset + 1] = newColor[1];\n    batchValues[offset + 2] = newColor[2];\n\n    const wasTranslucent = showAlphaProperties[propertyOffset + 1] !== 255;\n\n    // Compute alpha used in the shader based on show and color.alpha properties\n    const show = showAlphaProperties[propertyOffset] !== 0;\n    batchValues[offset + 3] = show ? newAlpha : 0;\n    showAlphaProperties[propertyOffset + 1] = newAlpha;\n\n    // Track number of translucent features so we know if this tile needs\n    // opaque commands, translucent commands, or both for rendering.\n    const isTranslucent = newAlpha !== 255;\n    if (isTranslucent && !wasTranslucent) {\n      ++this._translucentFeaturesLength;\n    } else if (!isTranslucent && wasTranslucent) {\n      --this._translucentFeaturesLength;\n    }\n\n    this._batchValuesDirty = true;\n\n    if (defined(this._colorChangedCallback)) {\n      this._colorChangedCallback(batchId, color);\n    }\n  }\n};\n\n/**\n * Set the styling color for all features at once\n *\n * @param {Color} color the color to assign to all features.\n *\n * @private\n */\nBatchTexture.prototype.setAllColor = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"color\", color);\n  //>>includeEnd('debug');\n\n  const featuresLength = this._featuresLength;\n  for (let i = 0; i < featuresLength; ++i) {\n    this.setColor(i, color);\n  }\n};\n\n/**\n * Get the current color of a feature\n *\n * @param {number} batchId The ID of the feature\n * @param {Color} result A color object where the result will be stored.\n * @return {Color} The color assigned to the selected feature\n *\n * @private\n */\nBatchTexture.prototype.getColor = function (batchId, result) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this._featuresLength);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  if (!defined(this._batchValues)) {\n    return Color.clone(BatchTexture.DEFAULT_COLOR_VALUE, result);\n  }\n\n  const batchValues = this._batchValues;\n  const offset = batchId * 4;\n\n  const showAlphaProperties = this._showAlphaProperties;\n  const propertyOffset = batchId * 2;\n\n  return Color.fromBytes(\n    batchValues[offset],\n    batchValues[offset + 1],\n    batchValues[offset + 2],\n    showAlphaProperties[propertyOffset + 1],\n    result,\n  );\n};\n\n/**\n * Get the pick color of a feature. This feature is an RGBA encoding of the\n * pick ID.\n *\n * @param {number} batchId The ID of the feature\n * @return {PickId} The picking color assigned to this feature\n *\n * @private\n */\nBatchTexture.prototype.getPickColor = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this._featuresLength);\n  //>>includeEnd('debug');\n  return this._pickIds[batchId];\n};\n\nfunction createTexture(batchTexture, context, bytes) {\n  const dimensions = batchTexture._textureDimensions;\n  return new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    source: {\n      width: dimensions.x,\n      height: dimensions.y,\n      arrayBufferView: bytes,\n    },\n    flipY: false,\n    sampler: Sampler.NEAREST,\n  });\n}\n\nfunction createPickTexture(batchTexture, context) {\n  const featuresLength = batchTexture._featuresLength;\n  if (!defined(batchTexture._pickTexture) && featuresLength > 0) {\n    const pickIds = batchTexture._pickIds;\n    const byteLength = getByteLength(batchTexture);\n    const bytes = new Uint8Array(byteLength);\n    const owner = batchTexture._owner;\n    const statistics = batchTexture._statistics;\n\n    // PERFORMANCE_IDEA: we could skip the pick texture completely by allocating\n    // a continuous range of pickIds and then converting the base pickId + batchId\n    // to RGBA in the shader.  The only consider is precision issues, which might\n    // not be an issue in WebGL 2.\n    for (let i = 0; i < featuresLength; ++i) {\n      const pickId = context.createPickId(owner.getFeature(i));\n      pickIds.push(pickId);\n\n      const pickColor = pickId.color;\n      const offset = i * 4;\n      bytes[offset] = Color.floatToByte(pickColor.red);\n      bytes[offset + 1] = Color.floatToByte(pickColor.green);\n      bytes[offset + 2] = Color.floatToByte(pickColor.blue);\n      bytes[offset + 3] = Color.floatToByte(pickColor.alpha);\n    }\n\n    batchTexture._pickTexture = createTexture(batchTexture, context, bytes);\n\n    // Make sure the tileset statistics are updated the frame when the pick\n    // texture is created.\n    if (defined(statistics)) {\n      statistics.batchTableByteLength += batchTexture._pickTexture.sizeInBytes;\n    }\n  }\n}\n\nfunction updateBatchTexture(batchTexture) {\n  const dimensions = batchTexture._textureDimensions;\n  // PERFORMANCE_IDEA: Instead of rewriting the entire texture, use fine-grained\n  // texture updates when less than, for example, 10%, of the values changed.  Or\n  // even just optimize the common case when one feature show/color changed.\n  batchTexture._batchTexture.copyFrom({\n    source: {\n      width: dimensions.x,\n      height: dimensions.y,\n      arrayBufferView: batchTexture._batchValues,\n    },\n  });\n}\n\nBatchTexture.prototype.update = function (tileset, frameState) {\n  const context = frameState.context;\n  this._defaultTexture = context.defaultTexture;\n\n  const passes = frameState.passes;\n  if (passes.pick || passes.postProcess) {\n    createPickTexture(this, context);\n  }\n\n  if (this._batchValuesDirty) {\n    this._batchValuesDirty = false;\n\n    // Create batch texture on-demand\n    if (!defined(this._batchTexture)) {\n      this._batchTexture = createTexture(this, context, this._batchValues);\n\n      // Make sure the tileset statistics are updated the frame when the\n      // batch texture is created.\n      if (defined(this._statistics)) {\n        this._statistics.batchTableByteLength += this._batchTexture.sizeInBytes;\n      }\n    }\n\n    updateBatchTexture(this); // Apply per-feature show/color updates\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see BatchTexture#destroy\n * @private\n */\nBatchTexture.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see BatchTexture#isDestroyed\n * @private\n */\nBatchTexture.prototype.destroy = function () {\n  this._batchTexture = this._batchTexture && this._batchTexture.destroy();\n  this._pickTexture = this._pickTexture && this._pickTexture.destroy();\n\n  const pickIds = this._pickIds;\n  const length = pickIds.length;\n  for (let i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n\n  return destroyObject(this);\n};\n\nexport default BatchTexture;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}