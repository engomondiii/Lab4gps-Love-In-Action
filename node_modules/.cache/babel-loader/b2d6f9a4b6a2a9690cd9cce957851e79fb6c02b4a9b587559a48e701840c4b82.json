{"ast":null,"code":"import earcut from \"earcut\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WindingOrder from \"./WindingOrder.js\";\nconst scaleToGeodeticHeightN = new Cartesian3();\nconst scaleToGeodeticHeightP = new Cartesian3();\n\n/**\n * @private\n */\nconst PolygonPipeline = {};\n\n/**\n * @exception {DeveloperError} At least three positions are required.\n */\nPolygonPipeline.computeArea2D = function (positions) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  Check.typeOf.number.greaterThanOrEquals(\"positions.length\", positions.length, 3);\n  //>>includeEnd('debug');\n\n  const length = positions.length;\n  let area = 0.0;\n  for (let i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n    const v0 = positions[i0];\n    const v1 = positions[i1];\n    area += v0.x * v1.y - v1.x * v0.y;\n  }\n  return area * 0.5;\n};\n\n/**\n * @returns {WindingOrder} The winding order.\n *\n * @exception {DeveloperError} At least three positions are required.\n */\nPolygonPipeline.computeWindingOrder2D = function (positions) {\n  const area = PolygonPipeline.computeArea2D(positions);\n  return area > 0.0 ? WindingOrder.COUNTER_CLOCKWISE : WindingOrder.CLOCKWISE;\n};\n\n/**\n * Triangulate a polygon.\n *\n * @param {Cartesian2[]} positions Cartesian2 array containing the vertices of the polygon\n * @param {number[]} [holes] An array of the staring indices of the holes.\n * @returns {number[]} Index array representing triangles that fill the polygon\n */\nPolygonPipeline.triangulate = function (positions, holes) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  const flattenedPositions = Cartesian2.packArray(positions);\n  return earcut(flattenedPositions, holes, 2);\n};\nconst subdivisionV0Scratch = new Cartesian3();\nconst subdivisionV1Scratch = new Cartesian3();\nconst subdivisionV2Scratch = new Cartesian3();\nconst subdivisionS0Scratch = new Cartesian3();\nconst subdivisionS1Scratch = new Cartesian3();\nconst subdivisionS2Scratch = new Cartesian3();\nconst subdivisionMidScratch = new Cartesian3();\nconst subdivisionT0Scratch = new Cartesian2();\nconst subdivisionT1Scratch = new Cartesian2();\nconst subdivisionT2Scratch = new Cartesian2();\nconst subdivisionTexcoordMidScratch = new Cartesian2();\n\n/**\n * Subdivides positions and raises points to the surface of the ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid the polygon in on.\n * @param {Cartesian3[]} positions An array of {@link Cartesian3} positions of the polygon.\n * @param {number[]} indices An array of indices that determines the triangles in the polygon.\n * @param {Cartesian2[]} texcoords An optional array of {@link Cartesian2} texture coordinates of the polygon.\n * @param {number} [granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n *\n * @exception {DeveloperError} At least three indices are required.\n * @exception {DeveloperError} The number of indices must be divisable by three.\n * @exception {DeveloperError} Granularity must be greater than zero.\n */\nPolygonPipeline.computeSubdivision = function (ellipsoid, positions, indices, texcoords, granularity) {\n  granularity = defaultValue(granularity, CesiumMath.RADIANS_PER_DEGREE);\n  const hasTexcoords = defined(texcoords);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.defined(\"positions\", positions);\n  Check.defined(\"indices\", indices);\n  Check.typeOf.number.greaterThanOrEquals(\"indices.length\", indices.length, 3);\n  Check.typeOf.number.equals(\"indices.length % 3\", \"0\", indices.length % 3, 0);\n  Check.typeOf.number.greaterThan(\"granularity\", granularity, 0.0);\n  //>>includeEnd('debug');\n\n  // triangles that need (or might need) to be subdivided.\n  const triangles = indices.slice(0);\n\n  // New positions due to edge splits are appended to the positions list.\n  let i;\n  const length = positions.length;\n  const subdividedPositions = new Array(length * 3);\n  const subdividedTexcoords = new Array(length * 2);\n  let q = 0;\n  let p = 0;\n  for (i = 0; i < length; i++) {\n    const item = positions[i];\n    subdividedPositions[q++] = item.x;\n    subdividedPositions[q++] = item.y;\n    subdividedPositions[q++] = item.z;\n    if (hasTexcoords) {\n      const texcoordItem = texcoords[i];\n      subdividedTexcoords[p++] = texcoordItem.x;\n      subdividedTexcoords[p++] = texcoordItem.y;\n    }\n  }\n  const subdividedIndices = [];\n\n  // Used to make sure shared edges are not split more than once.\n  const edges = {};\n  const radius = ellipsoid.maximumRadius;\n  const minDistance = CesiumMath.chordLength(granularity, radius);\n  const minDistanceSqrd = minDistance * minDistance;\n  while (triangles.length > 0) {\n    const i2 = triangles.pop();\n    const i1 = triangles.pop();\n    const i0 = triangles.pop();\n    const v0 = Cartesian3.fromArray(subdividedPositions, i0 * 3, subdivisionV0Scratch);\n    const v1 = Cartesian3.fromArray(subdividedPositions, i1 * 3, subdivisionV1Scratch);\n    const v2 = Cartesian3.fromArray(subdividedPositions, i2 * 3, subdivisionV2Scratch);\n    let t0, t1, t2;\n    if (hasTexcoords) {\n      t0 = Cartesian2.fromArray(subdividedTexcoords, i0 * 2, subdivisionT0Scratch);\n      t1 = Cartesian2.fromArray(subdividedTexcoords, i1 * 2, subdivisionT1Scratch);\n      t2 = Cartesian2.fromArray(subdividedTexcoords, i2 * 2, subdivisionT2Scratch);\n    }\n    const s0 = Cartesian3.multiplyByScalar(Cartesian3.normalize(v0, subdivisionS0Scratch), radius, subdivisionS0Scratch);\n    const s1 = Cartesian3.multiplyByScalar(Cartesian3.normalize(v1, subdivisionS1Scratch), radius, subdivisionS1Scratch);\n    const s2 = Cartesian3.multiplyByScalar(Cartesian3.normalize(v2, subdivisionS2Scratch), radius, subdivisionS2Scratch);\n    const g0 = Cartesian3.magnitudeSquared(Cartesian3.subtract(s0, s1, subdivisionMidScratch));\n    const g1 = Cartesian3.magnitudeSquared(Cartesian3.subtract(s1, s2, subdivisionMidScratch));\n    const g2 = Cartesian3.magnitudeSquared(Cartesian3.subtract(s2, s0, subdivisionMidScratch));\n    const max = Math.max(g0, g1, g2);\n    let edge;\n    let mid;\n    let midTexcoord;\n\n    // if the max length squared of a triangle edge is greater than the chord length of squared\n    // of the granularity, subdivide the triangle\n    if (max > minDistanceSqrd) {\n      if (g0 === max) {\n        edge = `${Math.min(i0, i1)} ${Math.max(i0, i1)}`;\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = Cartesian3.add(v0, v1, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t0, t1, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n        triangles.push(i0, i, i2);\n        triangles.push(i, i1, i2);\n      } else if (g1 === max) {\n        edge = `${Math.min(i1, i2)} ${Math.max(i1, i2)}`;\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = Cartesian3.add(v1, v2, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t1, t2, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n        triangles.push(i1, i, i0);\n        triangles.push(i, i2, i0);\n      } else if (g2 === max) {\n        edge = `${Math.min(i2, i0)} ${Math.max(i2, i0)}`;\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = Cartesian3.add(v2, v0, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t2, t0, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n        triangles.push(i2, i, i1);\n        triangles.push(i, i0, i1);\n      }\n    } else {\n      subdividedIndices.push(i0);\n      subdividedIndices.push(i1);\n      subdividedIndices.push(i2);\n    }\n  }\n  const geometryOptions = {\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: subdividedPositions\n      })\n    },\n    indices: subdividedIndices,\n    primitiveType: PrimitiveType.TRIANGLES\n  };\n  if (hasTexcoords) {\n    geometryOptions.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: subdividedTexcoords\n    });\n  }\n  return new Geometry(geometryOptions);\n};\nconst subdivisionC0Scratch = new Cartographic();\nconst subdivisionC1Scratch = new Cartographic();\nconst subdivisionC2Scratch = new Cartographic();\nconst subdivisionCartographicScratch = new Cartographic();\n\n/**\n * Subdivides positions on rhumb lines and raises points to the surface of the ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid the polygon in on.\n * @param {Cartesian3[]} positions An array of {@link Cartesian3} positions of the polygon.\n * @param {number[]} indices An array of indices that determines the triangles in the polygon.\n * @param {Cartesian2[]} texcoords An optional array of {@link Cartesian2} texture coordinates of the polygon.\n * @param {number} [granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n *\n * @exception {DeveloperError} At least three indices are required.\n * @exception {DeveloperError} The number of indices must be divisable by three.\n * @exception {DeveloperError} Granularity must be greater than zero.\n */\nPolygonPipeline.computeRhumbLineSubdivision = function (ellipsoid, positions, indices, texcoords, granularity) {\n  granularity = defaultValue(granularity, CesiumMath.RADIANS_PER_DEGREE);\n  const hasTexcoords = defined(texcoords);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.defined(\"positions\", positions);\n  Check.defined(\"indices\", indices);\n  Check.typeOf.number.greaterThanOrEquals(\"indices.length\", indices.length, 3);\n  Check.typeOf.number.equals(\"indices.length % 3\", \"0\", indices.length % 3, 0);\n  Check.typeOf.number.greaterThan(\"granularity\", granularity, 0.0);\n  //>>includeEnd('debug');\n\n  // triangles that need (or might need) to be subdivided.\n  const triangles = indices.slice(0);\n\n  // New positions due to edge splits are appended to the positions list.\n  let i;\n  const length = positions.length;\n  const subdividedPositions = new Array(length * 3);\n  const subdividedTexcoords = new Array(length * 2);\n  let q = 0;\n  let p = 0;\n  for (i = 0; i < length; i++) {\n    const item = positions[i];\n    subdividedPositions[q++] = item.x;\n    subdividedPositions[q++] = item.y;\n    subdividedPositions[q++] = item.z;\n    if (hasTexcoords) {\n      const texcoordItem = texcoords[i];\n      subdividedTexcoords[p++] = texcoordItem.x;\n      subdividedTexcoords[p++] = texcoordItem.y;\n    }\n  }\n  const subdividedIndices = [];\n\n  // Used to make sure shared edges are not split more than once.\n  const edges = {};\n  const radius = ellipsoid.maximumRadius;\n  const minDistance = CesiumMath.chordLength(granularity, radius);\n  const rhumb0 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  const rhumb1 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  const rhumb2 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  while (triangles.length > 0) {\n    const i2 = triangles.pop();\n    const i1 = triangles.pop();\n    const i0 = triangles.pop();\n    const v0 = Cartesian3.fromArray(subdividedPositions, i0 * 3, subdivisionV0Scratch);\n    const v1 = Cartesian3.fromArray(subdividedPositions, i1 * 3, subdivisionV1Scratch);\n    const v2 = Cartesian3.fromArray(subdividedPositions, i2 * 3, subdivisionV2Scratch);\n    let t0, t1, t2;\n    if (hasTexcoords) {\n      t0 = Cartesian2.fromArray(subdividedTexcoords, i0 * 2, subdivisionT0Scratch);\n      t1 = Cartesian2.fromArray(subdividedTexcoords, i1 * 2, subdivisionT1Scratch);\n      t2 = Cartesian2.fromArray(subdividedTexcoords, i2 * 2, subdivisionT2Scratch);\n    }\n    const c0 = ellipsoid.cartesianToCartographic(v0, subdivisionC0Scratch);\n    const c1 = ellipsoid.cartesianToCartographic(v1, subdivisionC1Scratch);\n    const c2 = ellipsoid.cartesianToCartographic(v2, subdivisionC2Scratch);\n    rhumb0.setEndPoints(c0, c1);\n    const g0 = rhumb0.surfaceDistance;\n    rhumb1.setEndPoints(c1, c2);\n    const g1 = rhumb1.surfaceDistance;\n    rhumb2.setEndPoints(c2, c0);\n    const g2 = rhumb2.surfaceDistance;\n    const max = Math.max(g0, g1, g2);\n    let edge;\n    let mid;\n    let midHeight;\n    let midCartesian3;\n    let midTexcoord;\n\n    // if the max length squared of a triangle edge is greater than granularity, subdivide the triangle\n    if (max > minDistance) {\n      if (g0 === max) {\n        edge = `${Math.min(i0, i1)} ${Math.max(i0, i1)}`;\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = rhumb0.interpolateUsingFraction(0.5, subdivisionCartographicScratch);\n          midHeight = (c0.height + c1.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(mid.longitude, mid.latitude, midHeight, ellipsoid, subdivisionMidScratch);\n          subdividedPositions.push(midCartesian3.x, midCartesian3.y, midCartesian3.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t0, t1, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n        triangles.push(i0, i, i2);\n        triangles.push(i, i1, i2);\n      } else if (g1 === max) {\n        edge = `${Math.min(i1, i2)} ${Math.max(i1, i2)}`;\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = rhumb1.interpolateUsingFraction(0.5, subdivisionCartographicScratch);\n          midHeight = (c1.height + c2.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(mid.longitude, mid.latitude, midHeight, ellipsoid, subdivisionMidScratch);\n          subdividedPositions.push(midCartesian3.x, midCartesian3.y, midCartesian3.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t1, t2, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n        triangles.push(i1, i, i0);\n        triangles.push(i, i2, i0);\n      } else if (g2 === max) {\n        edge = `${Math.min(i2, i0)} ${Math.max(i2, i0)}`;\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = rhumb2.interpolateUsingFraction(0.5, subdivisionCartographicScratch);\n          midHeight = (c2.height + c0.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(mid.longitude, mid.latitude, midHeight, ellipsoid, subdivisionMidScratch);\n          subdividedPositions.push(midCartesian3.x, midCartesian3.y, midCartesian3.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t2, t0, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n        triangles.push(i2, i, i1);\n        triangles.push(i, i0, i1);\n      }\n    } else {\n      subdividedIndices.push(i0);\n      subdividedIndices.push(i1);\n      subdividedIndices.push(i2);\n    }\n  }\n  const geometryOptions = {\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: subdividedPositions\n      })\n    },\n    indices: subdividedIndices,\n    primitiveType: PrimitiveType.TRIANGLES\n  };\n  if (hasTexcoords) {\n    geometryOptions.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: subdividedTexcoords\n    });\n  }\n  return new Geometry(geometryOptions);\n};\n\n/**\n * Scales each position of a geometry's position attribute to a height, in place.\n *\n * @param {number[]} positions The array of numbers representing the positions to be scaled\n * @param {number} [height=0.0] The desired height to add to the positions\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the positions lie.\n * @param {boolean} [scaleToSurface=true] <code>true</code> if the positions need to be scaled to the surface before the height is added.\n * @returns {number[]} The input array of positions, scaled to height\n */\nPolygonPipeline.scaleToGeodeticHeight = function (positions, height, ellipsoid, scaleToSurface) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n  let n = scaleToGeodeticHeightN;\n  let p = scaleToGeodeticHeightP;\n  height = defaultValue(height, 0.0);\n  scaleToSurface = defaultValue(scaleToSurface, true);\n  if (defined(positions)) {\n    const length = positions.length;\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.fromArray(positions, i, p);\n      if (scaleToSurface) {\n        p = ellipsoid.scaleToGeodeticSurface(p, p);\n      }\n      if (height !== 0) {\n        n = ellipsoid.geodeticSurfaceNormal(p, n);\n        Cartesian3.multiplyByScalar(n, height, n);\n        Cartesian3.add(p, n, p);\n      }\n      positions[i] = p.x;\n      positions[i + 1] = p.y;\n      positions[i + 2] = p.z;\n    }\n  }\n  return positions;\n};\nexport default PolygonPipeline;","map":{"version":3,"names":["earcut","Cartesian2","Cartesian3","Cartographic","Check","ComponentDatatype","defaultValue","defined","Ellipsoid","EllipsoidRhumbLine","Geometry","GeometryAttribute","CesiumMath","PrimitiveType","WindingOrder","scaleToGeodeticHeightN","scaleToGeodeticHeightP","PolygonPipeline","computeArea2D","positions","typeOf","number","greaterThanOrEquals","length","area","i0","i1","v0","v1","x","y","computeWindingOrder2D","COUNTER_CLOCKWISE","CLOCKWISE","triangulate","holes","flattenedPositions","packArray","subdivisionV0Scratch","subdivisionV1Scratch","subdivisionV2Scratch","subdivisionS0Scratch","subdivisionS1Scratch","subdivisionS2Scratch","subdivisionMidScratch","subdivisionT0Scratch","subdivisionT1Scratch","subdivisionT2Scratch","subdivisionTexcoordMidScratch","computeSubdivision","ellipsoid","indices","texcoords","granularity","RADIANS_PER_DEGREE","hasTexcoords","object","equals","greaterThan","triangles","slice","i","subdividedPositions","Array","subdividedTexcoords","q","p","item","z","texcoordItem","subdividedIndices","edges","radius","maximumRadius","minDistance","chordLength","minDistanceSqrd","i2","pop","fromArray","v2","t0","t1","t2","s0","multiplyByScalar","normalize","s1","s2","g0","magnitudeSquared","subtract","g1","g2","max","Math","edge","mid","midTexcoord","min","add","push","geometryOptions","attributes","position","componentDatatype","DOUBLE","componentsPerAttribute","values","primitiveType","TRIANGLES","st","FLOAT","subdivisionC0Scratch","subdivisionC1Scratch","subdivisionC2Scratch","subdivisionCartographicScratch","computeRhumbLineSubdivision","rhumb0","undefined","rhumb1","rhumb2","c0","cartesianToCartographic","c1","c2","setEndPoints","surfaceDistance","midHeight","midCartesian3","interpolateUsingFraction","height","fromRadians","longitude","latitude","scaleToGeodeticHeight","scaleToSurface","default","n","scaleToGeodeticSurface","geodeticSurfaceNormal"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/PolygonPipeline.js"],"sourcesContent":["import earcut from \"earcut\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\nconst scaleToGeodeticHeightN = new Cartesian3();\nconst scaleToGeodeticHeightP = new Cartesian3();\n\n/**\n * @private\n */\nconst PolygonPipeline = {};\n\n/**\n * @exception {DeveloperError} At least three positions are required.\n */\nPolygonPipeline.computeArea2D = function (positions) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"positions.length\",\n    positions.length,\n    3,\n  );\n  //>>includeEnd('debug');\n\n  const length = positions.length;\n  let area = 0.0;\n\n  for (let i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n    const v0 = positions[i0];\n    const v1 = positions[i1];\n\n    area += v0.x * v1.y - v1.x * v0.y;\n  }\n\n  return area * 0.5;\n};\n\n/**\n * @returns {WindingOrder} The winding order.\n *\n * @exception {DeveloperError} At least three positions are required.\n */\nPolygonPipeline.computeWindingOrder2D = function (positions) {\n  const area = PolygonPipeline.computeArea2D(positions);\n  return area > 0.0 ? WindingOrder.COUNTER_CLOCKWISE : WindingOrder.CLOCKWISE;\n};\n\n/**\n * Triangulate a polygon.\n *\n * @param {Cartesian2[]} positions Cartesian2 array containing the vertices of the polygon\n * @param {number[]} [holes] An array of the staring indices of the holes.\n * @returns {number[]} Index array representing triangles that fill the polygon\n */\nPolygonPipeline.triangulate = function (positions, holes) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  const flattenedPositions = Cartesian2.packArray(positions);\n  return earcut(flattenedPositions, holes, 2);\n};\n\nconst subdivisionV0Scratch = new Cartesian3();\nconst subdivisionV1Scratch = new Cartesian3();\nconst subdivisionV2Scratch = new Cartesian3();\nconst subdivisionS0Scratch = new Cartesian3();\nconst subdivisionS1Scratch = new Cartesian3();\nconst subdivisionS2Scratch = new Cartesian3();\nconst subdivisionMidScratch = new Cartesian3();\nconst subdivisionT0Scratch = new Cartesian2();\nconst subdivisionT1Scratch = new Cartesian2();\nconst subdivisionT2Scratch = new Cartesian2();\nconst subdivisionTexcoordMidScratch = new Cartesian2();\n\n/**\n * Subdivides positions and raises points to the surface of the ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid the polygon in on.\n * @param {Cartesian3[]} positions An array of {@link Cartesian3} positions of the polygon.\n * @param {number[]} indices An array of indices that determines the triangles in the polygon.\n * @param {Cartesian2[]} texcoords An optional array of {@link Cartesian2} texture coordinates of the polygon.\n * @param {number} [granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n *\n * @exception {DeveloperError} At least three indices are required.\n * @exception {DeveloperError} The number of indices must be divisable by three.\n * @exception {DeveloperError} Granularity must be greater than zero.\n */\nPolygonPipeline.computeSubdivision = function (\n  ellipsoid,\n  positions,\n  indices,\n  texcoords,\n  granularity,\n) {\n  granularity = defaultValue(granularity, CesiumMath.RADIANS_PER_DEGREE);\n\n  const hasTexcoords = defined(texcoords);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.defined(\"positions\", positions);\n  Check.defined(\"indices\", indices);\n  Check.typeOf.number.greaterThanOrEquals(\"indices.length\", indices.length, 3);\n  Check.typeOf.number.equals(\"indices.length % 3\", \"0\", indices.length % 3, 0);\n  Check.typeOf.number.greaterThan(\"granularity\", granularity, 0.0);\n  //>>includeEnd('debug');\n\n  // triangles that need (or might need) to be subdivided.\n  const triangles = indices.slice(0);\n\n  // New positions due to edge splits are appended to the positions list.\n  let i;\n  const length = positions.length;\n  const subdividedPositions = new Array(length * 3);\n  const subdividedTexcoords = new Array(length * 2);\n  let q = 0;\n  let p = 0;\n  for (i = 0; i < length; i++) {\n    const item = positions[i];\n    subdividedPositions[q++] = item.x;\n    subdividedPositions[q++] = item.y;\n    subdividedPositions[q++] = item.z;\n\n    if (hasTexcoords) {\n      const texcoordItem = texcoords[i];\n      subdividedTexcoords[p++] = texcoordItem.x;\n      subdividedTexcoords[p++] = texcoordItem.y;\n    }\n  }\n\n  const subdividedIndices = [];\n\n  // Used to make sure shared edges are not split more than once.\n  const edges = {};\n\n  const radius = ellipsoid.maximumRadius;\n  const minDistance = CesiumMath.chordLength(granularity, radius);\n  const minDistanceSqrd = minDistance * minDistance;\n\n  while (triangles.length > 0) {\n    const i2 = triangles.pop();\n    const i1 = triangles.pop();\n    const i0 = triangles.pop();\n\n    const v0 = Cartesian3.fromArray(\n      subdividedPositions,\n      i0 * 3,\n      subdivisionV0Scratch,\n    );\n    const v1 = Cartesian3.fromArray(\n      subdividedPositions,\n      i1 * 3,\n      subdivisionV1Scratch,\n    );\n    const v2 = Cartesian3.fromArray(\n      subdividedPositions,\n      i2 * 3,\n      subdivisionV2Scratch,\n    );\n\n    let t0, t1, t2;\n    if (hasTexcoords) {\n      t0 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i0 * 2,\n        subdivisionT0Scratch,\n      );\n      t1 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i1 * 2,\n        subdivisionT1Scratch,\n      );\n      t2 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i2 * 2,\n        subdivisionT2Scratch,\n      );\n    }\n\n    const s0 = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(v0, subdivisionS0Scratch),\n      radius,\n      subdivisionS0Scratch,\n    );\n    const s1 = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(v1, subdivisionS1Scratch),\n      radius,\n      subdivisionS1Scratch,\n    );\n    const s2 = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(v2, subdivisionS2Scratch),\n      radius,\n      subdivisionS2Scratch,\n    );\n\n    const g0 = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(s0, s1, subdivisionMidScratch),\n    );\n    const g1 = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(s1, s2, subdivisionMidScratch),\n    );\n    const g2 = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(s2, s0, subdivisionMidScratch),\n    );\n\n    const max = Math.max(g0, g1, g2);\n    let edge;\n    let mid;\n    let midTexcoord;\n\n    // if the max length squared of a triangle edge is greater than the chord length of squared\n    // of the granularity, subdivide the triangle\n    if (max > minDistanceSqrd) {\n      if (g0 === max) {\n        edge = `${Math.min(i0, i1)} ${Math.max(i0, i1)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = Cartesian3.add(v0, v1, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t0, t1, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i0, i, i2);\n        triangles.push(i, i1, i2);\n      } else if (g1 === max) {\n        edge = `${Math.min(i1, i2)} ${Math.max(i1, i2)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = Cartesian3.add(v1, v2, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t1, t2, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i1, i, i0);\n        triangles.push(i, i2, i0);\n      } else if (g2 === max) {\n        edge = `${Math.min(i2, i0)} ${Math.max(i2, i0)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = Cartesian3.add(v2, v0, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t2, t0, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i2, i, i1);\n        triangles.push(i, i0, i1);\n      }\n    } else {\n      subdividedIndices.push(i0);\n      subdividedIndices.push(i1);\n      subdividedIndices.push(i2);\n    }\n  }\n\n  const geometryOptions = {\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: subdividedPositions,\n      }),\n    },\n    indices: subdividedIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  };\n\n  if (hasTexcoords) {\n    geometryOptions.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: subdividedTexcoords,\n    });\n  }\n\n  return new Geometry(geometryOptions);\n};\n\nconst subdivisionC0Scratch = new Cartographic();\nconst subdivisionC1Scratch = new Cartographic();\nconst subdivisionC2Scratch = new Cartographic();\nconst subdivisionCartographicScratch = new Cartographic();\n\n/**\n * Subdivides positions on rhumb lines and raises points to the surface of the ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid the polygon in on.\n * @param {Cartesian3[]} positions An array of {@link Cartesian3} positions of the polygon.\n * @param {number[]} indices An array of indices that determines the triangles in the polygon.\n * @param {Cartesian2[]} texcoords An optional array of {@link Cartesian2} texture coordinates of the polygon.\n * @param {number} [granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n *\n * @exception {DeveloperError} At least three indices are required.\n * @exception {DeveloperError} The number of indices must be divisable by three.\n * @exception {DeveloperError} Granularity must be greater than zero.\n */\nPolygonPipeline.computeRhumbLineSubdivision = function (\n  ellipsoid,\n  positions,\n  indices,\n  texcoords,\n  granularity,\n) {\n  granularity = defaultValue(granularity, CesiumMath.RADIANS_PER_DEGREE);\n\n  const hasTexcoords = defined(texcoords);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.defined(\"positions\", positions);\n  Check.defined(\"indices\", indices);\n  Check.typeOf.number.greaterThanOrEquals(\"indices.length\", indices.length, 3);\n  Check.typeOf.number.equals(\"indices.length % 3\", \"0\", indices.length % 3, 0);\n  Check.typeOf.number.greaterThan(\"granularity\", granularity, 0.0);\n  //>>includeEnd('debug');\n\n  // triangles that need (or might need) to be subdivided.\n  const triangles = indices.slice(0);\n\n  // New positions due to edge splits are appended to the positions list.\n  let i;\n  const length = positions.length;\n  const subdividedPositions = new Array(length * 3);\n  const subdividedTexcoords = new Array(length * 2);\n  let q = 0;\n  let p = 0;\n  for (i = 0; i < length; i++) {\n    const item = positions[i];\n    subdividedPositions[q++] = item.x;\n    subdividedPositions[q++] = item.y;\n    subdividedPositions[q++] = item.z;\n\n    if (hasTexcoords) {\n      const texcoordItem = texcoords[i];\n      subdividedTexcoords[p++] = texcoordItem.x;\n      subdividedTexcoords[p++] = texcoordItem.y;\n    }\n  }\n\n  const subdividedIndices = [];\n\n  // Used to make sure shared edges are not split more than once.\n  const edges = {};\n\n  const radius = ellipsoid.maximumRadius;\n  const minDistance = CesiumMath.chordLength(granularity, radius);\n\n  const rhumb0 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  const rhumb1 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  const rhumb2 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n\n  while (triangles.length > 0) {\n    const i2 = triangles.pop();\n    const i1 = triangles.pop();\n    const i0 = triangles.pop();\n\n    const v0 = Cartesian3.fromArray(\n      subdividedPositions,\n      i0 * 3,\n      subdivisionV0Scratch,\n    );\n    const v1 = Cartesian3.fromArray(\n      subdividedPositions,\n      i1 * 3,\n      subdivisionV1Scratch,\n    );\n    const v2 = Cartesian3.fromArray(\n      subdividedPositions,\n      i2 * 3,\n      subdivisionV2Scratch,\n    );\n\n    let t0, t1, t2;\n    if (hasTexcoords) {\n      t0 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i0 * 2,\n        subdivisionT0Scratch,\n      );\n      t1 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i1 * 2,\n        subdivisionT1Scratch,\n      );\n      t2 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i2 * 2,\n        subdivisionT2Scratch,\n      );\n    }\n\n    const c0 = ellipsoid.cartesianToCartographic(v0, subdivisionC0Scratch);\n    const c1 = ellipsoid.cartesianToCartographic(v1, subdivisionC1Scratch);\n    const c2 = ellipsoid.cartesianToCartographic(v2, subdivisionC2Scratch);\n\n    rhumb0.setEndPoints(c0, c1);\n    const g0 = rhumb0.surfaceDistance;\n    rhumb1.setEndPoints(c1, c2);\n    const g1 = rhumb1.surfaceDistance;\n    rhumb2.setEndPoints(c2, c0);\n    const g2 = rhumb2.surfaceDistance;\n\n    const max = Math.max(g0, g1, g2);\n    let edge;\n    let mid;\n    let midHeight;\n    let midCartesian3;\n    let midTexcoord;\n\n    // if the max length squared of a triangle edge is greater than granularity, subdivide the triangle\n    if (max > minDistance) {\n      if (g0 === max) {\n        edge = `${Math.min(i0, i1)} ${Math.max(i0, i1)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = rhumb0.interpolateUsingFraction(\n            0.5,\n            subdivisionCartographicScratch,\n          );\n          midHeight = (c0.height + c1.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(\n            mid.longitude,\n            mid.latitude,\n            midHeight,\n            ellipsoid,\n            subdivisionMidScratch,\n          );\n          subdividedPositions.push(\n            midCartesian3.x,\n            midCartesian3.y,\n            midCartesian3.z,\n          );\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t0, t1, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i0, i, i2);\n        triangles.push(i, i1, i2);\n      } else if (g1 === max) {\n        edge = `${Math.min(i1, i2)} ${Math.max(i1, i2)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = rhumb1.interpolateUsingFraction(\n            0.5,\n            subdivisionCartographicScratch,\n          );\n          midHeight = (c1.height + c2.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(\n            mid.longitude,\n            mid.latitude,\n            midHeight,\n            ellipsoid,\n            subdivisionMidScratch,\n          );\n          subdividedPositions.push(\n            midCartesian3.x,\n            midCartesian3.y,\n            midCartesian3.z,\n          );\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t1, t2, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i1, i, i0);\n        triangles.push(i, i2, i0);\n      } else if (g2 === max) {\n        edge = `${Math.min(i2, i0)} ${Math.max(i2, i0)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = rhumb2.interpolateUsingFraction(\n            0.5,\n            subdivisionCartographicScratch,\n          );\n          midHeight = (c2.height + c0.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(\n            mid.longitude,\n            mid.latitude,\n            midHeight,\n            ellipsoid,\n            subdivisionMidScratch,\n          );\n          subdividedPositions.push(\n            midCartesian3.x,\n            midCartesian3.y,\n            midCartesian3.z,\n          );\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t2, t0, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i2, i, i1);\n        triangles.push(i, i0, i1);\n      }\n    } else {\n      subdividedIndices.push(i0);\n      subdividedIndices.push(i1);\n      subdividedIndices.push(i2);\n    }\n  }\n\n  const geometryOptions = {\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: subdividedPositions,\n      }),\n    },\n    indices: subdividedIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  };\n\n  if (hasTexcoords) {\n    geometryOptions.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: subdividedTexcoords,\n    });\n  }\n\n  return new Geometry(geometryOptions);\n};\n\n/**\n * Scales each position of a geometry's position attribute to a height, in place.\n *\n * @param {number[]} positions The array of numbers representing the positions to be scaled\n * @param {number} [height=0.0] The desired height to add to the positions\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.default] The ellipsoid on which the positions lie.\n * @param {boolean} [scaleToSurface=true] <code>true</code> if the positions need to be scaled to the surface before the height is added.\n * @returns {number[]} The input array of positions, scaled to height\n */\nPolygonPipeline.scaleToGeodeticHeight = function (\n  positions,\n  height,\n  ellipsoid,\n  scaleToSurface,\n) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.default);\n\n  let n = scaleToGeodeticHeightN;\n  let p = scaleToGeodeticHeightP;\n\n  height = defaultValue(height, 0.0);\n  scaleToSurface = defaultValue(scaleToSurface, true);\n\n  if (defined(positions)) {\n    const length = positions.length;\n\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.fromArray(positions, i, p);\n\n      if (scaleToSurface) {\n        p = ellipsoid.scaleToGeodeticSurface(p, p);\n      }\n\n      if (height !== 0) {\n        n = ellipsoid.geodeticSurfaceNormal(p, n);\n\n        Cartesian3.multiplyByScalar(n, height, n);\n        Cartesian3.add(p, n, p);\n      }\n\n      positions[i] = p.x;\n      positions[i + 1] = p.y;\n      positions[i + 2] = p.z;\n    }\n  }\n\n  return positions;\n};\nexport default PolygonPipeline;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}