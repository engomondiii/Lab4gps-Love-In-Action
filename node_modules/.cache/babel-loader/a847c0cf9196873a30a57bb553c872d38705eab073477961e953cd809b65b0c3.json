{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 3x3 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix3\n * @constructor\n * @implements {ArrayLike<number>}\n *\n * @param {number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {number} [column2Row0=0.0] The value for column 2, row 0.\n * @param {number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {number} [column1Row1=0.0] The value for column 1, row 1.\n * @param {number} [column2Row1=0.0] The value for column 2, row 1.\n * @param {number} [column0Row2=0.0] The value for column 0, row 2.\n * @param {number} [column1Row2=0.0] The value for column 1, row 2.\n * @param {number} [column2Row2=0.0] The value for column 2, row 2.\n *\n * @see Matrix3.fromArray\n * @see Matrix3.fromColumnMajorArray\n * @see Matrix3.fromRowMajorArray\n * @see Matrix3.fromQuaternion\n * @see Matrix3.fromHeadingPitchRoll\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.fromCrossProduct\n * @see Matrix3.fromRotationX\n * @see Matrix3.fromRotationY\n * @see Matrix3.fromRotationZ\n * @see Matrix2\n * @see Matrix4\n */\nfunction Matrix3(column0Row0, column1Row0, column2Row0, column0Row1, column1Row1, column2Row1, column0Row2, column1Row2, column2Row2) {\n  this[0] = defaultValue(column0Row0, 0.0);\n  this[1] = defaultValue(column0Row1, 0.0);\n  this[2] = defaultValue(column0Row2, 0.0);\n  this[3] = defaultValue(column1Row0, 0.0);\n  this[4] = defaultValue(column1Row1, 0.0);\n  this[5] = defaultValue(column1Row2, 0.0);\n  this[6] = defaultValue(column2Row0, 0.0);\n  this[7] = defaultValue(column2Row1, 0.0);\n  this[8] = defaultValue(column2Row2, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nMatrix3.packedLength = 9;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix3} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nMatrix3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n  array[startingIndex++] = value[4];\n  array[startingIndex++] = value[5];\n  array[startingIndex++] = value[6];\n  array[startingIndex++] = value[7];\n  array[startingIndex++] = value[8];\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix3} [result] The object into which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n */\nMatrix3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  result[4] = array[startingIndex++];\n  result[5] = array[startingIndex++];\n  result[6] = array[startingIndex++];\n  result[7] = array[startingIndex++];\n  result[8] = array[startingIndex++];\n  return result;\n};\n\n/**\n * Flattens an array of Matrix3s into an array of components. The components\n * are stored in column-major order.\n *\n * @param {Matrix3[]} array The array of matrices to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 9 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 9) elements.\n * @returns {number[]} The packed array.\n */\nMatrix3.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 9;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\"If result is a typed array, it must have exactly array.length * 9 elements\");\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n  for (let i = 0; i < length; ++i) {\n    Matrix3.pack(array[i], result, i * 9);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of column-major matrix components into an array of Matrix3s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Matrix3[]} [result] The array onto which to store the result.\n * @returns {Matrix3[]} The unpacked array.\n */\nMatrix3.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 9);\n  if (array.length % 9 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 9.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 9);\n  } else {\n    result.length = length / 9;\n  }\n  for (let i = 0; i < length; i += 9) {\n    const index = i / 9;\n    result[index] = Matrix3.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Duplicates a Matrix3 instance.\n *\n * @param {Matrix3} matrix The matrix to duplicate.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix3.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Matrix3(matrix[0], matrix[3], matrix[6], matrix[1], matrix[4], matrix[7], matrix[2], matrix[5], matrix[8]);\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  return result;\n};\n\n/**\n * Creates a Matrix3 from 9 consecutive elements in an array.\n *\n * @function\n * @param {number[]} array The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Create the Matrix3:\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n *\n * const v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * const m = Cesium.Matrix3.fromArray(v);\n *\n * // Create same Matrix3 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * const m2 = Cesium.Matrix3.fromArray(v2, 2);\n */\nMatrix3.fromArray = Matrix3.unpack;\n\n/**\n * Creates a Matrix3 instance from a column-major order array.\n *\n * @param {number[]} values The column-major order array.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n */\nMatrix3.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix3.clone(values, result);\n};\n\n/**\n * Creates a Matrix3 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {number[]} values The row-major order array.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n */\nMatrix3.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8]);\n  }\n  result[0] = values[0];\n  result[1] = values[3];\n  result[2] = values[6];\n  result[3] = values[1];\n  result[4] = values[4];\n  result[5] = values[7];\n  result[6] = values[2];\n  result[7] = values[5];\n  result[8] = values[8];\n  return result;\n};\n\n/**\n * Computes a 3x3 rotation matrix from the provided quaternion.\n *\n * @param {Quaternion} quaternion the quaternion to use.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The 3x3 rotation matrix from this quaternion.\n */\nMatrix3.fromQuaternion = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  const x2 = quaternion.x * quaternion.x;\n  const xy = quaternion.x * quaternion.y;\n  const xz = quaternion.x * quaternion.z;\n  const xw = quaternion.x * quaternion.w;\n  const y2 = quaternion.y * quaternion.y;\n  const yz = quaternion.y * quaternion.z;\n  const yw = quaternion.y * quaternion.w;\n  const z2 = quaternion.z * quaternion.z;\n  const zw = quaternion.z * quaternion.w;\n  const w2 = quaternion.w * quaternion.w;\n  const m00 = x2 - y2 - z2 + w2;\n  const m01 = 2.0 * (xy - zw);\n  const m02 = 2.0 * (xz + yw);\n  const m10 = 2.0 * (xy + zw);\n  const m11 = -x2 + y2 - z2 + w2;\n  const m12 = 2.0 * (yz - xw);\n  const m20 = 2.0 * (xz - yw);\n  const m21 = 2.0 * (yz + xw);\n  const m22 = -x2 - y2 + z2 + w2;\n  if (!defined(result)) {\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n  }\n  result[0] = m00;\n  result[1] = m10;\n  result[2] = m20;\n  result[3] = m01;\n  result[4] = m11;\n  result[5] = m21;\n  result[6] = m02;\n  result[7] = m12;\n  result[8] = m22;\n  return result;\n};\n\n/**\n * Computes a 3x3 rotation matrix from the provided headingPitchRoll. (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )\n *\n * @param {HeadingPitchRoll} headingPitchRoll the headingPitchRoll to use.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The 3x3 rotation matrix from this headingPitchRoll.\n */\nMatrix3.fromHeadingPitchRoll = function (headingPitchRoll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"headingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  const cosTheta = Math.cos(-headingPitchRoll.pitch);\n  const cosPsi = Math.cos(-headingPitchRoll.heading);\n  const cosPhi = Math.cos(headingPitchRoll.roll);\n  const sinTheta = Math.sin(-headingPitchRoll.pitch);\n  const sinPsi = Math.sin(-headingPitchRoll.heading);\n  const sinPhi = Math.sin(headingPitchRoll.roll);\n  const m00 = cosTheta * cosPsi;\n  const m01 = -cosPhi * sinPsi + sinPhi * sinTheta * cosPsi;\n  const m02 = sinPhi * sinPsi + cosPhi * sinTheta * cosPsi;\n  const m10 = cosTheta * sinPsi;\n  const m11 = cosPhi * cosPsi + sinPhi * sinTheta * sinPsi;\n  const m12 = -sinPhi * cosPsi + cosPhi * sinTheta * sinPsi;\n  const m20 = -sinTheta;\n  const m21 = sinPhi * cosTheta;\n  const m22 = cosPhi * cosTheta;\n  if (!defined(result)) {\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n  }\n  result[0] = m00;\n  result[1] = m10;\n  result[2] = m20;\n  result[3] = m01;\n  result[4] = m11;\n  result[5] = m21;\n  result[6] = m02;\n  result[7] = m12;\n  result[8] = m22;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing a non-uniform scale.\n *\n * @param {Cartesian3} scale The x, y, and z scale factors.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0, 0.0]\n * //   [0.0, 8.0, 0.0]\n * //   [0.0, 0.0, 9.0]\n * const m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix3.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);\n  }\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = scale.y;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = scale.z;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing a uniform scale.\n *\n * @param {number} scale The uniform scale factor.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0, 0.0]\n * //   [0.0, 2.0, 0.0]\n * //   [0.0, 0.0, 2.0]\n * const m = Cesium.Matrix3.fromUniformScale(2.0);\n */\nMatrix3.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(scale, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, scale);\n  }\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = scale;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = scale;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.\n *\n * @param {Cartesian3} vector the vector on the left hand side of the cross product operation.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [0.0, -9.0,  8.0]\n * //   [9.0,  0.0, -7.0]\n * //   [-8.0, 7.0,  0.0]\n * const m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix3.fromCrossProduct = function (vector, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"vector\", vector);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(0.0, -vector.z, vector.y, vector.z, 0.0, -vector.x, -vector.y, vector.x, 0.0);\n  }\n  result[0] = 0.0;\n  result[1] = vector.z;\n  result[2] = -vector.y;\n  result[3] = -vector.z;\n  result[4] = 0.0;\n  result[5] = vector.x;\n  result[6] = vector.y;\n  result[7] = -vector.x;\n  result[8] = 0.0;\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the x-axis.\n *\n * @param {number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the x-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationX = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  if (!defined(result)) {\n    return new Matrix3(1.0, 0.0, 0.0, 0.0, cosAngle, -sinAngle, 0.0, sinAngle, cosAngle);\n  }\n  result[0] = 1.0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = cosAngle;\n  result[5] = sinAngle;\n  result[6] = 0.0;\n  result[7] = -sinAngle;\n  result[8] = cosAngle;\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the y-axis.\n *\n * @param {number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the y-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationY = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  if (!defined(result)) {\n    return new Matrix3(cosAngle, 0.0, sinAngle, 0.0, 1.0, 0.0, -sinAngle, 0.0, cosAngle);\n  }\n  result[0] = cosAngle;\n  result[1] = 0.0;\n  result[2] = -sinAngle;\n  result[3] = 0.0;\n  result[4] = 1.0;\n  result[5] = 0.0;\n  result[6] = sinAngle;\n  result[7] = 0.0;\n  result[8] = cosAngle;\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the z-axis.\n *\n * @param {number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the z-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationZ = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  if (!defined(result)) {\n    return new Matrix3(cosAngle, -sinAngle, 0.0, sinAngle, cosAngle, 0.0, 0.0, 0.0, 1.0);\n  }\n  result[0] = cosAngle;\n  result[1] = sinAngle;\n  result[2] = 0.0;\n  result[3] = -sinAngle;\n  result[4] = cosAngle;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 1.0;\n  return result;\n};\n\n/**\n * Creates an Array from the provided Matrix3 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix3} matrix The matrix to use..\n * @param {number[]} [result] The Array onto which to store the result.\n * @returns {number[]} The modified Array parameter or a new Array instance if one was not provided.\n */\nMatrix3.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5], matrix[6], matrix[7], matrix[8]];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {number} column The zero-based index of the column.\n * @param {number} row The zero-based index of the row.\n * @returns {number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0, 1, or 2.\n * @exception {DeveloperError} column must be 0, 1, or 2.\n *\n * @example\n * const myMatrix = new Cesium.Matrix3();\n * const column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix3.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 2);\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 2);\n  //>>includeEnd('debug');\n\n  return column * 3 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {number} index The zero-based index of the column to retrieve.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const startIndex = index * 3;\n  const x = matrix[startIndex];\n  const y = matrix[startIndex + 1];\n  const z = matrix[startIndex + 2];\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {number} index The zero-based index of the column to set.\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix3.clone(matrix, result);\n  const startIndex = index * 3;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  result[startIndex + 2] = cartesian.z;\n  return result;\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {number} index The zero-based index of the row to retrieve.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = matrix[index];\n  const y = matrix[index + 3];\n  const z = matrix[index + 6];\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {number} index The zero-based index of the row to set.\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix3.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 3] = cartesian.y;\n  result[index + 6] = cartesian.z;\n  return result;\n};\nconst scaleScratch1 = new Cartesian3();\n\n/**\n * Computes a new matrix that replaces the scale with the provided scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Cartesian3} scale The scale that replaces the scale of the provided matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.setUniformScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.multiplyByScale\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.setScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix3.getScale(matrix, scaleScratch1);\n  const scaleRatioX = scale.x / existingScale.x;\n  const scaleRatioY = scale.y / existingScale.y;\n  const scaleRatioZ = scale.z / existingScale.z;\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioX;\n  result[3] = matrix[3] * scaleRatioY;\n  result[4] = matrix[4] * scaleRatioY;\n  result[5] = matrix[5] * scaleRatioY;\n  result[6] = matrix[6] * scaleRatioZ;\n  result[7] = matrix[7] * scaleRatioZ;\n  result[8] = matrix[8] * scaleRatioZ;\n  return result;\n};\nconst scaleScratch2 = new Cartesian3();\n\n/**\n * Computes a new matrix that replaces the scale with the provided uniform scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {number} scale The uniform scale that replaces the scale of the provided matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.setScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.multiplyByScale\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.setUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix3.getScale(matrix, scaleScratch2);\n  const scaleRatioX = scale / existingScale.x;\n  const scaleRatioY = scale / existingScale.y;\n  const scaleRatioZ = scale / existingScale.z;\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioX;\n  result[3] = matrix[3] * scaleRatioY;\n  result[4] = matrix[4] * scaleRatioY;\n  result[5] = matrix[5] * scaleRatioY;\n  result[6] = matrix[6] * scaleRatioZ;\n  result[7] = matrix[7] * scaleRatioZ;\n  result[8] = matrix[8] * scaleRatioZ;\n  return result;\n};\nconst scratchColumn = new Cartesian3();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @see Matrix3.multiplyByScale\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.setScale\n * @see Matrix3.setUniformScale\n */\nMatrix3.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Cartesian3.magnitude(Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn));\n  result.y = Cartesian3.magnitude(Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn));\n  result.z = Cartesian3.magnitude(Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn));\n  return result;\n};\nconst scaleScratch3 = new Cartesian3();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors.\n *\n * @param {Matrix3} matrix The matrix.\n * @returns {number} The maximum scale.\n */\nMatrix3.getMaximumScale = function (matrix) {\n  Matrix3.getScale(matrix, scaleScratch3);\n  return Cartesian3.maximumComponent(scaleScratch3);\n};\nconst scaleScratch4 = new Cartesian3();\n\n/**\n * Sets the rotation assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Matrix3} rotation The rotation matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.getRotation\n */\nMatrix3.setRotation = function (matrix, rotation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix3.getScale(matrix, scaleScratch4);\n  result[0] = rotation[0] * scale.x;\n  result[1] = rotation[1] * scale.x;\n  result[2] = rotation[2] * scale.x;\n  result[3] = rotation[3] * scale.y;\n  result[4] = rotation[4] * scale.y;\n  result[5] = rotation[5] * scale.y;\n  result[6] = rotation[6] * scale.z;\n  result[7] = rotation[7] * scale.z;\n  result[8] = rotation[8] * scale.z;\n  return result;\n};\nconst scaleScratch5 = new Cartesian3();\n\n/**\n * Extracts the rotation matrix assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.setRotation\n */\nMatrix3.getRotation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix3.getScale(matrix, scaleScratch5);\n  result[0] = matrix[0] / scale.x;\n  result[1] = matrix[1] / scale.x;\n  result[2] = matrix[2] / scale.x;\n  result[3] = matrix[3] / scale.y;\n  result[4] = matrix[4] / scale.y;\n  result[5] = matrix[5] / scale.y;\n  result[6] = matrix[6] / scale.z;\n  result[7] = matrix[7] / scale.z;\n  result[8] = matrix[8] / scale.z;\n  return result;\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = left[0] * right[0] + left[3] * right[1] + left[6] * right[2];\n  const column0Row1 = left[1] * right[0] + left[4] * right[1] + left[7] * right[2];\n  const column0Row2 = left[2] * right[0] + left[5] * right[1] + left[8] * right[2];\n  const column1Row0 = left[0] * right[3] + left[3] * right[4] + left[6] * right[5];\n  const column1Row1 = left[1] * right[3] + left[4] * right[4] + left[7] * right[5];\n  const column1Row2 = left[2] * right[3] + left[5] * right[4] + left[8] * right[5];\n  const column2Row0 = left[0] * right[6] + left[3] * right[7] + left[6] * right[8];\n  const column2Row1 = left[1] * right[6] + left[4] * right[7] + left[7] * right[8];\n  const column2Row2 = left[2] * right[6] + left[5] * right[7] + left[8] * right[8];\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column1Row0;\n  result[4] = column1Row1;\n  result[5] = column1Row2;\n  result[6] = column2Row0;\n  result[7] = column2Row1;\n  result[8] = column2Row2;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  result[4] = left[4] + right[4];\n  result[5] = left[5] + right[5];\n  result[6] = left[6] + right[6];\n  result[7] = left[7] + right[7];\n  result[8] = left[8] + right[8];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  result[4] = left[4] - right[4];\n  result[5] = left[5] - right[5];\n  result[6] = left[6] - right[6];\n  result[7] = left[7] - right[7];\n  result[8] = left[8] - right[8];\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Cartesian3} cartesian The column.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nMatrix3.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const vX = cartesian.x;\n  const vY = cartesian.y;\n  const vZ = cartesian.z;\n  const x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;\n  const y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;\n  const z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {number} scalar The number to multiply by.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  result[4] = matrix[4] * scalar;\n  result[5] = matrix[5] * scalar;\n  result[6] = matrix[6] * scalar;\n  result[7] = matrix[7] * scalar;\n  result[8] = matrix[8] * scalar;\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n *\n * @param {Matrix3} matrix The matrix on the left-hand side.\n * @param {Cartesian3} scale The non-uniform scale on the right-hand side.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromScale(scale), m);\n * Cesium.Matrix3.multiplyByScale(m, scale, m);\n *\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.setScale\n * @see Matrix3.setUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale.x;\n  result[1] = matrix[1] * scale.x;\n  result[2] = matrix[2] * scale.x;\n  result[3] = matrix[3] * scale.y;\n  result[4] = matrix[4] * scale.y;\n  result[5] = matrix[5] * scale.y;\n  result[6] = matrix[6] * scale.z;\n  result[7] = matrix[7] * scale.z;\n  result[8] = matrix[8] * scale.z;\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.\n *\n * @param {Matrix3} matrix The matrix on the left-hand side.\n * @param {number} scale The uniform scale on the right-hand side.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromUniformScale(scale), m);\n * Cesium.Matrix3.multiplyByUniformScale(m, scale, m);\n *\n * @see Matrix3.multiplyByScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.setScale\n * @see Matrix3.setUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.multiplyByUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale;\n  result[1] = matrix[1] * scale;\n  result[2] = matrix[2] * scale;\n  result[3] = matrix[3] * scale;\n  result[4] = matrix[4] * scale;\n  result[5] = matrix[5] * scale;\n  result[6] = matrix[6] * scale;\n  result[7] = matrix[7] * scale;\n  result[8] = matrix[8] * scale;\n  return result;\n};\n\n/**\n * Creates a negated copy of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to negate.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  result[4] = -matrix[4];\n  result[5] = -matrix[5];\n  result[6] = -matrix[6];\n  result[7] = -matrix[7];\n  result[8] = -matrix[8];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to transpose.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = matrix[0];\n  const column0Row1 = matrix[3];\n  const column0Row2 = matrix[6];\n  const column1Row0 = matrix[1];\n  const column1Row1 = matrix[4];\n  const column1Row2 = matrix[7];\n  const column2Row0 = matrix[2];\n  const column2Row1 = matrix[5];\n  const column2Row2 = matrix[8];\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column1Row0;\n  result[4] = column1Row1;\n  result[5] = column1Row2;\n  result[6] = column2Row0;\n  result[7] = column2Row1;\n  result[8] = column2Row2;\n  return result;\n};\nfunction computeFrobeniusNorm(matrix) {\n  let norm = 0.0;\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n  return Math.sqrt(norm);\n}\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\nfunction offDiagonalFrobeniusNorm(matrix) {\n  // Computes the \"off-diagonal\" Frobenius norm.\n  // Assumes matrix is symmetric.\n\n  let norm = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n  return Math.sqrt(norm);\n}\nfunction shurDecomposition(matrix, result) {\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n  // section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n  //\n  // The routine takes a matrix, which is assumed to be symmetric, and\n  // finds the largest off-diagonal term, and then creates\n  // a matrix (result) which can be used to help reduce it\n\n  const tolerance = CesiumMath.EPSILON15;\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n\n  // find pivot (rotAxis) based on max diagonal of matrix\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])]);\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n  let c = 1.0;\n  let s = 0.0;\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n  if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[Matrix3.getElementIndex(q, q)];\n    const pp = matrix[Matrix3.getElementIndex(p, p)];\n    const qp = matrix[Matrix3.getElementIndex(q, p)];\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n  result = Matrix3.clone(Matrix3.IDENTITY, result);\n  result[Matrix3.getElementIndex(p, p)] = result[Matrix3.getElementIndex(q, q)] = c;\n  result[Matrix3.getElementIndex(q, p)] = s;\n  result[Matrix3.getElementIndex(p, q)] = -s;\n  return result;\n}\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\n\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n * <p>\n * Returns a diagonal matrix and unitary matrix such that:\n * <code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>\n * </p>\n * <p>\n * The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * </p>\n *\n * @param {Matrix3} matrix The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param {object} [result] An object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns {object} An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * const a = //... symetric matrix\n * const result = {\n *     unitary : new Cesium.Matrix3(),\n *     diagonal : new Cesium.Matrix3()\n * };\n * Cesium.Matrix3.computeEigenDecomposition(a, result);\n *\n * const unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());\n * const b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());\n * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * const lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue\n * const v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector\n * const c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)\n */\nMatrix3.computeEigenDecomposition = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n  // section 8.4.3 The Classical Jacobi Algorithm\n\n  const tolerance = CesiumMath.EPSILON20;\n  const maxSweeps = 10;\n  let count = 0;\n  let sweep = 0;\n  if (!defined(result)) {\n    result = {};\n  }\n  const unitaryMatrix = result.unitary = Matrix3.clone(Matrix3.IDENTITY, result.unitary);\n  const diagMatrix = result.diagonal = Matrix3.clone(matrix, result.diagonal);\n  const epsilon = tolerance * computeFrobeniusNorm(diagMatrix);\n  while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {\n    shurDecomposition(diagMatrix, jMatrix);\n    Matrix3.transpose(jMatrix, jMatrixTranspose);\n    Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);\n    Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);\n    Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix3} matrix The matrix with signed elements.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n  result[4] = Math.abs(matrix[4]);\n  result[5] = Math.abs(matrix[5]);\n  result[6] = Math.abs(matrix[6]);\n  result[7] = Math.abs(matrix[7]);\n  result[8] = Math.abs(matrix[8]);\n  return result;\n};\n\n/**\n * Computes the determinant of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @returns {number} The value of the determinant of the matrix.\n */\nMatrix3.determinant = function (matrix) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  const m11 = matrix[0];\n  const m21 = matrix[3];\n  const m31 = matrix[6];\n  const m12 = matrix[1];\n  const m22 = matrix[4];\n  const m32 = matrix[7];\n  const m13 = matrix[2];\n  const m23 = matrix[5];\n  const m33 = matrix[8];\n  return m11 * (m22 * m33 - m23 * m32) + m12 * (m23 * m31 - m21 * m33) + m13 * (m21 * m32 - m22 * m31);\n};\n\n/**\n * Computes the inverse of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to invert.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} matrix is not invertible.\n */\nMatrix3.inverse = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const m11 = matrix[0];\n  const m21 = matrix[1];\n  const m31 = matrix[2];\n  const m12 = matrix[3];\n  const m22 = matrix[4];\n  const m32 = matrix[5];\n  const m13 = matrix[6];\n  const m23 = matrix[7];\n  const m33 = matrix[8];\n  const determinant = Matrix3.determinant(matrix);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (Math.abs(determinant) <= CesiumMath.EPSILON15) {\n    throw new DeveloperError(\"matrix is not invertible\");\n  }\n  //>>includeEnd('debug');\n\n  result[0] = m22 * m33 - m23 * m32;\n  result[1] = m23 * m31 - m21 * m33;\n  result[2] = m21 * m32 - m22 * m31;\n  result[3] = m13 * m32 - m12 * m33;\n  result[4] = m11 * m33 - m13 * m31;\n  result[5] = m12 * m31 - m11 * m32;\n  result[6] = m12 * m23 - m13 * m22;\n  result[7] = m13 * m21 - m11 * m23;\n  result[8] = m11 * m22 - m12 * m21;\n  const scale = 1.0 / determinant;\n  return Matrix3.multiplyByScalar(result, scale, result);\n};\nconst scratchTransposeMatrix = new Matrix3();\n\n/**\n * Computes the inverse transpose of a matrix.\n *\n * @param {Matrix3} matrix The matrix to transpose and invert.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.inverseTranspose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  return Matrix3.inverse(Matrix3.transpose(matrix, scratchTransposeMatrix), result);\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix3} [left] The first matrix.\n * @param {Matrix3} [right] The second matrix.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nMatrix3.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[3] === right[3] && left[4] === right[4] && left[5] === right[5] && left[6] === right[6] && left[7] === right[7] && left[8] === right[8];\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix3} [left] The first matrix.\n * @param {Matrix3} [right] The second matrix.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix3.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n  return left === right || defined(left) && defined(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon && Math.abs(left[4] - right[4]) <= epsilon && Math.abs(left[5] - right[5]) <= epsilon && Math.abs(left[6] - right[6]) <= epsilon && Math.abs(left[7] - right[7]) <= epsilon && Math.abs(left[8] - right[8]) <= epsilon;\n};\n\n/**\n * An immutable Matrix3 instance initialized to the identity matrix.\n *\n * @type {Matrix3}\n * @constant\n */\nMatrix3.IDENTITY = Object.freeze(new Matrix3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0));\n\n/**\n * An immutable Matrix3 instance initialized to the zero matrix.\n *\n * @type {Matrix3}\n * @constant\n */\nMatrix3.ZERO = Object.freeze(new Matrix3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));\n\n/**\n * The index into Matrix3 for column 0, row 0.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix3 for column 0, row 1.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix3 for column 0, row 2.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN0ROW2 = 2;\n\n/**\n * The index into Matrix3 for column 1, row 0.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN1ROW0 = 3;\n\n/**\n * The index into Matrix3 for column 1, row 1.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN1ROW1 = 4;\n\n/**\n * The index into Matrix3 for column 1, row 2.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN1ROW2 = 5;\n\n/**\n * The index into Matrix3 for column 2, row 0.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN2ROW0 = 6;\n\n/**\n * The index into Matrix3 for column 2, row 1.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN2ROW1 = 7;\n\n/**\n * The index into Matrix3 for column 2, row 2.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN2ROW2 = 8;\nObject.defineProperties(Matrix3.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix3.prototype\n   *\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      return Matrix3.packedLength;\n    }\n  }\n});\n\n/**\n * Duplicates the provided Matrix3 instance.\n *\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n */\nMatrix3.prototype.clone = function (result) {\n  return Matrix3.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix3} [right] The right hand side matrix.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix3.prototype.equals = function (right) {\n  return Matrix3.equals(this, right);\n};\n\n/**\n * @private\n */\nMatrix3.equalsArray = function (matrix, array, offset) {\n  return matrix[0] === array[offset] && matrix[1] === array[offset + 1] && matrix[2] === array[offset + 2] && matrix[3] === array[offset + 3] && matrix[4] === array[offset + 4] && matrix[5] === array[offset + 5] && matrix[6] === array[offset + 6] && matrix[7] === array[offset + 7] && matrix[8] === array[offset + 8];\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix3} [right] The right hand side matrix.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix3.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix3.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1, column2)'.\n *\n * @returns {string} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.\n */\nMatrix3.prototype.toString = function () {\n  return `(${this[0]}, ${this[3]}, ${this[6]})\\n` + `(${this[1]}, ${this[4]}, ${this[7]})\\n` + `(${this[2]}, ${this[5]}, ${this[8]})`;\n};\nexport default Matrix3;","map":{"version":3,"names":["Cartesian3","Check","defaultValue","defined","DeveloperError","CesiumMath","Matrix3","column0Row0","column1Row0","column2Row0","column0Row1","column1Row1","column2Row1","column0Row2","column1Row2","column2Row2","packedLength","pack","value","array","startingIndex","typeOf","object","unpack","result","packArray","length","resultLength","Array","isArray","i","unpackArray","number","greaterThanOrEquals","index","clone","matrix","undefined","fromArray","fromColumnMajorArray","values","fromRowMajorArray","fromQuaternion","quaternion","x2","x","xy","y","xz","z","xw","w","y2","yz","yw","z2","zw","w2","m00","m01","m02","m10","m11","m12","m20","m21","m22","fromHeadingPitchRoll","headingPitchRoll","cosTheta","Math","cos","pitch","cosPsi","heading","cosPhi","roll","sinTheta","sin","sinPsi","sinPhi","fromScale","scale","fromUniformScale","fromCrossProduct","vector","fromRotationX","angle","cosAngle","sinAngle","fromRotationY","fromRotationZ","toArray","getElementIndex","column","row","lessThanOrEquals","getColumn","startIndex","setColumn","cartesian","getRow","setRow","scaleScratch1","setScale","existingScale","getScale","scaleRatioX","scaleRatioY","scaleRatioZ","scaleScratch2","setUniformScale","scratchColumn","magnitude","fromElements","scaleScratch3","getMaximumScale","maximumComponent","scaleScratch4","setRotation","rotation","scaleScratch5","getRotation","multiply","left","right","add","subtract","multiplyByVector","vX","vY","vZ","multiplyByScalar","scalar","multiplyByScale","multiplyByUniformScale","negate","transpose","computeFrobeniusNorm","norm","temp","sqrt","rowVal","colVal","offDiagonalFrobeniusNorm","shurDecomposition","tolerance","EPSILON15","maxDiagonal","rotAxis","abs","c","s","p","q","qq","pp","qp","tau","t","IDENTITY","jMatrix","jMatrixTranspose","computeEigenDecomposition","EPSILON20","maxSweeps","count","sweep","unitaryMatrix","unitary","diagMatrix","diagonal","epsilon","determinant","m31","m32","m13","m23","m33","inverse","scratchTransposeMatrix","inverseTranspose","equals","equalsEpsilon","Object","freeze","ZERO","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","defineProperties","prototype","get","equalsArray","offset","toString"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/Matrix3.js"],"sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 3x3 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix3\n * @constructor\n * @implements {ArrayLike<number>}\n *\n * @param {number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {number} [column2Row0=0.0] The value for column 2, row 0.\n * @param {number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {number} [column1Row1=0.0] The value for column 1, row 1.\n * @param {number} [column2Row1=0.0] The value for column 2, row 1.\n * @param {number} [column0Row2=0.0] The value for column 0, row 2.\n * @param {number} [column1Row2=0.0] The value for column 1, row 2.\n * @param {number} [column2Row2=0.0] The value for column 2, row 2.\n *\n * @see Matrix3.fromArray\n * @see Matrix3.fromColumnMajorArray\n * @see Matrix3.fromRowMajorArray\n * @see Matrix3.fromQuaternion\n * @see Matrix3.fromHeadingPitchRoll\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.fromCrossProduct\n * @see Matrix3.fromRotationX\n * @see Matrix3.fromRotationY\n * @see Matrix3.fromRotationZ\n * @see Matrix2\n * @see Matrix4\n */\nfunction Matrix3(\n  column0Row0,\n  column1Row0,\n  column2Row0,\n  column0Row1,\n  column1Row1,\n  column2Row1,\n  column0Row2,\n  column1Row2,\n  column2Row2,\n) {\n  this[0] = defaultValue(column0Row0, 0.0);\n  this[1] = defaultValue(column0Row1, 0.0);\n  this[2] = defaultValue(column0Row2, 0.0);\n  this[3] = defaultValue(column1Row0, 0.0);\n  this[4] = defaultValue(column1Row1, 0.0);\n  this[5] = defaultValue(column1Row2, 0.0);\n  this[6] = defaultValue(column2Row0, 0.0);\n  this[7] = defaultValue(column2Row1, 0.0);\n  this[8] = defaultValue(column2Row2, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nMatrix3.packedLength = 9;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix3} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nMatrix3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n  array[startingIndex++] = value[4];\n  array[startingIndex++] = value[5];\n  array[startingIndex++] = value[6];\n  array[startingIndex++] = value[7];\n  array[startingIndex++] = value[8];\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix3} [result] The object into which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n */\nMatrix3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  result[4] = array[startingIndex++];\n  result[5] = array[startingIndex++];\n  result[6] = array[startingIndex++];\n  result[7] = array[startingIndex++];\n  result[8] = array[startingIndex++];\n  return result;\n};\n\n/**\n * Flattens an array of Matrix3s into an array of components. The components\n * are stored in column-major order.\n *\n * @param {Matrix3[]} array The array of matrices to pack.\n * @param {number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 9 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 9) elements.\n * @returns {number[]} The packed array.\n */\nMatrix3.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 9;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 9 elements\",\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Matrix3.pack(array[i], result, i * 9);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of column-major matrix components into an array of Matrix3s.\n *\n * @param {number[]} array The array of components to unpack.\n * @param {Matrix3[]} [result] The array onto which to store the result.\n * @returns {Matrix3[]} The unpacked array.\n */\nMatrix3.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 9);\n  if (array.length % 9 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 9.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 9);\n  } else {\n    result.length = length / 9;\n  }\n\n  for (let i = 0; i < length; i += 9) {\n    const index = i / 9;\n    result[index] = Matrix3.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Duplicates a Matrix3 instance.\n *\n * @param {Matrix3} matrix The matrix to duplicate.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix3.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Matrix3(\n      matrix[0],\n      matrix[3],\n      matrix[6],\n      matrix[1],\n      matrix[4],\n      matrix[7],\n      matrix[2],\n      matrix[5],\n      matrix[8],\n    );\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  return result;\n};\n\n/**\n * Creates a Matrix3 from 9 consecutive elements in an array.\n *\n * @function\n * @param {number[]} array The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Create the Matrix3:\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n *\n * const v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * const m = Cesium.Matrix3.fromArray(v);\n *\n * // Create same Matrix3 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * const m2 = Cesium.Matrix3.fromArray(v2, 2);\n */\nMatrix3.fromArray = Matrix3.unpack;\n\n/**\n * Creates a Matrix3 instance from a column-major order array.\n *\n * @param {number[]} values The column-major order array.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n */\nMatrix3.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix3.clone(values, result);\n};\n\n/**\n * Creates a Matrix3 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {number[]} values The row-major order array.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n */\nMatrix3.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(\n      values[0],\n      values[1],\n      values[2],\n      values[3],\n      values[4],\n      values[5],\n      values[6],\n      values[7],\n      values[8],\n    );\n  }\n  result[0] = values[0];\n  result[1] = values[3];\n  result[2] = values[6];\n  result[3] = values[1];\n  result[4] = values[4];\n  result[5] = values[7];\n  result[6] = values[2];\n  result[7] = values[5];\n  result[8] = values[8];\n  return result;\n};\n\n/**\n * Computes a 3x3 rotation matrix from the provided quaternion.\n *\n * @param {Quaternion} quaternion the quaternion to use.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The 3x3 rotation matrix from this quaternion.\n */\nMatrix3.fromQuaternion = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  const x2 = quaternion.x * quaternion.x;\n  const xy = quaternion.x * quaternion.y;\n  const xz = quaternion.x * quaternion.z;\n  const xw = quaternion.x * quaternion.w;\n  const y2 = quaternion.y * quaternion.y;\n  const yz = quaternion.y * quaternion.z;\n  const yw = quaternion.y * quaternion.w;\n  const z2 = quaternion.z * quaternion.z;\n  const zw = quaternion.z * quaternion.w;\n  const w2 = quaternion.w * quaternion.w;\n\n  const m00 = x2 - y2 - z2 + w2;\n  const m01 = 2.0 * (xy - zw);\n  const m02 = 2.0 * (xz + yw);\n\n  const m10 = 2.0 * (xy + zw);\n  const m11 = -x2 + y2 - z2 + w2;\n  const m12 = 2.0 * (yz - xw);\n\n  const m20 = 2.0 * (xz - yw);\n  const m21 = 2.0 * (yz + xw);\n  const m22 = -x2 - y2 + z2 + w2;\n\n  if (!defined(result)) {\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n  }\n  result[0] = m00;\n  result[1] = m10;\n  result[2] = m20;\n  result[3] = m01;\n  result[4] = m11;\n  result[5] = m21;\n  result[6] = m02;\n  result[7] = m12;\n  result[8] = m22;\n  return result;\n};\n\n/**\n * Computes a 3x3 rotation matrix from the provided headingPitchRoll. (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )\n *\n * @param {HeadingPitchRoll} headingPitchRoll the headingPitchRoll to use.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The 3x3 rotation matrix from this headingPitchRoll.\n */\nMatrix3.fromHeadingPitchRoll = function (headingPitchRoll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"headingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  const cosTheta = Math.cos(-headingPitchRoll.pitch);\n  const cosPsi = Math.cos(-headingPitchRoll.heading);\n  const cosPhi = Math.cos(headingPitchRoll.roll);\n  const sinTheta = Math.sin(-headingPitchRoll.pitch);\n  const sinPsi = Math.sin(-headingPitchRoll.heading);\n  const sinPhi = Math.sin(headingPitchRoll.roll);\n\n  const m00 = cosTheta * cosPsi;\n  const m01 = -cosPhi * sinPsi + sinPhi * sinTheta * cosPsi;\n  const m02 = sinPhi * sinPsi + cosPhi * sinTheta * cosPsi;\n\n  const m10 = cosTheta * sinPsi;\n  const m11 = cosPhi * cosPsi + sinPhi * sinTheta * sinPsi;\n  const m12 = -sinPhi * cosPsi + cosPhi * sinTheta * sinPsi;\n\n  const m20 = -sinTheta;\n  const m21 = sinPhi * cosTheta;\n  const m22 = cosPhi * cosTheta;\n\n  if (!defined(result)) {\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n  }\n  result[0] = m00;\n  result[1] = m10;\n  result[2] = m20;\n  result[3] = m01;\n  result[4] = m11;\n  result[5] = m21;\n  result[6] = m02;\n  result[7] = m12;\n  result[8] = m22;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing a non-uniform scale.\n *\n * @param {Cartesian3} scale The x, y, and z scale factors.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0, 0.0]\n * //   [0.0, 8.0, 0.0]\n * //   [0.0, 0.0, 9.0]\n * const m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix3.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = scale.y;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = scale.z;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing a uniform scale.\n *\n * @param {number} scale The uniform scale factor.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0, 0.0]\n * //   [0.0, 2.0, 0.0]\n * //   [0.0, 0.0, 2.0]\n * const m = Cesium.Matrix3.fromUniformScale(2.0);\n */\nMatrix3.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(scale, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, scale);\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = scale;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = scale;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.\n *\n * @param {Cartesian3} vector the vector on the left hand side of the cross product operation.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [0.0, -9.0,  8.0]\n * //   [9.0,  0.0, -7.0]\n * //   [-8.0, 7.0,  0.0]\n * const m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix3.fromCrossProduct = function (vector, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"vector\", vector);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(\n      0.0,\n      -vector.z,\n      vector.y,\n      vector.z,\n      0.0,\n      -vector.x,\n      -vector.y,\n      vector.x,\n      0.0,\n    );\n  }\n\n  result[0] = 0.0;\n  result[1] = vector.z;\n  result[2] = -vector.y;\n  result[3] = -vector.z;\n  result[4] = 0.0;\n  result[5] = vector.x;\n  result[6] = vector.y;\n  result[7] = -vector.x;\n  result[8] = 0.0;\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the x-axis.\n *\n * @param {number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the x-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationX = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      1.0,\n      0.0,\n      0.0,\n      0.0,\n      cosAngle,\n      -sinAngle,\n      0.0,\n      sinAngle,\n      cosAngle,\n    );\n  }\n\n  result[0] = 1.0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = cosAngle;\n  result[5] = sinAngle;\n  result[6] = 0.0;\n  result[7] = -sinAngle;\n  result[8] = cosAngle;\n\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the y-axis.\n *\n * @param {number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the y-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationY = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      cosAngle,\n      0.0,\n      sinAngle,\n      0.0,\n      1.0,\n      0.0,\n      -sinAngle,\n      0.0,\n      cosAngle,\n    );\n  }\n\n  result[0] = cosAngle;\n  result[1] = 0.0;\n  result[2] = -sinAngle;\n  result[3] = 0.0;\n  result[4] = 1.0;\n  result[5] = 0.0;\n  result[6] = sinAngle;\n  result[7] = 0.0;\n  result[8] = cosAngle;\n\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the z-axis.\n *\n * @param {number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the z-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationZ = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      cosAngle,\n      -sinAngle,\n      0.0,\n      sinAngle,\n      cosAngle,\n      0.0,\n      0.0,\n      0.0,\n      1.0,\n    );\n  }\n\n  result[0] = cosAngle;\n  result[1] = sinAngle;\n  result[2] = 0.0;\n  result[3] = -sinAngle;\n  result[4] = cosAngle;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 1.0;\n\n  return result;\n};\n\n/**\n * Creates an Array from the provided Matrix3 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix3} matrix The matrix to use..\n * @param {number[]} [result] The Array onto which to store the result.\n * @returns {number[]} The modified Array parameter or a new Array instance if one was not provided.\n */\nMatrix3.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [\n      matrix[0],\n      matrix[1],\n      matrix[2],\n      matrix[3],\n      matrix[4],\n      matrix[5],\n      matrix[6],\n      matrix[7],\n      matrix[8],\n    ];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {number} column The zero-based index of the column.\n * @param {number} row The zero-based index of the row.\n * @returns {number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0, 1, or 2.\n * @exception {DeveloperError} column must be 0, 1, or 2.\n *\n * @example\n * const myMatrix = new Cesium.Matrix3();\n * const column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix3.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 2);\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 2);\n  //>>includeEnd('debug');\n\n  return column * 3 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {number} index The zero-based index of the column to retrieve.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const startIndex = index * 3;\n  const x = matrix[startIndex];\n  const y = matrix[startIndex + 1];\n  const z = matrix[startIndex + 2];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {number} index The zero-based index of the column to set.\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix3.clone(matrix, result);\n  const startIndex = index * 3;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  result[startIndex + 2] = cartesian.z;\n  return result;\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {number} index The zero-based index of the row to retrieve.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = matrix[index];\n  const y = matrix[index + 3];\n  const z = matrix[index + 6];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {number} index The zero-based index of the row to set.\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix3.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 3] = cartesian.y;\n  result[index + 6] = cartesian.z;\n  return result;\n};\n\nconst scaleScratch1 = new Cartesian3();\n\n/**\n * Computes a new matrix that replaces the scale with the provided scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Cartesian3} scale The scale that replaces the scale of the provided matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.setUniformScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.multiplyByScale\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.setScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix3.getScale(matrix, scaleScratch1);\n  const scaleRatioX = scale.x / existingScale.x;\n  const scaleRatioY = scale.y / existingScale.y;\n  const scaleRatioZ = scale.z / existingScale.z;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioX;\n  result[3] = matrix[3] * scaleRatioY;\n  result[4] = matrix[4] * scaleRatioY;\n  result[5] = matrix[5] * scaleRatioY;\n  result[6] = matrix[6] * scaleRatioZ;\n  result[7] = matrix[7] * scaleRatioZ;\n  result[8] = matrix[8] * scaleRatioZ;\n\n  return result;\n};\n\nconst scaleScratch2 = new Cartesian3();\n\n/**\n * Computes a new matrix that replaces the scale with the provided uniform scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {number} scale The uniform scale that replaces the scale of the provided matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.setScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.multiplyByScale\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.setUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix3.getScale(matrix, scaleScratch2);\n  const scaleRatioX = scale / existingScale.x;\n  const scaleRatioY = scale / existingScale.y;\n  const scaleRatioZ = scale / existingScale.z;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioX;\n  result[3] = matrix[3] * scaleRatioY;\n  result[4] = matrix[4] * scaleRatioY;\n  result[5] = matrix[5] * scaleRatioY;\n  result[6] = matrix[6] * scaleRatioZ;\n  result[7] = matrix[7] * scaleRatioZ;\n  result[8] = matrix[8] * scaleRatioZ;\n\n  return result;\n};\n\nconst scratchColumn = new Cartesian3();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @see Matrix3.multiplyByScale\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.setScale\n * @see Matrix3.setUniformScale\n */\nMatrix3.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn),\n  );\n  result.y = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn),\n  );\n  result.z = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn),\n  );\n  return result;\n};\n\nconst scaleScratch3 = new Cartesian3();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors.\n *\n * @param {Matrix3} matrix The matrix.\n * @returns {number} The maximum scale.\n */\nMatrix3.getMaximumScale = function (matrix) {\n  Matrix3.getScale(matrix, scaleScratch3);\n  return Cartesian3.maximumComponent(scaleScratch3);\n};\n\nconst scaleScratch4 = new Cartesian3();\n\n/**\n * Sets the rotation assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Matrix3} rotation The rotation matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.getRotation\n */\nMatrix3.setRotation = function (matrix, rotation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix3.getScale(matrix, scaleScratch4);\n\n  result[0] = rotation[0] * scale.x;\n  result[1] = rotation[1] * scale.x;\n  result[2] = rotation[2] * scale.x;\n  result[3] = rotation[3] * scale.y;\n  result[4] = rotation[4] * scale.y;\n  result[5] = rotation[5] * scale.y;\n  result[6] = rotation[6] * scale.z;\n  result[7] = rotation[7] * scale.z;\n  result[8] = rotation[8] * scale.z;\n\n  return result;\n};\n\nconst scaleScratch5 = new Cartesian3();\n\n/**\n * Extracts the rotation matrix assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.setRotation\n */\nMatrix3.getRotation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix3.getScale(matrix, scaleScratch5);\n\n  result[0] = matrix[0] / scale.x;\n  result[1] = matrix[1] / scale.x;\n  result[2] = matrix[2] / scale.x;\n  result[3] = matrix[3] / scale.y;\n  result[4] = matrix[4] / scale.y;\n  result[5] = matrix[5] / scale.y;\n  result[6] = matrix[6] / scale.z;\n  result[7] = matrix[7] / scale.z;\n  result[8] = matrix[8] / scale.z;\n\n  return result;\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 =\n    left[0] * right[0] + left[3] * right[1] + left[6] * right[2];\n  const column0Row1 =\n    left[1] * right[0] + left[4] * right[1] + left[7] * right[2];\n  const column0Row2 =\n    left[2] * right[0] + left[5] * right[1] + left[8] * right[2];\n\n  const column1Row0 =\n    left[0] * right[3] + left[3] * right[4] + left[6] * right[5];\n  const column1Row1 =\n    left[1] * right[3] + left[4] * right[4] + left[7] * right[5];\n  const column1Row2 =\n    left[2] * right[3] + left[5] * right[4] + left[8] * right[5];\n\n  const column2Row0 =\n    left[0] * right[6] + left[3] * right[7] + left[6] * right[8];\n  const column2Row1 =\n    left[1] * right[6] + left[4] * right[7] + left[7] * right[8];\n  const column2Row2 =\n    left[2] * right[6] + left[5] * right[7] + left[8] * right[8];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column1Row0;\n  result[4] = column1Row1;\n  result[5] = column1Row2;\n  result[6] = column2Row0;\n  result[7] = column2Row1;\n  result[8] = column2Row2;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  result[4] = left[4] + right[4];\n  result[5] = left[5] + right[5];\n  result[6] = left[6] + right[6];\n  result[7] = left[7] + right[7];\n  result[8] = left[8] + right[8];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  result[4] = left[4] - right[4];\n  result[5] = left[5] - right[5];\n  result[6] = left[6] - right[6];\n  result[7] = left[7] - right[7];\n  result[8] = left[8] - right[8];\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Cartesian3} cartesian The column.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nMatrix3.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const vX = cartesian.x;\n  const vY = cartesian.y;\n  const vZ = cartesian.z;\n\n  const x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;\n  const y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;\n  const z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {number} scalar The number to multiply by.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  result[4] = matrix[4] * scalar;\n  result[5] = matrix[5] * scalar;\n  result[6] = matrix[6] * scalar;\n  result[7] = matrix[7] * scalar;\n  result[8] = matrix[8] * scalar;\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n *\n * @param {Matrix3} matrix The matrix on the left-hand side.\n * @param {Cartesian3} scale The non-uniform scale on the right-hand side.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromScale(scale), m);\n * Cesium.Matrix3.multiplyByScale(m, scale, m);\n *\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.setScale\n * @see Matrix3.setUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale.x;\n  result[1] = matrix[1] * scale.x;\n  result[2] = matrix[2] * scale.x;\n  result[3] = matrix[3] * scale.y;\n  result[4] = matrix[4] * scale.y;\n  result[5] = matrix[5] * scale.y;\n  result[6] = matrix[6] * scale.z;\n  result[7] = matrix[7] * scale.z;\n  result[8] = matrix[8] * scale.z;\n\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.\n *\n * @param {Matrix3} matrix The matrix on the left-hand side.\n * @param {number} scale The uniform scale on the right-hand side.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromUniformScale(scale), m);\n * Cesium.Matrix3.multiplyByUniformScale(m, scale, m);\n *\n * @see Matrix3.multiplyByScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.setScale\n * @see Matrix3.setUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.multiplyByUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale;\n  result[1] = matrix[1] * scale;\n  result[2] = matrix[2] * scale;\n  result[3] = matrix[3] * scale;\n  result[4] = matrix[4] * scale;\n  result[5] = matrix[5] * scale;\n  result[6] = matrix[6] * scale;\n  result[7] = matrix[7] * scale;\n  result[8] = matrix[8] * scale;\n\n  return result;\n};\n\n/**\n * Creates a negated copy of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to negate.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  result[4] = -matrix[4];\n  result[5] = -matrix[5];\n  result[6] = -matrix[6];\n  result[7] = -matrix[7];\n  result[8] = -matrix[8];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to transpose.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = matrix[0];\n  const column0Row1 = matrix[3];\n  const column0Row2 = matrix[6];\n  const column1Row0 = matrix[1];\n  const column1Row1 = matrix[4];\n  const column1Row2 = matrix[7];\n  const column2Row0 = matrix[2];\n  const column2Row1 = matrix[5];\n  const column2Row2 = matrix[8];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column1Row0;\n  result[4] = column1Row1;\n  result[5] = column1Row2;\n  result[6] = column2Row0;\n  result[7] = column2Row1;\n  result[8] = column2Row2;\n  return result;\n};\n\nfunction computeFrobeniusNorm(matrix) {\n  let norm = 0.0;\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n\nfunction offDiagonalFrobeniusNorm(matrix) {\n  // Computes the \"off-diagonal\" Frobenius norm.\n  // Assumes matrix is symmetric.\n\n  let norm = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nfunction shurDecomposition(matrix, result) {\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n  // section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n  //\n  // The routine takes a matrix, which is assumed to be symmetric, and\n  // finds the largest off-diagonal term, and then creates\n  // a matrix (result) which can be used to help reduce it\n\n  const tolerance = CesiumMath.EPSILON15;\n\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n\n  // find pivot (rotAxis) based on max diagonal of matrix\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(\n      matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])],\n    );\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  let c = 1.0;\n  let s = 0.0;\n\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n\n  if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[Matrix3.getElementIndex(q, q)];\n    const pp = matrix[Matrix3.getElementIndex(p, p)];\n    const qp = matrix[Matrix3.getElementIndex(q, p)];\n\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  result = Matrix3.clone(Matrix3.IDENTITY, result);\n\n  result[Matrix3.getElementIndex(p, p)] = result[\n    Matrix3.getElementIndex(q, q)\n  ] = c;\n  result[Matrix3.getElementIndex(q, p)] = s;\n  result[Matrix3.getElementIndex(p, q)] = -s;\n\n  return result;\n}\n\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\n\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n * <p>\n * Returns a diagonal matrix and unitary matrix such that:\n * <code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>\n * </p>\n * <p>\n * The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * </p>\n *\n * @param {Matrix3} matrix The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param {object} [result] An object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns {object} An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * const a = //... symetric matrix\n * const result = {\n *     unitary : new Cesium.Matrix3(),\n *     diagonal : new Cesium.Matrix3()\n * };\n * Cesium.Matrix3.computeEigenDecomposition(a, result);\n *\n * const unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());\n * const b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());\n * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * const lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue\n * const v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector\n * const c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)\n */\nMatrix3.computeEigenDecomposition = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n  // section 8.4.3 The Classical Jacobi Algorithm\n\n  const tolerance = CesiumMath.EPSILON20;\n  const maxSweeps = 10;\n\n  let count = 0;\n  let sweep = 0;\n\n  if (!defined(result)) {\n    result = {};\n  }\n\n  const unitaryMatrix = (result.unitary = Matrix3.clone(\n    Matrix3.IDENTITY,\n    result.unitary,\n  ));\n  const diagMatrix = (result.diagonal = Matrix3.clone(matrix, result.diagonal));\n\n  const epsilon = tolerance * computeFrobeniusNorm(diagMatrix);\n\n  while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {\n    shurDecomposition(diagMatrix, jMatrix);\n    Matrix3.transpose(jMatrix, jMatrixTranspose);\n    Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);\n    Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);\n    Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix3} matrix The matrix with signed elements.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n  result[4] = Math.abs(matrix[4]);\n  result[5] = Math.abs(matrix[5]);\n  result[6] = Math.abs(matrix[6]);\n  result[7] = Math.abs(matrix[7]);\n  result[8] = Math.abs(matrix[8]);\n\n  return result;\n};\n\n/**\n * Computes the determinant of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @returns {number} The value of the determinant of the matrix.\n */\nMatrix3.determinant = function (matrix) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  const m11 = matrix[0];\n  const m21 = matrix[3];\n  const m31 = matrix[6];\n  const m12 = matrix[1];\n  const m22 = matrix[4];\n  const m32 = matrix[7];\n  const m13 = matrix[2];\n  const m23 = matrix[5];\n  const m33 = matrix[8];\n\n  return (\n    m11 * (m22 * m33 - m23 * m32) +\n    m12 * (m23 * m31 - m21 * m33) +\n    m13 * (m21 * m32 - m22 * m31)\n  );\n};\n\n/**\n * Computes the inverse of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to invert.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} matrix is not invertible.\n */\nMatrix3.inverse = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const m11 = matrix[0];\n  const m21 = matrix[1];\n  const m31 = matrix[2];\n  const m12 = matrix[3];\n  const m22 = matrix[4];\n  const m32 = matrix[5];\n  const m13 = matrix[6];\n  const m23 = matrix[7];\n  const m33 = matrix[8];\n\n  const determinant = Matrix3.determinant(matrix);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (Math.abs(determinant) <= CesiumMath.EPSILON15) {\n    throw new DeveloperError(\"matrix is not invertible\");\n  }\n  //>>includeEnd('debug');\n\n  result[0] = m22 * m33 - m23 * m32;\n  result[1] = m23 * m31 - m21 * m33;\n  result[2] = m21 * m32 - m22 * m31;\n  result[3] = m13 * m32 - m12 * m33;\n  result[4] = m11 * m33 - m13 * m31;\n  result[5] = m12 * m31 - m11 * m32;\n  result[6] = m12 * m23 - m13 * m22;\n  result[7] = m13 * m21 - m11 * m23;\n  result[8] = m11 * m22 - m12 * m21;\n\n  const scale = 1.0 / determinant;\n  return Matrix3.multiplyByScalar(result, scale, result);\n};\n\nconst scratchTransposeMatrix = new Matrix3();\n\n/**\n * Computes the inverse transpose of a matrix.\n *\n * @param {Matrix3} matrix The matrix to transpose and invert.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.inverseTranspose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  return Matrix3.inverse(\n    Matrix3.transpose(matrix, scratchTransposeMatrix),\n    result,\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix3} [left] The first matrix.\n * @param {Matrix3} [right] The second matrix.\n * @returns {boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nMatrix3.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left[0] === right[0] &&\n      left[1] === right[1] &&\n      left[2] === right[2] &&\n      left[3] === right[3] &&\n      left[4] === right[4] &&\n      left[5] === right[5] &&\n      left[6] === right[6] &&\n      left[7] === right[7] &&\n      left[8] === right[8])\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix3} [left] The first matrix.\n * @param {Matrix3} [right] The second matrix.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix3.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left[0] - right[0]) <= epsilon &&\n      Math.abs(left[1] - right[1]) <= epsilon &&\n      Math.abs(left[2] - right[2]) <= epsilon &&\n      Math.abs(left[3] - right[3]) <= epsilon &&\n      Math.abs(left[4] - right[4]) <= epsilon &&\n      Math.abs(left[5] - right[5]) <= epsilon &&\n      Math.abs(left[6] - right[6]) <= epsilon &&\n      Math.abs(left[7] - right[7]) <= epsilon &&\n      Math.abs(left[8] - right[8]) <= epsilon)\n  );\n};\n\n/**\n * An immutable Matrix3 instance initialized to the identity matrix.\n *\n * @type {Matrix3}\n * @constant\n */\nMatrix3.IDENTITY = Object.freeze(\n  new Matrix3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0),\n);\n\n/**\n * An immutable Matrix3 instance initialized to the zero matrix.\n *\n * @type {Matrix3}\n * @constant\n */\nMatrix3.ZERO = Object.freeze(\n  new Matrix3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0),\n);\n\n/**\n * The index into Matrix3 for column 0, row 0.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix3 for column 0, row 1.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix3 for column 0, row 2.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN0ROW2 = 2;\n\n/**\n * The index into Matrix3 for column 1, row 0.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN1ROW0 = 3;\n\n/**\n * The index into Matrix3 for column 1, row 1.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN1ROW1 = 4;\n\n/**\n * The index into Matrix3 for column 1, row 2.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN1ROW2 = 5;\n\n/**\n * The index into Matrix3 for column 2, row 0.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN2ROW0 = 6;\n\n/**\n * The index into Matrix3 for column 2, row 1.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN2ROW1 = 7;\n\n/**\n * The index into Matrix3 for column 2, row 2.\n *\n * @type {number}\n * @constant\n */\nMatrix3.COLUMN2ROW2 = 8;\n\nObject.defineProperties(Matrix3.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix3.prototype\n   *\n   * @type {number}\n   */\n  length: {\n    get: function () {\n      return Matrix3.packedLength;\n    },\n  },\n});\n\n/**\n * Duplicates the provided Matrix3 instance.\n *\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n */\nMatrix3.prototype.clone = function (result) {\n  return Matrix3.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix3} [right] The right hand side matrix.\n * @returns {boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix3.prototype.equals = function (right) {\n  return Matrix3.equals(this, right);\n};\n\n/**\n * @private\n */\nMatrix3.equalsArray = function (matrix, array, offset) {\n  return (\n    matrix[0] === array[offset] &&\n    matrix[1] === array[offset + 1] &&\n    matrix[2] === array[offset + 2] &&\n    matrix[3] === array[offset + 3] &&\n    matrix[4] === array[offset + 4] &&\n    matrix[5] === array[offset + 5] &&\n    matrix[6] === array[offset + 6] &&\n    matrix[7] === array[offset + 7] &&\n    matrix[8] === array[offset + 8]\n  );\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix3} [right] The right hand side matrix.\n * @param {number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix3.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix3.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1, column2)'.\n *\n * @returns {string} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.\n */\nMatrix3.prototype.toString = function () {\n  return (\n    `(${this[0]}, ${this[3]}, ${this[6]})\\n` +\n    `(${this[1]}, ${this[4]}, ${this[7]})\\n` +\n    `(${this[2]}, ${this[5]}, ${this[8]})`\n  );\n};\nexport default Matrix3;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}