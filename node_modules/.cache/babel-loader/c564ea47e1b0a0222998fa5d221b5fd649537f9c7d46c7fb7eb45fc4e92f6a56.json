{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useLocationInfo.js\nimport { useState, useEffect, useRef } from 'react';\nimport { debounce } from 'lodash';\nimport PropTypes from 'prop-types';\n\n/**\n * Custom hook to manage location information based on Cesium camera movements.\n *\n * @param {Cesium.Viewer} viewer - The Cesium Viewer instance.\n * @param {Function} reverseGeocode - Function to perform reverse geocoding.\n * @returns {Object} - Contains locationInfo, loading, and error states.\n */\nconst useLocationInfo = (viewer, Cesium, reverseGeocode) => {\n  _s();\n  const [locationInfo, setLocationInfo] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const handleCameraMoveEnd = useRef(null);\n  useEffect(() => {\n    if (!viewer || !Cesium || !reverseGeocode) return;\n\n    // Debounced function to handle camera move end\n    handleCameraMoveEnd.current = debounce(async () => {\n      setLoading(true);\n      setError(null);\n      const camera = viewer.camera;\n      const ellipsoid = viewer.scene.globe.ellipsoid;\n\n      // Get camera position in cartesian coordinates\n      const cartesian = camera.positionWC;\n\n      // Convert to cartographic (longitude, latitude, height)\n      const cartographic = Cesium.Cartographic.fromCartesian(cartesian, ellipsoid);\n      const longitude = Cesium.Math.toDegrees(cartographic.longitude).toFixed(6);\n      const latitude = Cesium.Math.toDegrees(cartographic.latitude).toFixed(6);\n      const height = cartographic.height.toFixed(2);\n\n      // Determine zoom level based on height\n      let zoomLevel;\n      if (height < 1000) {\n        zoomLevel = 'Very High';\n      } else if (height < 5000) {\n        zoomLevel = 'High';\n      } else if (height < 20000) {\n        zoomLevel = 'Medium';\n      } else {\n        zoomLevel = 'Low';\n      }\n      try {\n        const address = await reverseGeocode(latitude, longitude);\n        setLocationInfo({\n          longitude,\n          latitude,\n          height,\n          zoomLevel,\n          address\n        });\n      } catch (err) {\n        console.error('Reverse geocoding failed:', err);\n        setError('Failed to fetch address');\n        setLocationInfo({\n          longitude,\n          latitude,\n          height,\n          zoomLevel,\n          address: 'Unknown'\n        });\n      } finally {\n        setLoading(false);\n      }\n    }, 500); // 500ms debounce delay\n\n    // Attach event listener\n    viewer.camera.moveEnd.addEventListener(handleCameraMoveEnd.current);\n\n    // Initial fetch\n    handleCameraMoveEnd.current();\n\n    // Cleanup function\n    return () => {\n      viewer.camera.moveEnd.removeEventListener(handleCameraMoveEnd.current);\n      handleCameraMoveEnd.current.cancel();\n    };\n  }, [viewer, Cesium, reverseGeocode]);\n  return {\n    locationInfo,\n    loading,\n    error\n  };\n};\n_s(useLocationInfo, \"pjkE1rAieKkE75zQ/1wW42NMt+A=\");\nuseLocationInfo.propTypes = {\n  viewer: PropTypes.object.isRequired,\n  Cesium: PropTypes.object.isRequired,\n  reverseGeocode: PropTypes.func.isRequired\n};\nexport default useLocationInfo;","map":{"version":3,"names":["useState","useEffect","useRef","debounce","PropTypes","useLocationInfo","viewer","Cesium","reverseGeocode","_s","locationInfo","setLocationInfo","loading","setLoading","error","setError","handleCameraMoveEnd","current","camera","ellipsoid","scene","globe","cartesian","positionWC","cartographic","Cartographic","fromCartesian","longitude","Math","toDegrees","toFixed","latitude","height","zoomLevel","address","err","console","moveEnd","addEventListener","removeEventListener","cancel","propTypes","object","isRequired","func"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/src/components/hooks/useLocationInfo.js"],"sourcesContent":["// src/hooks/useLocationInfo.js\nimport { useState, useEffect, useRef } from 'react';\nimport { debounce } from 'lodash';\nimport PropTypes from 'prop-types';\n\n/**\n * Custom hook to manage location information based on Cesium camera movements.\n *\n * @param {Cesium.Viewer} viewer - The Cesium Viewer instance.\n * @param {Function} reverseGeocode - Function to perform reverse geocoding.\n * @returns {Object} - Contains locationInfo, loading, and error states.\n */\nconst useLocationInfo = (viewer, Cesium, reverseGeocode) => {\n  const [locationInfo, setLocationInfo] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const handleCameraMoveEnd = useRef(null);\n\n  useEffect(() => {\n    if (!viewer || !Cesium || !reverseGeocode) return;\n\n    // Debounced function to handle camera move end\n    handleCameraMoveEnd.current = debounce(async () => {\n      setLoading(true);\n      setError(null);\n      const camera = viewer.camera;\n      const ellipsoid = viewer.scene.globe.ellipsoid;\n\n      // Get camera position in cartesian coordinates\n      const cartesian = camera.positionWC;\n\n      // Convert to cartographic (longitude, latitude, height)\n      const cartographic = Cesium.Cartographic.fromCartesian(cartesian, ellipsoid);\n\n      const longitude = Cesium.Math.toDegrees(cartographic.longitude).toFixed(6);\n      const latitude = Cesium.Math.toDegrees(cartographic.latitude).toFixed(6);\n      const height = cartographic.height.toFixed(2);\n\n      // Determine zoom level based on height\n      let zoomLevel;\n      if (height < 1000) {\n        zoomLevel = 'Very High';\n      } else if (height < 5000) {\n        zoomLevel = 'High';\n      } else if (height < 20000) {\n        zoomLevel = 'Medium';\n      } else {\n        zoomLevel = 'Low';\n      }\n\n      try {\n        const address = await reverseGeocode(latitude, longitude);\n        setLocationInfo({\n          longitude,\n          latitude,\n          height,\n          zoomLevel,\n          address,\n        });\n      } catch (err) {\n        console.error('Reverse geocoding failed:', err);\n        setError('Failed to fetch address');\n        setLocationInfo({\n          longitude,\n          latitude,\n          height,\n          zoomLevel,\n          address: 'Unknown',\n        });\n      } finally {\n        setLoading(false);\n      }\n    }, 500); // 500ms debounce delay\n\n    // Attach event listener\n    viewer.camera.moveEnd.addEventListener(handleCameraMoveEnd.current);\n\n    // Initial fetch\n    handleCameraMoveEnd.current();\n\n    // Cleanup function\n    return () => {\n      viewer.camera.moveEnd.removeEventListener(handleCameraMoveEnd.current);\n      handleCameraMoveEnd.current.cancel();\n    };\n  }, [viewer, Cesium, reverseGeocode]);\n\n  return { locationInfo, loading, error };\n};\n\nuseLocationInfo.propTypes = {\n  viewer: PropTypes.object.isRequired,\n  Cesium: PropTypes.object.isRequired,\n  reverseGeocode: PropTypes.func.isRequired,\n};\n\nexport default useLocationInfo;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}