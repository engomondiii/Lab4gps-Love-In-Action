{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Cesium3DTilesetMetadata from \"./Cesium3DTilesetMetadata.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport ImplicitSubtree from \"./ImplicitSubtree.js\";\nimport ImplicitSubtreeCache from \"./ImplicitSubtreeCache.js\";\nimport ImplicitTileCoordinates from \"./ImplicitTileCoordinates.js\";\nimport ImplicitTileset from \"./ImplicitTileset.js\";\nimport MetadataSemantic from \"./MetadataSemantic.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport preprocess3DTileContent from \"./preprocess3DTileContent.js\";\nimport ResourceCache from \"./ResourceCache.js\";\nimport VoxelBoxShape from \"./VoxelBoxShape.js\";\nimport VoxelContent from \"./VoxelContent.js\";\nimport VoxelCylinderShape from \"./VoxelCylinderShape.js\";\nimport VoxelShapeType from \"./VoxelShapeType.js\";\n\n/**\n * A {@link VoxelProvider} that fetches voxel data from a 3D Tiles tileset.\n * <p>\n * Implements the {@link VoxelProvider} interface.\n * </p>\n * <div class=\"notice\">\n * This object is normally not instantiated directly, use {@link Cesium3DTilesVoxelProvider.fromUrl}.\n * </div>\n *\n * @alias Cesium3DTilesVoxelProvider\n * @constructor\n * @augments VoxelProvider\n *\n * @param {object} options Object with the following properties:\n *\n * @see Cesium3DTilesVoxelProvider.fromUrl\n * @see VoxelProvider\n * @see VoxelPrimitive\n * @see VoxelShapeType\n *\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction Cesium3DTilesVoxelProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /** @inheritdoc */\n  this.shapeTransform = undefined;\n\n  /** @inheritdoc */\n  this.globalTransform = undefined;\n\n  /** @inheritdoc */\n  this.shape = undefined;\n\n  /** @inheritdoc */\n  this.minBounds = undefined;\n\n  /** @inheritdoc */\n  this.maxBounds = undefined;\n\n  /** @inheritdoc */\n  this.dimensions = undefined;\n\n  /** @inheritdoc */\n  this.paddingBefore = undefined;\n\n  /** @inheritdoc */\n  this.paddingAfter = undefined;\n\n  /** @inheritdoc */\n  this.names = undefined;\n\n  /** @inheritdoc */\n  this.types = undefined;\n\n  /** @inheritdoc */\n  this.componentTypes = undefined;\n\n  /** @inheritdoc */\n  this.minimumValues = undefined;\n\n  /** @inheritdoc */\n  this.maximumValues = undefined;\n\n  /** @inheritdoc */\n  this.maximumTileCount = undefined;\n  this._implicitTileset = undefined;\n  this._subtreeCache = new ImplicitSubtreeCache();\n}\n\n/**\n * Creates a {@link VoxelProvider} that fetches voxel data from a 3D Tiles tileset.\n *\n * @param {Resource|string} url The URL to a tileset JSON file\n * @returns {Promise<Cesium3DTilesVoxelProvider>} The created provider\n *\n * @exception {RuntimeException} Root must have content\n * @exception {RuntimeException} Root tile content must have 3DTILES_content_voxels extension\n * @exception {RuntimeException} Root tile must have implicit tiling\n * @exception {RuntimeException} Tileset must have a metadata schema\n * @exception {RuntimeException} Only box, region and 3DTILES_bounding_volume_cylinder are supported in Cesium3DTilesVoxelProvider\n */\nCesium3DTilesVoxelProvider.fromUrl = async function (url) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  const resource = Resource.createIfNeeded(url);\n  const tilesetJson = await resource.fetchJson();\n  validate(tilesetJson);\n  const schemaLoader = getMetadataSchemaLoader(tilesetJson, resource);\n  await schemaLoader.load();\n  const root = tilesetJson.root;\n  const voxel = root.content.extensions[\"3DTILES_content_voxels\"];\n  const className = voxel.class;\n  const metadataJson = hasExtension(tilesetJson, \"3DTILES_metadata\") ? tilesetJson.extensions[\"3DTILES_metadata\"] : tilesetJson;\n  const metadataSchema = schemaLoader.schema;\n  const metadata = new Cesium3DTilesetMetadata({\n    metadataJson: metadataJson,\n    schema: metadataSchema\n  });\n  const provider = new Cesium3DTilesVoxelProvider();\n  addAttributeInfo(provider, metadata, className);\n  const implicitTileset = new ImplicitTileset(resource, root, metadataSchema);\n  const {\n    shape,\n    minBounds,\n    maxBounds,\n    shapeTransform,\n    globalTransform\n  } = getShape(root);\n  provider.shape = shape;\n  provider.minBounds = minBounds;\n  provider.maxBounds = maxBounds;\n  provider.dimensions = Cartesian3.unpack(voxel.dimensions);\n  provider.shapeTransform = shapeTransform;\n  provider.globalTransform = globalTransform;\n  provider.maximumTileCount = getTileCount(metadata);\n  let paddingBefore;\n  let paddingAfter;\n  if (defined(voxel.padding)) {\n    paddingBefore = Cartesian3.unpack(voxel.padding.before);\n    paddingAfter = Cartesian3.unpack(voxel.padding.after);\n  }\n  provider.paddingBefore = paddingBefore;\n  provider.paddingAfter = paddingAfter;\n  provider._implicitTileset = implicitTileset;\n  ResourceCache.unload(schemaLoader);\n  return provider;\n};\nfunction getTileCount(metadata) {\n  if (!defined(metadata.tileset)) {\n    return undefined;\n  }\n  return metadata.tileset.getPropertyBySemantic(MetadataSemantic.TILESET_TILE_COUNT);\n}\nfunction validate(tileset) {\n  const root = tileset.root;\n  if (!defined(root.content)) {\n    throw new RuntimeError(\"Root must have content\");\n  }\n  if (!hasExtension(root.content, \"3DTILES_content_voxels\")) {\n    throw new RuntimeError(\"Root tile content must have 3DTILES_content_voxels extension\");\n  }\n  if (!hasExtension(root, \"3DTILES_implicit_tiling\") && !defined(root.implicitTiling)) {\n    throw new RuntimeError(\"Root tile must have implicit tiling\");\n  }\n  if (!defined(tileset.schema) && !defined(tileset.schemaUri) && !hasExtension(tileset, \"3DTILES_metadata\")) {\n    throw new RuntimeError(\"Tileset must have a metadata schema\");\n  }\n}\nfunction getShape(tile) {\n  const boundingVolume = tile.boundingVolume;\n  let tileTransform;\n  if (defined(tile.transform)) {\n    tileTransform = Matrix4.unpack(tile.transform);\n  } else {\n    tileTransform = Matrix4.clone(Matrix4.IDENTITY);\n  }\n  if (defined(boundingVolume.box)) {\n    return getBoxShape(boundingVolume.box, tileTransform);\n  } else if (defined(boundingVolume.region)) {\n    return getEllipsoidShape(boundingVolume.region);\n  } else if (hasExtension(boundingVolume, \"3DTILES_bounding_volume_cylinder\")) {\n    return getCylinderShape(boundingVolume.extensions[\"3DTILES_bounding_volume_cylinder\"].cylinder, tileTransform);\n  }\n  throw new RuntimeError(\"Only box, region and 3DTILES_bounding_volume_cylinder are supported in Cesium3DTilesVoxelProvider\");\n}\nfunction getEllipsoidShape(region) {\n  const west = region[0];\n  const south = region[1];\n  const east = region[2];\n  const north = region[3];\n  const minHeight = region[4];\n  const maxHeight = region[5];\n  const shapeTransform = Matrix4.fromScale(Ellipsoid.WGS84.radii);\n  const minBounds = new Cartesian3(west, south, minHeight);\n  const maxBounds = new Cartesian3(east, north, maxHeight);\n  return {\n    shape: VoxelShapeType.ELLIPSOID,\n    minBounds: minBounds,\n    maxBounds: maxBounds,\n    shapeTransform: shapeTransform,\n    globalTransform: Matrix4.clone(Matrix4.IDENTITY)\n  };\n}\nfunction getBoxShape(box, tileTransform) {\n  const obb = OrientedBoundingBox.unpack(box);\n  const shapeTransform = Matrix4.fromRotationTranslation(obb.halfAxes, obb.center);\n  return {\n    shape: VoxelShapeType.BOX,\n    minBounds: Cartesian3.clone(VoxelBoxShape.DefaultMinBounds),\n    maxBounds: Cartesian3.clone(VoxelBoxShape.DefaultMaxBounds),\n    shapeTransform: shapeTransform,\n    globalTransform: tileTransform\n  };\n}\nfunction getCylinderShape(cylinder, tileTransform) {\n  const obb = OrientedBoundingBox.unpack(cylinder);\n  const shapeTransform = Matrix4.fromRotationTranslation(obb.halfAxes, obb.center);\n  return {\n    shape: VoxelShapeType.CYLINDER,\n    minBounds: Cartesian3.clone(VoxelCylinderShape.DefaultMinBounds),\n    maxBounds: Cartesian3.clone(VoxelCylinderShape.DefaultMaxBounds),\n    shapeTransform: shapeTransform,\n    globalTransform: tileTransform\n  };\n}\nfunction getMetadataSchemaLoader(tilesetJson, resource) {\n  const {\n    schemaUri,\n    schema\n  } = tilesetJson;\n  if (!defined(schemaUri)) {\n    return ResourceCache.getSchemaLoader({\n      schema\n    });\n  }\n  return ResourceCache.getSchemaLoader({\n    resource: resource.getDerivedResource({\n      url: schemaUri\n    })\n  });\n}\nfunction addAttributeInfo(provider, metadata, className) {\n  const {\n    schema,\n    statistics\n  } = metadata;\n  const classStatistics = statistics?.classes[className];\n  const properties = schema.classes[className].properties;\n  const propertyInfo = Object.entries(properties).map(([id, property]) => {\n    const {\n      type,\n      componentType\n    } = property;\n    const min = classStatistics?.properties[id].min;\n    const max = classStatistics?.properties[id].max;\n    const componentCount = MetadataType.getComponentCount(type);\n    const minValue = copyArray(min, componentCount);\n    const maxValue = copyArray(max, componentCount);\n    return {\n      id,\n      type,\n      componentType,\n      minValue,\n      maxValue\n    };\n  });\n  provider.names = propertyInfo.map(info => info.id);\n  provider.types = propertyInfo.map(info => info.type);\n  provider.componentTypes = propertyInfo.map(info => info.componentType);\n  const minimumValues = propertyInfo.map(info => info.minValue);\n  const maximumValues = propertyInfo.map(info => info.maxValue);\n  const hasMinimumValues = minimumValues.some(defined);\n  provider.minimumValues = hasMinimumValues ? minimumValues : undefined;\n  provider.maximumValues = hasMinimumValues ? maximumValues : undefined;\n}\nfunction copyArray(values, length) {\n  // Copy input values into a new array of a specified length.\n  // If the input is not an array, its value will be copied into the first element\n  // of the returned array. If the input is an array shorter than the returned\n  // array, the extra elements in the returned array will be undefined. If the\n  // input is undefined, the return will be undefined.\n  if (!defined(values)) {\n    return;\n  }\n  const valuesArray = Array.isArray(values) ? values : [values];\n  return Array.from({\n    length\n  }, (v, i) => valuesArray[i]);\n}\nasync function getVoxelContent(implicitTileset, tileCoordinates) {\n  const voxelRelative = implicitTileset.contentUriTemplates[0].getDerivedResource({\n    templateValues: tileCoordinates.getTemplateValues()\n  });\n  const voxelResource = implicitTileset.baseResource.getDerivedResource({\n    url: voxelRelative.url\n  });\n  const arrayBuffer = await voxelResource.fetchArrayBuffer();\n  const preprocessed = preprocess3DTileContent(arrayBuffer);\n  const voxelContent = await VoxelContent.fromJson(voxelResource, preprocessed.jsonPayload, preprocessed.binaryPayload, implicitTileset.metadataSchema);\n  return voxelContent;\n}\nasync function getSubtreePromise(provider, subtreeCoord) {\n  const implicitTileset = provider._implicitTileset;\n  const subtreeCache = provider._subtreeCache;\n\n  // First load the subtree to check if the tile is available.\n  // If the subtree has been requested previously it might still be in the cache\n  let subtree = subtreeCache.find(subtreeCoord);\n  if (defined(subtree)) {\n    return subtree;\n  }\n  const subtreeRelative = implicitTileset.subtreeUriTemplate.getDerivedResource({\n    templateValues: subtreeCoord.getTemplateValues()\n  });\n  const subtreeResource = implicitTileset.baseResource.getDerivedResource({\n    url: subtreeRelative.url\n  });\n  const arrayBuffer = await subtreeResource.fetchArrayBuffer();\n  // Check one more time if the subtree is in the cache.\n  // This could happen if there are two in-flight tile requests from the same\n  // subtree and one finishes before the other.\n  subtree = subtreeCache.find(subtreeCoord);\n  if (defined(subtree)) {\n    return subtree;\n  }\n  const preprocessed = preprocess3DTileContent(arrayBuffer);\n  subtree = await ImplicitSubtree.fromSubtreeJson(subtreeResource, preprocessed.jsonPayload, preprocessed.binaryPayload, implicitTileset, subtreeCoord);\n  subtreeCache.addSubtree(subtree);\n  return subtree;\n}\n\n/** @inheritdoc */\nCesium3DTilesVoxelProvider.prototype.requestData = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const tileLevel = defaultValue(options.tileLevel, 0);\n  const tileX = defaultValue(options.tileX, 0);\n  const tileY = defaultValue(options.tileY, 0);\n  const tileZ = defaultValue(options.tileZ, 0);\n  const keyframe = defaultValue(options.keyframe, 0);\n\n  // 3D Tiles currently doesn't support time-dynamic data.\n  if (keyframe !== 0) {\n    return undefined;\n  }\n\n  // 1. Load the subtree that the tile belongs to (possibly from the subtree cache)\n  // 2. Load the voxel content if available\n\n  const implicitTileset = this._implicitTileset;\n  const names = this.names;\n\n  // Can't use a scratch variable here because the object is used inside the promise chain.\n  const tileCoordinates = new ImplicitTileCoordinates({\n    subdivisionScheme: implicitTileset.subdivisionScheme,\n    subtreeLevels: implicitTileset.subtreeLevels,\n    level: tileLevel,\n    x: tileX,\n    y: tileY,\n    z: tileZ\n  });\n\n  // Find the coordinates of the parent subtree containing tileCoordinates\n  // If tileCoordinates is a subtree child, use that subtree\n  // If tileCoordinates is a subtree root, use its parent subtree\n  const isSubtreeRoot = tileCoordinates.isSubtreeRoot() && tileCoordinates.level > 0;\n  const subtreeCoord = isSubtreeRoot ? tileCoordinates.getParentSubtreeCoordinates() : tileCoordinates.getSubtreeCoordinates();\n  const that = this;\n  return getSubtreePromise(that, subtreeCoord).then(function (subtree) {\n    const available = isSubtreeRoot ? subtree.childSubtreeIsAvailableAtCoordinates(tileCoordinates) : subtree.tileIsAvailableAtCoordinates(tileCoordinates);\n    if (!available) {\n      return Promise.reject(\"Tile is not available\");\n    }\n    return getVoxelContent(implicitTileset, tileCoordinates);\n  }).then(function (voxelContent) {\n    return names.map(function (name) {\n      return voxelContent.metadataTable.getPropertyTypedArray(name);\n    });\n  });\n};\nexport default Cesium3DTilesVoxelProvider;","map":{"version":3,"names":["Cartesian3","Check","defaultValue","defined","Ellipsoid","Matrix4","OrientedBoundingBox","Resource","RuntimeError","Cesium3DTilesetMetadata","hasExtension","ImplicitSubtree","ImplicitSubtreeCache","ImplicitTileCoordinates","ImplicitTileset","MetadataSemantic","MetadataType","preprocess3DTileContent","ResourceCache","VoxelBoxShape","VoxelContent","VoxelCylinderShape","VoxelShapeType","Cesium3DTilesVoxelProvider","options","EMPTY_OBJECT","shapeTransform","undefined","globalTransform","shape","minBounds","maxBounds","dimensions","paddingBefore","paddingAfter","names","types","componentTypes","minimumValues","maximumValues","maximumTileCount","_implicitTileset","_subtreeCache","fromUrl","url","resource","createIfNeeded","tilesetJson","fetchJson","validate","schemaLoader","getMetadataSchemaLoader","load","root","voxel","content","extensions","className","class","metadataJson","metadataSchema","schema","metadata","provider","addAttributeInfo","implicitTileset","getShape","unpack","getTileCount","padding","before","after","unload","tileset","getPropertyBySemantic","TILESET_TILE_COUNT","implicitTiling","schemaUri","tile","boundingVolume","tileTransform","transform","clone","IDENTITY","box","getBoxShape","region","getEllipsoidShape","getCylinderShape","cylinder","west","south","east","north","minHeight","maxHeight","fromScale","WGS84","radii","ELLIPSOID","obb","fromRotationTranslation","halfAxes","center","BOX","DefaultMinBounds","DefaultMaxBounds","CYLINDER","getSchemaLoader","getDerivedResource","statistics","classStatistics","classes","properties","propertyInfo","Object","entries","map","id","property","type","componentType","min","max","componentCount","getComponentCount","minValue","copyArray","maxValue","info","hasMinimumValues","some","values","length","valuesArray","Array","isArray","from","v","i","getVoxelContent","tileCoordinates","voxelRelative","contentUriTemplates","templateValues","getTemplateValues","voxelResource","baseResource","arrayBuffer","fetchArrayBuffer","preprocessed","voxelContent","fromJson","jsonPayload","binaryPayload","getSubtreePromise","subtreeCoord","subtreeCache","subtree","find","subtreeRelative","subtreeUriTemplate","subtreeResource","fromSubtreeJson","addSubtree","prototype","requestData","tileLevel","tileX","tileY","tileZ","keyframe","subdivisionScheme","subtreeLevels","level","x","y","z","isSubtreeRoot","getParentSubtreeCoordinates","getSubtreeCoordinates","that","then","available","childSubtreeIsAvailableAtCoordinates","tileIsAvailableAtCoordinates","Promise","reject","name","metadataTable","getPropertyTypedArray"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/Cesium3DTilesVoxelProvider.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Cesium3DTilesetMetadata from \"./Cesium3DTilesetMetadata.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport ImplicitSubtree from \"./ImplicitSubtree.js\";\nimport ImplicitSubtreeCache from \"./ImplicitSubtreeCache.js\";\nimport ImplicitTileCoordinates from \"./ImplicitTileCoordinates.js\";\nimport ImplicitTileset from \"./ImplicitTileset.js\";\nimport MetadataSemantic from \"./MetadataSemantic.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport preprocess3DTileContent from \"./preprocess3DTileContent.js\";\nimport ResourceCache from \"./ResourceCache.js\";\nimport VoxelBoxShape from \"./VoxelBoxShape.js\";\nimport VoxelContent from \"./VoxelContent.js\";\nimport VoxelCylinderShape from \"./VoxelCylinderShape.js\";\nimport VoxelShapeType from \"./VoxelShapeType.js\";\n\n/**\n * A {@link VoxelProvider} that fetches voxel data from a 3D Tiles tileset.\n * <p>\n * Implements the {@link VoxelProvider} interface.\n * </p>\n * <div class=\"notice\">\n * This object is normally not instantiated directly, use {@link Cesium3DTilesVoxelProvider.fromUrl}.\n * </div>\n *\n * @alias Cesium3DTilesVoxelProvider\n * @constructor\n * @augments VoxelProvider\n *\n * @param {object} options Object with the following properties:\n *\n * @see Cesium3DTilesVoxelProvider.fromUrl\n * @see VoxelProvider\n * @see VoxelPrimitive\n * @see VoxelShapeType\n *\n * @experimental This feature is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction Cesium3DTilesVoxelProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /** @inheritdoc */\n  this.shapeTransform = undefined;\n\n  /** @inheritdoc */\n  this.globalTransform = undefined;\n\n  /** @inheritdoc */\n  this.shape = undefined;\n\n  /** @inheritdoc */\n  this.minBounds = undefined;\n\n  /** @inheritdoc */\n  this.maxBounds = undefined;\n\n  /** @inheritdoc */\n  this.dimensions = undefined;\n\n  /** @inheritdoc */\n  this.paddingBefore = undefined;\n\n  /** @inheritdoc */\n  this.paddingAfter = undefined;\n\n  /** @inheritdoc */\n  this.names = undefined;\n\n  /** @inheritdoc */\n  this.types = undefined;\n\n  /** @inheritdoc */\n  this.componentTypes = undefined;\n\n  /** @inheritdoc */\n  this.minimumValues = undefined;\n\n  /** @inheritdoc */\n  this.maximumValues = undefined;\n\n  /** @inheritdoc */\n  this.maximumTileCount = undefined;\n\n  this._implicitTileset = undefined;\n  this._subtreeCache = new ImplicitSubtreeCache();\n}\n\n/**\n * Creates a {@link VoxelProvider} that fetches voxel data from a 3D Tiles tileset.\n *\n * @param {Resource|string} url The URL to a tileset JSON file\n * @returns {Promise<Cesium3DTilesVoxelProvider>} The created provider\n *\n * @exception {RuntimeException} Root must have content\n * @exception {RuntimeException} Root tile content must have 3DTILES_content_voxels extension\n * @exception {RuntimeException} Root tile must have implicit tiling\n * @exception {RuntimeException} Tileset must have a metadata schema\n * @exception {RuntimeException} Only box, region and 3DTILES_bounding_volume_cylinder are supported in Cesium3DTilesVoxelProvider\n */\nCesium3DTilesVoxelProvider.fromUrl = async function (url) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  const resource = Resource.createIfNeeded(url);\n  const tilesetJson = await resource.fetchJson();\n\n  validate(tilesetJson);\n\n  const schemaLoader = getMetadataSchemaLoader(tilesetJson, resource);\n  await schemaLoader.load();\n\n  const root = tilesetJson.root;\n  const voxel = root.content.extensions[\"3DTILES_content_voxels\"];\n  const className = voxel.class;\n\n  const metadataJson = hasExtension(tilesetJson, \"3DTILES_metadata\")\n    ? tilesetJson.extensions[\"3DTILES_metadata\"]\n    : tilesetJson;\n\n  const metadataSchema = schemaLoader.schema;\n  const metadata = new Cesium3DTilesetMetadata({\n    metadataJson: metadataJson,\n    schema: metadataSchema,\n  });\n\n  const provider = new Cesium3DTilesVoxelProvider();\n\n  addAttributeInfo(provider, metadata, className);\n\n  const implicitTileset = new ImplicitTileset(resource, root, metadataSchema);\n\n  const { shape, minBounds, maxBounds, shapeTransform, globalTransform } =\n    getShape(root);\n\n  provider.shape = shape;\n  provider.minBounds = minBounds;\n  provider.maxBounds = maxBounds;\n  provider.dimensions = Cartesian3.unpack(voxel.dimensions);\n  provider.shapeTransform = shapeTransform;\n  provider.globalTransform = globalTransform;\n  provider.maximumTileCount = getTileCount(metadata);\n\n  let paddingBefore;\n  let paddingAfter;\n\n  if (defined(voxel.padding)) {\n    paddingBefore = Cartesian3.unpack(voxel.padding.before);\n    paddingAfter = Cartesian3.unpack(voxel.padding.after);\n  }\n\n  provider.paddingBefore = paddingBefore;\n  provider.paddingAfter = paddingAfter;\n\n  provider._implicitTileset = implicitTileset;\n\n  ResourceCache.unload(schemaLoader);\n\n  return provider;\n};\n\nfunction getTileCount(metadata) {\n  if (!defined(metadata.tileset)) {\n    return undefined;\n  }\n\n  return metadata.tileset.getPropertyBySemantic(\n    MetadataSemantic.TILESET_TILE_COUNT,\n  );\n}\n\nfunction validate(tileset) {\n  const root = tileset.root;\n\n  if (!defined(root.content)) {\n    throw new RuntimeError(\"Root must have content\");\n  }\n\n  if (!hasExtension(root.content, \"3DTILES_content_voxels\")) {\n    throw new RuntimeError(\n      \"Root tile content must have 3DTILES_content_voxels extension\",\n    );\n  }\n\n  if (\n    !hasExtension(root, \"3DTILES_implicit_tiling\") &&\n    !defined(root.implicitTiling)\n  ) {\n    throw new RuntimeError(\"Root tile must have implicit tiling\");\n  }\n\n  if (\n    !defined(tileset.schema) &&\n    !defined(tileset.schemaUri) &&\n    !hasExtension(tileset, \"3DTILES_metadata\")\n  ) {\n    throw new RuntimeError(\"Tileset must have a metadata schema\");\n  }\n}\n\nfunction getShape(tile) {\n  const boundingVolume = tile.boundingVolume;\n\n  let tileTransform;\n  if (defined(tile.transform)) {\n    tileTransform = Matrix4.unpack(tile.transform);\n  } else {\n    tileTransform = Matrix4.clone(Matrix4.IDENTITY);\n  }\n\n  if (defined(boundingVolume.box)) {\n    return getBoxShape(boundingVolume.box, tileTransform);\n  } else if (defined(boundingVolume.region)) {\n    return getEllipsoidShape(boundingVolume.region);\n  } else if (hasExtension(boundingVolume, \"3DTILES_bounding_volume_cylinder\")) {\n    return getCylinderShape(\n      boundingVolume.extensions[\"3DTILES_bounding_volume_cylinder\"].cylinder,\n      tileTransform,\n    );\n  }\n\n  throw new RuntimeError(\n    \"Only box, region and 3DTILES_bounding_volume_cylinder are supported in Cesium3DTilesVoxelProvider\",\n  );\n}\n\nfunction getEllipsoidShape(region) {\n  const west = region[0];\n  const south = region[1];\n  const east = region[2];\n  const north = region[3];\n  const minHeight = region[4];\n  const maxHeight = region[5];\n\n  const shapeTransform = Matrix4.fromScale(Ellipsoid.WGS84.radii);\n\n  const minBounds = new Cartesian3(west, south, minHeight);\n  const maxBounds = new Cartesian3(east, north, maxHeight);\n\n  return {\n    shape: VoxelShapeType.ELLIPSOID,\n    minBounds: minBounds,\n    maxBounds: maxBounds,\n    shapeTransform: shapeTransform,\n    globalTransform: Matrix4.clone(Matrix4.IDENTITY),\n  };\n}\n\nfunction getBoxShape(box, tileTransform) {\n  const obb = OrientedBoundingBox.unpack(box);\n  const shapeTransform = Matrix4.fromRotationTranslation(\n    obb.halfAxes,\n    obb.center,\n  );\n\n  return {\n    shape: VoxelShapeType.BOX,\n    minBounds: Cartesian3.clone(VoxelBoxShape.DefaultMinBounds),\n    maxBounds: Cartesian3.clone(VoxelBoxShape.DefaultMaxBounds),\n    shapeTransform: shapeTransform,\n    globalTransform: tileTransform,\n  };\n}\n\nfunction getCylinderShape(cylinder, tileTransform) {\n  const obb = OrientedBoundingBox.unpack(cylinder);\n  const shapeTransform = Matrix4.fromRotationTranslation(\n    obb.halfAxes,\n    obb.center,\n  );\n\n  return {\n    shape: VoxelShapeType.CYLINDER,\n    minBounds: Cartesian3.clone(VoxelCylinderShape.DefaultMinBounds),\n    maxBounds: Cartesian3.clone(VoxelCylinderShape.DefaultMaxBounds),\n    shapeTransform: shapeTransform,\n    globalTransform: tileTransform,\n  };\n}\n\nfunction getMetadataSchemaLoader(tilesetJson, resource) {\n  const { schemaUri, schema } = tilesetJson;\n  if (!defined(schemaUri)) {\n    return ResourceCache.getSchemaLoader({ schema });\n  }\n  return ResourceCache.getSchemaLoader({\n    resource: resource.getDerivedResource({\n      url: schemaUri,\n    }),\n  });\n}\n\nfunction addAttributeInfo(provider, metadata, className) {\n  const { schema, statistics } = metadata;\n  const classStatistics = statistics?.classes[className];\n  const properties = schema.classes[className].properties;\n\n  const propertyInfo = Object.entries(properties).map(([id, property]) => {\n    const { type, componentType } = property;\n    const min = classStatistics?.properties[id].min;\n    const max = classStatistics?.properties[id].max;\n    const componentCount = MetadataType.getComponentCount(type);\n    const minValue = copyArray(min, componentCount);\n    const maxValue = copyArray(max, componentCount);\n\n    return { id, type, componentType, minValue, maxValue };\n  });\n\n  provider.names = propertyInfo.map((info) => info.id);\n  provider.types = propertyInfo.map((info) => info.type);\n  provider.componentTypes = propertyInfo.map((info) => info.componentType);\n\n  const minimumValues = propertyInfo.map((info) => info.minValue);\n  const maximumValues = propertyInfo.map((info) => info.maxValue);\n  const hasMinimumValues = minimumValues.some(defined);\n\n  provider.minimumValues = hasMinimumValues ? minimumValues : undefined;\n  provider.maximumValues = hasMinimumValues ? maximumValues : undefined;\n}\n\nfunction copyArray(values, length) {\n  // Copy input values into a new array of a specified length.\n  // If the input is not an array, its value will be copied into the first element\n  // of the returned array. If the input is an array shorter than the returned\n  // array, the extra elements in the returned array will be undefined. If the\n  // input is undefined, the return will be undefined.\n  if (!defined(values)) {\n    return;\n  }\n  const valuesArray = Array.isArray(values) ? values : [values];\n  return Array.from({ length }, (v, i) => valuesArray[i]);\n}\n\nasync function getVoxelContent(implicitTileset, tileCoordinates) {\n  const voxelRelative =\n    implicitTileset.contentUriTemplates[0].getDerivedResource({\n      templateValues: tileCoordinates.getTemplateValues(),\n    });\n  const voxelResource = implicitTileset.baseResource.getDerivedResource({\n    url: voxelRelative.url,\n  });\n\n  const arrayBuffer = await voxelResource.fetchArrayBuffer();\n  const preprocessed = preprocess3DTileContent(arrayBuffer);\n\n  const voxelContent = await VoxelContent.fromJson(\n    voxelResource,\n    preprocessed.jsonPayload,\n    preprocessed.binaryPayload,\n    implicitTileset.metadataSchema,\n  );\n\n  return voxelContent;\n}\n\nasync function getSubtreePromise(provider, subtreeCoord) {\n  const implicitTileset = provider._implicitTileset;\n  const subtreeCache = provider._subtreeCache;\n\n  // First load the subtree to check if the tile is available.\n  // If the subtree has been requested previously it might still be in the cache\n  let subtree = subtreeCache.find(subtreeCoord);\n  if (defined(subtree)) {\n    return subtree;\n  }\n\n  const subtreeRelative = implicitTileset.subtreeUriTemplate.getDerivedResource(\n    {\n      templateValues: subtreeCoord.getTemplateValues(),\n    },\n  );\n  const subtreeResource = implicitTileset.baseResource.getDerivedResource({\n    url: subtreeRelative.url,\n  });\n\n  const arrayBuffer = await subtreeResource.fetchArrayBuffer();\n  // Check one more time if the subtree is in the cache.\n  // This could happen if there are two in-flight tile requests from the same\n  // subtree and one finishes before the other.\n  subtree = subtreeCache.find(subtreeCoord);\n  if (defined(subtree)) {\n    return subtree;\n  }\n\n  const preprocessed = preprocess3DTileContent(arrayBuffer);\n  subtree = await ImplicitSubtree.fromSubtreeJson(\n    subtreeResource,\n    preprocessed.jsonPayload,\n    preprocessed.binaryPayload,\n    implicitTileset,\n    subtreeCoord,\n  );\n  subtreeCache.addSubtree(subtree);\n  return subtree;\n}\n\n/** @inheritdoc */\nCesium3DTilesVoxelProvider.prototype.requestData = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const tileLevel = defaultValue(options.tileLevel, 0);\n  const tileX = defaultValue(options.tileX, 0);\n  const tileY = defaultValue(options.tileY, 0);\n  const tileZ = defaultValue(options.tileZ, 0);\n  const keyframe = defaultValue(options.keyframe, 0);\n\n  // 3D Tiles currently doesn't support time-dynamic data.\n  if (keyframe !== 0) {\n    return undefined;\n  }\n\n  // 1. Load the subtree that the tile belongs to (possibly from the subtree cache)\n  // 2. Load the voxel content if available\n\n  const implicitTileset = this._implicitTileset;\n  const names = this.names;\n\n  // Can't use a scratch variable here because the object is used inside the promise chain.\n  const tileCoordinates = new ImplicitTileCoordinates({\n    subdivisionScheme: implicitTileset.subdivisionScheme,\n    subtreeLevels: implicitTileset.subtreeLevels,\n    level: tileLevel,\n    x: tileX,\n    y: tileY,\n    z: tileZ,\n  });\n\n  // Find the coordinates of the parent subtree containing tileCoordinates\n  // If tileCoordinates is a subtree child, use that subtree\n  // If tileCoordinates is a subtree root, use its parent subtree\n  const isSubtreeRoot =\n    tileCoordinates.isSubtreeRoot() && tileCoordinates.level > 0;\n\n  const subtreeCoord = isSubtreeRoot\n    ? tileCoordinates.getParentSubtreeCoordinates()\n    : tileCoordinates.getSubtreeCoordinates();\n\n  const that = this;\n\n  return getSubtreePromise(that, subtreeCoord)\n    .then(function (subtree) {\n      const available = isSubtreeRoot\n        ? subtree.childSubtreeIsAvailableAtCoordinates(tileCoordinates)\n        : subtree.tileIsAvailableAtCoordinates(tileCoordinates);\n\n      if (!available) {\n        return Promise.reject(\"Tile is not available\");\n      }\n\n      return getVoxelContent(implicitTileset, tileCoordinates);\n    })\n    .then(function (voxelContent) {\n      return names.map(function (name) {\n        return voxelContent.metadataTable.getPropertyTypedArray(name);\n      });\n    });\n};\n\nexport default Cesium3DTilesVoxelProvider;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}