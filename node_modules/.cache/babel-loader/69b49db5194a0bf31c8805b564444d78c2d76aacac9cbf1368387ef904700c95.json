{"ast":null,"code":"// Regex that holds the characters used to separate segments of a phone number\nvar separatorCharRe = /[-. ]/;\n// Regex that specifies any delimiter char that allows us to treat the number as\n// a phone number rather than just any other number that could appear in text.\nvar hasDelimCharsRe = /[-. ()]/;\n// \"Pause\" and \"Wait\" control chars\nvar controlCharRe = /[,;]/;\n// Over the years, many people have added to this regex, but it should have been\n// split up by country. Maybe one day we can break this down.\nvar mostPhoneNumbers = /(?:(?:(?:(\\+)?\\d{1,3}[-. ]?)?\\(?\\d{3}\\)?[-. ]?\\d{3}[-. ]?\\d{4})|(?:(\\+)(?:9[976]\\d|8[987530]\\d|6[987]\\d|5[90]\\d|42\\d|3[875]\\d|2[98654321]\\d|9[8543210]|8[6421]|6[6543210]|5[87654321]|4[987654310]|3[9643210]|2[70]|7|1)[-. ]?(?:\\d[-. ]?){6,12}\\d+))([,;]+[0-9]+#?)*/;\n// Regex for Japanese phone numbers\nvar japanesePhoneRe = /(0([1-9]-?[1-9]\\d{3}|[1-9]{2}-?\\d{3}|[1-9]{2}\\d{1}-?\\d{2}|[1-9]{2}\\d{2}-?\\d{1})-?\\d{4}|0[789]0-?\\d{4}-?\\d{4}|050-?\\d{4}-?\\d{4})/;\n// Combined regex\nvar validPhoneNumberRe = new RegExp(\"^\".concat(mostPhoneNumbers.source, \"|\").concat(japanesePhoneRe.source, \"$\"));\n/**\n * Determines if the character is a phone number separator character (i.e.\n * '-', '.', or ' ' (space))\n */\nexport function isPhoneNumberSeparatorChar(char) {\n  return separatorCharRe.test(char);\n}\n/**\n * Determines if the character is a control character in a phone number. Control\n * characters are as follows:\n *\n * - ',': A 1 second pause. Useful for dialing extensions once the main phone number has been reached\n * - ';': A \"wait\" that waits for the user to take action (tap something, for instance on a smart phone)\n */\nexport function isPhoneNumberControlChar(char) {\n  return controlCharRe.test(char);\n}\n/**\n * Determines if the given phone number text found in a string is a valid phone\n * number.\n *\n * Our state machine parser is simplified to grab anything that looks like a\n * phone number, and this function confirms the match.\n */\nexport function isValidPhoneNumber(phoneNumberText) {\n  // We'll only consider the match as a phone number if there is some kind of\n  // delimiter character (a prefixed '+' sign, or separator chars).\n  //\n  // Accepts:\n  //     (123) 456-7890\n  //     +38755233976\n  // Does not accept:\n  //     1234567890  (no delimiter chars - may just be a random number that's not a phone number)\n  var hasDelimiters = phoneNumberText.charAt(0) === '+' || hasDelimCharsRe.test(phoneNumberText);\n  return hasDelimiters && validPhoneNumberRe.test(phoneNumberText);\n}","map":{"version":3,"names":["separatorCharRe","hasDelimCharsRe","controlCharRe","mostPhoneNumbers","japanesePhoneRe","validPhoneNumberRe","RegExp","concat","source","isPhoneNumberSeparatorChar","char","test","isPhoneNumberControlChar","isValidPhoneNumber","phoneNumberText","hasDelimiters","charAt"],"sources":["../../../src/parser/phone-number-utils.ts"],"sourcesContent":[null],"mappings":"AAAA;AACA,IAAMA,eAAe,GAAG,OAAO;AAE/B;AACA;AACA,IAAMC,eAAe,GAAG,SAAS;AAEjC;AACA,IAAMC,aAAa,GAAG,MAAM;AAE5B;AACA;AACA,IAAMC,gBAAgB,GAClB,uQAAuQ;AAE3Q;AACA,IAAMC,eAAe,GACjB,iIAAiI;AAErI;AACA,IAAMC,kBAAkB,GAAG,IAAIC,MAAM,CAAC,IAAAC,MAAA,CAAIJ,gBAAgB,CAACK,MAAM,OAAAD,MAAA,CAAIH,eAAe,CAACI,MAAM,MAAG,CAAC;AAE/F;;;;AAIA,OAAM,SAAUC,0BAA0BA,CAACC,IAAY;EACnD,OAAOV,eAAe,CAACW,IAAI,CAACD,IAAI,CAAC;AACrC;AAEA;;;;;;;AAOA,OAAM,SAAUE,wBAAwBA,CAACF,IAAY;EACjD,OAAOR,aAAa,CAACS,IAAI,CAACD,IAAI,CAAC;AACnC;AAEA;;;;;;;AAOA,OAAM,SAAUG,kBAAkBA,CAACC,eAAuB;EACtD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAMC,aAAa,GACfD,eAAe,CAACE,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIf,eAAe,CAACU,IAAI,CAACG,eAAe,CAAC;EAE9E,OAAOC,aAAa,IAAIV,kBAAkB,CAACM,IAAI,CAACG,eAAe,CAAC;AACpE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}