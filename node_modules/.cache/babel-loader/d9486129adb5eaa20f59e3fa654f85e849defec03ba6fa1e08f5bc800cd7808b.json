{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Buffer from \"./Buffer.js\";\nimport BufferUsage from \"./BufferUsage.js\";\nimport VertexArray from \"./VertexArray.js\";\n\n/**\n * @private\n */\nfunction VertexArrayFacade(context, attributes, sizeInVertices, instanced) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"context\", context);\n  if (!attributes || attributes.length === 0) {\n    throw new DeveloperError(\"At least one attribute is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const attrs = VertexArrayFacade._verifyAttributes(attributes);\n  sizeInVertices = defaultValue(sizeInVertices, 0);\n  const precreatedAttributes = [];\n  const attributesByUsage = {};\n  let attributesForUsage;\n  let usage;\n\n  // Bucket the attributes by usage.\n  const length = attrs.length;\n  for (let i = 0; i < length; ++i) {\n    const attribute = attrs[i];\n\n    // If the attribute already has a vertex buffer, we do not need\n    // to manage a vertex buffer or typed array for it.\n    if (attribute.vertexBuffer) {\n      precreatedAttributes.push(attribute);\n      continue;\n    }\n    usage = attribute.usage;\n    attributesForUsage = attributesByUsage[usage];\n    if (!defined(attributesForUsage)) {\n      attributesForUsage = attributesByUsage[usage] = [];\n    }\n    attributesForUsage.push(attribute);\n  }\n\n  // A function to sort attributes by the size of their components.  From left to right, a vertex\n  // stores floats, shorts, and then bytes.\n  function compare(left, right) {\n    return ComponentDatatype.getSizeInBytes(right.componentDatatype) - ComponentDatatype.getSizeInBytes(left.componentDatatype);\n  }\n  this._allBuffers = [];\n  for (usage in attributesByUsage) {\n    if (attributesByUsage.hasOwnProperty(usage)) {\n      attributesForUsage = attributesByUsage[usage];\n      attributesForUsage.sort(compare);\n      const vertexSizeInBytes = VertexArrayFacade._vertexSizeInBytes(attributesForUsage);\n      const bufferUsage = attributesForUsage[0].usage;\n      const buffer = {\n        vertexSizeInBytes: vertexSizeInBytes,\n        vertexBuffer: undefined,\n        usage: bufferUsage,\n        needsCommit: false,\n        arrayBuffer: undefined,\n        arrayViews: VertexArrayFacade._createArrayViews(attributesForUsage, vertexSizeInBytes)\n      };\n      this._allBuffers.push(buffer);\n    }\n  }\n  this._size = 0;\n  this._instanced = defaultValue(instanced, false);\n  this._precreated = precreatedAttributes;\n  this._context = context;\n  this.writers = undefined;\n  this.va = undefined;\n  this.resize(sizeInVertices);\n}\nVertexArrayFacade._verifyAttributes = function (attributes) {\n  const attrs = [];\n  for (let i = 0; i < attributes.length; ++i) {\n    const attribute = attributes[i];\n    const attr = {\n      index: defaultValue(attribute.index, i),\n      enabled: defaultValue(attribute.enabled, true),\n      componentsPerAttribute: attribute.componentsPerAttribute,\n      componentDatatype: defaultValue(attribute.componentDatatype, ComponentDatatype.FLOAT),\n      normalize: defaultValue(attribute.normalize, false),\n      // There will be either a vertexBuffer or an [optional] usage.\n      vertexBuffer: attribute.vertexBuffer,\n      usage: defaultValue(attribute.usage, BufferUsage.STATIC_DRAW)\n    };\n    attrs.push(attr);\n\n    //>>includeStart('debug', pragmas.debug);\n    if (attr.componentsPerAttribute !== 1 && attr.componentsPerAttribute !== 2 && attr.componentsPerAttribute !== 3 && attr.componentsPerAttribute !== 4) {\n      throw new DeveloperError(\"attribute.componentsPerAttribute must be in the range [1, 4].\");\n    }\n    const datatype = attr.componentDatatype;\n    if (!ComponentDatatype.validate(datatype)) {\n      throw new DeveloperError(\"Attribute must have a valid componentDatatype or not specify it.\");\n    }\n    if (!BufferUsage.validate(attr.usage)) {\n      throw new DeveloperError(\"Attribute must have a valid usage or not specify it.\");\n    }\n    //>>includeEnd('debug');\n  }\n\n  // Verify all attribute names are unique.\n  const uniqueIndices = new Array(attrs.length);\n  for (let j = 0; j < attrs.length; ++j) {\n    const currentAttr = attrs[j];\n    const index = currentAttr.index;\n    //>>includeStart('debug', pragmas.debug);\n    if (uniqueIndices[index]) {\n      throw new DeveloperError(`Index ${index} is used by more than one attribute.`);\n    }\n    //>>includeEnd('debug');\n    uniqueIndices[index] = true;\n  }\n  return attrs;\n};\nVertexArrayFacade._vertexSizeInBytes = function (attributes) {\n  let sizeInBytes = 0;\n  const length = attributes.length;\n  for (let i = 0; i < length; ++i) {\n    const attribute = attributes[i];\n    sizeInBytes += attribute.componentsPerAttribute * ComponentDatatype.getSizeInBytes(attribute.componentDatatype);\n  }\n  const maxComponentSizeInBytes = length > 0 ? ComponentDatatype.getSizeInBytes(attributes[0].componentDatatype) : 0; // Sorted by size\n  const remainder = maxComponentSizeInBytes > 0 ? sizeInBytes % maxComponentSizeInBytes : 0;\n  const padding = remainder === 0 ? 0 : maxComponentSizeInBytes - remainder;\n  sizeInBytes += padding;\n  return sizeInBytes;\n};\nVertexArrayFacade._createArrayViews = function (attributes, vertexSizeInBytes) {\n  const views = [];\n  let offsetInBytes = 0;\n  const length = attributes.length;\n  for (let i = 0; i < length; ++i) {\n    const attribute = attributes[i];\n    const componentDatatype = attribute.componentDatatype;\n    views.push({\n      index: attribute.index,\n      enabled: attribute.enabled,\n      componentsPerAttribute: attribute.componentsPerAttribute,\n      componentDatatype: componentDatatype,\n      normalize: attribute.normalize,\n      offsetInBytes: offsetInBytes,\n      vertexSizeInComponentType: vertexSizeInBytes / ComponentDatatype.getSizeInBytes(componentDatatype),\n      view: undefined\n    });\n    offsetInBytes += attribute.componentsPerAttribute * ComponentDatatype.getSizeInBytes(componentDatatype);\n  }\n  return views;\n};\n\n/**\n * Invalidates writers.  Can't render again until commit is called.\n */\nVertexArrayFacade.prototype.resize = function (sizeInVertices) {\n  this._size = sizeInVertices;\n  const allBuffers = this._allBuffers;\n  this.writers = [];\n  for (let i = 0, len = allBuffers.length; i < len; ++i) {\n    const buffer = allBuffers[i];\n    VertexArrayFacade._resize(buffer, this._size);\n\n    // Reserving invalidates the writers, so if client's cache them, they need to invalidate their cache.\n    VertexArrayFacade._appendWriters(this.writers, buffer);\n  }\n\n  // VAs are recreated next time commit is called.\n  destroyVA(this);\n};\nVertexArrayFacade._resize = function (buffer, size) {\n  if (buffer.vertexSizeInBytes > 0) {\n    // Create larger array buffer\n    const arrayBuffer = new ArrayBuffer(size * buffer.vertexSizeInBytes);\n\n    // Copy contents from previous array buffer\n    if (defined(buffer.arrayBuffer)) {\n      const destView = new Uint8Array(arrayBuffer);\n      const sourceView = new Uint8Array(buffer.arrayBuffer);\n      const sourceLength = sourceView.length;\n      for (let j = 0; j < sourceLength; ++j) {\n        destView[j] = sourceView[j];\n      }\n    }\n\n    // Create typed views into the new array buffer\n    const views = buffer.arrayViews;\n    const length = views.length;\n    for (let i = 0; i < length; ++i) {\n      const view = views[i];\n      view.view = ComponentDatatype.createArrayBufferView(view.componentDatatype, arrayBuffer, view.offsetInBytes);\n    }\n    buffer.arrayBuffer = arrayBuffer;\n  }\n};\nconst createWriters = [\n// 1 component per attribute\nfunction (buffer, view, vertexSizeInComponentType) {\n  return function (index, attribute) {\n    view[index * vertexSizeInComponentType] = attribute;\n    buffer.needsCommit = true;\n  };\n},\n// 2 component per attribute\nfunction (buffer, view, vertexSizeInComponentType) {\n  return function (index, component0, component1) {\n    const i = index * vertexSizeInComponentType;\n    view[i] = component0;\n    view[i + 1] = component1;\n    buffer.needsCommit = true;\n  };\n},\n// 3 component per attribute\nfunction (buffer, view, vertexSizeInComponentType) {\n  return function (index, component0, component1, component2) {\n    const i = index * vertexSizeInComponentType;\n    view[i] = component0;\n    view[i + 1] = component1;\n    view[i + 2] = component2;\n    buffer.needsCommit = true;\n  };\n},\n// 4 component per attribute\nfunction (buffer, view, vertexSizeInComponentType) {\n  return function (index, component0, component1, component2, component3) {\n    const i = index * vertexSizeInComponentType;\n    view[i] = component0;\n    view[i + 1] = component1;\n    view[i + 2] = component2;\n    view[i + 3] = component3;\n    buffer.needsCommit = true;\n  };\n}];\nVertexArrayFacade._appendWriters = function (writers, buffer) {\n  const arrayViews = buffer.arrayViews;\n  const length = arrayViews.length;\n  for (let i = 0; i < length; ++i) {\n    const arrayView = arrayViews[i];\n    writers[arrayView.index] = createWriters[arrayView.componentsPerAttribute - 1](buffer, arrayView.view, arrayView.vertexSizeInComponentType);\n  }\n};\nVertexArrayFacade.prototype.commit = function (indexBuffer) {\n  let recreateVA = false;\n  const allBuffers = this._allBuffers;\n  let buffer;\n  let i;\n  let length;\n  for (i = 0, length = allBuffers.length; i < length; ++i) {\n    buffer = allBuffers[i];\n    recreateVA = commit(this, buffer) || recreateVA;\n  }\n\n  ///////////////////////////////////////////////////////////////////////\n\n  if (recreateVA || !defined(this.va)) {\n    destroyVA(this);\n    const va = this.va = [];\n    const chunkSize = CesiumMath.SIXTY_FOUR_KILOBYTES - 4; // The 65535 index is reserved for primitive restart. Reserve the last 4 indices so that billboard quads are not broken up.\n    const numberOfVertexArrays = defined(indexBuffer) && !this._instanced ? Math.ceil(this._size / chunkSize) : 1;\n    for (let k = 0; k < numberOfVertexArrays; ++k) {\n      let attributes = [];\n      for (i = 0, length = allBuffers.length; i < length; ++i) {\n        buffer = allBuffers[i];\n        const offset = k * (buffer.vertexSizeInBytes * chunkSize);\n        VertexArrayFacade._appendAttributes(attributes, buffer, offset, this._instanced);\n      }\n      attributes = attributes.concat(this._precreated);\n      va.push({\n        va: new VertexArray({\n          context: this._context,\n          attributes: attributes,\n          indexBuffer: indexBuffer\n        }),\n        indicesCount: 1.5 * (k !== numberOfVertexArrays - 1 ? chunkSize : this._size % chunkSize)\n        // TODO: not hardcode 1.5, this assumes 6 indices per 4 vertices (as for Billboard quads).\n      });\n    }\n  }\n};\nfunction commit(vertexArrayFacade, buffer) {\n  if (buffer.needsCommit && buffer.vertexSizeInBytes > 0) {\n    buffer.needsCommit = false;\n    const vertexBuffer = buffer.vertexBuffer;\n    const vertexBufferSizeInBytes = vertexArrayFacade._size * buffer.vertexSizeInBytes;\n    const vertexBufferDefined = defined(vertexBuffer);\n    if (!vertexBufferDefined || vertexBuffer.sizeInBytes < vertexBufferSizeInBytes) {\n      if (vertexBufferDefined) {\n        vertexBuffer.destroy();\n      }\n      buffer.vertexBuffer = Buffer.createVertexBuffer({\n        context: vertexArrayFacade._context,\n        typedArray: buffer.arrayBuffer,\n        usage: buffer.usage\n      });\n      buffer.vertexBuffer.vertexArrayDestroyable = false;\n      return true; // Created new vertex buffer\n    }\n    buffer.vertexBuffer.copyFromArrayView(buffer.arrayBuffer);\n  }\n  return false; // Did not create new vertex buffer\n}\nVertexArrayFacade._appendAttributes = function (attributes, buffer, vertexBufferOffset, instanced) {\n  const arrayViews = buffer.arrayViews;\n  const length = arrayViews.length;\n  for (let i = 0; i < length; ++i) {\n    const view = arrayViews[i];\n    attributes.push({\n      index: view.index,\n      enabled: view.enabled,\n      componentsPerAttribute: view.componentsPerAttribute,\n      componentDatatype: view.componentDatatype,\n      normalize: view.normalize,\n      vertexBuffer: buffer.vertexBuffer,\n      offsetInBytes: vertexBufferOffset + view.offsetInBytes,\n      strideInBytes: buffer.vertexSizeInBytes,\n      instanceDivisor: instanced ? 1 : 0\n    });\n  }\n};\nVertexArrayFacade.prototype.subCommit = function (offsetInVertices, lengthInVertices) {\n  //>>includeStart('debug', pragmas.debug);\n  if (offsetInVertices < 0 || offsetInVertices >= this._size) {\n    throw new DeveloperError(\"offsetInVertices must be greater than or equal to zero and less than the vertex array size.\");\n  }\n  if (offsetInVertices + lengthInVertices > this._size) {\n    throw new DeveloperError(\"offsetInVertices + lengthInVertices cannot exceed the vertex array size.\");\n  }\n  //>>includeEnd('debug');\n\n  const allBuffers = this._allBuffers;\n  for (let i = 0, len = allBuffers.length; i < len; ++i) {\n    subCommit(allBuffers[i], offsetInVertices, lengthInVertices);\n  }\n};\nfunction subCommit(buffer, offsetInVertices, lengthInVertices) {\n  if (buffer.needsCommit && buffer.vertexSizeInBytes > 0) {\n    const byteOffset = buffer.vertexSizeInBytes * offsetInVertices;\n    const byteLength = buffer.vertexSizeInBytes * lengthInVertices;\n\n    // PERFORMANCE_IDEA: If we want to get really crazy, we could consider updating\n    // individual attributes instead of the entire (sub-)vertex.\n    //\n    // PERFORMANCE_IDEA: Does creating the typed view add too much GC overhead?\n    buffer.vertexBuffer.copyFromArrayView(new Uint8Array(buffer.arrayBuffer, byteOffset, byteLength), byteOffset);\n  }\n}\nVertexArrayFacade.prototype.endSubCommits = function () {\n  const allBuffers = this._allBuffers;\n  for (let i = 0, len = allBuffers.length; i < len; ++i) {\n    allBuffers[i].needsCommit = false;\n  }\n};\nfunction destroyVA(vertexArrayFacade) {\n  const va = vertexArrayFacade.va;\n  if (!defined(va)) {\n    return;\n  }\n  const length = va.length;\n  for (let i = 0; i < length; ++i) {\n    va[i].va.destroy();\n  }\n  vertexArrayFacade.va = undefined;\n}\nVertexArrayFacade.prototype.isDestroyed = function () {\n  return false;\n};\nVertexArrayFacade.prototype.destroy = function () {\n  const allBuffers = this._allBuffers;\n  for (let i = 0, len = allBuffers.length; i < len; ++i) {\n    const buffer = allBuffers[i];\n    buffer.vertexBuffer = buffer.vertexBuffer && buffer.vertexBuffer.destroy();\n  }\n  destroyVA(this);\n  return destroyObject(this);\n};\nexport default VertexArrayFacade;","map":{"version":3,"names":["Check","ComponentDatatype","defaultValue","defined","destroyObject","DeveloperError","CesiumMath","Buffer","BufferUsage","VertexArray","VertexArrayFacade","context","attributes","sizeInVertices","instanced","length","attrs","_verifyAttributes","precreatedAttributes","attributesByUsage","attributesForUsage","usage","i","attribute","vertexBuffer","push","compare","left","right","getSizeInBytes","componentDatatype","_allBuffers","hasOwnProperty","sort","vertexSizeInBytes","_vertexSizeInBytes","bufferUsage","buffer","undefined","needsCommit","arrayBuffer","arrayViews","_createArrayViews","_size","_instanced","_precreated","_context","writers","va","resize","attr","index","enabled","componentsPerAttribute","FLOAT","normalize","STATIC_DRAW","datatype","validate","uniqueIndices","Array","j","currentAttr","sizeInBytes","maxComponentSizeInBytes","remainder","padding","views","offsetInBytes","vertexSizeInComponentType","view","prototype","allBuffers","len","_resize","_appendWriters","destroyVA","size","ArrayBuffer","destView","Uint8Array","sourceView","sourceLength","createArrayBufferView","createWriters","component0","component1","component2","component3","arrayView","commit","indexBuffer","recreateVA","chunkSize","SIXTY_FOUR_KILOBYTES","numberOfVertexArrays","Math","ceil","k","offset","_appendAttributes","concat","indicesCount","vertexArrayFacade","vertexBufferSizeInBytes","vertexBufferDefined","destroy","createVertexBuffer","typedArray","vertexArrayDestroyable","copyFromArrayView","vertexBufferOffset","strideInBytes","instanceDivisor","subCommit","offsetInVertices","lengthInVertices","byteOffset","byteLength","endSubCommits","isDestroyed"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Renderer/VertexArrayFacade.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Buffer from \"./Buffer.js\";\nimport BufferUsage from \"./BufferUsage.js\";\nimport VertexArray from \"./VertexArray.js\";\n\n/**\n * @private\n */\nfunction VertexArrayFacade(context, attributes, sizeInVertices, instanced) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"context\", context);\n  if (!attributes || attributes.length === 0) {\n    throw new DeveloperError(\"At least one attribute is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const attrs = VertexArrayFacade._verifyAttributes(attributes);\n  sizeInVertices = defaultValue(sizeInVertices, 0);\n  const precreatedAttributes = [];\n  const attributesByUsage = {};\n  let attributesForUsage;\n  let usage;\n\n  // Bucket the attributes by usage.\n  const length = attrs.length;\n  for (let i = 0; i < length; ++i) {\n    const attribute = attrs[i];\n\n    // If the attribute already has a vertex buffer, we do not need\n    // to manage a vertex buffer or typed array for it.\n    if (attribute.vertexBuffer) {\n      precreatedAttributes.push(attribute);\n      continue;\n    }\n\n    usage = attribute.usage;\n    attributesForUsage = attributesByUsage[usage];\n    if (!defined(attributesForUsage)) {\n      attributesForUsage = attributesByUsage[usage] = [];\n    }\n\n    attributesForUsage.push(attribute);\n  }\n\n  // A function to sort attributes by the size of their components.  From left to right, a vertex\n  // stores floats, shorts, and then bytes.\n  function compare(left, right) {\n    return (\n      ComponentDatatype.getSizeInBytes(right.componentDatatype) -\n      ComponentDatatype.getSizeInBytes(left.componentDatatype)\n    );\n  }\n\n  this._allBuffers = [];\n\n  for (usage in attributesByUsage) {\n    if (attributesByUsage.hasOwnProperty(usage)) {\n      attributesForUsage = attributesByUsage[usage];\n\n      attributesForUsage.sort(compare);\n      const vertexSizeInBytes =\n        VertexArrayFacade._vertexSizeInBytes(attributesForUsage);\n\n      const bufferUsage = attributesForUsage[0].usage;\n\n      const buffer = {\n        vertexSizeInBytes: vertexSizeInBytes,\n        vertexBuffer: undefined,\n        usage: bufferUsage,\n        needsCommit: false,\n        arrayBuffer: undefined,\n        arrayViews: VertexArrayFacade._createArrayViews(\n          attributesForUsage,\n          vertexSizeInBytes,\n        ),\n      };\n\n      this._allBuffers.push(buffer);\n    }\n  }\n\n  this._size = 0;\n  this._instanced = defaultValue(instanced, false);\n\n  this._precreated = precreatedAttributes;\n  this._context = context;\n\n  this.writers = undefined;\n  this.va = undefined;\n\n  this.resize(sizeInVertices);\n}\nVertexArrayFacade._verifyAttributes = function (attributes) {\n  const attrs = [];\n\n  for (let i = 0; i < attributes.length; ++i) {\n    const attribute = attributes[i];\n\n    const attr = {\n      index: defaultValue(attribute.index, i),\n      enabled: defaultValue(attribute.enabled, true),\n      componentsPerAttribute: attribute.componentsPerAttribute,\n      componentDatatype: defaultValue(\n        attribute.componentDatatype,\n        ComponentDatatype.FLOAT,\n      ),\n      normalize: defaultValue(attribute.normalize, false),\n\n      // There will be either a vertexBuffer or an [optional] usage.\n      vertexBuffer: attribute.vertexBuffer,\n      usage: defaultValue(attribute.usage, BufferUsage.STATIC_DRAW),\n    };\n    attrs.push(attr);\n\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      attr.componentsPerAttribute !== 1 &&\n      attr.componentsPerAttribute !== 2 &&\n      attr.componentsPerAttribute !== 3 &&\n      attr.componentsPerAttribute !== 4\n    ) {\n      throw new DeveloperError(\n        \"attribute.componentsPerAttribute must be in the range [1, 4].\",\n      );\n    }\n\n    const datatype = attr.componentDatatype;\n    if (!ComponentDatatype.validate(datatype)) {\n      throw new DeveloperError(\n        \"Attribute must have a valid componentDatatype or not specify it.\",\n      );\n    }\n\n    if (!BufferUsage.validate(attr.usage)) {\n      throw new DeveloperError(\n        \"Attribute must have a valid usage or not specify it.\",\n      );\n    }\n    //>>includeEnd('debug');\n  }\n\n  // Verify all attribute names are unique.\n  const uniqueIndices = new Array(attrs.length);\n  for (let j = 0; j < attrs.length; ++j) {\n    const currentAttr = attrs[j];\n    const index = currentAttr.index;\n    //>>includeStart('debug', pragmas.debug);\n    if (uniqueIndices[index]) {\n      throw new DeveloperError(\n        `Index ${index} is used by more than one attribute.`,\n      );\n    }\n    //>>includeEnd('debug');\n    uniqueIndices[index] = true;\n  }\n\n  return attrs;\n};\n\nVertexArrayFacade._vertexSizeInBytes = function (attributes) {\n  let sizeInBytes = 0;\n\n  const length = attributes.length;\n  for (let i = 0; i < length; ++i) {\n    const attribute = attributes[i];\n    sizeInBytes +=\n      attribute.componentsPerAttribute *\n      ComponentDatatype.getSizeInBytes(attribute.componentDatatype);\n  }\n\n  const maxComponentSizeInBytes =\n    length > 0\n      ? ComponentDatatype.getSizeInBytes(attributes[0].componentDatatype)\n      : 0; // Sorted by size\n  const remainder =\n    maxComponentSizeInBytes > 0 ? sizeInBytes % maxComponentSizeInBytes : 0;\n  const padding = remainder === 0 ? 0 : maxComponentSizeInBytes - remainder;\n  sizeInBytes += padding;\n\n  return sizeInBytes;\n};\n\nVertexArrayFacade._createArrayViews = function (attributes, vertexSizeInBytes) {\n  const views = [];\n  let offsetInBytes = 0;\n\n  const length = attributes.length;\n  for (let i = 0; i < length; ++i) {\n    const attribute = attributes[i];\n    const componentDatatype = attribute.componentDatatype;\n\n    views.push({\n      index: attribute.index,\n      enabled: attribute.enabled,\n      componentsPerAttribute: attribute.componentsPerAttribute,\n      componentDatatype: componentDatatype,\n      normalize: attribute.normalize,\n\n      offsetInBytes: offsetInBytes,\n      vertexSizeInComponentType:\n        vertexSizeInBytes / ComponentDatatype.getSizeInBytes(componentDatatype),\n\n      view: undefined,\n    });\n\n    offsetInBytes +=\n      attribute.componentsPerAttribute *\n      ComponentDatatype.getSizeInBytes(componentDatatype);\n  }\n\n  return views;\n};\n\n/**\n * Invalidates writers.  Can't render again until commit is called.\n */\nVertexArrayFacade.prototype.resize = function (sizeInVertices) {\n  this._size = sizeInVertices;\n\n  const allBuffers = this._allBuffers;\n  this.writers = [];\n\n  for (let i = 0, len = allBuffers.length; i < len; ++i) {\n    const buffer = allBuffers[i];\n\n    VertexArrayFacade._resize(buffer, this._size);\n\n    // Reserving invalidates the writers, so if client's cache them, they need to invalidate their cache.\n    VertexArrayFacade._appendWriters(this.writers, buffer);\n  }\n\n  // VAs are recreated next time commit is called.\n  destroyVA(this);\n};\n\nVertexArrayFacade._resize = function (buffer, size) {\n  if (buffer.vertexSizeInBytes > 0) {\n    // Create larger array buffer\n    const arrayBuffer = new ArrayBuffer(size * buffer.vertexSizeInBytes);\n\n    // Copy contents from previous array buffer\n    if (defined(buffer.arrayBuffer)) {\n      const destView = new Uint8Array(arrayBuffer);\n      const sourceView = new Uint8Array(buffer.arrayBuffer);\n      const sourceLength = sourceView.length;\n      for (let j = 0; j < sourceLength; ++j) {\n        destView[j] = sourceView[j];\n      }\n    }\n\n    // Create typed views into the new array buffer\n    const views = buffer.arrayViews;\n    const length = views.length;\n    for (let i = 0; i < length; ++i) {\n      const view = views[i];\n      view.view = ComponentDatatype.createArrayBufferView(\n        view.componentDatatype,\n        arrayBuffer,\n        view.offsetInBytes,\n      );\n    }\n\n    buffer.arrayBuffer = arrayBuffer;\n  }\n};\n\nconst createWriters = [\n  // 1 component per attribute\n  function (buffer, view, vertexSizeInComponentType) {\n    return function (index, attribute) {\n      view[index * vertexSizeInComponentType] = attribute;\n      buffer.needsCommit = true;\n    };\n  },\n\n  // 2 component per attribute\n  function (buffer, view, vertexSizeInComponentType) {\n    return function (index, component0, component1) {\n      const i = index * vertexSizeInComponentType;\n      view[i] = component0;\n      view[i + 1] = component1;\n      buffer.needsCommit = true;\n    };\n  },\n\n  // 3 component per attribute\n  function (buffer, view, vertexSizeInComponentType) {\n    return function (index, component0, component1, component2) {\n      const i = index * vertexSizeInComponentType;\n      view[i] = component0;\n      view[i + 1] = component1;\n      view[i + 2] = component2;\n      buffer.needsCommit = true;\n    };\n  },\n\n  // 4 component per attribute\n  function (buffer, view, vertexSizeInComponentType) {\n    return function (index, component0, component1, component2, component3) {\n      const i = index * vertexSizeInComponentType;\n      view[i] = component0;\n      view[i + 1] = component1;\n      view[i + 2] = component2;\n      view[i + 3] = component3;\n      buffer.needsCommit = true;\n    };\n  },\n];\n\nVertexArrayFacade._appendWriters = function (writers, buffer) {\n  const arrayViews = buffer.arrayViews;\n  const length = arrayViews.length;\n  for (let i = 0; i < length; ++i) {\n    const arrayView = arrayViews[i];\n    writers[arrayView.index] = createWriters[\n      arrayView.componentsPerAttribute - 1\n    ](buffer, arrayView.view, arrayView.vertexSizeInComponentType);\n  }\n};\n\nVertexArrayFacade.prototype.commit = function (indexBuffer) {\n  let recreateVA = false;\n\n  const allBuffers = this._allBuffers;\n  let buffer;\n  let i;\n  let length;\n\n  for (i = 0, length = allBuffers.length; i < length; ++i) {\n    buffer = allBuffers[i];\n    recreateVA = commit(this, buffer) || recreateVA;\n  }\n\n  ///////////////////////////////////////////////////////////////////////\n\n  if (recreateVA || !defined(this.va)) {\n    destroyVA(this);\n    const va = (this.va = []);\n\n    const chunkSize = CesiumMath.SIXTY_FOUR_KILOBYTES - 4; // The 65535 index is reserved for primitive restart. Reserve the last 4 indices so that billboard quads are not broken up.\n    const numberOfVertexArrays =\n      defined(indexBuffer) && !this._instanced\n        ? Math.ceil(this._size / chunkSize)\n        : 1;\n    for (let k = 0; k < numberOfVertexArrays; ++k) {\n      let attributes = [];\n      for (i = 0, length = allBuffers.length; i < length; ++i) {\n        buffer = allBuffers[i];\n        const offset = k * (buffer.vertexSizeInBytes * chunkSize);\n        VertexArrayFacade._appendAttributes(\n          attributes,\n          buffer,\n          offset,\n          this._instanced,\n        );\n      }\n\n      attributes = attributes.concat(this._precreated);\n\n      va.push({\n        va: new VertexArray({\n          context: this._context,\n          attributes: attributes,\n          indexBuffer: indexBuffer,\n        }),\n        indicesCount:\n          1.5 *\n          (k !== numberOfVertexArrays - 1 ? chunkSize : this._size % chunkSize),\n        // TODO: not hardcode 1.5, this assumes 6 indices per 4 vertices (as for Billboard quads).\n      });\n    }\n  }\n};\n\nfunction commit(vertexArrayFacade, buffer) {\n  if (buffer.needsCommit && buffer.vertexSizeInBytes > 0) {\n    buffer.needsCommit = false;\n\n    const vertexBuffer = buffer.vertexBuffer;\n    const vertexBufferSizeInBytes =\n      vertexArrayFacade._size * buffer.vertexSizeInBytes;\n    const vertexBufferDefined = defined(vertexBuffer);\n    if (\n      !vertexBufferDefined ||\n      vertexBuffer.sizeInBytes < vertexBufferSizeInBytes\n    ) {\n      if (vertexBufferDefined) {\n        vertexBuffer.destroy();\n      }\n      buffer.vertexBuffer = Buffer.createVertexBuffer({\n        context: vertexArrayFacade._context,\n        typedArray: buffer.arrayBuffer,\n        usage: buffer.usage,\n      });\n      buffer.vertexBuffer.vertexArrayDestroyable = false;\n\n      return true; // Created new vertex buffer\n    }\n\n    buffer.vertexBuffer.copyFromArrayView(buffer.arrayBuffer);\n  }\n\n  return false; // Did not create new vertex buffer\n}\n\nVertexArrayFacade._appendAttributes = function (\n  attributes,\n  buffer,\n  vertexBufferOffset,\n  instanced,\n) {\n  const arrayViews = buffer.arrayViews;\n  const length = arrayViews.length;\n  for (let i = 0; i < length; ++i) {\n    const view = arrayViews[i];\n\n    attributes.push({\n      index: view.index,\n      enabled: view.enabled,\n      componentsPerAttribute: view.componentsPerAttribute,\n      componentDatatype: view.componentDatatype,\n      normalize: view.normalize,\n      vertexBuffer: buffer.vertexBuffer,\n      offsetInBytes: vertexBufferOffset + view.offsetInBytes,\n      strideInBytes: buffer.vertexSizeInBytes,\n      instanceDivisor: instanced ? 1 : 0,\n    });\n  }\n};\n\nVertexArrayFacade.prototype.subCommit = function (\n  offsetInVertices,\n  lengthInVertices,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (offsetInVertices < 0 || offsetInVertices >= this._size) {\n    throw new DeveloperError(\n      \"offsetInVertices must be greater than or equal to zero and less than the vertex array size.\",\n    );\n  }\n  if (offsetInVertices + lengthInVertices > this._size) {\n    throw new DeveloperError(\n      \"offsetInVertices + lengthInVertices cannot exceed the vertex array size.\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const allBuffers = this._allBuffers;\n  for (let i = 0, len = allBuffers.length; i < len; ++i) {\n    subCommit(allBuffers[i], offsetInVertices, lengthInVertices);\n  }\n};\n\nfunction subCommit(buffer, offsetInVertices, lengthInVertices) {\n  if (buffer.needsCommit && buffer.vertexSizeInBytes > 0) {\n    const byteOffset = buffer.vertexSizeInBytes * offsetInVertices;\n    const byteLength = buffer.vertexSizeInBytes * lengthInVertices;\n\n    // PERFORMANCE_IDEA: If we want to get really crazy, we could consider updating\n    // individual attributes instead of the entire (sub-)vertex.\n    //\n    // PERFORMANCE_IDEA: Does creating the typed view add too much GC overhead?\n    buffer.vertexBuffer.copyFromArrayView(\n      new Uint8Array(buffer.arrayBuffer, byteOffset, byteLength),\n      byteOffset,\n    );\n  }\n}\n\nVertexArrayFacade.prototype.endSubCommits = function () {\n  const allBuffers = this._allBuffers;\n\n  for (let i = 0, len = allBuffers.length; i < len; ++i) {\n    allBuffers[i].needsCommit = false;\n  }\n};\n\nfunction destroyVA(vertexArrayFacade) {\n  const va = vertexArrayFacade.va;\n  if (!defined(va)) {\n    return;\n  }\n\n  const length = va.length;\n  for (let i = 0; i < length; ++i) {\n    va[i].va.destroy();\n  }\n\n  vertexArrayFacade.va = undefined;\n}\n\nVertexArrayFacade.prototype.isDestroyed = function () {\n  return false;\n};\n\nVertexArrayFacade.prototype.destroy = function () {\n  const allBuffers = this._allBuffers;\n  for (let i = 0, len = allBuffers.length; i < len; ++i) {\n    const buffer = allBuffers[i];\n    buffer.vertexBuffer = buffer.vertexBuffer && buffer.vertexBuffer.destroy();\n  }\n\n  destroyVA(this);\n\n  return destroyObject(this);\n};\nexport default VertexArrayFacade;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}