{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport KeyboardEventModifier from \"../Core/KeyboardEventModifier.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport VerticalExaggeration from \"../Core/VerticalExaggeration.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraEventAggregator from \"./CameraEventAggregator.js\";\nimport CameraEventType from \"./CameraEventType.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport TweenCollection from \"./TweenCollection.js\";\n\n/**\n * Modifies the camera position and orientation based on mouse input to a canvas.\n * @alias ScreenSpaceCameraController\n * @constructor\n *\n * @param {Scene} scene The scene.\n */\nfunction ScreenSpaceCameraController(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * If true, inputs are allowed conditionally with the flags enableTranslate, enableZoom,\n   * enableRotate, enableTilt, and enableLook.  If false, all inputs are disabled.\n   *\n   * NOTE: This setting is for temporary use cases, such as camera flights and\n   * drag-selection of regions (see Picking demo).  It is typically set to false at the\n   * start of such events, and set true on completion.  To keep inputs disabled\n   * past the end of camera flights, you must use the other booleans (enableTranslate,\n   * enableZoom, enableRotate, enableTilt, and enableLook).\n   * @type {boolean}\n   * @default true\n   */\n  this.enableInputs = true;\n  /**\n   * If true, allows the user to pan around the map.  If false, the camera stays locked at the current position.\n   * This flag only applies in 2D and Columbus view modes.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableTranslate = true;\n  /**\n   * If true, allows the user to zoom in and out.  If false, the camera is locked to the current distance from the ellipsoid.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableZoom = true;\n  /**\n   * If true, allows the user to rotate the world which translates the user's position.\n   * This flag only applies in 2D and 3D.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableRotate = true;\n  /**\n   * If true, allows the user to tilt the camera.  If false, the camera is locked to the current heading.\n   * This flag only applies in 3D and Columbus view.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableTilt = true;\n  /**\n   * If true, allows the user to use free-look. If false, the camera view direction can only be changed through translating\n   * or rotating. This flag only applies in 3D and Columbus view modes.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableLook = true;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to spin because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {number}\n   * @default 0.9\n   */\n  this.inertiaSpin = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to translate because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {number}\n   * @default 0.9\n   */\n  this.inertiaTranslate = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to zoom because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {number}\n   * @default 0.8\n   */\n  this.inertiaZoom = 0.8;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to limit the range\n   * of various user inputs to a percentage of the window width/height per animation frame.\n   * This helps keep the camera under control in low-frame-rate situations.\n   * @type {number}\n   * @default 0.1\n   */\n  this.maximumMovementRatio = 0.1;\n  /**\n   * Sets the duration, in seconds, of the bounce back animations in 2D and Columbus view.\n   * @type {number}\n   * @default 3.0\n   */\n  this.bounceAnimationTime = 3.0;\n  /**\n   * The minimum magnitude, in meters, of the camera position when zooming. Defaults to 1.0.\n   * @type {number}\n   * @default 1.0\n   */\n  this.minimumZoomDistance = 1.0;\n  /**\n   * The maximum magnitude, in meters, of the camera position when zooming. Defaults to positive infinity.\n   * @type {number}\n   * @default {@link Number.POSITIVE_INFINITY}\n   */\n  this.maximumZoomDistance = Number.POSITIVE_INFINITY;\n\n  /**\n   * A multiplier for the speed at which the camera will zoom.\n   * @type {Number}\n   * @default 5.0\n   */\n  this.zoomFactor = 5.0;\n\n  /**\n   * The input that allows the user to pan around the map. This only applies in 2D and Columbus view modes.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n  this.translateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to zoom in/out.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.RIGHT_DRAG}, {@link CameraEventType.WHEEL}, {@link CameraEventType.PINCH}]\n   */\n  this.zoomEventTypes = [CameraEventType.RIGHT_DRAG, CameraEventType.WHEEL, CameraEventType.PINCH];\n  /**\n   * The input that allows the user to rotate around the globe or another object. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n  this.rotateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to tilt in 3D and Columbus view or twist in 2D.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.MIDDLE_DRAG}, {@link CameraEventType.PINCH}, {\n   *     eventType : {@link CameraEventType.LEFT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }, {\n   *     eventType : {@link CameraEventType.RIGHT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }]\n   */\n  this.tiltEventTypes = [CameraEventType.MIDDLE_DRAG, CameraEventType.PINCH, {\n    eventType: CameraEventType.LEFT_DRAG,\n    modifier: KeyboardEventModifier.CTRL\n  }, {\n    eventType: CameraEventType.RIGHT_DRAG,\n    modifier: KeyboardEventModifier.CTRL\n  }];\n  /**\n   * The input that allows the user to change the direction the camera is viewing. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default { eventType : {@link CameraEventType.LEFT_DRAG}, modifier : {@link KeyboardEventModifier.SHIFT} }\n   */\n  this.lookEventTypes = {\n    eventType: CameraEventType.LEFT_DRAG,\n    modifier: KeyboardEventModifier.SHIFT\n  };\n  const ellipsoid = defaultValue(scene.ellipsoid, Ellipsoid.default);\n\n  /**\n   * The minimum height the camera must be before picking the terrain or scene content instead of the ellipsoid. Defaults to scene.ellipsoid.minimumRadius * 0.025 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 150000.0 or scene.ellipsoid.minimumRadius * 0.025\n   */\n  this.minimumPickingTerrainHeight = Ellipsoid.WGS84.equals(ellipsoid) ? 150000.0 : ellipsoid.minimumRadius * 0.025;\n  this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight;\n  /**\n   * The minimum distance the camera must be before testing for collision with terrain when zoom with inertia. Default to scene.ellipsoid.minimumRadius * 0.00063 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 4000.0 or scene.ellipsoid.minimumRadius * 0.00063\n   */\n  this.minimumPickingTerrainDistanceWithInertia = Ellipsoid.WGS84.equals(ellipsoid) ? 4000.0 : ellipsoid.minimumRadius * 0.00063;\n  /**\n   * The minimum height the camera must be before testing for collision with terrain. Default to scene.ellipsoid.minimumRadius * 0.0025 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 15000.0 or scene.ellipsoid.minimumRadius * 0.0025.\n   */\n  this.minimumCollisionTerrainHeight = Ellipsoid.WGS84.equals(ellipsoid) ? 15000.0 : ellipsoid.minimumRadius * 0.0025;\n  this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight;\n  /**\n   * The minimum height the camera must be before switching from rotating a track ball to\n   * free look when clicks originate on the sky or in space. Defaults to ellipsoid.minimumRadius * 1.175 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 7500000.0 or scene.ellipsoid.minimumRadius * 1.175\n   */\n  this.minimumTrackBallHeight = Ellipsoid.WGS84.equals(ellipsoid) ? 7500000.0 : ellipsoid.minimumRadius * 1.175;\n  this._minimumTrackBallHeight = this.minimumTrackBallHeight;\n  /**\n   * When disabled, the values of <code>maximumZoomDistance</code> and <code>minimumZoomDistance</code> are ignored.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableCollisionDetection = true;\n  /**\n   * The angle, relative to the ellipsoid normal, restricting the maximum amount that the user can tilt the camera. If <code>undefined</code>, the angle of the camera tilt is unrestricted.\n   * @type {number|undefined}\n   * @default undefined\n   *\n   * @example\n   * // Prevent the camera from tilting below the ellipsoid surface\n   * viewer.scene.screenSpaceCameraController.maximumTiltAngle = Math.PI / 2.0;\n   */\n  this.maximumTiltAngle = undefined;\n  this._scene = scene;\n  this._globe = undefined;\n  this._ellipsoid = ellipsoid;\n  this._lastGlobeHeight = 0.0;\n  this._aggregator = new CameraEventAggregator(scene.canvas);\n  this._lastInertiaSpinMovement = undefined;\n  this._lastInertiaZoomMovement = undefined;\n  this._lastInertiaTranslateMovement = undefined;\n  this._lastInertiaTiltMovement = undefined;\n\n  // Zoom disables tilt, spin, and translate inertia\n  // Tilt disables spin and translate inertia\n  this._inertiaDisablers = {\n    _lastInertiaZoomMovement: [\"_lastInertiaSpinMovement\", \"_lastInertiaTranslateMovement\", \"_lastInertiaTiltMovement\"],\n    _lastInertiaTiltMovement: [\"_lastInertiaSpinMovement\", \"_lastInertiaTranslateMovement\"]\n  };\n  this._tweens = new TweenCollection();\n  this._tween = undefined;\n  this._horizontalRotationAxis = undefined;\n  this._tiltCenterMousePosition = new Cartesian2(-1.0, -1.0);\n  this._tiltCenter = new Cartesian3();\n  this._rotateMousePosition = new Cartesian2(-1.0, -1.0);\n  this._rotateStartPosition = new Cartesian3();\n  this._strafeStartPosition = new Cartesian3();\n  this._strafeMousePosition = new Cartesian2();\n  this._strafeEndMousePosition = new Cartesian2();\n  this._zoomMouseStart = new Cartesian2(-1.0, -1.0);\n  this._zoomWorldPosition = new Cartesian3();\n  this._useZoomWorldPosition = false;\n  this._panLastMousePosition = new Cartesian2();\n  this._panLastWorldPosition = new Cartesian3();\n  this._tiltCVOffMap = false;\n  this._looking = false;\n  this._rotating = false;\n  this._strafing = false;\n  this._zoomingOnVector = false;\n  this._zoomingUnderground = false;\n  this._rotatingZoom = false;\n  this._adjustedHeightForTerrain = false;\n  this._cameraUnderground = false;\n  const projection = scene.mapProjection;\n  this._maxCoord = projection.project(new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO));\n\n  // Constants, Make any of these public?\n  this._rotateFactor = undefined;\n  this._rotateRateRangeAdjustment = undefined;\n  this._maximumRotateRate = 1.77;\n  this._minimumRotateRate = 1.0 / 5000.0;\n  this._minimumZoomRate = 20.0;\n  this._maximumZoomRate = 5906376272000.0; // distance from the Sun to Pluto in meters.\n  this._minimumUndergroundPickDistance = 2000.0;\n  this._maximumUndergroundPickDistance = 10000.0;\n}\nfunction decay(time, coefficient) {\n  if (time < 0) {\n    return 0.0;\n  }\n  const tau = (1.0 - coefficient) * 25.0;\n  return Math.exp(-tau * time);\n}\nfunction sameMousePosition(movement) {\n  return Cartesian2.equalsEpsilon(movement.startPosition, movement.endPosition, CesiumMath.EPSILON14);\n}\n\n// If the time between mouse down and mouse up is not between\n// these thresholds, the camera will not move with inertia.\n// This value is probably dependent on the browser and/or the\n// hardware. Should be investigated further.\nconst inertiaMaxClickTimeThreshold = 0.4;\nfunction maintainInertia(aggregator, type, modifier, decayCoef, action, object, lastMovementName) {\n  let movementState = object[lastMovementName];\n  if (!defined(movementState)) {\n    movementState = object[lastMovementName] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      motion: new Cartesian2(),\n      inertiaEnabled: true\n    };\n  }\n  const ts = aggregator.getButtonPressTime(type, modifier);\n  const tr = aggregator.getButtonReleaseTime(type, modifier);\n  const threshold = ts && tr && (tr.getTime() - ts.getTime()) / 1000.0;\n  const now = new Date();\n  const fromNow = tr && (now.getTime() - tr.getTime()) / 1000.0;\n  if (ts && tr && threshold < inertiaMaxClickTimeThreshold) {\n    const d = decay(fromNow, decayCoef);\n    const lastMovement = aggregator.getLastMovement(type, modifier);\n    if (!defined(lastMovement) || sameMousePosition(lastMovement) || !movementState.inertiaEnabled) {\n      return;\n    }\n    movementState.motion.x = (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;\n    movementState.motion.y = (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;\n    movementState.startPosition = Cartesian2.clone(lastMovement.startPosition, movementState.startPosition);\n    movementState.endPosition = Cartesian2.multiplyByScalar(movementState.motion, d, movementState.endPosition);\n    movementState.endPosition = Cartesian2.add(movementState.startPosition, movementState.endPosition, movementState.endPosition);\n\n    // If value from the decreasing exponential function is close to zero,\n    // the end coordinates may be NaN.\n    if (isNaN(movementState.endPosition.x) || isNaN(movementState.endPosition.y) || Cartesian2.distance(movementState.startPosition, movementState.endPosition) < 0.5) {\n      return;\n    }\n    if (!aggregator.isButtonDown(type, modifier)) {\n      const startPosition = aggregator.getStartMousePosition(type, modifier);\n      action(object, startPosition, movementState);\n    }\n  }\n}\nfunction activateInertia(controller, inertiaStateName) {\n  if (defined(inertiaStateName)) {\n    // Re-enable inertia if it was disabled\n    let movementState = controller[inertiaStateName];\n    if (defined(movementState)) {\n      movementState.inertiaEnabled = true;\n    }\n    // Disable inertia on other movements\n    const inertiasToDisable = controller._inertiaDisablers[inertiaStateName];\n    if (defined(inertiasToDisable)) {\n      const length = inertiasToDisable.length;\n      for (let i = 0; i < length; ++i) {\n        movementState = controller[inertiasToDisable[i]];\n        if (defined(movementState)) {\n          movementState.inertiaEnabled = false;\n        }\n      }\n    }\n  }\n}\nconst scratchEventTypeArray = [];\nfunction reactToInput(controller, enabled, eventTypes, action, inertiaConstant, inertiaStateName) {\n  if (!defined(eventTypes)) {\n    return;\n  }\n  const aggregator = controller._aggregator;\n  if (!Array.isArray(eventTypes)) {\n    scratchEventTypeArray[0] = eventTypes;\n    eventTypes = scratchEventTypeArray;\n  }\n  const length = eventTypes.length;\n  for (let i = 0; i < length; ++i) {\n    const eventType = eventTypes[i];\n    const type = defined(eventType.eventType) ? eventType.eventType : eventType;\n    const modifier = eventType.modifier;\n    const movement = aggregator.isMoving(type, modifier) && aggregator.getMovement(type, modifier);\n    const startPosition = aggregator.getStartMousePosition(type, modifier);\n    if (controller.enableInputs && enabled) {\n      if (movement) {\n        action(controller, startPosition, movement);\n        activateInertia(controller, inertiaStateName);\n      } else if (inertiaConstant < 1.0) {\n        maintainInertia(aggregator, type, modifier, inertiaConstant, action, controller, inertiaStateName);\n      }\n    }\n  }\n}\nconst scratchZoomPickRay = new Ray();\nconst scratchPickCartesian = new Cartesian3();\nconst scratchZoomOffset = new Cartesian2();\nconst scratchZoomDirection = new Cartesian3();\nconst scratchCenterPixel = new Cartesian2();\nconst scratchCenterPosition = new Cartesian3();\nconst scratchPositionNormal = new Cartesian3();\nconst scratchPickNormal = new Cartesian3();\nconst scratchZoomAxis = new Cartesian3();\nconst scratchCameraPositionNormal = new Cartesian3();\n\n// Scratch variables used in zooming algorithm\nconst scratchTargetNormal = new Cartesian3();\nconst scratchCameraPosition = new Cartesian3();\nconst scratchCameraUpNormal = new Cartesian3();\nconst scratchCameraRightNormal = new Cartesian3();\nconst scratchForwardNormal = new Cartesian3();\nconst scratchPositionToTarget = new Cartesian3();\nconst scratchPositionToTargetNormal = new Cartesian3();\nconst scratchPan = new Cartesian3();\nconst scratchCenterMovement = new Cartesian3();\nconst scratchCenter = new Cartesian3();\nconst scratchCartesian = new Cartesian3();\nconst scratchCartesianTwo = new Cartesian3();\nconst scratchCartesianThree = new Cartesian3();\nconst scratchZoomViewOptions = {\n  orientation: new HeadingPitchRoll()\n};\nfunction handleZoom(object, startPosition, movement, zoomFactor, distanceMeasure, unitPositionDotDirection) {\n  let percentage = 1.0;\n  if (defined(unitPositionDotDirection)) {\n    percentage = CesiumMath.clamp(Math.abs(unitPositionDotDirection), 0.25, 1.0);\n  }\n  const diff = movement.endPosition.y - movement.startPosition.y;\n\n  // distanceMeasure should be the height above the ellipsoid.\n  // When approaching the surface, the zoomRate slows and stops minimumZoomDistance above it.\n  const approachingSurface = diff > 0;\n  const minHeight = approachingSurface ? object.minimumZoomDistance * percentage : 0;\n  const maxHeight = object.maximumZoomDistance;\n  const minDistance = distanceMeasure - minHeight;\n  let zoomRate = zoomFactor * minDistance;\n  zoomRate = CesiumMath.clamp(zoomRate, object._minimumZoomRate, object._maximumZoomRate);\n  let rangeWindowRatio = diff / object._scene.canvas.clientHeight;\n  rangeWindowRatio = Math.min(rangeWindowRatio, object.maximumMovementRatio);\n  let distance = zoomRate * rangeWindowRatio;\n  if (object.enableCollisionDetection || object.minimumZoomDistance === 0.0 || !defined(object._globe) // look-at mode\n  ) {\n    if (distance > 0.0 && Math.abs(distanceMeasure - minHeight) < 1.0) {\n      return;\n    }\n    if (distance < 0.0 && Math.abs(distanceMeasure - maxHeight) < 1.0) {\n      return;\n    }\n    if (distanceMeasure - distance < minHeight) {\n      distance = distanceMeasure - minHeight - 1.0;\n    } else if (distanceMeasure - distance > maxHeight) {\n      distance = distanceMeasure - maxHeight;\n    }\n  }\n  const scene = object._scene;\n  const camera = scene.camera;\n  const mode = scene.mode;\n  const orientation = scratchZoomViewOptions.orientation;\n  orientation.heading = camera.heading;\n  orientation.pitch = camera.pitch;\n  orientation.roll = camera.roll;\n  if (camera.frustum instanceof OrthographicFrustum) {\n    if (Math.abs(distance) > 0.0) {\n      camera.zoomIn(distance);\n      camera._adjustOrthographicFrustum(true);\n    }\n    return;\n  }\n  const sameStartPosition = defaultValue(movement.inertiaEnabled, Cartesian2.equals(startPosition, object._zoomMouseStart));\n  let zoomingOnVector = object._zoomingOnVector;\n  let rotatingZoom = object._rotatingZoom;\n  let pickedPosition;\n  if (!sameStartPosition) {\n    object._zoomMouseStart = Cartesian2.clone(startPosition, object._zoomMouseStart);\n\n    // When camera transform is set, such as tracking an entity, object._globe will be undefined, and no position should be picked\n    if (defined(object._globe) && mode === SceneMode.SCENE2D) {\n      pickedPosition = camera.getPickRay(startPosition, scratchZoomPickRay).origin;\n      pickedPosition = Cartesian3.fromElements(pickedPosition.y, pickedPosition.z, pickedPosition.x);\n    } else if (defined(object._globe)) {\n      pickedPosition = pickPosition(object, startPosition, scratchPickCartesian);\n    }\n    if (defined(pickedPosition)) {\n      object._useZoomWorldPosition = true;\n      object._zoomWorldPosition = Cartesian3.clone(pickedPosition, object._zoomWorldPosition);\n    } else {\n      object._useZoomWorldPosition = false;\n    }\n    zoomingOnVector = object._zoomingOnVector = false;\n    rotatingZoom = object._rotatingZoom = false;\n    object._zoomingUnderground = object._cameraUnderground;\n  }\n  if (!object._useZoomWorldPosition) {\n    camera.zoomIn(distance);\n    return;\n  }\n  let zoomOnVector = mode === SceneMode.COLUMBUS_VIEW;\n  if (camera.positionCartographic.height < 2000000) {\n    rotatingZoom = true;\n  }\n  if (!sameStartPosition || rotatingZoom) {\n    if (mode === SceneMode.SCENE2D) {\n      const worldPosition = object._zoomWorldPosition;\n      const endPosition = camera.position;\n      if (!Cartesian3.equals(worldPosition, endPosition) && camera.positionCartographic.height < object._maxCoord.x * 2.0) {\n        const savedX = camera.position.x;\n        const direction = Cartesian3.subtract(worldPosition, endPosition, scratchZoomDirection);\n        Cartesian3.normalize(direction, direction);\n        const d = Cartesian3.distance(worldPosition, endPosition) * distance / (camera.getMagnitude() * 0.5);\n        camera.move(direction, d * 0.5);\n        if (camera.position.x < 0.0 && savedX > 0.0 || camera.position.x > 0.0 && savedX < 0.0) {\n          pickedPosition = camera.getPickRay(startPosition, scratchZoomPickRay).origin;\n          pickedPosition = Cartesian3.fromElements(pickedPosition.y, pickedPosition.z, pickedPosition.x);\n          object._zoomWorldPosition = Cartesian3.clone(pickedPosition, object._zoomWorldPosition);\n        }\n      }\n    } else if (mode === SceneMode.SCENE3D) {\n      const cameraPositionNormal = Cartesian3.normalize(camera.position, scratchCameraPositionNormal);\n      if (object._cameraUnderground || object._zoomingUnderground || camera.positionCartographic.height < 3000.0 && Math.abs(Cartesian3.dot(camera.direction, cameraPositionNormal)) < 0.6) {\n        zoomOnVector = true;\n      } else {\n        const canvas = scene.canvas;\n        const centerPixel = scratchCenterPixel;\n        centerPixel.x = canvas.clientWidth / 2;\n        centerPixel.y = canvas.clientHeight / 2;\n        const centerPosition = pickPosition(object, centerPixel, scratchCenterPosition);\n        // If centerPosition is not defined, it means the globe does not cover the center position of screen\n\n        if (!defined(centerPosition)) {\n          zoomOnVector = true;\n        } else if (camera.positionCartographic.height < 1000000) {\n          // The math in the else block assumes the camera\n          // points toward the earth surface, so we check it here.\n          // Theoretically, we should check for 90 degree, but it doesn't behave well when parallel\n          // to the earth surface\n          if (Cartesian3.dot(camera.direction, cameraPositionNormal) >= -0.5) {\n            zoomOnVector = true;\n          } else {\n            const cameraPosition = scratchCameraPosition;\n            Cartesian3.clone(camera.position, cameraPosition);\n            const target = object._zoomWorldPosition;\n            let targetNormal = scratchTargetNormal;\n            targetNormal = Cartesian3.normalize(target, targetNormal);\n            if (Cartesian3.dot(targetNormal, cameraPositionNormal) < 0.0) {\n              return;\n            }\n            const center = scratchCenter;\n            const forward = scratchForwardNormal;\n            Cartesian3.clone(camera.direction, forward);\n            Cartesian3.add(cameraPosition, Cartesian3.multiplyByScalar(forward, 1000, scratchCartesian), center);\n            const positionToTarget = scratchPositionToTarget;\n            const positionToTargetNormal = scratchPositionToTargetNormal;\n            Cartesian3.subtract(target, cameraPosition, positionToTarget);\n            Cartesian3.normalize(positionToTarget, positionToTargetNormal);\n            const alphaDot = Cartesian3.dot(cameraPositionNormal, positionToTargetNormal);\n            if (alphaDot >= 0.0) {\n              // We zoomed past the target, and this zoom is not valid anymore.\n              // This line causes the next zoom movement to pick a new starting point.\n              object._zoomMouseStart.x = -1;\n              return;\n            }\n            const alpha = Math.acos(-alphaDot);\n            const cameraDistance = Cartesian3.magnitude(cameraPosition);\n            const targetDistance = Cartesian3.magnitude(target);\n            const remainingDistance = cameraDistance - distance;\n            const positionToTargetDistance = Cartesian3.magnitude(positionToTarget);\n            const gamma = Math.asin(CesiumMath.clamp(positionToTargetDistance / targetDistance * Math.sin(alpha), -1.0, 1.0));\n            const delta = Math.asin(CesiumMath.clamp(remainingDistance / targetDistance * Math.sin(alpha), -1.0, 1.0));\n            const beta = gamma - delta + alpha;\n            const up = scratchCameraUpNormal;\n            Cartesian3.normalize(cameraPosition, up);\n            let right = scratchCameraRightNormal;\n            right = Cartesian3.cross(positionToTargetNormal, up, right);\n            right = Cartesian3.normalize(right, right);\n            Cartesian3.normalize(Cartesian3.cross(up, right, scratchCartesian), forward);\n\n            // Calculate new position to move to\n            Cartesian3.multiplyByScalar(Cartesian3.normalize(center, scratchCartesian), Cartesian3.magnitude(center) - distance, center);\n            Cartesian3.normalize(cameraPosition, cameraPosition);\n            Cartesian3.multiplyByScalar(cameraPosition, remainingDistance, cameraPosition);\n\n            // Pan\n            const pMid = scratchPan;\n            Cartesian3.multiplyByScalar(Cartesian3.add(Cartesian3.multiplyByScalar(up, Math.cos(beta) - 1, scratchCartesianTwo), Cartesian3.multiplyByScalar(forward, Math.sin(beta), scratchCartesianThree), scratchCartesian), remainingDistance, pMid);\n            Cartesian3.add(cameraPosition, pMid, cameraPosition);\n            Cartesian3.normalize(center, up);\n            Cartesian3.normalize(Cartesian3.cross(up, right, scratchCartesian), forward);\n            const cMid = scratchCenterMovement;\n            Cartesian3.multiplyByScalar(Cartesian3.add(Cartesian3.multiplyByScalar(up, Math.cos(beta) - 1, scratchCartesianTwo), Cartesian3.multiplyByScalar(forward, Math.sin(beta), scratchCartesianThree), scratchCartesian), Cartesian3.magnitude(center), cMid);\n            Cartesian3.add(center, cMid, center);\n\n            // Update camera\n\n            // Set new position\n            Cartesian3.clone(cameraPosition, camera.position);\n\n            // Set new direction\n            Cartesian3.normalize(Cartesian3.subtract(center, cameraPosition, scratchCartesian), camera.direction);\n            Cartesian3.clone(camera.direction, camera.direction);\n\n            // Set new right & up vectors\n            Cartesian3.cross(camera.direction, camera.up, camera.right);\n            Cartesian3.cross(camera.right, camera.direction, camera.up);\n            camera.setView(scratchZoomViewOptions);\n            return;\n          }\n        } else {\n          const positionNormal = Cartesian3.normalize(centerPosition, scratchPositionNormal);\n          const pickedNormal = Cartesian3.normalize(object._zoomWorldPosition, scratchPickNormal);\n          const dotProduct = Cartesian3.dot(pickedNormal, positionNormal);\n          if (dotProduct > 0.0 && dotProduct < 1.0) {\n            const angle = CesiumMath.acosClamped(dotProduct);\n            const axis = Cartesian3.cross(pickedNormal, positionNormal, scratchZoomAxis);\n            const denom = Math.abs(angle) > CesiumMath.toRadians(20.0) ? camera.positionCartographic.height * 0.75 : camera.positionCartographic.height - distance;\n            const scalar = distance / denom;\n            camera.rotate(axis, angle * scalar);\n          }\n        }\n      }\n    }\n    object._rotatingZoom = !zoomOnVector;\n  }\n  if (!sameStartPosition && zoomOnVector || zoomingOnVector) {\n    let ray;\n    const zoomMouseStart = SceneTransforms.worldToWindowCoordinates(scene, object._zoomWorldPosition, scratchZoomOffset);\n    if (mode !== SceneMode.COLUMBUS_VIEW && Cartesian2.equals(startPosition, object._zoomMouseStart) && defined(zoomMouseStart)) {\n      ray = camera.getPickRay(zoomMouseStart, scratchZoomPickRay);\n    } else {\n      ray = camera.getPickRay(startPosition, scratchZoomPickRay);\n    }\n    const rayDirection = ray.direction;\n    if (mode === SceneMode.COLUMBUS_VIEW || mode === SceneMode.SCENE2D) {\n      Cartesian3.fromElements(rayDirection.y, rayDirection.z, rayDirection.x, rayDirection);\n    }\n    camera.move(rayDirection, distance);\n    object._zoomingOnVector = true;\n  } else {\n    camera.zoomIn(distance);\n  }\n  if (!object._cameraUnderground) {\n    camera.setView(scratchZoomViewOptions);\n  }\n}\nconst translate2DStart = new Ray();\nconst translate2DEnd = new Ray();\nconst scratchTranslateP0 = new Cartesian3();\nfunction translate2D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  let start = camera.getPickRay(movement.startPosition, translate2DStart).origin;\n  let end = camera.getPickRay(movement.endPosition, translate2DEnd).origin;\n  start = Cartesian3.fromElements(start.y, start.z, start.x, start);\n  end = Cartesian3.fromElements(end.y, end.z, end.x, end);\n  const direction = Cartesian3.subtract(start, end, scratchTranslateP0);\n  const distance = Cartesian3.magnitude(direction);\n  if (distance > 0.0) {\n    Cartesian3.normalize(direction, direction);\n    camera.move(direction, distance);\n  }\n}\nfunction zoom2D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n  const scene = controller._scene;\n  const camera = scene.camera;\n  handleZoom(controller, startPosition, movement, controller.zoomFactor, camera.getMagnitude());\n}\nconst twist2DStart = new Cartesian2();\nconst twist2DEnd = new Cartesian2();\nfunction twist2D(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    singleAxisTwist2D(controller, startPosition, movement.angleAndHeight);\n    return;\n  }\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n  let start = twist2DStart;\n  start.x = 2.0 / width * movement.startPosition.x - 1.0;\n  start.y = 2.0 / height * (height - movement.startPosition.y) - 1.0;\n  start = Cartesian2.normalize(start, start);\n  let end = twist2DEnd;\n  end.x = 2.0 / width * movement.endPosition.x - 1.0;\n  end.y = 2.0 / height * (height - movement.endPosition.y) - 1.0;\n  end = Cartesian2.normalize(end, end);\n  let startTheta = CesiumMath.acosClamped(start.x);\n  if (start.y < 0) {\n    startTheta = CesiumMath.TWO_PI - startTheta;\n  }\n  let endTheta = CesiumMath.acosClamped(end.x);\n  if (end.y < 0) {\n    endTheta = CesiumMath.TWO_PI - endTheta;\n  }\n  const theta = endTheta - startTheta;\n  camera.twistRight(theta);\n}\nfunction singleAxisTwist2D(controller, startPosition, movement) {\n  let rotateRate = controller._rotateFactor * controller._rotateRateRangeAdjustment;\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n  let phiWindowRatio = (movement.endPosition.x - movement.startPosition.x) / canvas.clientWidth;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n  const deltaPhi = rotateRate * phiWindowRatio * Math.PI * 4.0;\n  camera.twistRight(deltaPhi);\n}\nfunction update2D(controller) {\n  const rotatable2D = controller._scene.mapMode2D === MapMode2D.ROTATE;\n  if (!Matrix4.equals(Matrix4.IDENTITY, controller._scene.camera.transform)) {\n    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom2D, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n    if (rotatable2D) {\n      reactToInput(controller, controller.enableRotate, controller.translateEventTypes, twist2D, controller.inertiaSpin, \"_lastInertiaSpinMovement\");\n    }\n  } else {\n    reactToInput(controller, controller.enableTranslate, controller.translateEventTypes, translate2D, controller.inertiaTranslate, \"_lastInertiaTranslateMovement\");\n    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom2D, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n    if (rotatable2D) {\n      reactToInput(controller, controller.enableRotate, controller.tiltEventTypes, twist2D, controller.inertiaSpin, \"_lastInertiaTiltMovement\");\n    }\n  }\n}\nconst pickGlobeScratchRay = new Ray();\nconst scratchDepthIntersection = new Cartesian3();\nconst scratchRayIntersection = new Cartesian3();\nfunction pickPosition(controller, mousePosition, result) {\n  const scene = controller._scene;\n  const globe = controller._globe;\n  const camera = scene.camera;\n  let depthIntersection;\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(mousePosition, scratchDepthIntersection);\n  }\n  if (!defined(globe)) {\n    return Cartesian3.clone(depthIntersection, result);\n  }\n  const cullBackFaces = !controller._cameraUnderground;\n  const ray = camera.getPickRay(mousePosition, pickGlobeScratchRay);\n  const rayIntersection = globe.pickWorldCoordinates(ray, scene, cullBackFaces, scratchRayIntersection);\n  const pickDistance = defined(depthIntersection) ? Cartesian3.distance(depthIntersection, camera.positionWC) : Number.POSITIVE_INFINITY;\n  const rayDistance = defined(rayIntersection) ? Cartesian3.distance(rayIntersection, camera.positionWC) : Number.POSITIVE_INFINITY;\n  if (pickDistance < rayDistance) {\n    return Cartesian3.clone(depthIntersection, result);\n  }\n  return Cartesian3.clone(rayIntersection, result);\n}\nconst scratchDistanceCartographic = new Cartographic();\nfunction getDistanceFromSurface(controller) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const mode = scene.mode;\n  let height = 0.0;\n  if (mode === SceneMode.SCENE3D) {\n    const cartographic = ellipsoid.cartesianToCartographic(camera.position, scratchDistanceCartographic);\n    if (defined(cartographic)) {\n      height = cartographic.height;\n    }\n  } else {\n    height = camera.position.z;\n  }\n  const globeHeight = defaultValue(controller._scene.globeHeight, 0.0);\n  const distanceFromSurface = Math.abs(globeHeight - height);\n  return distanceFromSurface;\n}\nconst scratchSurfaceNormal = new Cartesian3();\nfunction getZoomDistanceUnderground(controller, ray) {\n  const origin = ray.origin;\n  const direction = ray.direction;\n  const distanceFromSurface = getDistanceFromSurface(controller);\n\n  // Weight zoom distance based on how strongly the pick ray is pointing inward.\n  // Geocentric normal is accurate enough for these purposes\n  const surfaceNormal = Cartesian3.normalize(origin, scratchSurfaceNormal);\n  let strength = Math.abs(Cartesian3.dot(surfaceNormal, direction));\n  strength = Math.max(strength, 0.5) * 2.0;\n  return distanceFromSurface * strength;\n}\nfunction getTiltCenterUnderground(controller, ray, pickedPosition, result) {\n  let distance = Cartesian3.distance(ray.origin, pickedPosition);\n  const distanceFromSurface = getDistanceFromSurface(controller);\n  const maximumDistance = CesiumMath.clamp(distanceFromSurface * 5.0, controller._minimumUndergroundPickDistance, controller._maximumUndergroundPickDistance);\n  if (distance > maximumDistance) {\n    // Simulate look-at behavior by tilting around a small invisible sphere\n    distance = Math.min(distance, distanceFromSurface / 5.0);\n    distance = Math.max(distance, 100.0);\n  }\n  return Ray.getPoint(ray, distance, result);\n}\nfunction getStrafeStartPositionUnderground(controller, ray, pickedPosition, result) {\n  let distance;\n  if (!defined(pickedPosition)) {\n    distance = getDistanceFromSurface(controller);\n  } else {\n    distance = Cartesian3.distance(ray.origin, pickedPosition);\n    if (distance > controller._maximumUndergroundPickDistance) {\n      // If the picked position is too far away set the strafe speed based on the\n      // camera's height from the globe surface\n      distance = getDistanceFromSurface(controller);\n    }\n  }\n  return Ray.getPoint(ray, distance, result);\n}\nconst scratchInertialDelta = new Cartesian2();\nfunction continueStrafing(controller, movement) {\n  // Update the end position continually based on the inertial delta\n  const originalEndPosition = movement.endPosition;\n  const inertialDelta = Cartesian2.subtract(movement.endPosition, movement.startPosition, scratchInertialDelta);\n  const endPosition = controller._strafeEndMousePosition;\n  Cartesian2.add(endPosition, inertialDelta, endPosition);\n  movement.endPosition = endPosition;\n  strafe(controller, movement, controller._strafeStartPosition);\n  movement.endPosition = originalEndPosition;\n}\nconst translateCVStartRay = new Ray();\nconst translateCVEndRay = new Ray();\nconst translateCVStartPos = new Cartesian3();\nconst translateCVEndPos = new Cartesian3();\nconst translateCVDifference = new Cartesian3();\nconst translateCVOrigin = new Cartesian3();\nconst translateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst translateCVStartMouse = new Cartesian2();\nconst translateCVEndMouse = new Cartesian2();\nfunction translateCV(controller, startPosition, movement) {\n  if (!Cartesian3.equals(startPosition, controller._translateMousePosition)) {\n    controller._looking = false;\n  }\n  if (!Cartesian3.equals(startPosition, controller._strafeMousePosition)) {\n    controller._strafing = false;\n  }\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n  if (controller._strafing) {\n    continueStrafing(controller, movement);\n    return;\n  }\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n  const startMouse = Cartesian2.clone(movement.startPosition, translateCVStartMouse);\n  const endMouse = Cartesian2.clone(movement.endPosition, translateCVEndMouse);\n  let startRay = camera.getPickRay(startMouse, translateCVStartRay);\n  const origin = Cartesian3.clone(Cartesian3.ZERO, translateCVOrigin);\n  const normal = Cartesian3.UNIT_X;\n  let globePos;\n  if (camera.position.z < controller._minimumPickingTerrainHeight) {\n    globePos = pickPosition(controller, startMouse, translateCVStartPos);\n    if (defined(globePos)) {\n      origin.x = globePos.x;\n    }\n  }\n  if (cameraUnderground || origin.x > camera.position.z && defined(globePos)) {\n    let pickPosition = globePos;\n    if (cameraUnderground) {\n      pickPosition = getStrafeStartPositionUnderground(controller, startRay, globePos, translateCVStartPos);\n    }\n    Cartesian2.clone(startPosition, controller._strafeMousePosition);\n    Cartesian2.clone(startPosition, controller._strafeEndMousePosition);\n    Cartesian3.clone(pickPosition, controller._strafeStartPosition);\n    controller._strafing = true;\n    strafe(controller, movement, controller._strafeStartPosition);\n    return;\n  }\n  const plane = Plane.fromPointNormal(origin, normal, translateCVPlane);\n  startRay = camera.getPickRay(startMouse, translateCVStartRay);\n  const startPlanePos = IntersectionTests.rayPlane(startRay, plane, translateCVStartPos);\n  const endRay = camera.getPickRay(endMouse, translateCVEndRay);\n  const endPlanePos = IntersectionTests.rayPlane(endRay, plane, translateCVEndPos);\n  if (!defined(startPlanePos) || !defined(endPlanePos)) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._translateMousePosition);\n    return;\n  }\n  const diff = Cartesian3.subtract(startPlanePos, endPlanePos, translateCVDifference);\n  const temp = diff.x;\n  diff.x = diff.y;\n  diff.y = diff.z;\n  diff.z = temp;\n  const mag = Cartesian3.magnitude(diff);\n  if (mag > CesiumMath.EPSILON6) {\n    Cartesian3.normalize(diff, diff);\n    camera.move(diff, mag);\n  }\n}\nconst rotateCVWindowPos = new Cartesian2();\nconst rotateCVWindowRay = new Ray();\nconst rotateCVCenter = new Cartesian3();\nconst rotateCVVerticalCenter = new Cartesian3();\nconst rotateCVTransform = new Matrix4();\nconst rotateCVVerticalTransform = new Matrix4();\nconst rotateCVOrigin = new Cartesian3();\nconst rotateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst rotateCVCartesian3 = new Cartesian3();\nconst rotateCVCart = new Cartographic();\nconst rotateCVOldTransform = new Matrix4();\nconst rotateCVQuaternion = new Quaternion();\nconst rotateCVMatrix = new Matrix3();\nconst tilt3DCartesian3 = new Cartesian3();\nfunction rotateCV(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltCVOffMap = false;\n    controller._looking = false;\n  }\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n  const scene = controller._scene;\n  const camera = scene.camera;\n  if (controller._tiltCVOffMap || !controller.onMap() || Math.abs(camera.position.z) > controller._minimumPickingTerrainHeight) {\n    controller._tiltCVOffMap = true;\n    rotateCVOnPlane(controller, startPosition, movement);\n  } else {\n    rotateCVOnTerrain(controller, startPosition, movement);\n  }\n}\nfunction rotateCVOnPlane(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n  const windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  const ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n  const normal = Cartesian3.UNIT_X;\n  const position = ray.origin;\n  const direction = ray.direction;\n  let scalar;\n  const normalDotDirection = Cartesian3.dot(normal, direction);\n  if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n    scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n  }\n  if (!defined(scalar) || scalar <= 0.0) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n  const center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n  Cartesian3.add(position, center, center);\n  const projection = scene.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  const cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n  const transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, rotateCVTransform);\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n  const oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n  camera._setTransform(transform);\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\nfunction rotateCVOnTerrain(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n  let center;\n  let ray;\n  const normal = Cartesian3.UNIT_X;\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, rotateCVCenter);\n  } else {\n    if (camera.position.z < controller._minimumPickingTerrainHeight) {\n      center = pickPosition(controller, startPosition, rotateCVCenter);\n    }\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      const position = ray.origin;\n      const direction = ray.direction;\n      let scalar;\n      const normalDotDirection = Cartesian3.dot(normal, direction);\n      if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n        scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n      }\n      if (!defined(scalar) || scalar <= 0.0) {\n        controller._looking = true;\n        look3D(controller, startPosition, movement);\n        Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        return;\n      }\n      center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n      Cartesian3.add(position, center, center);\n    }\n    if (cameraUnderground) {\n      if (!defined(ray)) {\n        ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      }\n      getTiltCenterUnderground(controller, ray, center, center);\n    }\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n  const canvas = scene.canvas;\n  const windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n  const origin = Cartesian3.clone(Cartesian3.ZERO, rotateCVOrigin);\n  origin.x = center.x;\n  const plane = Plane.fromPointNormal(origin, normal, rotateCVPlane);\n  const verticalCenter = IntersectionTests.rayPlane(ray, plane, rotateCVVerticalCenter);\n  const projection = camera._projection;\n  const ellipsoid = projection.ellipsoid;\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  let cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n  const transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, rotateCVTransform);\n  let verticalTransform;\n  if (defined(verticalCenter)) {\n    Cartesian3.fromElements(verticalCenter.y, verticalCenter.z, verticalCenter.x, verticalCenter);\n    cart = projection.unproject(verticalCenter, rotateCVCart);\n    ellipsoid.cartographicToCartesian(cart, verticalCenter);\n    verticalTransform = Transforms.eastNorthUpToFixedFrame(verticalCenter, ellipsoid, rotateCVVerticalTransform);\n  } else {\n    verticalTransform = transform;\n  }\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n  let constrainedAxis = Cartesian3.UNIT_Z;\n  const oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n  camera._setTransform(transform);\n  const tangent = Cartesian3.cross(Cartesian3.UNIT_Z, Cartesian3.normalize(camera.position, rotateCVCartesian3), rotateCVCartesian3);\n  const dot = Cartesian3.dot(camera.right, tangent);\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n  camera._setTransform(verticalTransform);\n  if (dot < 0.0) {\n    const movementDelta = movement.startPosition.y - movement.endPosition.y;\n    if (cameraUnderground && movementDelta < 0.0 || !cameraUnderground && movementDelta > 0.0) {\n      // Prevent camera from flipping past the up axis\n      constrainedAxis = undefined;\n    }\n    const oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n  if (defined(camera.constrainedAxis)) {\n    const right = Cartesian3.cross(camera.direction, camera.constrainedAxis, tilt3DCartesian3);\n    if (!Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n  const originalPosition = Cartesian3.clone(camera.positionWC, rotateCVCartesian3);\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller, true);\n  }\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n    const magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(camera.position, Math.sqrt(magSqrd), camera.position);\n    }\n    const angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    const axis = Cartesian3.cross(originalPosition, camera.position, originalPosition);\n    Cartesian3.normalize(axis, axis);\n    const quaternion = Quaternion.fromAxisAngle(axis, angle, rotateCVQuaternion);\n    const rotation = Matrix3.fromQuaternion(quaternion, rotateCVMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n    camera._setTransform(oldTransform);\n  }\n}\nconst zoomCVWindowPos = new Cartesian2();\nconst zoomCVWindowRay = new Ray();\nconst zoomCVIntersection = new Cartesian3();\nfunction zoomCV(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n  const cameraUnderground = controller._cameraUnderground;\n  let windowPosition;\n  if (cameraUnderground) {\n    windowPosition = startPosition;\n  } else {\n    windowPosition = zoomCVWindowPos;\n    windowPosition.x = canvas.clientWidth / 2;\n    windowPosition.y = canvas.clientHeight / 2;\n  }\n  const ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n  const position = ray.origin;\n  const direction = ray.direction;\n  const height = camera.position.z;\n  let intersection;\n  if (height < controller._minimumPickingTerrainHeight) {\n    intersection = pickPosition(controller, windowPosition, zoomCVIntersection);\n  }\n  let distance;\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(position, intersection);\n  }\n  if (cameraUnderground) {\n    const distanceUnderground = getZoomDistanceUnderground(controller, ray, height);\n    if (defined(distance)) {\n      distance = Math.min(distance, distanceUnderground);\n    } else {\n      distance = distanceUnderground;\n    }\n  }\n  if (!defined(distance)) {\n    const normal = Cartesian3.UNIT_X;\n    distance = -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  }\n  handleZoom(controller, startPosition, movement, controller.zoomFactor, distance);\n}\nfunction updateCV(controller) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {\n    reactToInput(controller, controller.enableRotate, controller.rotateEventTypes, rotate3D, controller.inertiaSpin, \"_lastInertiaSpinMovement\");\n    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom3D, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n  } else {\n    const tweens = controller._tweens;\n    if (controller._aggregator.anyButtonDown) {\n      tweens.removeAll();\n    }\n    reactToInput(controller, controller.enableTilt, controller.tiltEventTypes, rotateCV, controller.inertiaSpin, \"_lastInertiaTiltMovement\");\n    reactToInput(controller, controller.enableTranslate, controller.translateEventTypes, translateCV, controller.inertiaTranslate, \"_lastInertiaTranslateMovement\");\n    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoomCV, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n    reactToInput(controller, controller.enableLook, controller.lookEventTypes, look3D);\n    if (!controller._aggregator.anyButtonDown && !tweens.contains(controller._tween)) {\n      const tween = camera.createCorrectPositionTween(controller.bounceAnimationTime);\n      if (defined(tween)) {\n        controller._tween = tweens.add(tween);\n      }\n    }\n    tweens.update();\n  }\n}\nconst scratchStrafeRay = new Ray();\nconst scratchStrafePlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst scratchStrafeIntersection = new Cartesian3();\nconst scratchStrafeDirection = new Cartesian3();\nfunction strafe(controller, movement, strafeStartPosition) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const ray = camera.getPickRay(movement.endPosition, scratchStrafeRay);\n  let direction = Cartesian3.clone(camera.direction, scratchStrafeDirection);\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.z, direction.x, direction.y, direction);\n  }\n  const plane = Plane.fromPointNormal(strafeStartPosition, direction, scratchStrafePlane);\n  const intersection = IntersectionTests.rayPlane(ray, plane, scratchStrafeIntersection);\n  if (!defined(intersection)) {\n    return;\n  }\n  direction = Cartesian3.subtract(strafeStartPosition, intersection, direction);\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.y, direction.z, direction.x, direction);\n  }\n  Cartesian3.add(camera.position, direction, camera.position);\n}\nconst spin3DPick = new Cartesian3();\nconst scratchCartographic = new Cartographic();\nconst scratchRadii = new Cartesian3();\nconst scratchEllipsoid = new Ellipsoid();\nconst scratchLookUp = new Cartesian3();\nconst scratchNormal = new Cartesian3();\nconst scratchMousePosition = new Cartesian3();\nfunction spin3D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n  let ellipsoid = controller._ellipsoid;\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n  let magnitude;\n  let radii;\n  const up = ellipsoid.geodeticSurfaceNormal(camera.position, scratchLookUp);\n  if (Cartesian2.equals(startPosition, controller._rotateMousePosition)) {\n    if (controller._looking) {\n      look3D(controller, startPosition, movement, up);\n    } else if (controller._rotating) {\n      rotate3D(controller, startPosition, movement);\n    } else if (controller._strafing) {\n      continueStrafing(controller, movement);\n    } else {\n      if (Cartesian3.magnitude(camera.position) < Cartesian3.magnitude(controller._rotateStartPosition)) {\n        // Pan action is no longer valid if camera moves below the pan ellipsoid\n        return;\n      }\n      magnitude = Cartesian3.magnitude(controller._rotateStartPosition);\n      radii = scratchRadii;\n      radii.x = radii.y = radii.z = magnitude;\n      ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n      pan3D(controller, startPosition, movement, ellipsoid);\n    }\n    return;\n  }\n  controller._looking = false;\n  controller._rotating = false;\n  controller._strafing = false;\n  const height = ellipsoid.cartesianToCartographic(camera.positionWC, scratchCartographic).height;\n  const globe = controller._globe;\n  if (defined(globe) && height < controller._minimumPickingTerrainHeight) {\n    const mousePos = pickPosition(controller, movement.startPosition, scratchMousePosition);\n    if (defined(mousePos)) {\n      let strafing = false;\n      const ray = camera.getPickRay(movement.startPosition, pickGlobeScratchRay);\n      if (cameraUnderground) {\n        strafing = true;\n        getStrafeStartPositionUnderground(controller, ray, mousePos, mousePos);\n      } else {\n        const normal = ellipsoid.geodeticSurfaceNormal(mousePos, scratchNormal);\n        const tangentPick = Math.abs(Cartesian3.dot(ray.direction, normal)) < 0.05;\n        if (tangentPick) {\n          strafing = true;\n        } else {\n          strafing = Cartesian3.magnitude(camera.position) < Cartesian3.magnitude(mousePos);\n        }\n      }\n      if (strafing) {\n        Cartesian2.clone(startPosition, controller._strafeEndMousePosition);\n        Cartesian3.clone(mousePos, controller._strafeStartPosition);\n        controller._strafing = true;\n        strafe(controller, movement, controller._strafeStartPosition);\n      } else {\n        magnitude = Cartesian3.magnitude(mousePos);\n        radii = scratchRadii;\n        radii.x = radii.y = radii.z = magnitude;\n        ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n        pan3D(controller, startPosition, movement, ellipsoid);\n        Cartesian3.clone(mousePos, controller._rotateStartPosition);\n      }\n    } else {\n      controller._looking = true;\n      look3D(controller, startPosition, movement, up);\n    }\n  } else if (defined(camera.pickEllipsoid(movement.startPosition, controller._ellipsoid, spin3DPick))) {\n    pan3D(controller, startPosition, movement, controller._ellipsoid);\n    Cartesian3.clone(spin3DPick, controller._rotateStartPosition);\n  } else if (height > controller._minimumTrackBallHeight) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n  } else {\n    controller._looking = true;\n    look3D(controller, startPosition, movement, up);\n  }\n  Cartesian2.clone(startPosition, controller._rotateMousePosition);\n}\nfunction rotate3D(controller, startPosition, movement, constrainedAxis, rotateOnlyVertical, rotateOnlyHorizontal) {\n  rotateOnlyVertical = defaultValue(rotateOnlyVertical, false);\n  rotateOnlyHorizontal = defaultValue(rotateOnlyHorizontal, false);\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n  const oldAxis = camera.constrainedAxis;\n  if (defined(constrainedAxis)) {\n    camera.constrainedAxis = constrainedAxis;\n  }\n  const rho = Cartesian3.magnitude(camera.position);\n  let rotateRate = controller._rotateFactor * (rho - controller._rotateRateRangeAdjustment);\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n  let phiWindowRatio = (movement.startPosition.x - movement.endPosition.x) / canvas.clientWidth;\n  let thetaWindowRatio = (movement.startPosition.y - movement.endPosition.y) / canvas.clientHeight;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n  thetaWindowRatio = Math.min(thetaWindowRatio, controller.maximumMovementRatio);\n  const deltaPhi = rotateRate * phiWindowRatio * Math.PI * 2.0;\n  let deltaTheta = rotateRate * thetaWindowRatio * Math.PI;\n  if (defined(constrainedAxis) && defined(controller.maximumTiltAngle)) {\n    const maximumTiltAngle = controller.maximumTiltAngle;\n    const dotProduct = Cartesian3.dot(camera.direction, constrainedAxis);\n    const tilt = Math.PI - Math.acos(dotProduct) + deltaTheta;\n    if (tilt > maximumTiltAngle) {\n      deltaTheta -= tilt - maximumTiltAngle;\n    }\n  }\n  if (!rotateOnlyVertical) {\n    camera.rotateRight(deltaPhi);\n  }\n  if (!rotateOnlyHorizontal) {\n    camera.rotateUp(deltaTheta);\n  }\n  camera.constrainedAxis = oldAxis;\n}\nconst pan3DP0 = Cartesian4.clone(Cartesian4.UNIT_W);\nconst pan3DP1 = Cartesian4.clone(Cartesian4.UNIT_W);\nconst pan3DTemp0 = new Cartesian3();\nconst pan3DTemp1 = new Cartesian3();\nconst pan3DTemp2 = new Cartesian3();\nconst pan3DTemp3 = new Cartesian3();\nconst pan3DStartMousePosition = new Cartesian2();\nconst pan3DEndMousePosition = new Cartesian2();\nconst pan3DDiffMousePosition = new Cartesian2();\nconst pan3DPixelDimensions = new Cartesian2();\nconst panRay = new Ray();\nfunction pan3D(controller, startPosition, movement, ellipsoid) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const startMousePosition = Cartesian2.clone(movement.startPosition, pan3DStartMousePosition);\n  const endMousePosition = Cartesian2.clone(movement.endPosition, pan3DEndMousePosition);\n  const height = ellipsoid.cartesianToCartographic(camera.positionWC, scratchCartographic).height;\n  let p0, p1;\n  if (!movement.inertiaEnabled && height < controller._minimumPickingTerrainHeight) {\n    p0 = Cartesian3.clone(controller._panLastWorldPosition, pan3DP0);\n\n    // Use the last picked world position unless we're starting a new drag\n    if (!defined(controller._globe) && !Cartesian2.equalsEpsilon(startMousePosition, controller._panLastMousePosition)) {\n      p0 = pickPosition(controller, startMousePosition, pan3DP0);\n    }\n    if (!defined(controller._globe) && defined(p0)) {\n      const toCenter = Cartesian3.subtract(p0, camera.positionWC, pan3DTemp1);\n      const toCenterProj = Cartesian3.multiplyByScalar(camera.directionWC, Cartesian3.dot(camera.directionWC, toCenter), pan3DTemp1);\n      const distanceToNearPlane = Cartesian3.magnitude(toCenterProj);\n      const pixelDimensions = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distanceToNearPlane, scene.pixelRatio, pan3DPixelDimensions);\n      const dragDelta = Cartesian2.subtract(endMousePosition, startMousePosition, pan3DDiffMousePosition);\n\n      // Move the camera to the the distance the cursor moved in worldspace\n      const right = Cartesian3.multiplyByScalar(camera.rightWC, dragDelta.x * pixelDimensions.x, pan3DTemp1);\n\n      // Move the camera towards the picked position in worldspace as the camera is pointed towards a horizon view\n      const cameraPositionNormal = Cartesian3.normalize(camera.positionWC, scratchCameraPositionNormal);\n      const endPickDirection = camera.getPickRay(endMousePosition, panRay).direction;\n      const endPickProj = Cartesian3.subtract(endPickDirection, Cartesian3.projectVector(endPickDirection, camera.rightWC, pan3DTemp2), pan3DTemp2);\n      const angle = Cartesian3.angleBetween(endPickProj, camera.directionWC);\n      let forward = 1.0;\n      if (defined(camera.frustum.fov)) {\n        forward = Math.max(Math.tan(angle), 0.1); // Clamp so we don't make the magnitude infinitely large when the angle is small\n      }\n      let dot = Math.abs(Cartesian3.dot(camera.directionWC, cameraPositionNormal));\n      const magnitude = -dragDelta.y * pixelDimensions.y * 2.0 / Math.sqrt(forward) * (1.0 - dot);\n      const direction = Cartesian3.multiplyByScalar(endPickDirection, magnitude, pan3DTemp2);\n\n      // Move the camera up the distance the cursor moved in worldspace as the camera is pointed towards the center\n      dot = Math.abs(Cartesian3.dot(camera.upWC, cameraPositionNormal));\n      const up = Cartesian3.multiplyByScalar(camera.upWC, -dragDelta.y * (1.0 - dot) * pixelDimensions.y, pan3DTemp3);\n      p1 = Cartesian3.add(p0, right, pan3DP1);\n      p1 = Cartesian3.add(p1, direction, p1);\n      p1 = Cartesian3.add(p1, up, p1);\n      Cartesian3.clone(p1, controller._panLastWorldPosition);\n      Cartesian2.clone(endMousePosition, controller._panLastMousePosition);\n    }\n  }\n  if (!defined(p0) || !defined(p1)) {\n    p0 = camera.pickEllipsoid(startMousePosition, ellipsoid, pan3DP0);\n    p1 = camera.pickEllipsoid(endMousePosition, ellipsoid, pan3DP1);\n  }\n  if (!defined(p0) || !defined(p1)) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n  p0 = camera.worldToCameraCoordinates(p0, p0);\n  p1 = camera.worldToCameraCoordinates(p1, p1);\n  if (!defined(camera.constrainedAxis)) {\n    Cartesian3.normalize(p0, p0);\n    Cartesian3.normalize(p1, p1);\n    const dot = Cartesian3.dot(p0, p1);\n    const axis = Cartesian3.cross(p0, p1, pan3DTemp0);\n    if (dot < 1.0 && !Cartesian3.equalsEpsilon(axis, Cartesian3.ZERO, CesiumMath.EPSILON14)) {\n      // dot is in [0, 1]\n      const angle = Math.acos(dot);\n      camera.rotate(axis, angle);\n    }\n  } else {\n    const basis0 = camera.constrainedAxis;\n    const basis1 = Cartesian3.mostOrthogonalAxis(basis0, pan3DTemp0);\n    Cartesian3.cross(basis1, basis0, basis1);\n    Cartesian3.normalize(basis1, basis1);\n    const basis2 = Cartesian3.cross(basis0, basis1, pan3DTemp1);\n    const startRho = Cartesian3.magnitude(p0);\n    const startDot = Cartesian3.dot(basis0, p0);\n    const startTheta = Math.acos(startDot / startRho);\n    const startRej = Cartesian3.multiplyByScalar(basis0, startDot, pan3DTemp2);\n    Cartesian3.subtract(p0, startRej, startRej);\n    Cartesian3.normalize(startRej, startRej);\n    const endRho = Cartesian3.magnitude(p1);\n    const endDot = Cartesian3.dot(basis0, p1);\n    const endTheta = Math.acos(endDot / endRho);\n    const endRej = Cartesian3.multiplyByScalar(basis0, endDot, pan3DTemp3);\n    Cartesian3.subtract(p1, endRej, endRej);\n    Cartesian3.normalize(endRej, endRej);\n    let startPhi = Math.acos(Cartesian3.dot(startRej, basis1));\n    if (Cartesian3.dot(startRej, basis2) < 0) {\n      startPhi = CesiumMath.TWO_PI - startPhi;\n    }\n    let endPhi = Math.acos(Cartesian3.dot(endRej, basis1));\n    if (Cartesian3.dot(endRej, basis2) < 0) {\n      endPhi = CesiumMath.TWO_PI - endPhi;\n    }\n    const deltaPhi = startPhi - endPhi;\n    let east;\n    if (Cartesian3.equalsEpsilon(basis0, camera.position, CesiumMath.EPSILON2)) {\n      east = camera.right;\n    } else {\n      east = Cartesian3.cross(basis0, camera.position, pan3DTemp0);\n    }\n    const planeNormal = Cartesian3.cross(basis0, east, pan3DTemp0);\n    const side0 = Cartesian3.dot(planeNormal, Cartesian3.subtract(p0, basis0, pan3DTemp1));\n    const side1 = Cartesian3.dot(planeNormal, Cartesian3.subtract(p1, basis0, pan3DTemp1));\n    let deltaTheta;\n    if (side0 > 0 && side1 > 0) {\n      deltaTheta = endTheta - startTheta;\n    } else if (side0 > 0 && side1 <= 0) {\n      if (Cartesian3.dot(camera.position, basis0) > 0) {\n        deltaTheta = -startTheta - endTheta;\n      } else {\n        deltaTheta = startTheta + endTheta;\n      }\n    } else {\n      deltaTheta = startTheta - endTheta;\n    }\n    camera.rotateRight(deltaPhi);\n    camera.rotateUp(deltaTheta);\n  }\n}\nconst zoom3DUnitPosition = new Cartesian3();\nconst zoom3DCartographic = new Cartographic();\nlet preIntersectionDistance = 0;\nfunction zoom3D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n  const inertiaMovement = movement.inertiaEnabled;\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n  const cameraUnderground = controller._cameraUnderground;\n  let windowPosition;\n  if (cameraUnderground) {\n    windowPosition = startPosition;\n  } else {\n    windowPosition = zoomCVWindowPos;\n    windowPosition.x = canvas.clientWidth / 2;\n    windowPosition.y = canvas.clientHeight / 2;\n  }\n  const ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n  let intersection;\n  const height = ellipsoid.cartesianToCartographic(camera.position, zoom3DCartographic).height;\n  const approachingCollision = Math.abs(preIntersectionDistance) < controller.minimumPickingTerrainDistanceWithInertia;\n  const needPickGlobe = inertiaMovement ? approachingCollision : height < controller._minimumPickingTerrainHeight;\n  if (needPickGlobe) {\n    intersection = pickPosition(controller, windowPosition, zoomCVIntersection);\n  }\n  let distance;\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(ray.origin, intersection);\n    preIntersectionDistance = distance;\n  }\n  if (cameraUnderground) {\n    const distanceUnderground = getZoomDistanceUnderground(controller, ray, height);\n    if (defined(distance)) {\n      distance = Math.min(distance, distanceUnderground);\n    } else {\n      distance = distanceUnderground;\n    }\n  }\n  if (!defined(distance)) {\n    distance = height;\n  }\n  const unitPosition = Cartesian3.normalize(camera.position, zoom3DUnitPosition);\n  handleZoom(controller, startPosition, movement, controller.zoomFactor, distance, Cartesian3.dot(unitPosition, camera.direction));\n}\nconst tilt3DWindowPos = new Cartesian2();\nconst tilt3DRay = new Ray();\nconst tilt3DCenter = new Cartesian3();\nconst tilt3DVerticalCenter = new Cartesian3();\nconst tilt3DTransform = new Matrix4();\nconst tilt3DVerticalTransform = new Matrix4();\nconst tilt3DOldTransform = new Matrix4();\nconst tilt3DQuaternion = new Quaternion();\nconst tilt3DMatrix = new Matrix3();\nconst tilt3DCart = new Cartographic();\nconst tilt3DLookUp = new Cartesian3();\nfunction tilt3D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    return;\n  }\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltOnEllipsoid = false;\n    controller._looking = false;\n  }\n  if (controller._looking) {\n    const up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, tilt3DLookUp);\n    look3D(controller, startPosition, movement, up);\n    return;\n  }\n  const ellipsoid = controller._ellipsoid;\n  const cartographic = ellipsoid.cartesianToCartographic(camera.position, tilt3DCart);\n  if (controller._tiltOnEllipsoid || cartographic.height > controller._minimumCollisionTerrainHeight) {\n    controller._tiltOnEllipsoid = true;\n    tilt3DOnEllipsoid(controller, startPosition, movement);\n  } else {\n    tilt3DOnTerrain(controller, startPosition, movement);\n  }\n}\nconst tilt3DOnEllipsoidCartographic = new Cartographic();\nfunction tilt3DOnEllipsoid(controller, startPosition, movement) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const minHeight = controller.minimumZoomDistance * 0.25;\n  const height = ellipsoid.cartesianToCartographic(camera.positionWC, tilt3DOnEllipsoidCartographic).height;\n  if (height - minHeight - 1.0 < CesiumMath.EPSILON3 && movement.endPosition.y - movement.startPosition.y < 0) {\n    return;\n  }\n  const canvas = scene.canvas;\n  const windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  const ray = camera.getPickRay(windowPosition, tilt3DRay);\n  let center;\n  const intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n  if (defined(intersection)) {\n    center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n  } else if (height > controller._minimumTrackBallHeight) {\n    const grazingAltitudeLocation = IntersectionTests.grazingAltitudeLocation(ray, ellipsoid);\n    if (!defined(grazingAltitudeLocation)) {\n      return;\n    }\n    const grazingAltitudeCart = ellipsoid.cartesianToCartographic(grazingAltitudeLocation, tilt3DCart);\n    grazingAltitudeCart.height = 0.0;\n    center = ellipsoid.cartographicToCartesian(grazingAltitudeCart, tilt3DCenter);\n  } else {\n    controller._looking = true;\n    const up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, tilt3DLookUp);\n    look3D(controller, startPosition, movement, up);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n  const transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, tilt3DTransform);\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n  const oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n  camera._setTransform(transform);\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\nfunction tilt3DOnTerrain(controller, startPosition, movement) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n  let center;\n  let ray;\n  let intersection;\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, tilt3DCenter);\n  } else {\n    center = pickPosition(controller, startPosition, tilt3DCenter);\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, tilt3DRay);\n      intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n      if (!defined(intersection)) {\n        const cartographic = ellipsoid.cartesianToCartographic(camera.position, tilt3DCart);\n        if (cartographic.height <= controller._minimumTrackBallHeight) {\n          controller._looking = true;\n          const up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, tilt3DLookUp);\n          look3D(controller, startPosition, movement, up);\n          Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        }\n        return;\n      }\n      center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n    }\n    if (cameraUnderground) {\n      if (!defined(ray)) {\n        ray = camera.getPickRay(startPosition, tilt3DRay);\n      }\n      getTiltCenterUnderground(controller, ray, center, center);\n    }\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n  const canvas = scene.canvas;\n  const windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, tilt3DRay);\n  const mag = Cartesian3.magnitude(center);\n  const radii = Cartesian3.fromElements(mag, mag, mag, scratchRadii);\n  const newEllipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n  intersection = IntersectionTests.rayEllipsoid(ray, newEllipsoid);\n  if (!defined(intersection)) {\n    return;\n  }\n  const t = Cartesian3.magnitude(ray.origin) > mag ? intersection.start : intersection.stop;\n  const verticalCenter = Ray.getPoint(ray, t, tilt3DVerticalCenter);\n  const transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, tilt3DTransform);\n  const verticalTransform = Transforms.eastNorthUpToFixedFrame(verticalCenter, newEllipsoid, tilt3DVerticalTransform);\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n  let constrainedAxis = Cartesian3.UNIT_Z;\n  const oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n  camera._setTransform(verticalTransform);\n  const tangent = Cartesian3.cross(verticalCenter, camera.positionWC, tilt3DCartesian3);\n  const dot = Cartesian3.dot(camera.rightWC, tangent);\n  if (dot < 0.0) {\n    const movementDelta = movement.startPosition.y - movement.endPosition.y;\n    if (cameraUnderground && movementDelta < 0.0 || !cameraUnderground && movementDelta > 0.0) {\n      // Prevent camera from flipping past the up axis\n      constrainedAxis = undefined;\n    }\n    const oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n  camera._setTransform(transform);\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n  if (defined(camera.constrainedAxis)) {\n    const right = Cartesian3.cross(camera.direction, camera.constrainedAxis, tilt3DCartesian3);\n    if (!Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n  const originalPosition = Cartesian3.clone(camera.positionWC, tilt3DCartesian3);\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller, true);\n  }\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n    const magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(camera.position, Math.sqrt(magSqrd), camera.position);\n    }\n    const angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    const axis = Cartesian3.cross(originalPosition, camera.position, originalPosition);\n    Cartesian3.normalize(axis, axis);\n    const quaternion = Quaternion.fromAxisAngle(axis, angle, tilt3DQuaternion);\n    const rotation = Matrix3.fromQuaternion(quaternion, tilt3DMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n    camera._setTransform(oldTransform);\n  }\n}\nconst look3DStartPos = new Cartesian2();\nconst look3DEndPos = new Cartesian2();\nconst look3DStartRay = new Ray();\nconst look3DEndRay = new Ray();\nconst look3DNegativeRot = new Cartesian3();\nconst look3DTan = new Cartesian3();\nfunction look3D(controller, startPosition, movement, rotationAxis) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const startPos = look3DStartPos;\n  startPos.x = movement.startPosition.x;\n  startPos.y = 0.0;\n  const endPos = look3DEndPos;\n  endPos.x = movement.endPosition.x;\n  endPos.y = 0.0;\n  let startRay = camera.getPickRay(startPos, look3DStartRay);\n  let endRay = camera.getPickRay(endPos, look3DEndRay);\n  let angle = 0.0;\n  let start;\n  let end;\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n  let dot = Cartesian3.dot(start, end);\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n  angle = movement.startPosition.x > movement.endPosition.x ? -angle : angle;\n  const horizontalRotationAxis = controller._horizontalRotationAxis;\n  if (defined(rotationAxis)) {\n    camera.look(rotationAxis, -angle);\n  } else if (defined(horizontalRotationAxis)) {\n    camera.look(horizontalRotationAxis, -angle);\n  } else {\n    camera.lookLeft(angle);\n  }\n  startPos.x = 0.0;\n  startPos.y = movement.startPosition.y;\n  endPos.x = 0.0;\n  endPos.y = movement.endPosition.y;\n  startRay = camera.getPickRay(startPos, look3DStartRay);\n  endRay = camera.getPickRay(endPos, look3DEndRay);\n  angle = 0.0;\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n  dot = Cartesian3.dot(start, end);\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n  angle = movement.startPosition.y > movement.endPosition.y ? -angle : angle;\n  rotationAxis = defaultValue(rotationAxis, horizontalRotationAxis);\n  if (defined(rotationAxis)) {\n    const direction = camera.direction;\n    const negativeRotationAxis = Cartesian3.negate(rotationAxis, look3DNegativeRot);\n    const northParallel = Cartesian3.equalsEpsilon(direction, rotationAxis, CesiumMath.EPSILON2);\n    const southParallel = Cartesian3.equalsEpsilon(direction, negativeRotationAxis, CesiumMath.EPSILON2);\n    if (!northParallel && !southParallel) {\n      dot = Cartesian3.dot(direction, rotationAxis);\n      let angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n      dot = Cartesian3.dot(direction, negativeRotationAxis);\n      angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n      const tangent = Cartesian3.cross(rotationAxis, direction, look3DTan);\n      camera.look(tangent, angle);\n    } else if (northParallel && angle < 0 || southParallel && angle > 0) {\n      camera.look(camera.right, -angle);\n    }\n  } else {\n    camera.lookUp(angle);\n  }\n}\nfunction update3D(controller) {\n  reactToInput(controller, controller.enableRotate, controller.rotateEventTypes, spin3D, controller.inertiaSpin, \"_lastInertiaSpinMovement\");\n  reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom3D, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n  reactToInput(controller, controller.enableTilt, controller.tiltEventTypes, tilt3D, controller.inertiaSpin, \"_lastInertiaTiltMovement\");\n  reactToInput(controller, controller.enableLook, controller.lookEventTypes, look3D);\n}\nconst scratchAdjustHeightTransform = new Matrix4();\nconst scratchAdjustHeightCartographic = new Cartographic();\nfunction adjustHeightForTerrain(controller, cameraChanged) {\n  controller._adjustedHeightForTerrain = true;\n  const scene = controller._scene;\n  const mode = scene.mode;\n  if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n    return;\n  }\n  const camera = scene.camera;\n  const ellipsoid = defaultValue(scene.ellipsoid, Ellipsoid.WGS84);\n  const projection = scene.mapProjection;\n  let transform;\n  let mag;\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    transform = Matrix4.clone(camera.transform, scratchAdjustHeightTransform);\n    mag = Cartesian3.magnitude(camera.position);\n    camera._setTransform(Matrix4.IDENTITY);\n  }\n  const cartographic = scratchAdjustHeightCartographic;\n  if (mode === SceneMode.SCENE3D) {\n    ellipsoid.cartesianToCartographic(camera.position, cartographic);\n  } else {\n    projection.unproject(camera.position, cartographic);\n  }\n  let heightUpdated = false;\n  if (cartographic.height < controller._minimumCollisionTerrainHeight) {\n    const globeHeight = controller._scene.globeHeight;\n    if (defined(globeHeight)) {\n      const height = globeHeight + controller.minimumZoomDistance;\n      const difference = globeHeight - controller._lastGlobeHeight;\n      const percentDifference = difference / controller._lastGlobeHeight;\n\n      // Unless the camera has been moved by user input, to avoid big jumps during tile loads\n      // only make height updates when the globe height has been fairly stable across several frames\n      if (cartographic.height < height && (cameraChanged || Math.abs(percentDifference) <= 0.1)) {\n        cartographic.height = height;\n        if (mode === SceneMode.SCENE3D) {\n          ellipsoid.cartographicToCartesian(cartographic, camera.position);\n        } else {\n          projection.project(cartographic, camera.position);\n        }\n        heightUpdated = true;\n      }\n      if (cameraChanged || Math.abs(percentDifference) <= 0.1) {\n        controller._lastGlobeHeight = globeHeight;\n      } else {\n        controller._lastGlobeHeight += difference * 0.1;\n      }\n    }\n  }\n  if (defined(transform)) {\n    camera._setTransform(transform);\n    if (heightUpdated) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.negate(camera.position, camera.direction);\n      Cartesian3.multiplyByScalar(camera.position, Math.max(mag, controller.minimumZoomDistance), camera.position);\n      Cartesian3.normalize(camera.direction, camera.direction);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.cross(camera.right, camera.direction, camera.up);\n    }\n  }\n}\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.onMap = function () {\n  const scene = this._scene;\n  const mode = scene.mode;\n  const camera = scene.camera;\n  if (mode === SceneMode.COLUMBUS_VIEW) {\n    return Math.abs(camera.position.x) - this._maxCoord.x < 0 && Math.abs(camera.position.y) - this._maxCoord.y < 0;\n  }\n  return true;\n};\nconst scratchPreviousPosition = new Cartesian3();\nconst scratchPreviousDirection = new Cartesian3();\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.update = function () {\n  const scene = this._scene;\n  const {\n    camera,\n    globe,\n    mode\n  } = scene;\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    this._globe = undefined;\n    this._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  } else {\n    this._globe = globe;\n    this._ellipsoid = defaultValue(scene.ellipsoid, Ellipsoid.default);\n  }\n  const {\n    verticalExaggeration,\n    verticalExaggerationRelativeHeight\n  } = scene;\n  this._minimumCollisionTerrainHeight = VerticalExaggeration.getHeight(this.minimumCollisionTerrainHeight, verticalExaggeration, verticalExaggerationRelativeHeight);\n  this._minimumPickingTerrainHeight = VerticalExaggeration.getHeight(this.minimumPickingTerrainHeight, verticalExaggeration, verticalExaggerationRelativeHeight);\n  this._minimumTrackBallHeight = VerticalExaggeration.getHeight(this.minimumTrackBallHeight, verticalExaggeration, verticalExaggerationRelativeHeight);\n  this._cameraUnderground = scene.cameraUnderground && defined(this._globe);\n  const radius = this._ellipsoid.maximumRadius;\n  this._rotateFactor = 1.0 / radius;\n  this._rotateRateRangeAdjustment = radius;\n  this._adjustedHeightForTerrain = false;\n  const previousPosition = Cartesian3.clone(camera.positionWC, scratchPreviousPosition);\n  const previousDirection = Cartesian3.clone(camera.directionWC, scratchPreviousDirection);\n  if (mode === SceneMode.SCENE2D) {\n    update2D(this);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    this._horizontalRotationAxis = Cartesian3.UNIT_Z;\n    updateCV(this);\n  } else if (mode === SceneMode.SCENE3D) {\n    this._horizontalRotationAxis = undefined;\n    update3D(this);\n  }\n  if (this.enableCollisionDetection && !this._adjustedHeightForTerrain) {\n    // Adjust the camera height if the camera moved at all (user input or inertia) and an action didn't already adjust the camera height\n    const cameraChanged = !Cartesian3.equals(previousPosition, camera.positionWC) || !Cartesian3.equals(previousDirection, camera.directionWC);\n    adjustHeightForTerrain(this, cameraChanged);\n  }\n  this._aggregator.reset();\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ScreenSpaceCameraController#destroy\n */\nScreenSpaceCameraController.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes mouse listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * controller = controller && controller.destroy();\n *\n * @see ScreenSpaceCameraController#isDestroyed\n */\nScreenSpaceCameraController.prototype.destroy = function () {\n  this._tweens.removeAll();\n  this._aggregator = this._aggregator && this._aggregator.destroy();\n  return destroyObject(this);\n};\nexport default ScreenSpaceCameraController;","map":{"version":3,"names":["Cartesian2","Cartesian3","Cartesian4","Cartographic","defaultValue","defined","destroyObject","DeveloperError","Ellipsoid","HeadingPitchRoll","IntersectionTests","KeyboardEventModifier","CesiumMath","Matrix3","Matrix4","OrthographicFrustum","Plane","Quaternion","Ray","VerticalExaggeration","Transforms","CameraEventAggregator","CameraEventType","MapMode2D","SceneMode","SceneTransforms","TweenCollection","ScreenSpaceCameraController","scene","enableInputs","enableTranslate","enableZoom","enableRotate","enableTilt","enableLook","inertiaSpin","inertiaTranslate","inertiaZoom","maximumMovementRatio","bounceAnimationTime","minimumZoomDistance","maximumZoomDistance","Number","POSITIVE_INFINITY","zoomFactor","translateEventTypes","LEFT_DRAG","zoomEventTypes","RIGHT_DRAG","WHEEL","PINCH","rotateEventTypes","tiltEventTypes","MIDDLE_DRAG","eventType","modifier","CTRL","lookEventTypes","SHIFT","ellipsoid","default","minimumPickingTerrainHeight","WGS84","equals","minimumRadius","_minimumPickingTerrainHeight","minimumPickingTerrainDistanceWithInertia","minimumCollisionTerrainHeight","_minimumCollisionTerrainHeight","minimumTrackBallHeight","_minimumTrackBallHeight","enableCollisionDetection","maximumTiltAngle","undefined","_scene","_globe","_ellipsoid","_lastGlobeHeight","_aggregator","canvas","_lastInertiaSpinMovement","_lastInertiaZoomMovement","_lastInertiaTranslateMovement","_lastInertiaTiltMovement","_inertiaDisablers","_tweens","_tween","_horizontalRotationAxis","_tiltCenterMousePosition","_tiltCenter","_rotateMousePosition","_rotateStartPosition","_strafeStartPosition","_strafeMousePosition","_strafeEndMousePosition","_zoomMouseStart","_zoomWorldPosition","_useZoomWorldPosition","_panLastMousePosition","_panLastWorldPosition","_tiltCVOffMap","_looking","_rotating","_strafing","_zoomingOnVector","_zoomingUnderground","_rotatingZoom","_adjustedHeightForTerrain","_cameraUnderground","projection","mapProjection","_maxCoord","project","Math","PI","PI_OVER_TWO","_rotateFactor","_rotateRateRangeAdjustment","_maximumRotateRate","_minimumRotateRate","_minimumZoomRate","_maximumZoomRate","_minimumUndergroundPickDistance","_maximumUndergroundPickDistance","decay","time","coefficient","tau","exp","sameMousePosition","movement","equalsEpsilon","startPosition","endPosition","EPSILON14","inertiaMaxClickTimeThreshold","maintainInertia","aggregator","type","decayCoef","action","object","lastMovementName","movementState","motion","inertiaEnabled","ts","getButtonPressTime","tr","getButtonReleaseTime","threshold","getTime","now","Date","fromNow","d","lastMovement","getLastMovement","x","y","clone","multiplyByScalar","add","isNaN","distance","isButtonDown","getStartMousePosition","activateInertia","controller","inertiaStateName","inertiasToDisable","length","i","scratchEventTypeArray","reactToInput","enabled","eventTypes","inertiaConstant","Array","isArray","isMoving","getMovement","scratchZoomPickRay","scratchPickCartesian","scratchZoomOffset","scratchZoomDirection","scratchCenterPixel","scratchCenterPosition","scratchPositionNormal","scratchPickNormal","scratchZoomAxis","scratchCameraPositionNormal","scratchTargetNormal","scratchCameraPosition","scratchCameraUpNormal","scratchCameraRightNormal","scratchForwardNormal","scratchPositionToTarget","scratchPositionToTargetNormal","scratchPan","scratchCenterMovement","scratchCenter","scratchCartesian","scratchCartesianTwo","scratchCartesianThree","scratchZoomViewOptions","orientation","handleZoom","distanceMeasure","unitPositionDotDirection","percentage","clamp","abs","diff","approachingSurface","minHeight","maxHeight","minDistance","zoomRate","rangeWindowRatio","clientHeight","min","camera","mode","heading","pitch","roll","frustum","zoomIn","_adjustOrthographicFrustum","sameStartPosition","zoomingOnVector","rotatingZoom","pickedPosition","SCENE2D","getPickRay","origin","fromElements","z","pickPosition","zoomOnVector","COLUMBUS_VIEW","positionCartographic","height","worldPosition","position","savedX","direction","subtract","normalize","getMagnitude","move","SCENE3D","cameraPositionNormal","dot","centerPixel","clientWidth","centerPosition","cameraPosition","target","targetNormal","center","forward","positionToTarget","positionToTargetNormal","alphaDot","alpha","acos","cameraDistance","magnitude","targetDistance","remainingDistance","positionToTargetDistance","gamma","asin","sin","delta","beta","up","right","cross","pMid","cos","cMid","setView","positionNormal","pickedNormal","dotProduct","angle","acosClamped","axis","denom","toRadians","scalar","rotate","ray","zoomMouseStart","worldToWindowCoordinates","rayDirection","translate2DStart","translate2DEnd","scratchTranslateP0","translate2D","start","end","zoom2D","twist2DStart","twist2DEnd","twist2D","angleAndHeight","singleAxisTwist2D","width","startTheta","TWO_PI","endTheta","theta","twistRight","rotateRate","phiWindowRatio","deltaPhi","update2D","rotatable2D","mapMode2D","ROTATE","IDENTITY","transform","pickGlobeScratchRay","scratchDepthIntersection","scratchRayIntersection","mousePosition","result","globe","depthIntersection","pickPositionSupported","pickPositionWorldCoordinates","cullBackFaces","rayIntersection","pickWorldCoordinates","pickDistance","positionWC","rayDistance","scratchDistanceCartographic","getDistanceFromSurface","cartographic","cartesianToCartographic","globeHeight","distanceFromSurface","scratchSurfaceNormal","getZoomDistanceUnderground","surfaceNormal","strength","max","getTiltCenterUnderground","maximumDistance","getPoint","getStrafeStartPositionUnderground","scratchInertialDelta","continueStrafing","originalEndPosition","inertialDelta","strafe","translateCVStartRay","translateCVEndRay","translateCVStartPos","translateCVEndPos","translateCVDifference","translateCVOrigin","translateCVPlane","UNIT_X","translateCVStartMouse","translateCVEndMouse","translateCV","_translateMousePosition","look3D","cameraUnderground","startMouse","endMouse","startRay","ZERO","normal","globePos","plane","fromPointNormal","startPlanePos","rayPlane","endRay","endPlanePos","temp","mag","EPSILON6","rotateCVWindowPos","rotateCVWindowRay","rotateCVCenter","rotateCVVerticalCenter","rotateCVTransform","rotateCVVerticalTransform","rotateCVOrigin","rotateCVPlane","rotateCVCartesian3","rotateCVCart","rotateCVOldTransform","rotateCVQuaternion","rotateCVMatrix","tilt3DCartesian3","rotateCV","onMap","rotateCVOnPlane","rotateCVOnTerrain","windowPosition","normalDotDirection","cart","unproject","cartographicToCartesian","eastNorthUpToFixedFrame","oldGlobe","oldEllipsoid","UNIT_SPHERE","oldTransform","_setTransform","rotate3D","UNIT_Z","radius","maximumRadius","verticalCenter","_projection","verticalTransform","constrainedAxis","tangent","movementDelta","oldConstrainedAxis","negate","originalPosition","adjustHeightForTerrain","worldToCameraCoordinatesPoint","magSqrd","magnitudeSquared","sqrt","angleBetween","quaternion","fromAxisAngle","rotation","fromQuaternion","multiplyByVector","zoomCVWindowPos","zoomCVWindowRay","zoomCVIntersection","zoomCV","intersection","distanceUnderground","updateCV","zoom3D","tweens","anyButtonDown","removeAll","contains","tween","createCorrectPositionTween","update","scratchStrafeRay","scratchStrafePlane","scratchStrafeIntersection","scratchStrafeDirection","strafeStartPosition","spin3DPick","scratchCartographic","scratchRadii","scratchEllipsoid","scratchLookUp","scratchNormal","scratchMousePosition","spin3D","radii","geodeticSurfaceNormal","fromCartesian3","pan3D","mousePos","strafing","tangentPick","pickEllipsoid","rotateOnlyVertical","rotateOnlyHorizontal","oldAxis","rho","thetaWindowRatio","deltaTheta","tilt","rotateRight","rotateUp","pan3DP0","UNIT_W","pan3DP1","pan3DTemp0","pan3DTemp1","pan3DTemp2","pan3DTemp3","pan3DStartMousePosition","pan3DEndMousePosition","pan3DDiffMousePosition","pan3DPixelDimensions","panRay","startMousePosition","endMousePosition","p0","p1","toCenter","toCenterProj","directionWC","distanceToNearPlane","pixelDimensions","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","pixelRatio","dragDelta","rightWC","endPickDirection","endPickProj","projectVector","fov","tan","upWC","worldToCameraCoordinates","basis0","basis1","mostOrthogonalAxis","basis2","startRho","startDot","startRej","endRho","endDot","endRej","startPhi","endPhi","east","EPSILON2","planeNormal","side0","side1","zoom3DUnitPosition","zoom3DCartographic","preIntersectionDistance","inertiaMovement","approachingCollision","needPickGlobe","unitPosition","tilt3DWindowPos","tilt3DRay","tilt3DCenter","tilt3DVerticalCenter","tilt3DTransform","tilt3DVerticalTransform","tilt3DOldTransform","tilt3DQuaternion","tilt3DMatrix","tilt3DCart","tilt3DLookUp","tilt3D","_tiltOnEllipsoid","tilt3DOnEllipsoid","tilt3DOnTerrain","tilt3DOnEllipsoidCartographic","EPSILON3","rayEllipsoid","grazingAltitudeLocation","grazingAltitudeCart","newEllipsoid","t","stop","look3DStartPos","look3DEndPos","look3DStartRay","look3DEndRay","look3DNegativeRot","look3DTan","rotationAxis","startPos","endPos","horizontalRotationAxis","look","lookLeft","negativeRotationAxis","northParallel","southParallel","angleToAxis","EPSILON4","lookUp","update3D","scratchAdjustHeightTransform","scratchAdjustHeightCartographic","cameraChanged","MORPHING","heightUpdated","difference","percentDifference","prototype","scratchPreviousPosition","scratchPreviousDirection","verticalExaggeration","verticalExaggerationRelativeHeight","getHeight","previousPosition","previousDirection","reset","isDestroyed","destroy"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/ScreenSpaceCameraController.js"],"sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport KeyboardEventModifier from \"../Core/KeyboardEventModifier.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport VerticalExaggeration from \"../Core/VerticalExaggeration.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraEventAggregator from \"./CameraEventAggregator.js\";\nimport CameraEventType from \"./CameraEventType.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport TweenCollection from \"./TweenCollection.js\";\n\n/**\n * Modifies the camera position and orientation based on mouse input to a canvas.\n * @alias ScreenSpaceCameraController\n * @constructor\n *\n * @param {Scene} scene The scene.\n */\nfunction ScreenSpaceCameraController(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * If true, inputs are allowed conditionally with the flags enableTranslate, enableZoom,\n   * enableRotate, enableTilt, and enableLook.  If false, all inputs are disabled.\n   *\n   * NOTE: This setting is for temporary use cases, such as camera flights and\n   * drag-selection of regions (see Picking demo).  It is typically set to false at the\n   * start of such events, and set true on completion.  To keep inputs disabled\n   * past the end of camera flights, you must use the other booleans (enableTranslate,\n   * enableZoom, enableRotate, enableTilt, and enableLook).\n   * @type {boolean}\n   * @default true\n   */\n  this.enableInputs = true;\n  /**\n   * If true, allows the user to pan around the map.  If false, the camera stays locked at the current position.\n   * This flag only applies in 2D and Columbus view modes.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableTranslate = true;\n  /**\n   * If true, allows the user to zoom in and out.  If false, the camera is locked to the current distance from the ellipsoid.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableZoom = true;\n  /**\n   * If true, allows the user to rotate the world which translates the user's position.\n   * This flag only applies in 2D and 3D.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableRotate = true;\n  /**\n   * If true, allows the user to tilt the camera.  If false, the camera is locked to the current heading.\n   * This flag only applies in 3D and Columbus view.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableTilt = true;\n  /**\n   * If true, allows the user to use free-look. If false, the camera view direction can only be changed through translating\n   * or rotating. This flag only applies in 3D and Columbus view modes.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableLook = true;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to spin because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {number}\n   * @default 0.9\n   */\n  this.inertiaSpin = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to translate because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {number}\n   * @default 0.9\n   */\n  this.inertiaTranslate = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to zoom because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {number}\n   * @default 0.8\n   */\n  this.inertiaZoom = 0.8;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to limit the range\n   * of various user inputs to a percentage of the window width/height per animation frame.\n   * This helps keep the camera under control in low-frame-rate situations.\n   * @type {number}\n   * @default 0.1\n   */\n  this.maximumMovementRatio = 0.1;\n  /**\n   * Sets the duration, in seconds, of the bounce back animations in 2D and Columbus view.\n   * @type {number}\n   * @default 3.0\n   */\n  this.bounceAnimationTime = 3.0;\n  /**\n   * The minimum magnitude, in meters, of the camera position when zooming. Defaults to 1.0.\n   * @type {number}\n   * @default 1.0\n   */\n  this.minimumZoomDistance = 1.0;\n  /**\n   * The maximum magnitude, in meters, of the camera position when zooming. Defaults to positive infinity.\n   * @type {number}\n   * @default {@link Number.POSITIVE_INFINITY}\n   */\n  this.maximumZoomDistance = Number.POSITIVE_INFINITY;\n\n  /**\n   * A multiplier for the speed at which the camera will zoom.\n   * @type {Number}\n   * @default 5.0\n   */\n  this.zoomFactor = 5.0;\n\n  /**\n   * The input that allows the user to pan around the map. This only applies in 2D and Columbus view modes.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n  this.translateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to zoom in/out.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.RIGHT_DRAG}, {@link CameraEventType.WHEEL}, {@link CameraEventType.PINCH}]\n   */\n  this.zoomEventTypes = [\n    CameraEventType.RIGHT_DRAG,\n    CameraEventType.WHEEL,\n    CameraEventType.PINCH,\n  ];\n  /**\n   * The input that allows the user to rotate around the globe or another object. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n  this.rotateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to tilt in 3D and Columbus view or twist in 2D.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.MIDDLE_DRAG}, {@link CameraEventType.PINCH}, {\n   *     eventType : {@link CameraEventType.LEFT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }, {\n   *     eventType : {@link CameraEventType.RIGHT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }]\n   */\n  this.tiltEventTypes = [\n    CameraEventType.MIDDLE_DRAG,\n    CameraEventType.PINCH,\n    {\n      eventType: CameraEventType.LEFT_DRAG,\n      modifier: KeyboardEventModifier.CTRL,\n    },\n    {\n      eventType: CameraEventType.RIGHT_DRAG,\n      modifier: KeyboardEventModifier.CTRL,\n    },\n  ];\n  /**\n   * The input that allows the user to change the direction the camera is viewing. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default { eventType : {@link CameraEventType.LEFT_DRAG}, modifier : {@link KeyboardEventModifier.SHIFT} }\n   */\n  this.lookEventTypes = {\n    eventType: CameraEventType.LEFT_DRAG,\n    modifier: KeyboardEventModifier.SHIFT,\n  };\n\n  const ellipsoid = defaultValue(scene.ellipsoid, Ellipsoid.default);\n\n  /**\n   * The minimum height the camera must be before picking the terrain or scene content instead of the ellipsoid. Defaults to scene.ellipsoid.minimumRadius * 0.025 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 150000.0 or scene.ellipsoid.minimumRadius * 0.025\n   */\n  this.minimumPickingTerrainHeight = Ellipsoid.WGS84.equals(ellipsoid)\n    ? 150000.0\n    : ellipsoid.minimumRadius * 0.025;\n  this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight;\n  /**\n   * The minimum distance the camera must be before testing for collision with terrain when zoom with inertia. Default to scene.ellipsoid.minimumRadius * 0.00063 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 4000.0 or scene.ellipsoid.minimumRadius * 0.00063\n   */\n  this.minimumPickingTerrainDistanceWithInertia = Ellipsoid.WGS84.equals(\n    ellipsoid,\n  )\n    ? 4000.0\n    : ellipsoid.minimumRadius * 0.00063;\n  /**\n   * The minimum height the camera must be before testing for collision with terrain. Default to scene.ellipsoid.minimumRadius * 0.0025 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 15000.0 or scene.ellipsoid.minimumRadius * 0.0025.\n   */\n  this.minimumCollisionTerrainHeight = Ellipsoid.WGS84.equals(ellipsoid)\n    ? 15000.0\n    : ellipsoid.minimumRadius * 0.0025;\n  this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight;\n  /**\n   * The minimum height the camera must be before switching from rotating a track ball to\n   * free look when clicks originate on the sky or in space. Defaults to ellipsoid.minimumRadius * 1.175 when another ellipsoid than WGS84 is used.\n   * @type {number}\n   * @default 7500000.0 or scene.ellipsoid.minimumRadius * 1.175\n   */\n  this.minimumTrackBallHeight = Ellipsoid.WGS84.equals(ellipsoid)\n    ? 7500000.0\n    : ellipsoid.minimumRadius * 1.175;\n  this._minimumTrackBallHeight = this.minimumTrackBallHeight;\n  /**\n   * When disabled, the values of <code>maximumZoomDistance</code> and <code>minimumZoomDistance</code> are ignored.\n   * @type {boolean}\n   * @default true\n   */\n  this.enableCollisionDetection = true;\n  /**\n   * The angle, relative to the ellipsoid normal, restricting the maximum amount that the user can tilt the camera. If <code>undefined</code>, the angle of the camera tilt is unrestricted.\n   * @type {number|undefined}\n   * @default undefined\n   *\n   * @example\n   * // Prevent the camera from tilting below the ellipsoid surface\n   * viewer.scene.screenSpaceCameraController.maximumTiltAngle = Math.PI / 2.0;\n   */\n  this.maximumTiltAngle = undefined;\n\n  this._scene = scene;\n  this._globe = undefined;\n  this._ellipsoid = ellipsoid;\n\n  this._lastGlobeHeight = 0.0;\n\n  this._aggregator = new CameraEventAggregator(scene.canvas);\n\n  this._lastInertiaSpinMovement = undefined;\n  this._lastInertiaZoomMovement = undefined;\n  this._lastInertiaTranslateMovement = undefined;\n  this._lastInertiaTiltMovement = undefined;\n\n  // Zoom disables tilt, spin, and translate inertia\n  // Tilt disables spin and translate inertia\n  this._inertiaDisablers = {\n    _lastInertiaZoomMovement: [\n      \"_lastInertiaSpinMovement\",\n      \"_lastInertiaTranslateMovement\",\n      \"_lastInertiaTiltMovement\",\n    ],\n    _lastInertiaTiltMovement: [\n      \"_lastInertiaSpinMovement\",\n      \"_lastInertiaTranslateMovement\",\n    ],\n  };\n\n  this._tweens = new TweenCollection();\n  this._tween = undefined;\n\n  this._horizontalRotationAxis = undefined;\n\n  this._tiltCenterMousePosition = new Cartesian2(-1.0, -1.0);\n  this._tiltCenter = new Cartesian3();\n  this._rotateMousePosition = new Cartesian2(-1.0, -1.0);\n  this._rotateStartPosition = new Cartesian3();\n  this._strafeStartPosition = new Cartesian3();\n  this._strafeMousePosition = new Cartesian2();\n  this._strafeEndMousePosition = new Cartesian2();\n  this._zoomMouseStart = new Cartesian2(-1.0, -1.0);\n  this._zoomWorldPosition = new Cartesian3();\n  this._useZoomWorldPosition = false;\n  this._panLastMousePosition = new Cartesian2();\n  this._panLastWorldPosition = new Cartesian3();\n  this._tiltCVOffMap = false;\n  this._looking = false;\n  this._rotating = false;\n  this._strafing = false;\n  this._zoomingOnVector = false;\n  this._zoomingUnderground = false;\n  this._rotatingZoom = false;\n  this._adjustedHeightForTerrain = false;\n  this._cameraUnderground = false;\n\n  const projection = scene.mapProjection;\n  this._maxCoord = projection.project(\n    new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO),\n  );\n\n  // Constants, Make any of these public?\n  this._rotateFactor = undefined;\n  this._rotateRateRangeAdjustment = undefined;\n  this._maximumRotateRate = 1.77;\n  this._minimumRotateRate = 1.0 / 5000.0;\n  this._minimumZoomRate = 20.0;\n  this._maximumZoomRate = 5906376272000.0; // distance from the Sun to Pluto in meters.\n  this._minimumUndergroundPickDistance = 2000.0;\n  this._maximumUndergroundPickDistance = 10000.0;\n}\n\nfunction decay(time, coefficient) {\n  if (time < 0) {\n    return 0.0;\n  }\n\n  const tau = (1.0 - coefficient) * 25.0;\n  return Math.exp(-tau * time);\n}\n\nfunction sameMousePosition(movement) {\n  return Cartesian2.equalsEpsilon(\n    movement.startPosition,\n    movement.endPosition,\n    CesiumMath.EPSILON14,\n  );\n}\n\n// If the time between mouse down and mouse up is not between\n// these thresholds, the camera will not move with inertia.\n// This value is probably dependent on the browser and/or the\n// hardware. Should be investigated further.\nconst inertiaMaxClickTimeThreshold = 0.4;\n\nfunction maintainInertia(\n  aggregator,\n  type,\n  modifier,\n  decayCoef,\n  action,\n  object,\n  lastMovementName,\n) {\n  let movementState = object[lastMovementName];\n  if (!defined(movementState)) {\n    movementState = object[lastMovementName] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      motion: new Cartesian2(),\n      inertiaEnabled: true,\n    };\n  }\n\n  const ts = aggregator.getButtonPressTime(type, modifier);\n  const tr = aggregator.getButtonReleaseTime(type, modifier);\n\n  const threshold = ts && tr && (tr.getTime() - ts.getTime()) / 1000.0;\n  const now = new Date();\n  const fromNow = tr && (now.getTime() - tr.getTime()) / 1000.0;\n\n  if (ts && tr && threshold < inertiaMaxClickTimeThreshold) {\n    const d = decay(fromNow, decayCoef);\n\n    const lastMovement = aggregator.getLastMovement(type, modifier);\n    if (\n      !defined(lastMovement) ||\n      sameMousePosition(lastMovement) ||\n      !movementState.inertiaEnabled\n    ) {\n      return;\n    }\n\n    movementState.motion.x =\n      (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;\n    movementState.motion.y =\n      (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;\n\n    movementState.startPosition = Cartesian2.clone(\n      lastMovement.startPosition,\n      movementState.startPosition,\n    );\n\n    movementState.endPosition = Cartesian2.multiplyByScalar(\n      movementState.motion,\n      d,\n      movementState.endPosition,\n    );\n    movementState.endPosition = Cartesian2.add(\n      movementState.startPosition,\n      movementState.endPosition,\n      movementState.endPosition,\n    );\n\n    // If value from the decreasing exponential function is close to zero,\n    // the end coordinates may be NaN.\n    if (\n      isNaN(movementState.endPosition.x) ||\n      isNaN(movementState.endPosition.y) ||\n      Cartesian2.distance(\n        movementState.startPosition,\n        movementState.endPosition,\n      ) < 0.5\n    ) {\n      return;\n    }\n\n    if (!aggregator.isButtonDown(type, modifier)) {\n      const startPosition = aggregator.getStartMousePosition(type, modifier);\n      action(object, startPosition, movementState);\n    }\n  }\n}\n\nfunction activateInertia(controller, inertiaStateName) {\n  if (defined(inertiaStateName)) {\n    // Re-enable inertia if it was disabled\n    let movementState = controller[inertiaStateName];\n    if (defined(movementState)) {\n      movementState.inertiaEnabled = true;\n    }\n    // Disable inertia on other movements\n    const inertiasToDisable = controller._inertiaDisablers[inertiaStateName];\n    if (defined(inertiasToDisable)) {\n      const length = inertiasToDisable.length;\n      for (let i = 0; i < length; ++i) {\n        movementState = controller[inertiasToDisable[i]];\n        if (defined(movementState)) {\n          movementState.inertiaEnabled = false;\n        }\n      }\n    }\n  }\n}\n\nconst scratchEventTypeArray = [];\n\nfunction reactToInput(\n  controller,\n  enabled,\n  eventTypes,\n  action,\n  inertiaConstant,\n  inertiaStateName,\n) {\n  if (!defined(eventTypes)) {\n    return;\n  }\n\n  const aggregator = controller._aggregator;\n\n  if (!Array.isArray(eventTypes)) {\n    scratchEventTypeArray[0] = eventTypes;\n    eventTypes = scratchEventTypeArray;\n  }\n\n  const length = eventTypes.length;\n  for (let i = 0; i < length; ++i) {\n    const eventType = eventTypes[i];\n    const type = defined(eventType.eventType) ? eventType.eventType : eventType;\n    const modifier = eventType.modifier;\n\n    const movement =\n      aggregator.isMoving(type, modifier) &&\n      aggregator.getMovement(type, modifier);\n    const startPosition = aggregator.getStartMousePosition(type, modifier);\n\n    if (controller.enableInputs && enabled) {\n      if (movement) {\n        action(controller, startPosition, movement);\n        activateInertia(controller, inertiaStateName);\n      } else if (inertiaConstant < 1.0) {\n        maintainInertia(\n          aggregator,\n          type,\n          modifier,\n          inertiaConstant,\n          action,\n          controller,\n          inertiaStateName,\n        );\n      }\n    }\n  }\n}\n\nconst scratchZoomPickRay = new Ray();\nconst scratchPickCartesian = new Cartesian3();\nconst scratchZoomOffset = new Cartesian2();\nconst scratchZoomDirection = new Cartesian3();\nconst scratchCenterPixel = new Cartesian2();\nconst scratchCenterPosition = new Cartesian3();\nconst scratchPositionNormal = new Cartesian3();\nconst scratchPickNormal = new Cartesian3();\nconst scratchZoomAxis = new Cartesian3();\nconst scratchCameraPositionNormal = new Cartesian3();\n\n// Scratch variables used in zooming algorithm\nconst scratchTargetNormal = new Cartesian3();\nconst scratchCameraPosition = new Cartesian3();\nconst scratchCameraUpNormal = new Cartesian3();\nconst scratchCameraRightNormal = new Cartesian3();\nconst scratchForwardNormal = new Cartesian3();\nconst scratchPositionToTarget = new Cartesian3();\nconst scratchPositionToTargetNormal = new Cartesian3();\nconst scratchPan = new Cartesian3();\nconst scratchCenterMovement = new Cartesian3();\nconst scratchCenter = new Cartesian3();\nconst scratchCartesian = new Cartesian3();\nconst scratchCartesianTwo = new Cartesian3();\nconst scratchCartesianThree = new Cartesian3();\nconst scratchZoomViewOptions = {\n  orientation: new HeadingPitchRoll(),\n};\n\nfunction handleZoom(\n  object,\n  startPosition,\n  movement,\n  zoomFactor,\n  distanceMeasure,\n  unitPositionDotDirection,\n) {\n  let percentage = 1.0;\n  if (defined(unitPositionDotDirection)) {\n    percentage = CesiumMath.clamp(\n      Math.abs(unitPositionDotDirection),\n      0.25,\n      1.0,\n    );\n  }\n\n  const diff = movement.endPosition.y - movement.startPosition.y;\n\n  // distanceMeasure should be the height above the ellipsoid.\n  // When approaching the surface, the zoomRate slows and stops minimumZoomDistance above it.\n  const approachingSurface = diff > 0;\n  const minHeight = approachingSurface\n    ? object.minimumZoomDistance * percentage\n    : 0;\n  const maxHeight = object.maximumZoomDistance;\n\n  const minDistance = distanceMeasure - minHeight;\n  let zoomRate = zoomFactor * minDistance;\n  zoomRate = CesiumMath.clamp(\n    zoomRate,\n    object._minimumZoomRate,\n    object._maximumZoomRate,\n  );\n\n  let rangeWindowRatio = diff / object._scene.canvas.clientHeight;\n  rangeWindowRatio = Math.min(rangeWindowRatio, object.maximumMovementRatio);\n  let distance = zoomRate * rangeWindowRatio;\n\n  if (\n    object.enableCollisionDetection ||\n    object.minimumZoomDistance === 0.0 ||\n    !defined(object._globe) // look-at mode\n  ) {\n    if (distance > 0.0 && Math.abs(distanceMeasure - minHeight) < 1.0) {\n      return;\n    }\n\n    if (distance < 0.0 && Math.abs(distanceMeasure - maxHeight) < 1.0) {\n      return;\n    }\n\n    if (distanceMeasure - distance < minHeight) {\n      distance = distanceMeasure - minHeight - 1.0;\n    } else if (distanceMeasure - distance > maxHeight) {\n      distance = distanceMeasure - maxHeight;\n    }\n  }\n\n  const scene = object._scene;\n  const camera = scene.camera;\n  const mode = scene.mode;\n\n  const orientation = scratchZoomViewOptions.orientation;\n  orientation.heading = camera.heading;\n  orientation.pitch = camera.pitch;\n  orientation.roll = camera.roll;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    if (Math.abs(distance) > 0.0) {\n      camera.zoomIn(distance);\n      camera._adjustOrthographicFrustum(true);\n    }\n    return;\n  }\n\n  const sameStartPosition = defaultValue(\n    movement.inertiaEnabled,\n    Cartesian2.equals(startPosition, object._zoomMouseStart),\n  );\n  let zoomingOnVector = object._zoomingOnVector;\n  let rotatingZoom = object._rotatingZoom;\n  let pickedPosition;\n\n  if (!sameStartPosition) {\n    object._zoomMouseStart = Cartesian2.clone(\n      startPosition,\n      object._zoomMouseStart,\n    );\n\n    // When camera transform is set, such as tracking an entity, object._globe will be undefined, and no position should be picked\n    if (defined(object._globe) && mode === SceneMode.SCENE2D) {\n      pickedPosition = camera.getPickRay(\n        startPosition,\n        scratchZoomPickRay,\n      ).origin;\n      pickedPosition = Cartesian3.fromElements(\n        pickedPosition.y,\n        pickedPosition.z,\n        pickedPosition.x,\n      );\n    } else if (defined(object._globe)) {\n      pickedPosition = pickPosition(\n        object,\n        startPosition,\n        scratchPickCartesian,\n      );\n    }\n\n    if (defined(pickedPosition)) {\n      object._useZoomWorldPosition = true;\n      object._zoomWorldPosition = Cartesian3.clone(\n        pickedPosition,\n        object._zoomWorldPosition,\n      );\n    } else {\n      object._useZoomWorldPosition = false;\n    }\n\n    zoomingOnVector = object._zoomingOnVector = false;\n    rotatingZoom = object._rotatingZoom = false;\n    object._zoomingUnderground = object._cameraUnderground;\n  }\n\n  if (!object._useZoomWorldPosition) {\n    camera.zoomIn(distance);\n    return;\n  }\n\n  let zoomOnVector = mode === SceneMode.COLUMBUS_VIEW;\n\n  if (camera.positionCartographic.height < 2000000) {\n    rotatingZoom = true;\n  }\n\n  if (!sameStartPosition || rotatingZoom) {\n    if (mode === SceneMode.SCENE2D) {\n      const worldPosition = object._zoomWorldPosition;\n      const endPosition = camera.position;\n\n      if (\n        !Cartesian3.equals(worldPosition, endPosition) &&\n        camera.positionCartographic.height < object._maxCoord.x * 2.0\n      ) {\n        const savedX = camera.position.x;\n\n        const direction = Cartesian3.subtract(\n          worldPosition,\n          endPosition,\n          scratchZoomDirection,\n        );\n        Cartesian3.normalize(direction, direction);\n\n        const d =\n          (Cartesian3.distance(worldPosition, endPosition) * distance) /\n          (camera.getMagnitude() * 0.5);\n        camera.move(direction, d * 0.5);\n\n        if (\n          (camera.position.x < 0.0 && savedX > 0.0) ||\n          (camera.position.x > 0.0 && savedX < 0.0)\n        ) {\n          pickedPosition = camera.getPickRay(\n            startPosition,\n            scratchZoomPickRay,\n          ).origin;\n          pickedPosition = Cartesian3.fromElements(\n            pickedPosition.y,\n            pickedPosition.z,\n            pickedPosition.x,\n          );\n          object._zoomWorldPosition = Cartesian3.clone(\n            pickedPosition,\n            object._zoomWorldPosition,\n          );\n        }\n      }\n    } else if (mode === SceneMode.SCENE3D) {\n      const cameraPositionNormal = Cartesian3.normalize(\n        camera.position,\n        scratchCameraPositionNormal,\n      );\n      if (\n        object._cameraUnderground ||\n        object._zoomingUnderground ||\n        (camera.positionCartographic.height < 3000.0 &&\n          Math.abs(Cartesian3.dot(camera.direction, cameraPositionNormal)) <\n            0.6)\n      ) {\n        zoomOnVector = true;\n      } else {\n        const canvas = scene.canvas;\n\n        const centerPixel = scratchCenterPixel;\n        centerPixel.x = canvas.clientWidth / 2;\n        centerPixel.y = canvas.clientHeight / 2;\n        const centerPosition = pickPosition(\n          object,\n          centerPixel,\n          scratchCenterPosition,\n        );\n        // If centerPosition is not defined, it means the globe does not cover the center position of screen\n\n        if (!defined(centerPosition)) {\n          zoomOnVector = true;\n        } else if (camera.positionCartographic.height < 1000000) {\n          // The math in the else block assumes the camera\n          // points toward the earth surface, so we check it here.\n          // Theoretically, we should check for 90 degree, but it doesn't behave well when parallel\n          // to the earth surface\n          if (Cartesian3.dot(camera.direction, cameraPositionNormal) >= -0.5) {\n            zoomOnVector = true;\n          } else {\n            const cameraPosition = scratchCameraPosition;\n            Cartesian3.clone(camera.position, cameraPosition);\n            const target = object._zoomWorldPosition;\n\n            let targetNormal = scratchTargetNormal;\n\n            targetNormal = Cartesian3.normalize(target, targetNormal);\n\n            if (Cartesian3.dot(targetNormal, cameraPositionNormal) < 0.0) {\n              return;\n            }\n\n            const center = scratchCenter;\n            const forward = scratchForwardNormal;\n            Cartesian3.clone(camera.direction, forward);\n            Cartesian3.add(\n              cameraPosition,\n              Cartesian3.multiplyByScalar(forward, 1000, scratchCartesian),\n              center,\n            );\n\n            const positionToTarget = scratchPositionToTarget;\n            const positionToTargetNormal = scratchPositionToTargetNormal;\n            Cartesian3.subtract(target, cameraPosition, positionToTarget);\n\n            Cartesian3.normalize(positionToTarget, positionToTargetNormal);\n\n            const alphaDot = Cartesian3.dot(\n              cameraPositionNormal,\n              positionToTargetNormal,\n            );\n            if (alphaDot >= 0.0) {\n              // We zoomed past the target, and this zoom is not valid anymore.\n              // This line causes the next zoom movement to pick a new starting point.\n              object._zoomMouseStart.x = -1;\n              return;\n            }\n            const alpha = Math.acos(-alphaDot);\n            const cameraDistance = Cartesian3.magnitude(cameraPosition);\n            const targetDistance = Cartesian3.magnitude(target);\n            const remainingDistance = cameraDistance - distance;\n            const positionToTargetDistance =\n              Cartesian3.magnitude(positionToTarget);\n\n            const gamma = Math.asin(\n              CesiumMath.clamp(\n                (positionToTargetDistance / targetDistance) * Math.sin(alpha),\n                -1.0,\n                1.0,\n              ),\n            );\n            const delta = Math.asin(\n              CesiumMath.clamp(\n                (remainingDistance / targetDistance) * Math.sin(alpha),\n                -1.0,\n                1.0,\n              ),\n            );\n            const beta = gamma - delta + alpha;\n\n            const up = scratchCameraUpNormal;\n            Cartesian3.normalize(cameraPosition, up);\n            let right = scratchCameraRightNormal;\n            right = Cartesian3.cross(positionToTargetNormal, up, right);\n            right = Cartesian3.normalize(right, right);\n\n            Cartesian3.normalize(\n              Cartesian3.cross(up, right, scratchCartesian),\n              forward,\n            );\n\n            // Calculate new position to move to\n            Cartesian3.multiplyByScalar(\n              Cartesian3.normalize(center, scratchCartesian),\n              Cartesian3.magnitude(center) - distance,\n              center,\n            );\n            Cartesian3.normalize(cameraPosition, cameraPosition);\n            Cartesian3.multiplyByScalar(\n              cameraPosition,\n              remainingDistance,\n              cameraPosition,\n            );\n\n            // Pan\n            const pMid = scratchPan;\n            Cartesian3.multiplyByScalar(\n              Cartesian3.add(\n                Cartesian3.multiplyByScalar(\n                  up,\n                  Math.cos(beta) - 1,\n                  scratchCartesianTwo,\n                ),\n                Cartesian3.multiplyByScalar(\n                  forward,\n                  Math.sin(beta),\n                  scratchCartesianThree,\n                ),\n                scratchCartesian,\n              ),\n              remainingDistance,\n              pMid,\n            );\n            Cartesian3.add(cameraPosition, pMid, cameraPosition);\n\n            Cartesian3.normalize(center, up);\n            Cartesian3.normalize(\n              Cartesian3.cross(up, right, scratchCartesian),\n              forward,\n            );\n\n            const cMid = scratchCenterMovement;\n            Cartesian3.multiplyByScalar(\n              Cartesian3.add(\n                Cartesian3.multiplyByScalar(\n                  up,\n                  Math.cos(beta) - 1,\n                  scratchCartesianTwo,\n                ),\n                Cartesian3.multiplyByScalar(\n                  forward,\n                  Math.sin(beta),\n                  scratchCartesianThree,\n                ),\n                scratchCartesian,\n              ),\n              Cartesian3.magnitude(center),\n              cMid,\n            );\n            Cartesian3.add(center, cMid, center);\n\n            // Update camera\n\n            // Set new position\n            Cartesian3.clone(cameraPosition, camera.position);\n\n            // Set new direction\n            Cartesian3.normalize(\n              Cartesian3.subtract(center, cameraPosition, scratchCartesian),\n              camera.direction,\n            );\n            Cartesian3.clone(camera.direction, camera.direction);\n\n            // Set new right & up vectors\n            Cartesian3.cross(camera.direction, camera.up, camera.right);\n            Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n            camera.setView(scratchZoomViewOptions);\n            return;\n          }\n        } else {\n          const positionNormal = Cartesian3.normalize(\n            centerPosition,\n            scratchPositionNormal,\n          );\n          const pickedNormal = Cartesian3.normalize(\n            object._zoomWorldPosition,\n            scratchPickNormal,\n          );\n          const dotProduct = Cartesian3.dot(pickedNormal, positionNormal);\n\n          if (dotProduct > 0.0 && dotProduct < 1.0) {\n            const angle = CesiumMath.acosClamped(dotProduct);\n            const axis = Cartesian3.cross(\n              pickedNormal,\n              positionNormal,\n              scratchZoomAxis,\n            );\n\n            const denom =\n              Math.abs(angle) > CesiumMath.toRadians(20.0)\n                ? camera.positionCartographic.height * 0.75\n                : camera.positionCartographic.height - distance;\n            const scalar = distance / denom;\n            camera.rotate(axis, angle * scalar);\n          }\n        }\n      }\n    }\n\n    object._rotatingZoom = !zoomOnVector;\n  }\n\n  if ((!sameStartPosition && zoomOnVector) || zoomingOnVector) {\n    let ray;\n    const zoomMouseStart = SceneTransforms.worldToWindowCoordinates(\n      scene,\n      object._zoomWorldPosition,\n      scratchZoomOffset,\n    );\n    if (\n      mode !== SceneMode.COLUMBUS_VIEW &&\n      Cartesian2.equals(startPosition, object._zoomMouseStart) &&\n      defined(zoomMouseStart)\n    ) {\n      ray = camera.getPickRay(zoomMouseStart, scratchZoomPickRay);\n    } else {\n      ray = camera.getPickRay(startPosition, scratchZoomPickRay);\n    }\n\n    const rayDirection = ray.direction;\n    if (mode === SceneMode.COLUMBUS_VIEW || mode === SceneMode.SCENE2D) {\n      Cartesian3.fromElements(\n        rayDirection.y,\n        rayDirection.z,\n        rayDirection.x,\n        rayDirection,\n      );\n    }\n\n    camera.move(rayDirection, distance);\n\n    object._zoomingOnVector = true;\n  } else {\n    camera.zoomIn(distance);\n  }\n\n  if (!object._cameraUnderground) {\n    camera.setView(scratchZoomViewOptions);\n  }\n}\n\nconst translate2DStart = new Ray();\nconst translate2DEnd = new Ray();\nconst scratchTranslateP0 = new Cartesian3();\n\nfunction translate2D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  let start = camera.getPickRay(\n    movement.startPosition,\n    translate2DStart,\n  ).origin;\n  let end = camera.getPickRay(movement.endPosition, translate2DEnd).origin;\n\n  start = Cartesian3.fromElements(start.y, start.z, start.x, start);\n  end = Cartesian3.fromElements(end.y, end.z, end.x, end);\n\n  const direction = Cartesian3.subtract(start, end, scratchTranslateP0);\n  const distance = Cartesian3.magnitude(direction);\n\n  if (distance > 0.0) {\n    Cartesian3.normalize(direction, direction);\n    camera.move(direction, distance);\n  }\n}\n\nfunction zoom2D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller.zoomFactor,\n    camera.getMagnitude(),\n  );\n}\n\nconst twist2DStart = new Cartesian2();\nconst twist2DEnd = new Cartesian2();\n\nfunction twist2D(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    singleAxisTwist2D(controller, startPosition, movement.angleAndHeight);\n    return;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n\n  let start = twist2DStart;\n  start.x = (2.0 / width) * movement.startPosition.x - 1.0;\n  start.y = (2.0 / height) * (height - movement.startPosition.y) - 1.0;\n  start = Cartesian2.normalize(start, start);\n\n  let end = twist2DEnd;\n  end.x = (2.0 / width) * movement.endPosition.x - 1.0;\n  end.y = (2.0 / height) * (height - movement.endPosition.y) - 1.0;\n  end = Cartesian2.normalize(end, end);\n\n  let startTheta = CesiumMath.acosClamped(start.x);\n  if (start.y < 0) {\n    startTheta = CesiumMath.TWO_PI - startTheta;\n  }\n  let endTheta = CesiumMath.acosClamped(end.x);\n  if (end.y < 0) {\n    endTheta = CesiumMath.TWO_PI - endTheta;\n  }\n  const theta = endTheta - startTheta;\n\n  camera.twistRight(theta);\n}\n\nfunction singleAxisTwist2D(controller, startPosition, movement) {\n  let rotateRate =\n    controller._rotateFactor * controller._rotateRateRangeAdjustment;\n\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  let phiWindowRatio =\n    (movement.endPosition.x - movement.startPosition.x) / canvas.clientWidth;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n\n  const deltaPhi = rotateRate * phiWindowRatio * Math.PI * 4.0;\n\n  camera.twistRight(deltaPhi);\n}\n\nfunction update2D(controller) {\n  const rotatable2D = controller._scene.mapMode2D === MapMode2D.ROTATE;\n  if (!Matrix4.equals(Matrix4.IDENTITY, controller._scene.camera.transform)) {\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom2D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\",\n    );\n    if (rotatable2D) {\n      reactToInput(\n        controller,\n        controller.enableRotate,\n        controller.translateEventTypes,\n        twist2D,\n        controller.inertiaSpin,\n        \"_lastInertiaSpinMovement\",\n      );\n    }\n  } else {\n    reactToInput(\n      controller,\n      controller.enableTranslate,\n      controller.translateEventTypes,\n      translate2D,\n      controller.inertiaTranslate,\n      \"_lastInertiaTranslateMovement\",\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom2D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\",\n    );\n    if (rotatable2D) {\n      reactToInput(\n        controller,\n        controller.enableRotate,\n        controller.tiltEventTypes,\n        twist2D,\n        controller.inertiaSpin,\n        \"_lastInertiaTiltMovement\",\n      );\n    }\n  }\n}\n\nconst pickGlobeScratchRay = new Ray();\nconst scratchDepthIntersection = new Cartesian3();\nconst scratchRayIntersection = new Cartesian3();\n\nfunction pickPosition(controller, mousePosition, result) {\n  const scene = controller._scene;\n  const globe = controller._globe;\n  const camera = scene.camera;\n\n  let depthIntersection;\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(\n      mousePosition,\n      scratchDepthIntersection,\n    );\n  }\n\n  if (!defined(globe)) {\n    return Cartesian3.clone(depthIntersection, result);\n  }\n\n  const cullBackFaces = !controller._cameraUnderground;\n  const ray = camera.getPickRay(mousePosition, pickGlobeScratchRay);\n  const rayIntersection = globe.pickWorldCoordinates(\n    ray,\n    scene,\n    cullBackFaces,\n    scratchRayIntersection,\n  );\n\n  const pickDistance = defined(depthIntersection)\n    ? Cartesian3.distance(depthIntersection, camera.positionWC)\n    : Number.POSITIVE_INFINITY;\n  const rayDistance = defined(rayIntersection)\n    ? Cartesian3.distance(rayIntersection, camera.positionWC)\n    : Number.POSITIVE_INFINITY;\n\n  if (pickDistance < rayDistance) {\n    return Cartesian3.clone(depthIntersection, result);\n  }\n\n  return Cartesian3.clone(rayIntersection, result);\n}\n\nconst scratchDistanceCartographic = new Cartographic();\n\nfunction getDistanceFromSurface(controller) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const mode = scene.mode;\n\n  let height = 0.0;\n  if (mode === SceneMode.SCENE3D) {\n    const cartographic = ellipsoid.cartesianToCartographic(\n      camera.position,\n      scratchDistanceCartographic,\n    );\n    if (defined(cartographic)) {\n      height = cartographic.height;\n    }\n  } else {\n    height = camera.position.z;\n  }\n  const globeHeight = defaultValue(controller._scene.globeHeight, 0.0);\n  const distanceFromSurface = Math.abs(globeHeight - height);\n  return distanceFromSurface;\n}\n\nconst scratchSurfaceNormal = new Cartesian3();\n\nfunction getZoomDistanceUnderground(controller, ray) {\n  const origin = ray.origin;\n  const direction = ray.direction;\n  const distanceFromSurface = getDistanceFromSurface(controller);\n\n  // Weight zoom distance based on how strongly the pick ray is pointing inward.\n  // Geocentric normal is accurate enough for these purposes\n  const surfaceNormal = Cartesian3.normalize(origin, scratchSurfaceNormal);\n  let strength = Math.abs(Cartesian3.dot(surfaceNormal, direction));\n  strength = Math.max(strength, 0.5) * 2.0;\n  return distanceFromSurface * strength;\n}\n\nfunction getTiltCenterUnderground(controller, ray, pickedPosition, result) {\n  let distance = Cartesian3.distance(ray.origin, pickedPosition);\n  const distanceFromSurface = getDistanceFromSurface(controller);\n\n  const maximumDistance = CesiumMath.clamp(\n    distanceFromSurface * 5.0,\n    controller._minimumUndergroundPickDistance,\n    controller._maximumUndergroundPickDistance,\n  );\n\n  if (distance > maximumDistance) {\n    // Simulate look-at behavior by tilting around a small invisible sphere\n    distance = Math.min(distance, distanceFromSurface / 5.0);\n    distance = Math.max(distance, 100.0);\n  }\n\n  return Ray.getPoint(ray, distance, result);\n}\n\nfunction getStrafeStartPositionUnderground(\n  controller,\n  ray,\n  pickedPosition,\n  result,\n) {\n  let distance;\n  if (!defined(pickedPosition)) {\n    distance = getDistanceFromSurface(controller);\n  } else {\n    distance = Cartesian3.distance(ray.origin, pickedPosition);\n    if (distance > controller._maximumUndergroundPickDistance) {\n      // If the picked position is too far away set the strafe speed based on the\n      // camera's height from the globe surface\n      distance = getDistanceFromSurface(controller);\n    }\n  }\n\n  return Ray.getPoint(ray, distance, result);\n}\n\nconst scratchInertialDelta = new Cartesian2();\n\nfunction continueStrafing(controller, movement) {\n  // Update the end position continually based on the inertial delta\n  const originalEndPosition = movement.endPosition;\n  const inertialDelta = Cartesian2.subtract(\n    movement.endPosition,\n    movement.startPosition,\n    scratchInertialDelta,\n  );\n  const endPosition = controller._strafeEndMousePosition;\n  Cartesian2.add(endPosition, inertialDelta, endPosition);\n  movement.endPosition = endPosition;\n  strafe(controller, movement, controller._strafeStartPosition);\n  movement.endPosition = originalEndPosition;\n}\n\nconst translateCVStartRay = new Ray();\nconst translateCVEndRay = new Ray();\nconst translateCVStartPos = new Cartesian3();\nconst translateCVEndPos = new Cartesian3();\nconst translateCVDifference = new Cartesian3();\nconst translateCVOrigin = new Cartesian3();\nconst translateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst translateCVStartMouse = new Cartesian2();\nconst translateCVEndMouse = new Cartesian2();\n\nfunction translateCV(controller, startPosition, movement) {\n  if (!Cartesian3.equals(startPosition, controller._translateMousePosition)) {\n    controller._looking = false;\n  }\n\n  if (!Cartesian3.equals(startPosition, controller._strafeMousePosition)) {\n    controller._strafing = false;\n  }\n\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n\n  if (controller._strafing) {\n    continueStrafing(controller, movement);\n    return;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n  const startMouse = Cartesian2.clone(\n    movement.startPosition,\n    translateCVStartMouse,\n  );\n  const endMouse = Cartesian2.clone(movement.endPosition, translateCVEndMouse);\n  let startRay = camera.getPickRay(startMouse, translateCVStartRay);\n\n  const origin = Cartesian3.clone(Cartesian3.ZERO, translateCVOrigin);\n  const normal = Cartesian3.UNIT_X;\n\n  let globePos;\n  if (camera.position.z < controller._minimumPickingTerrainHeight) {\n    globePos = pickPosition(controller, startMouse, translateCVStartPos);\n\n    if (defined(globePos)) {\n      origin.x = globePos.x;\n    }\n  }\n\n  if (\n    cameraUnderground ||\n    (origin.x > camera.position.z && defined(globePos))\n  ) {\n    let pickPosition = globePos;\n    if (cameraUnderground) {\n      pickPosition = getStrafeStartPositionUnderground(\n        controller,\n        startRay,\n        globePos,\n        translateCVStartPos,\n      );\n    }\n    Cartesian2.clone(startPosition, controller._strafeMousePosition);\n    Cartesian2.clone(startPosition, controller._strafeEndMousePosition);\n    Cartesian3.clone(pickPosition, controller._strafeStartPosition);\n    controller._strafing = true;\n    strafe(controller, movement, controller._strafeStartPosition);\n    return;\n  }\n\n  const plane = Plane.fromPointNormal(origin, normal, translateCVPlane);\n\n  startRay = camera.getPickRay(startMouse, translateCVStartRay);\n  const startPlanePos = IntersectionTests.rayPlane(\n    startRay,\n    plane,\n    translateCVStartPos,\n  );\n\n  const endRay = camera.getPickRay(endMouse, translateCVEndRay);\n  const endPlanePos = IntersectionTests.rayPlane(\n    endRay,\n    plane,\n    translateCVEndPos,\n  );\n\n  if (!defined(startPlanePos) || !defined(endPlanePos)) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._translateMousePosition);\n    return;\n  }\n\n  const diff = Cartesian3.subtract(\n    startPlanePos,\n    endPlanePos,\n    translateCVDifference,\n  );\n  const temp = diff.x;\n  diff.x = diff.y;\n  diff.y = diff.z;\n  diff.z = temp;\n  const mag = Cartesian3.magnitude(diff);\n  if (mag > CesiumMath.EPSILON6) {\n    Cartesian3.normalize(diff, diff);\n    camera.move(diff, mag);\n  }\n}\n\nconst rotateCVWindowPos = new Cartesian2();\nconst rotateCVWindowRay = new Ray();\nconst rotateCVCenter = new Cartesian3();\nconst rotateCVVerticalCenter = new Cartesian3();\nconst rotateCVTransform = new Matrix4();\nconst rotateCVVerticalTransform = new Matrix4();\nconst rotateCVOrigin = new Cartesian3();\nconst rotateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst rotateCVCartesian3 = new Cartesian3();\nconst rotateCVCart = new Cartographic();\nconst rotateCVOldTransform = new Matrix4();\nconst rotateCVQuaternion = new Quaternion();\nconst rotateCVMatrix = new Matrix3();\nconst tilt3DCartesian3 = new Cartesian3();\n\nfunction rotateCV(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltCVOffMap = false;\n    controller._looking = false;\n  }\n\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  if (\n    controller._tiltCVOffMap ||\n    !controller.onMap() ||\n    Math.abs(camera.position.z) > controller._minimumPickingTerrainHeight\n  ) {\n    controller._tiltCVOffMap = true;\n    rotateCVOnPlane(controller, startPosition, movement);\n  } else {\n    rotateCVOnTerrain(controller, startPosition, movement);\n  }\n}\n\nfunction rotateCVOnPlane(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  const windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  const ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n  const normal = Cartesian3.UNIT_X;\n\n  const position = ray.origin;\n  const direction = ray.direction;\n  let scalar;\n  const normalDotDirection = Cartesian3.dot(normal, direction);\n  if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n    scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n  }\n\n  if (!defined(scalar) || scalar <= 0.0) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n\n  const center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n  Cartesian3.add(position, center, center);\n\n  const projection = scene.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  const cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    rotateCVTransform,\n  );\n\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  const oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n  camera._setTransform(transform);\n\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\n\nfunction rotateCVOnTerrain(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n\n  let center;\n  let ray;\n  const normal = Cartesian3.UNIT_X;\n\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, rotateCVCenter);\n  } else {\n    if (camera.position.z < controller._minimumPickingTerrainHeight) {\n      center = pickPosition(controller, startPosition, rotateCVCenter);\n    }\n\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      const position = ray.origin;\n      const direction = ray.direction;\n\n      let scalar;\n      const normalDotDirection = Cartesian3.dot(normal, direction);\n      if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n        scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n      }\n\n      if (!defined(scalar) || scalar <= 0.0) {\n        controller._looking = true;\n        look3D(controller, startPosition, movement);\n        Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        return;\n      }\n\n      center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n      Cartesian3.add(position, center, center);\n    }\n\n    if (cameraUnderground) {\n      if (!defined(ray)) {\n        ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      }\n      getTiltCenterUnderground(controller, ray, center, center);\n    }\n\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n\n  const canvas = scene.canvas;\n\n  const windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n\n  const origin = Cartesian3.clone(Cartesian3.ZERO, rotateCVOrigin);\n  origin.x = center.x;\n\n  const plane = Plane.fromPointNormal(origin, normal, rotateCVPlane);\n  const verticalCenter = IntersectionTests.rayPlane(\n    ray,\n    plane,\n    rotateCVVerticalCenter,\n  );\n\n  const projection = camera._projection;\n  const ellipsoid = projection.ellipsoid;\n\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  let cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    rotateCVTransform,\n  );\n\n  let verticalTransform;\n  if (defined(verticalCenter)) {\n    Cartesian3.fromElements(\n      verticalCenter.y,\n      verticalCenter.z,\n      verticalCenter.x,\n      verticalCenter,\n    );\n    cart = projection.unproject(verticalCenter, rotateCVCart);\n    ellipsoid.cartographicToCartesian(cart, verticalCenter);\n\n    verticalTransform = Transforms.eastNorthUpToFixedFrame(\n      verticalCenter,\n      ellipsoid,\n      rotateCVVerticalTransform,\n    );\n  } else {\n    verticalTransform = transform;\n  }\n\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  let constrainedAxis = Cartesian3.UNIT_Z;\n\n  const oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n  camera._setTransform(transform);\n\n  const tangent = Cartesian3.cross(\n    Cartesian3.UNIT_Z,\n    Cartesian3.normalize(camera.position, rotateCVCartesian3),\n    rotateCVCartesian3,\n  );\n  const dot = Cartesian3.dot(camera.right, tangent);\n\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n\n  camera._setTransform(verticalTransform);\n  if (dot < 0.0) {\n    const movementDelta = movement.startPosition.y - movement.endPosition.y;\n    if (\n      (cameraUnderground && movementDelta < 0.0) ||\n      (!cameraUnderground && movementDelta > 0.0)\n    ) {\n      // Prevent camera from flipping past the up axis\n      constrainedAxis = undefined;\n    }\n\n    const oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n\n  if (defined(camera.constrainedAxis)) {\n    const right = Cartesian3.cross(\n      camera.direction,\n      camera.constrainedAxis,\n      tilt3DCartesian3,\n    );\n    if (\n      !Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)\n    ) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n\n  const originalPosition = Cartesian3.clone(\n    camera.positionWC,\n    rotateCVCartesian3,\n  );\n\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller, true);\n  }\n\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n\n    const magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.sqrt(magSqrd),\n        camera.position,\n      );\n    }\n\n    const angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    const axis = Cartesian3.cross(\n      originalPosition,\n      camera.position,\n      originalPosition,\n    );\n    Cartesian3.normalize(axis, axis);\n\n    const quaternion = Quaternion.fromAxisAngle(\n      axis,\n      angle,\n      rotateCVQuaternion,\n    );\n    const rotation = Matrix3.fromQuaternion(quaternion, rotateCVMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n    camera._setTransform(oldTransform);\n  }\n}\n\nconst zoomCVWindowPos = new Cartesian2();\nconst zoomCVWindowRay = new Ray();\nconst zoomCVIntersection = new Cartesian3();\n\nfunction zoomCV(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  const cameraUnderground = controller._cameraUnderground;\n\n  let windowPosition;\n\n  if (cameraUnderground) {\n    windowPosition = startPosition;\n  } else {\n    windowPosition = zoomCVWindowPos;\n    windowPosition.x = canvas.clientWidth / 2;\n    windowPosition.y = canvas.clientHeight / 2;\n  }\n\n  const ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n  const position = ray.origin;\n  const direction = ray.direction;\n  const height = camera.position.z;\n\n  let intersection;\n  if (height < controller._minimumPickingTerrainHeight) {\n    intersection = pickPosition(controller, windowPosition, zoomCVIntersection);\n  }\n\n  let distance;\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(position, intersection);\n  }\n\n  if (cameraUnderground) {\n    const distanceUnderground = getZoomDistanceUnderground(\n      controller,\n      ray,\n      height,\n    );\n    if (defined(distance)) {\n      distance = Math.min(distance, distanceUnderground);\n    } else {\n      distance = distanceUnderground;\n    }\n  }\n\n  if (!defined(distance)) {\n    const normal = Cartesian3.UNIT_X;\n    distance =\n      -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  }\n\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller.zoomFactor,\n    distance,\n  );\n}\n\nfunction updateCV(controller) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {\n    reactToInput(\n      controller,\n      controller.enableRotate,\n      controller.rotateEventTypes,\n      rotate3D,\n      controller.inertiaSpin,\n      \"_lastInertiaSpinMovement\",\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom3D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\",\n    );\n  } else {\n    const tweens = controller._tweens;\n\n    if (controller._aggregator.anyButtonDown) {\n      tweens.removeAll();\n    }\n\n    reactToInput(\n      controller,\n      controller.enableTilt,\n      controller.tiltEventTypes,\n      rotateCV,\n      controller.inertiaSpin,\n      \"_lastInertiaTiltMovement\",\n    );\n    reactToInput(\n      controller,\n      controller.enableTranslate,\n      controller.translateEventTypes,\n      translateCV,\n      controller.inertiaTranslate,\n      \"_lastInertiaTranslateMovement\",\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoomCV,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\",\n    );\n    reactToInput(\n      controller,\n      controller.enableLook,\n      controller.lookEventTypes,\n      look3D,\n    );\n\n    if (\n      !controller._aggregator.anyButtonDown &&\n      !tweens.contains(controller._tween)\n    ) {\n      const tween = camera.createCorrectPositionTween(\n        controller.bounceAnimationTime,\n      );\n      if (defined(tween)) {\n        controller._tween = tweens.add(tween);\n      }\n    }\n\n    tweens.update();\n  }\n}\n\nconst scratchStrafeRay = new Ray();\nconst scratchStrafePlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst scratchStrafeIntersection = new Cartesian3();\nconst scratchStrafeDirection = new Cartesian3();\n\nfunction strafe(controller, movement, strafeStartPosition) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  const ray = camera.getPickRay(movement.endPosition, scratchStrafeRay);\n\n  let direction = Cartesian3.clone(camera.direction, scratchStrafeDirection);\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.z, direction.x, direction.y, direction);\n  }\n\n  const plane = Plane.fromPointNormal(\n    strafeStartPosition,\n    direction,\n    scratchStrafePlane,\n  );\n  const intersection = IntersectionTests.rayPlane(\n    ray,\n    plane,\n    scratchStrafeIntersection,\n  );\n  if (!defined(intersection)) {\n    return;\n  }\n\n  direction = Cartesian3.subtract(strafeStartPosition, intersection, direction);\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.y, direction.z, direction.x, direction);\n  }\n\n  Cartesian3.add(camera.position, direction, camera.position);\n}\n\nconst spin3DPick = new Cartesian3();\nconst scratchCartographic = new Cartographic();\nconst scratchRadii = new Cartesian3();\nconst scratchEllipsoid = new Ellipsoid();\nconst scratchLookUp = new Cartesian3();\nconst scratchNormal = new Cartesian3();\nconst scratchMousePosition = new Cartesian3();\n\nfunction spin3D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n  let ellipsoid = controller._ellipsoid;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n\n  let magnitude;\n  let radii;\n\n  const up = ellipsoid.geodeticSurfaceNormal(camera.position, scratchLookUp);\n\n  if (Cartesian2.equals(startPosition, controller._rotateMousePosition)) {\n    if (controller._looking) {\n      look3D(controller, startPosition, movement, up);\n    } else if (controller._rotating) {\n      rotate3D(controller, startPosition, movement);\n    } else if (controller._strafing) {\n      continueStrafing(controller, movement);\n    } else {\n      if (\n        Cartesian3.magnitude(camera.position) <\n        Cartesian3.magnitude(controller._rotateStartPosition)\n      ) {\n        // Pan action is no longer valid if camera moves below the pan ellipsoid\n        return;\n      }\n      magnitude = Cartesian3.magnitude(controller._rotateStartPosition);\n      radii = scratchRadii;\n      radii.x = radii.y = radii.z = magnitude;\n      ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n      pan3D(controller, startPosition, movement, ellipsoid);\n    }\n    return;\n  }\n  controller._looking = false;\n  controller._rotating = false;\n  controller._strafing = false;\n\n  const height = ellipsoid.cartesianToCartographic(\n    camera.positionWC,\n    scratchCartographic,\n  ).height;\n  const globe = controller._globe;\n\n  if (defined(globe) && height < controller._minimumPickingTerrainHeight) {\n    const mousePos = pickPosition(\n      controller,\n      movement.startPosition,\n      scratchMousePosition,\n    );\n    if (defined(mousePos)) {\n      let strafing = false;\n      const ray = camera.getPickRay(\n        movement.startPosition,\n        pickGlobeScratchRay,\n      );\n\n      if (cameraUnderground) {\n        strafing = true;\n        getStrafeStartPositionUnderground(controller, ray, mousePos, mousePos);\n      } else {\n        const normal = ellipsoid.geodeticSurfaceNormal(mousePos, scratchNormal);\n        const tangentPick =\n          Math.abs(Cartesian3.dot(ray.direction, normal)) < 0.05;\n\n        if (tangentPick) {\n          strafing = true;\n        } else {\n          strafing =\n            Cartesian3.magnitude(camera.position) <\n            Cartesian3.magnitude(mousePos);\n        }\n      }\n\n      if (strafing) {\n        Cartesian2.clone(startPosition, controller._strafeEndMousePosition);\n        Cartesian3.clone(mousePos, controller._strafeStartPosition);\n        controller._strafing = true;\n        strafe(controller, movement, controller._strafeStartPosition);\n      } else {\n        magnitude = Cartesian3.magnitude(mousePos);\n        radii = scratchRadii;\n        radii.x = radii.y = radii.z = magnitude;\n        ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n        pan3D(controller, startPosition, movement, ellipsoid);\n\n        Cartesian3.clone(mousePos, controller._rotateStartPosition);\n      }\n    } else {\n      controller._looking = true;\n      look3D(controller, startPosition, movement, up);\n    }\n  } else if (\n    defined(\n      camera.pickEllipsoid(\n        movement.startPosition,\n        controller._ellipsoid,\n        spin3DPick,\n      ),\n    )\n  ) {\n    pan3D(controller, startPosition, movement, controller._ellipsoid);\n    Cartesian3.clone(spin3DPick, controller._rotateStartPosition);\n  } else if (height > controller._minimumTrackBallHeight) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n  } else {\n    controller._looking = true;\n    look3D(controller, startPosition, movement, up);\n  }\n\n  Cartesian2.clone(startPosition, controller._rotateMousePosition);\n}\n\nfunction rotate3D(\n  controller,\n  startPosition,\n  movement,\n  constrainedAxis,\n  rotateOnlyVertical,\n  rotateOnlyHorizontal,\n) {\n  rotateOnlyVertical = defaultValue(rotateOnlyVertical, false);\n  rotateOnlyHorizontal = defaultValue(rotateOnlyHorizontal, false);\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  const oldAxis = camera.constrainedAxis;\n  if (defined(constrainedAxis)) {\n    camera.constrainedAxis = constrainedAxis;\n  }\n\n  const rho = Cartesian3.magnitude(camera.position);\n  let rotateRate =\n    controller._rotateFactor * (rho - controller._rotateRateRangeAdjustment);\n\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n\n  let phiWindowRatio =\n    (movement.startPosition.x - movement.endPosition.x) / canvas.clientWidth;\n  let thetaWindowRatio =\n    (movement.startPosition.y - movement.endPosition.y) / canvas.clientHeight;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n  thetaWindowRatio = Math.min(\n    thetaWindowRatio,\n    controller.maximumMovementRatio,\n  );\n\n  const deltaPhi = rotateRate * phiWindowRatio * Math.PI * 2.0;\n  let deltaTheta = rotateRate * thetaWindowRatio * Math.PI;\n\n  if (defined(constrainedAxis) && defined(controller.maximumTiltAngle)) {\n    const maximumTiltAngle = controller.maximumTiltAngle;\n    const dotProduct = Cartesian3.dot(camera.direction, constrainedAxis);\n    const tilt = Math.PI - Math.acos(dotProduct) + deltaTheta;\n    if (tilt > maximumTiltAngle) {\n      deltaTheta -= tilt - maximumTiltAngle;\n    }\n  }\n\n  if (!rotateOnlyVertical) {\n    camera.rotateRight(deltaPhi);\n  }\n\n  if (!rotateOnlyHorizontal) {\n    camera.rotateUp(deltaTheta);\n  }\n\n  camera.constrainedAxis = oldAxis;\n}\n\nconst pan3DP0 = Cartesian4.clone(Cartesian4.UNIT_W);\nconst pan3DP1 = Cartesian4.clone(Cartesian4.UNIT_W);\nconst pan3DTemp0 = new Cartesian3();\nconst pan3DTemp1 = new Cartesian3();\nconst pan3DTemp2 = new Cartesian3();\nconst pan3DTemp3 = new Cartesian3();\nconst pan3DStartMousePosition = new Cartesian2();\nconst pan3DEndMousePosition = new Cartesian2();\nconst pan3DDiffMousePosition = new Cartesian2();\nconst pan3DPixelDimensions = new Cartesian2();\nconst panRay = new Ray();\n\nfunction pan3D(controller, startPosition, movement, ellipsoid) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  const startMousePosition = Cartesian2.clone(\n    movement.startPosition,\n    pan3DStartMousePosition,\n  );\n  const endMousePosition = Cartesian2.clone(\n    movement.endPosition,\n    pan3DEndMousePosition,\n  );\n  const height = ellipsoid.cartesianToCartographic(\n    camera.positionWC,\n    scratchCartographic,\n  ).height;\n\n  let p0, p1;\n\n  if (\n    !movement.inertiaEnabled &&\n    height < controller._minimumPickingTerrainHeight\n  ) {\n    p0 = Cartesian3.clone(controller._panLastWorldPosition, pan3DP0);\n\n    // Use the last picked world position unless we're starting a new drag\n    if (\n      !defined(controller._globe) &&\n      !Cartesian2.equalsEpsilon(\n        startMousePosition,\n        controller._panLastMousePosition,\n      )\n    ) {\n      p0 = pickPosition(controller, startMousePosition, pan3DP0);\n    }\n\n    if (!defined(controller._globe) && defined(p0)) {\n      const toCenter = Cartesian3.subtract(p0, camera.positionWC, pan3DTemp1);\n      const toCenterProj = Cartesian3.multiplyByScalar(\n        camera.directionWC,\n        Cartesian3.dot(camera.directionWC, toCenter),\n        pan3DTemp1,\n      );\n      const distanceToNearPlane = Cartesian3.magnitude(toCenterProj);\n      const pixelDimensions = camera.frustum.getPixelDimensions(\n        scene.drawingBufferWidth,\n        scene.drawingBufferHeight,\n        distanceToNearPlane,\n        scene.pixelRatio,\n        pan3DPixelDimensions,\n      );\n\n      const dragDelta = Cartesian2.subtract(\n        endMousePosition,\n        startMousePosition,\n        pan3DDiffMousePosition,\n      );\n\n      // Move the camera to the the distance the cursor moved in worldspace\n      const right = Cartesian3.multiplyByScalar(\n        camera.rightWC,\n        dragDelta.x * pixelDimensions.x,\n        pan3DTemp1,\n      );\n\n      // Move the camera towards the picked position in worldspace as the camera is pointed towards a horizon view\n      const cameraPositionNormal = Cartesian3.normalize(\n        camera.positionWC,\n        scratchCameraPositionNormal,\n      );\n      const endPickDirection = camera.getPickRay(\n        endMousePosition,\n        panRay,\n      ).direction;\n      const endPickProj = Cartesian3.subtract(\n        endPickDirection,\n        Cartesian3.projectVector(endPickDirection, camera.rightWC, pan3DTemp2),\n        pan3DTemp2,\n      );\n      const angle = Cartesian3.angleBetween(endPickProj, camera.directionWC);\n      let forward = 1.0;\n      if (defined(camera.frustum.fov)) {\n        forward = Math.max(Math.tan(angle), 0.1); // Clamp so we don't make the magnitude infinitely large when the angle is small\n      }\n      let dot = Math.abs(\n        Cartesian3.dot(camera.directionWC, cameraPositionNormal),\n      );\n      const magnitude =\n        ((-dragDelta.y * pixelDimensions.y * 2.0) / Math.sqrt(forward)) *\n        (1.0 - dot);\n      const direction = Cartesian3.multiplyByScalar(\n        endPickDirection,\n        magnitude,\n        pan3DTemp2,\n      );\n\n      // Move the camera up the distance the cursor moved in worldspace as the camera is pointed towards the center\n      dot = Math.abs(Cartesian3.dot(camera.upWC, cameraPositionNormal));\n      const up = Cartesian3.multiplyByScalar(\n        camera.upWC,\n        -dragDelta.y * (1.0 - dot) * pixelDimensions.y,\n        pan3DTemp3,\n      );\n\n      p1 = Cartesian3.add(p0, right, pan3DP1);\n      p1 = Cartesian3.add(p1, direction, p1);\n      p1 = Cartesian3.add(p1, up, p1);\n\n      Cartesian3.clone(p1, controller._panLastWorldPosition);\n      Cartesian2.clone(endMousePosition, controller._panLastMousePosition);\n    }\n  }\n\n  if (!defined(p0) || !defined(p1)) {\n    p0 = camera.pickEllipsoid(startMousePosition, ellipsoid, pan3DP0);\n    p1 = camera.pickEllipsoid(endMousePosition, ellipsoid, pan3DP1);\n  }\n\n  if (!defined(p0) || !defined(p1)) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n\n  p0 = camera.worldToCameraCoordinates(p0, p0);\n  p1 = camera.worldToCameraCoordinates(p1, p1);\n\n  if (!defined(camera.constrainedAxis)) {\n    Cartesian3.normalize(p0, p0);\n    Cartesian3.normalize(p1, p1);\n    const dot = Cartesian3.dot(p0, p1);\n    const axis = Cartesian3.cross(p0, p1, pan3DTemp0);\n\n    if (\n      dot < 1.0 &&\n      !Cartesian3.equalsEpsilon(axis, Cartesian3.ZERO, CesiumMath.EPSILON14)\n    ) {\n      // dot is in [0, 1]\n      const angle = Math.acos(dot);\n      camera.rotate(axis, angle);\n    }\n  } else {\n    const basis0 = camera.constrainedAxis;\n    const basis1 = Cartesian3.mostOrthogonalAxis(basis0, pan3DTemp0);\n    Cartesian3.cross(basis1, basis0, basis1);\n    Cartesian3.normalize(basis1, basis1);\n    const basis2 = Cartesian3.cross(basis0, basis1, pan3DTemp1);\n\n    const startRho = Cartesian3.magnitude(p0);\n    const startDot = Cartesian3.dot(basis0, p0);\n    const startTheta = Math.acos(startDot / startRho);\n    const startRej = Cartesian3.multiplyByScalar(basis0, startDot, pan3DTemp2);\n    Cartesian3.subtract(p0, startRej, startRej);\n    Cartesian3.normalize(startRej, startRej);\n\n    const endRho = Cartesian3.magnitude(p1);\n    const endDot = Cartesian3.dot(basis0, p1);\n    const endTheta = Math.acos(endDot / endRho);\n    const endRej = Cartesian3.multiplyByScalar(basis0, endDot, pan3DTemp3);\n    Cartesian3.subtract(p1, endRej, endRej);\n    Cartesian3.normalize(endRej, endRej);\n\n    let startPhi = Math.acos(Cartesian3.dot(startRej, basis1));\n    if (Cartesian3.dot(startRej, basis2) < 0) {\n      startPhi = CesiumMath.TWO_PI - startPhi;\n    }\n\n    let endPhi = Math.acos(Cartesian3.dot(endRej, basis1));\n    if (Cartesian3.dot(endRej, basis2) < 0) {\n      endPhi = CesiumMath.TWO_PI - endPhi;\n    }\n\n    const deltaPhi = startPhi - endPhi;\n\n    let east;\n    if (\n      Cartesian3.equalsEpsilon(basis0, camera.position, CesiumMath.EPSILON2)\n    ) {\n      east = camera.right;\n    } else {\n      east = Cartesian3.cross(basis0, camera.position, pan3DTemp0);\n    }\n\n    const planeNormal = Cartesian3.cross(basis0, east, pan3DTemp0);\n    const side0 = Cartesian3.dot(\n      planeNormal,\n      Cartesian3.subtract(p0, basis0, pan3DTemp1),\n    );\n    const side1 = Cartesian3.dot(\n      planeNormal,\n      Cartesian3.subtract(p1, basis0, pan3DTemp1),\n    );\n\n    let deltaTheta;\n    if (side0 > 0 && side1 > 0) {\n      deltaTheta = endTheta - startTheta;\n    } else if (side0 > 0 && side1 <= 0) {\n      if (Cartesian3.dot(camera.position, basis0) > 0) {\n        deltaTheta = -startTheta - endTheta;\n      } else {\n        deltaTheta = startTheta + endTheta;\n      }\n    } else {\n      deltaTheta = startTheta - endTheta;\n    }\n\n    camera.rotateRight(deltaPhi);\n    camera.rotateUp(deltaTheta);\n  }\n}\n\nconst zoom3DUnitPosition = new Cartesian3();\nconst zoom3DCartographic = new Cartographic();\n\nlet preIntersectionDistance = 0;\n\nfunction zoom3D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n  const inertiaMovement = movement.inertiaEnabled;\n\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  const cameraUnderground = controller._cameraUnderground;\n\n  let windowPosition;\n\n  if (cameraUnderground) {\n    windowPosition = startPosition;\n  } else {\n    windowPosition = zoomCVWindowPos;\n    windowPosition.x = canvas.clientWidth / 2;\n    windowPosition.y = canvas.clientHeight / 2;\n  }\n\n  const ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n\n  let intersection;\n  const height = ellipsoid.cartesianToCartographic(\n    camera.position,\n    zoom3DCartographic,\n  ).height;\n\n  const approachingCollision =\n    Math.abs(preIntersectionDistance) <\n    controller.minimumPickingTerrainDistanceWithInertia;\n\n  const needPickGlobe = inertiaMovement\n    ? approachingCollision\n    : height < controller._minimumPickingTerrainHeight;\n  if (needPickGlobe) {\n    intersection = pickPosition(controller, windowPosition, zoomCVIntersection);\n  }\n\n  let distance;\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(ray.origin, intersection);\n    preIntersectionDistance = distance;\n  }\n\n  if (cameraUnderground) {\n    const distanceUnderground = getZoomDistanceUnderground(\n      controller,\n      ray,\n      height,\n    );\n    if (defined(distance)) {\n      distance = Math.min(distance, distanceUnderground);\n    } else {\n      distance = distanceUnderground;\n    }\n  }\n\n  if (!defined(distance)) {\n    distance = height;\n  }\n\n  const unitPosition = Cartesian3.normalize(\n    camera.position,\n    zoom3DUnitPosition,\n  );\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller.zoomFactor,\n    distance,\n    Cartesian3.dot(unitPosition, camera.direction),\n  );\n}\n\nconst tilt3DWindowPos = new Cartesian2();\nconst tilt3DRay = new Ray();\nconst tilt3DCenter = new Cartesian3();\nconst tilt3DVerticalCenter = new Cartesian3();\nconst tilt3DTransform = new Matrix4();\nconst tilt3DVerticalTransform = new Matrix4();\nconst tilt3DOldTransform = new Matrix4();\nconst tilt3DQuaternion = new Quaternion();\nconst tilt3DMatrix = new Matrix3();\nconst tilt3DCart = new Cartographic();\nconst tilt3DLookUp = new Cartesian3();\n\nfunction tilt3D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    return;\n  }\n\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltOnEllipsoid = false;\n    controller._looking = false;\n  }\n\n  if (controller._looking) {\n    const up = controller._ellipsoid.geodeticSurfaceNormal(\n      camera.position,\n      tilt3DLookUp,\n    );\n    look3D(controller, startPosition, movement, up);\n    return;\n  }\n\n  const ellipsoid = controller._ellipsoid;\n  const cartographic = ellipsoid.cartesianToCartographic(\n    camera.position,\n    tilt3DCart,\n  );\n\n  if (\n    controller._tiltOnEllipsoid ||\n    cartographic.height > controller._minimumCollisionTerrainHeight\n  ) {\n    controller._tiltOnEllipsoid = true;\n    tilt3DOnEllipsoid(controller, startPosition, movement);\n  } else {\n    tilt3DOnTerrain(controller, startPosition, movement);\n  }\n}\n\nconst tilt3DOnEllipsoidCartographic = new Cartographic();\n\nfunction tilt3DOnEllipsoid(controller, startPosition, movement) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const minHeight = controller.minimumZoomDistance * 0.25;\n  const height = ellipsoid.cartesianToCartographic(\n    camera.positionWC,\n    tilt3DOnEllipsoidCartographic,\n  ).height;\n  if (\n    height - minHeight - 1.0 < CesiumMath.EPSILON3 &&\n    movement.endPosition.y - movement.startPosition.y < 0\n  ) {\n    return;\n  }\n\n  const canvas = scene.canvas;\n\n  const windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  const ray = camera.getPickRay(windowPosition, tilt3DRay);\n\n  let center;\n  const intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n  if (defined(intersection)) {\n    center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n  } else if (height > controller._minimumTrackBallHeight) {\n    const grazingAltitudeLocation = IntersectionTests.grazingAltitudeLocation(\n      ray,\n      ellipsoid,\n    );\n    if (!defined(grazingAltitudeLocation)) {\n      return;\n    }\n    const grazingAltitudeCart = ellipsoid.cartesianToCartographic(\n      grazingAltitudeLocation,\n      tilt3DCart,\n    );\n    grazingAltitudeCart.height = 0.0;\n    center = ellipsoid.cartographicToCartesian(\n      grazingAltitudeCart,\n      tilt3DCenter,\n    );\n  } else {\n    controller._looking = true;\n    const up = controller._ellipsoid.geodeticSurfaceNormal(\n      camera.position,\n      tilt3DLookUp,\n    );\n    look3D(controller, startPosition, movement, up);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    tilt3DTransform,\n  );\n\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  const oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n  camera._setTransform(transform);\n\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\n\nfunction tilt3DOnTerrain(controller, startPosition, movement) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n\n  let center;\n  let ray;\n  let intersection;\n\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, tilt3DCenter);\n  } else {\n    center = pickPosition(controller, startPosition, tilt3DCenter);\n\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, tilt3DRay);\n      intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n      if (!defined(intersection)) {\n        const cartographic = ellipsoid.cartesianToCartographic(\n          camera.position,\n          tilt3DCart,\n        );\n        if (cartographic.height <= controller._minimumTrackBallHeight) {\n          controller._looking = true;\n          const up = controller._ellipsoid.geodeticSurfaceNormal(\n            camera.position,\n            tilt3DLookUp,\n          );\n          look3D(controller, startPosition, movement, up);\n          Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        }\n        return;\n      }\n      center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n    }\n\n    if (cameraUnderground) {\n      if (!defined(ray)) {\n        ray = camera.getPickRay(startPosition, tilt3DRay);\n      }\n      getTiltCenterUnderground(controller, ray, center, center);\n    }\n\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n\n  const canvas = scene.canvas;\n\n  const windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, tilt3DRay);\n\n  const mag = Cartesian3.magnitude(center);\n  const radii = Cartesian3.fromElements(mag, mag, mag, scratchRadii);\n  const newEllipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n\n  intersection = IntersectionTests.rayEllipsoid(ray, newEllipsoid);\n  if (!defined(intersection)) {\n    return;\n  }\n\n  const t =\n    Cartesian3.magnitude(ray.origin) > mag\n      ? intersection.start\n      : intersection.stop;\n  const verticalCenter = Ray.getPoint(ray, t, tilt3DVerticalCenter);\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    tilt3DTransform,\n  );\n  const verticalTransform = Transforms.eastNorthUpToFixedFrame(\n    verticalCenter,\n    newEllipsoid,\n    tilt3DVerticalTransform,\n  );\n\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  let constrainedAxis = Cartesian3.UNIT_Z;\n\n  const oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n  camera._setTransform(verticalTransform);\n\n  const tangent = Cartesian3.cross(\n    verticalCenter,\n    camera.positionWC,\n    tilt3DCartesian3,\n  );\n  const dot = Cartesian3.dot(camera.rightWC, tangent);\n\n  if (dot < 0.0) {\n    const movementDelta = movement.startPosition.y - movement.endPosition.y;\n    if (\n      (cameraUnderground && movementDelta < 0.0) ||\n      (!cameraUnderground && movementDelta > 0.0)\n    ) {\n      // Prevent camera from flipping past the up axis\n      constrainedAxis = undefined;\n    }\n\n    const oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n\n  camera._setTransform(transform);\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n\n  if (defined(camera.constrainedAxis)) {\n    const right = Cartesian3.cross(\n      camera.direction,\n      camera.constrainedAxis,\n      tilt3DCartesian3,\n    );\n    if (\n      !Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)\n    ) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n\n  const originalPosition = Cartesian3.clone(\n    camera.positionWC,\n    tilt3DCartesian3,\n  );\n\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller, true);\n  }\n\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n\n    const magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.sqrt(magSqrd),\n        camera.position,\n      );\n    }\n\n    const angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    const axis = Cartesian3.cross(\n      originalPosition,\n      camera.position,\n      originalPosition,\n    );\n    Cartesian3.normalize(axis, axis);\n\n    const quaternion = Quaternion.fromAxisAngle(axis, angle, tilt3DQuaternion);\n    const rotation = Matrix3.fromQuaternion(quaternion, tilt3DMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n    camera._setTransform(oldTransform);\n  }\n}\n\nconst look3DStartPos = new Cartesian2();\nconst look3DEndPos = new Cartesian2();\nconst look3DStartRay = new Ray();\nconst look3DEndRay = new Ray();\nconst look3DNegativeRot = new Cartesian3();\nconst look3DTan = new Cartesian3();\n\nfunction look3D(controller, startPosition, movement, rotationAxis) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  const startPos = look3DStartPos;\n  startPos.x = movement.startPosition.x;\n  startPos.y = 0.0;\n  const endPos = look3DEndPos;\n  endPos.x = movement.endPosition.x;\n  endPos.y = 0.0;\n\n  let startRay = camera.getPickRay(startPos, look3DStartRay);\n  let endRay = camera.getPickRay(endPos, look3DEndRay);\n  let angle = 0.0;\n  let start;\n  let end;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n\n  let dot = Cartesian3.dot(start, end);\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n\n  angle = movement.startPosition.x > movement.endPosition.x ? -angle : angle;\n\n  const horizontalRotationAxis = controller._horizontalRotationAxis;\n  if (defined(rotationAxis)) {\n    camera.look(rotationAxis, -angle);\n  } else if (defined(horizontalRotationAxis)) {\n    camera.look(horizontalRotationAxis, -angle);\n  } else {\n    camera.lookLeft(angle);\n  }\n\n  startPos.x = 0.0;\n  startPos.y = movement.startPosition.y;\n  endPos.x = 0.0;\n  endPos.y = movement.endPosition.y;\n\n  startRay = camera.getPickRay(startPos, look3DStartRay);\n  endRay = camera.getPickRay(endPos, look3DEndRay);\n  angle = 0.0;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n\n  dot = Cartesian3.dot(start, end);\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n  angle = movement.startPosition.y > movement.endPosition.y ? -angle : angle;\n\n  rotationAxis = defaultValue(rotationAxis, horizontalRotationAxis);\n  if (defined(rotationAxis)) {\n    const direction = camera.direction;\n    const negativeRotationAxis = Cartesian3.negate(\n      rotationAxis,\n      look3DNegativeRot,\n    );\n    const northParallel = Cartesian3.equalsEpsilon(\n      direction,\n      rotationAxis,\n      CesiumMath.EPSILON2,\n    );\n    const southParallel = Cartesian3.equalsEpsilon(\n      direction,\n      negativeRotationAxis,\n      CesiumMath.EPSILON2,\n    );\n    if (!northParallel && !southParallel) {\n      dot = Cartesian3.dot(direction, rotationAxis);\n      let angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n\n      dot = Cartesian3.dot(direction, negativeRotationAxis);\n      angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n\n      const tangent = Cartesian3.cross(rotationAxis, direction, look3DTan);\n      camera.look(tangent, angle);\n    } else if ((northParallel && angle < 0) || (southParallel && angle > 0)) {\n      camera.look(camera.right, -angle);\n    }\n  } else {\n    camera.lookUp(angle);\n  }\n}\n\nfunction update3D(controller) {\n  reactToInput(\n    controller,\n    controller.enableRotate,\n    controller.rotateEventTypes,\n    spin3D,\n    controller.inertiaSpin,\n    \"_lastInertiaSpinMovement\",\n  );\n  reactToInput(\n    controller,\n    controller.enableZoom,\n    controller.zoomEventTypes,\n    zoom3D,\n    controller.inertiaZoom,\n    \"_lastInertiaZoomMovement\",\n  );\n  reactToInput(\n    controller,\n    controller.enableTilt,\n    controller.tiltEventTypes,\n    tilt3D,\n    controller.inertiaSpin,\n    \"_lastInertiaTiltMovement\",\n  );\n  reactToInput(\n    controller,\n    controller.enableLook,\n    controller.lookEventTypes,\n    look3D,\n  );\n}\n\nconst scratchAdjustHeightTransform = new Matrix4();\nconst scratchAdjustHeightCartographic = new Cartographic();\n\nfunction adjustHeightForTerrain(controller, cameraChanged) {\n  controller._adjustedHeightForTerrain = true;\n\n  const scene = controller._scene;\n  const mode = scene.mode;\n\n  if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  const camera = scene.camera;\n  const ellipsoid = defaultValue(scene.ellipsoid, Ellipsoid.WGS84);\n  const projection = scene.mapProjection;\n\n  let transform;\n  let mag;\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    transform = Matrix4.clone(camera.transform, scratchAdjustHeightTransform);\n    mag = Cartesian3.magnitude(camera.position);\n    camera._setTransform(Matrix4.IDENTITY);\n  }\n\n  const cartographic = scratchAdjustHeightCartographic;\n  if (mode === SceneMode.SCENE3D) {\n    ellipsoid.cartesianToCartographic(camera.position, cartographic);\n  } else {\n    projection.unproject(camera.position, cartographic);\n  }\n\n  let heightUpdated = false;\n  if (cartographic.height < controller._minimumCollisionTerrainHeight) {\n    const globeHeight = controller._scene.globeHeight;\n    if (defined(globeHeight)) {\n      const height = globeHeight + controller.minimumZoomDistance;\n      const difference = globeHeight - controller._lastGlobeHeight;\n      const percentDifference = difference / controller._lastGlobeHeight;\n\n      // Unless the camera has been moved by user input, to avoid big jumps during tile loads\n      // only make height updates when the globe height has been fairly stable across several frames\n      if (\n        cartographic.height < height &&\n        (cameraChanged || Math.abs(percentDifference) <= 0.1)\n      ) {\n        cartographic.height = height;\n        if (mode === SceneMode.SCENE3D) {\n          ellipsoid.cartographicToCartesian(cartographic, camera.position);\n        } else {\n          projection.project(cartographic, camera.position);\n        }\n        heightUpdated = true;\n      }\n\n      if (cameraChanged || Math.abs(percentDifference) <= 0.1) {\n        controller._lastGlobeHeight = globeHeight;\n      } else {\n        controller._lastGlobeHeight += difference * 0.1;\n      }\n    }\n  }\n\n  if (defined(transform)) {\n    camera._setTransform(transform);\n    if (heightUpdated) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.negate(camera.position, camera.direction);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.max(mag, controller.minimumZoomDistance),\n        camera.position,\n      );\n      Cartesian3.normalize(camera.direction, camera.direction);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.cross(camera.right, camera.direction, camera.up);\n    }\n  }\n}\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.onMap = function () {\n  const scene = this._scene;\n  const mode = scene.mode;\n  const camera = scene.camera;\n\n  if (mode === SceneMode.COLUMBUS_VIEW) {\n    return (\n      Math.abs(camera.position.x) - this._maxCoord.x < 0 &&\n      Math.abs(camera.position.y) - this._maxCoord.y < 0\n    );\n  }\n\n  return true;\n};\n\nconst scratchPreviousPosition = new Cartesian3();\nconst scratchPreviousDirection = new Cartesian3();\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.update = function () {\n  const scene = this._scene;\n  const { camera, globe, mode } = scene;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    this._globe = undefined;\n    this._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  } else {\n    this._globe = globe;\n    this._ellipsoid = defaultValue(scene.ellipsoid, Ellipsoid.default);\n  }\n\n  const { verticalExaggeration, verticalExaggerationRelativeHeight } = scene;\n  this._minimumCollisionTerrainHeight = VerticalExaggeration.getHeight(\n    this.minimumCollisionTerrainHeight,\n    verticalExaggeration,\n    verticalExaggerationRelativeHeight,\n  );\n  this._minimumPickingTerrainHeight = VerticalExaggeration.getHeight(\n    this.minimumPickingTerrainHeight,\n    verticalExaggeration,\n    verticalExaggerationRelativeHeight,\n  );\n  this._minimumTrackBallHeight = VerticalExaggeration.getHeight(\n    this.minimumTrackBallHeight,\n    verticalExaggeration,\n    verticalExaggerationRelativeHeight,\n  );\n\n  this._cameraUnderground = scene.cameraUnderground && defined(this._globe);\n\n  const radius = this._ellipsoid.maximumRadius;\n  this._rotateFactor = 1.0 / radius;\n  this._rotateRateRangeAdjustment = radius;\n\n  this._adjustedHeightForTerrain = false;\n  const previousPosition = Cartesian3.clone(\n    camera.positionWC,\n    scratchPreviousPosition,\n  );\n  const previousDirection = Cartesian3.clone(\n    camera.directionWC,\n    scratchPreviousDirection,\n  );\n\n  if (mode === SceneMode.SCENE2D) {\n    update2D(this);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    this._horizontalRotationAxis = Cartesian3.UNIT_Z;\n    updateCV(this);\n  } else if (mode === SceneMode.SCENE3D) {\n    this._horizontalRotationAxis = undefined;\n    update3D(this);\n  }\n\n  if (this.enableCollisionDetection && !this._adjustedHeightForTerrain) {\n    // Adjust the camera height if the camera moved at all (user input or inertia) and an action didn't already adjust the camera height\n    const cameraChanged =\n      !Cartesian3.equals(previousPosition, camera.positionWC) ||\n      !Cartesian3.equals(previousDirection, camera.directionWC);\n    adjustHeightForTerrain(this, cameraChanged);\n  }\n\n  this._aggregator.reset();\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ScreenSpaceCameraController#destroy\n */\nScreenSpaceCameraController.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes mouse listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * controller = controller && controller.destroy();\n *\n * @see ScreenSpaceCameraController#isDestroyed\n */\nScreenSpaceCameraController.prototype.destroy = function () {\n  this._tweens.removeAll();\n  this._aggregator = this._aggregator && this._aggregator.destroy();\n  return destroyObject(this);\n};\nexport default ScreenSpaceCameraController;\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,aAAa,MAAM,0BAA0B;AACpD,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,gBAAgB,MAAM,6BAA6B;AAC1D,OAAOC,iBAAiB,MAAM,8BAA8B;AAC5D,OAAOC,qBAAqB,MAAM,kCAAkC;AACpE,OAAOC,UAAU,MAAM,iBAAiB;AACxC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,mBAAmB,MAAM,gCAAgC;AAChE,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,GAAG,MAAM,gBAAgB;AAChC,OAAOC,oBAAoB,MAAM,iCAAiC;AAClE,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,qBAAqB,MAAM,4BAA4B;AAC9D,OAAOC,eAAe,MAAM,sBAAsB;AAClD,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,eAAe,MAAM,sBAAsB;AAClD,OAAOC,eAAe,MAAM,sBAAsB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,2BAA2BA,CAACC,KAAK,EAAE;EAC1C;EACA,IAAI,CAACvB,OAAO,CAACuB,KAAK,CAAC,EAAE;IACnB,MAAM,IAAIrB,cAAc,CAAC,oBAAoB,CAAC;EAChD;EACA;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACsB,YAAY,GAAG,IAAI;EACxB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,eAAe,GAAG,IAAI;EAC3B;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAG,IAAI;EACtB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,YAAY,GAAG,IAAI;EACxB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAG,IAAI;EACtB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAG,IAAI;EACtB;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,GAAG;EACtB;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,gBAAgB,GAAG,GAAG;EAC3B;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,GAAG;EACtB;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,oBAAoB,GAAG,GAAG;EAC/B;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,mBAAmB,GAAG,GAAG;EAC9B;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,mBAAmB,GAAG,GAAG;EAC9B;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,mBAAmB,GAAGC,MAAM,CAACC,iBAAiB;;EAEnD;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,UAAU,GAAG,GAAG;;EAErB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,mBAAmB,GAAGvB,eAAe,CAACwB,SAAS;EACpD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,cAAc,GAAG,CACpBzB,eAAe,CAAC0B,UAAU,EAC1B1B,eAAe,CAAC2B,KAAK,EACrB3B,eAAe,CAAC4B,KAAK,CACtB;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,gBAAgB,GAAG7B,eAAe,CAACwB,SAAS;EACjD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACM,cAAc,GAAG,CACpB9B,eAAe,CAAC+B,WAAW,EAC3B/B,eAAe,CAAC4B,KAAK,EAC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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}