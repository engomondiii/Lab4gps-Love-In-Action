{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * An entity containing metadata.\n * <p>\n * This type describes an interface and is not intended to be instantiated directly.\n * </p>\n * <p>\n * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension} for 3D Tiles\n * </p>\n *\n * @alias MetadataEntity\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction MetadataEntity() {}\nObject.defineProperties(MetadataEntity.prototype, {\n  /**\n   * The class that properties conform to.\n   *\n   * @memberof MetadataEntity.prototype\n   * @type {MetadataClass}\n   * @readonly\n   * @private\n   */\n  class: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    }\n  }\n});\n\n/**\n * Returns whether the entity has this property.\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {boolean} Whether the entity has this property.\n * @private\n */\nMetadataEntity.prototype.hasProperty = function (propertyId) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns whether the entity has a property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {boolean} Whether the entity has a property with the given semantic.\n * @private\n */\nMetadataEntity.prototype.hasPropertyBySemantic = function (semantic) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {string[]} [results] An array into which to store the results.\n * @returns {string[]} The property IDs.\n * @private\n */\nMetadataEntity.prototype.getPropertyIds = function (results) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is normalized the normalized value is returned.\n * </p>\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this property.\n * @private\n */\nMetadataEntity.prototype.getProperty = function (propertyId) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Sets the value of the property with the given ID.\n * <p>\n * If the property is normalized a normalized value must be provided to this function.\n * </p>\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nMetadataEntity.prototype.setProperty = function (propertyId, value) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this property.\n * @private\n */\nMetadataEntity.prototype.getPropertyBySemantic = function (semantic) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Sets the value of the property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nMetadataEntity.prototype.setPropertyBySemantic = function (semantic, value) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns whether the entity has this property.\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @param {object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {boolean} Whether the entity has this property.\n *\n * @private\n */\nMetadataEntity.hasProperty = function (propertyId, properties, classDefinition) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  if (defined(properties[propertyId])) {\n    return true;\n  }\n  const classProperties = classDefinition.properties;\n  if (!defined(classProperties)) {\n    return false;\n  }\n  const classProperty = classProperties[propertyId];\n  if (defined(classProperty) && defined(classProperty.default)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns whether the entity has a property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @param {object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {boolean} Whether the entity has a property with the given semantic.\n *\n * @private\n */\nMetadataEntity.hasPropertyBySemantic = function (semantic, properties, classDefinition) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  const propertiesBySemantic = classDefinition.propertiesBySemantic;\n  if (!defined(propertiesBySemantic)) {\n    return false;\n  }\n  const property = propertiesBySemantic[semantic];\n  return defined(property);\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @param {string[]} [results] An array into which to store the results.\n * @returns {string[]} The property IDs.\n *\n * @private\n */\nMetadataEntity.getPropertyIds = function (properties, classDefinition, results) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  results = defined(results) ? results : [];\n  results.length = 0;\n\n  // Add entity properties\n  for (const propertyId in properties) {\n    if (properties.hasOwnProperty(propertyId) && defined(properties[propertyId])) {\n      results.push(propertyId);\n    }\n  }\n\n  // Add default properties\n  const classProperties = classDefinition.properties;\n  if (defined(classProperties)) {\n    for (const classPropertyId in classProperties) {\n      if (classProperties.hasOwnProperty(classPropertyId) && !defined(properties[classPropertyId]) && defined(classProperties[classPropertyId].default)) {\n        results.push(classPropertyId);\n      }\n    }\n  }\n  return results;\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is normalized the normalized value is returned.\n * </p>\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @param {object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this property.\n *\n * @private\n */\nMetadataEntity.getProperty = function (propertyId, properties, classDefinition) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  if (!defined(classDefinition.properties[propertyId])) {\n    throw new DeveloperError(`Class definition missing property ${propertyId}`);\n  }\n  //>>includeEnd('debug');\n\n  const classProperty = classDefinition.properties[propertyId];\n  let value = properties[propertyId];\n\n  // Clone array values\n  if (Array.isArray(value)) {\n    value = value.slice();\n  }\n\n  // Arrays of vectors are represented as nested arrays in JSON\n  const enableNestedArrays = true;\n\n  // Handle noData and default\n  value = classProperty.handleNoData(value);\n  if (!defined(value) && defined(classProperty.default)) {\n    value = clone(classProperty.default, true);\n    return classProperty.unpackVectorAndMatrixTypes(value, enableNestedArrays);\n  }\n  if (!defined(value)) {\n    return undefined;\n  }\n  value = classProperty.normalize(value);\n  value = classProperty.applyValueTransform(value);\n  return classProperty.unpackVectorAndMatrixTypes(value, enableNestedArrays);\n};\n\n/**\n * Sets the value of the property with the given ID.\n * <p>\n * If the property is normalized a normalized value must be provided to this function.\n * </p>\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @param {object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @private\n */\nMetadataEntity.setProperty = function (propertyId, value, properties, classDefinition) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  Check.defined(\"value\", value);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  if (!defined(properties[propertyId])) {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    value = value.slice(); // clone\n  }\n  let classProperty;\n  const classProperties = classDefinition.properties;\n  if (defined(classProperties)) {\n    classProperty = classProperties[propertyId];\n  }\n\n  // arrays of vectors are represented as nested arrays in JSON\n  const enableNestedArrays = true;\n  if (defined(classProperty)) {\n    value = classProperty.packVectorAndMatrixTypes(value, enableNestedArrays);\n    value = classProperty.unapplyValueTransform(value);\n    value = classProperty.unnormalize(value);\n  }\n  properties[propertyId] = value;\n  return true;\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @param {object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this property.\n *\n * @private\n */\nMetadataEntity.getPropertyBySemantic = function (semantic, properties, classDefinition) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  const propertiesBySemantic = classDefinition.propertiesBySemantic;\n  if (!defined(propertiesBySemantic)) {\n    return undefined;\n  }\n  const property = propertiesBySemantic[semantic];\n  if (defined(property)) {\n    return MetadataEntity.getProperty(property.id, properties, classDefinition);\n  }\n  return undefined;\n};\n\n/**\n * Sets the value of the property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @param {object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nMetadataEntity.setPropertyBySemantic = function (semantic, value, properties, classDefinition) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  Check.defined(\"value\", value);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  const propertiesBySemantic = classDefinition.propertiesBySemantic;\n  if (!defined(propertiesBySemantic)) {\n    return false;\n  }\n  const property = classDefinition.propertiesBySemantic[semantic];\n  if (defined(property)) {\n    return MetadataEntity.setProperty(property.id, value, properties, classDefinition);\n  }\n  return false;\n};\nexport default MetadataEntity;","map":{"version":3,"names":["Check","clone","defined","DeveloperError","MetadataEntity","Object","defineProperties","prototype","class","get","throwInstantiationError","hasProperty","propertyId","hasPropertyBySemantic","semantic","getPropertyIds","results","getProperty","setProperty","value","getPropertyBySemantic","setPropertyBySemantic","properties","classDefinition","typeOf","string","object","classProperties","classProperty","default","propertiesBySemantic","property","length","hasOwnProperty","push","classPropertyId","Array","isArray","slice","enableNestedArrays","handleNoData","unpackVectorAndMatrixTypes","undefined","normalize","applyValueTransform","packVectorAndMatrixTypes","unapplyValueTransform","unnormalize","id"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/MetadataEntity.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * An entity containing metadata.\n * <p>\n * This type describes an interface and is not intended to be instantiated directly.\n * </p>\n * <p>\n * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension} for 3D Tiles\n * </p>\n *\n * @alias MetadataEntity\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction MetadataEntity() {}\n\nObject.defineProperties(MetadataEntity.prototype, {\n  /**\n   * The class that properties conform to.\n   *\n   * @memberof MetadataEntity.prototype\n   * @type {MetadataClass}\n   * @readonly\n   * @private\n   */\n  class: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n});\n\n/**\n * Returns whether the entity has this property.\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {boolean} Whether the entity has this property.\n * @private\n */\nMetadataEntity.prototype.hasProperty = function (propertyId) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns whether the entity has a property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {boolean} Whether the entity has a property with the given semantic.\n * @private\n */\nMetadataEntity.prototype.hasPropertyBySemantic = function (semantic) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {string[]} [results] An array into which to store the results.\n * @returns {string[]} The property IDs.\n * @private\n */\nMetadataEntity.prototype.getPropertyIds = function (results) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is normalized the normalized value is returned.\n * </p>\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this property.\n * @private\n */\nMetadataEntity.prototype.getProperty = function (propertyId) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Sets the value of the property with the given ID.\n * <p>\n * If the property is normalized a normalized value must be provided to this function.\n * </p>\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nMetadataEntity.prototype.setProperty = function (propertyId, value) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this property.\n * @private\n */\nMetadataEntity.prototype.getPropertyBySemantic = function (semantic) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Sets the value of the property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nMetadataEntity.prototype.setPropertyBySemantic = function (semantic, value) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns whether the entity has this property.\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @param {object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {boolean} Whether the entity has this property.\n *\n * @private\n */\nMetadataEntity.hasProperty = function (\n  propertyId,\n  properties,\n  classDefinition,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  if (defined(properties[propertyId])) {\n    return true;\n  }\n\n  const classProperties = classDefinition.properties;\n  if (!defined(classProperties)) {\n    return false;\n  }\n\n  const classProperty = classProperties[propertyId];\n  if (defined(classProperty) && defined(classProperty.default)) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Returns whether the entity has a property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @param {object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {boolean} Whether the entity has a property with the given semantic.\n *\n * @private\n */\nMetadataEntity.hasPropertyBySemantic = function (\n  semantic,\n  properties,\n  classDefinition,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  const propertiesBySemantic = classDefinition.propertiesBySemantic;\n  if (!defined(propertiesBySemantic)) {\n    return false;\n  }\n\n  const property = propertiesBySemantic[semantic];\n  return defined(property);\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @param {string[]} [results] An array into which to store the results.\n * @returns {string[]} The property IDs.\n *\n * @private\n */\nMetadataEntity.getPropertyIds = function (\n  properties,\n  classDefinition,\n  results,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  results = defined(results) ? results : [];\n  results.length = 0;\n\n  // Add entity properties\n  for (const propertyId in properties) {\n    if (\n      properties.hasOwnProperty(propertyId) &&\n      defined(properties[propertyId])\n    ) {\n      results.push(propertyId);\n    }\n  }\n\n  // Add default properties\n  const classProperties = classDefinition.properties;\n  if (defined(classProperties)) {\n    for (const classPropertyId in classProperties) {\n      if (\n        classProperties.hasOwnProperty(classPropertyId) &&\n        !defined(properties[classPropertyId]) &&\n        defined(classProperties[classPropertyId].default)\n      ) {\n        results.push(classPropertyId);\n      }\n    }\n  }\n\n  return results;\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is normalized the normalized value is returned.\n * </p>\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @param {object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this property.\n *\n * @private\n */\nMetadataEntity.getProperty = function (\n  propertyId,\n  properties,\n  classDefinition,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n\n  if (!defined(classDefinition.properties[propertyId])) {\n    throw new DeveloperError(`Class definition missing property ${propertyId}`);\n  }\n  //>>includeEnd('debug');\n\n  const classProperty = classDefinition.properties[propertyId];\n  let value = properties[propertyId];\n\n  // Clone array values\n  if (Array.isArray(value)) {\n    value = value.slice();\n  }\n\n  // Arrays of vectors are represented as nested arrays in JSON\n  const enableNestedArrays = true;\n\n  // Handle noData and default\n  value = classProperty.handleNoData(value);\n  if (!defined(value) && defined(classProperty.default)) {\n    value = clone(classProperty.default, true);\n    return classProperty.unpackVectorAndMatrixTypes(value, enableNestedArrays);\n  }\n\n  if (!defined(value)) {\n    return undefined;\n  }\n\n  value = classProperty.normalize(value);\n  value = classProperty.applyValueTransform(value);\n  return classProperty.unpackVectorAndMatrixTypes(value, enableNestedArrays);\n};\n\n/**\n * Sets the value of the property with the given ID.\n * <p>\n * If the property is normalized a normalized value must be provided to this function.\n * </p>\n *\n * @param {string} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @param {object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @private\n */\nMetadataEntity.setProperty = function (\n  propertyId,\n  value,\n  properties,\n  classDefinition,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  Check.defined(\"value\", value);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  if (!defined(properties[propertyId])) {\n    return false;\n  }\n\n  if (Array.isArray(value)) {\n    value = value.slice(); // clone\n  }\n\n  let classProperty;\n  const classProperties = classDefinition.properties;\n  if (defined(classProperties)) {\n    classProperty = classProperties[propertyId];\n  }\n\n  // arrays of vectors are represented as nested arrays in JSON\n  const enableNestedArrays = true;\n  if (defined(classProperty)) {\n    value = classProperty.packVectorAndMatrixTypes(value, enableNestedArrays);\n    value = classProperty.unapplyValueTransform(value);\n    value = classProperty.unnormalize(value);\n  }\n\n  properties[propertyId] = value;\n  return true;\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @param {object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this property.\n *\n * @private\n */\nMetadataEntity.getPropertyBySemantic = function (\n  semantic,\n  properties,\n  classDefinition,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  const propertiesBySemantic = classDefinition.propertiesBySemantic;\n  if (!defined(propertiesBySemantic)) {\n    return undefined;\n  }\n\n  const property = propertiesBySemantic[semantic];\n  if (defined(property)) {\n    return MetadataEntity.getProperty(property.id, properties, classDefinition);\n  }\n  return undefined;\n};\n\n/**\n * Sets the value of the property with the given semantic.\n *\n * @param {string} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @param {object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nMetadataEntity.setPropertyBySemantic = function (\n  semantic,\n  value,\n  properties,\n  classDefinition,\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  Check.defined(\"value\", value);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  const propertiesBySemantic = classDefinition.propertiesBySemantic;\n  if (!defined(propertiesBySemantic)) {\n    return false;\n  }\n\n  const property = classDefinition.propertiesBySemantic[semantic];\n  if (defined(property)) {\n    return MetadataEntity.setProperty(\n      property.id,\n      value,\n      properties,\n      classDefinition,\n    );\n  }\n\n  return false;\n};\n\nexport default MetadataEntity;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}