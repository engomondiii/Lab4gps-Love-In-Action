{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport RectangleGeometryLibrary from \"./RectangleGeometryLibrary.js\";\nconst bottomBoundingSphere = new BoundingSphere();\nconst topBoundingSphere = new BoundingSphere();\nconst positionScratch = new Cartesian3();\nconst rectangleScratch = new Rectangle();\nfunction constructRectangle(geometry, computedOptions) {\n  const ellipsoid = geometry._ellipsoid;\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n  const northCap = computedOptions.northCap;\n  const southCap = computedOptions.southCap;\n  let rowHeight = height;\n  let widthMultiplier = 2;\n  let size = 0;\n  let corners = 4;\n  if (northCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    size += 1;\n    corners -= 2;\n  }\n  if (southCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    size += 1;\n    corners -= 2;\n  }\n  size += widthMultiplier * width + 2 * rowHeight - corners;\n  const positions = new Float64Array(size * 3);\n  let posIndex = 0;\n  let row = 0;\n  let col;\n  const position = positionScratch;\n  if (northCap) {\n    RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, row, 0, position);\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  } else {\n    for (col = 0; col < width; col++) {\n      RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, row, col, position);\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n    }\n  }\n  col = width - 1;\n  for (row = 1; row < height; row++) {\n    RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, row, col, position);\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  }\n  row = height - 1;\n  if (!southCap) {\n    // if southCap is true, we dont need to add any more points because the south pole point was added by the iteration above\n    for (col = width - 2; col >= 0; col--) {\n      RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, row, col, position);\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n    }\n  }\n  col = 0;\n  for (row = height - 2; row > 0; row--) {\n    RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, row, col, position);\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  }\n  const indicesSize = positions.length / 3 * 2;\n  const indices = IndexDatatype.createTypedArray(positions.length / 3, indicesSize);\n  let index = 0;\n  for (let i = 0; i < positions.length / 3 - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n  indices[index++] = positions.length / 3 - 1;\n  indices[index++] = 0;\n  const geo = new Geometry({\n    attributes: new GeometryAttributes(),\n    primitiveType: PrimitiveType.LINES\n  });\n  geo.attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions\n  });\n  geo.indices = indices;\n  return geo;\n}\nfunction constructExtrudedRectangle(rectangleGeometry, computedOptions) {\n  const maxHeight = rectangleGeometry._surfaceHeight;\n  const minHeight = rectangleGeometry._extrudedHeight;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n  const geo = constructRectangle(rectangleGeometry, computedOptions);\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n  const topPositions = PolygonPipeline.scaleToGeodeticHeight(geo.attributes.position.values, maxHeight, ellipsoid, false);\n  let length = topPositions.length;\n  const positions = new Float64Array(length * 2);\n  positions.set(topPositions);\n  const bottomPositions = PolygonPipeline.scaleToGeodeticHeight(geo.attributes.position.values, minHeight, ellipsoid);\n  positions.set(bottomPositions, length);\n  geo.attributes.position.values = positions;\n  const northCap = computedOptions.northCap;\n  const southCap = computedOptions.southCap;\n  let corners = 4;\n  if (northCap) {\n    corners -= 1;\n  }\n  if (southCap) {\n    corners -= 1;\n  }\n  const indicesSize = (positions.length / 3 + corners) * 2;\n  const indices = IndexDatatype.createTypedArray(positions.length / 3, indicesSize);\n  length = positions.length / 6;\n  let index = 0;\n  for (let i = 0; i < length - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n    indices[index++] = i + length;\n    indices[index++] = i + length + 1;\n  }\n  indices[index++] = length - 1;\n  indices[index++] = 0;\n  indices[index++] = length + length - 1;\n  indices[index++] = length;\n  indices[index++] = 0;\n  indices[index++] = length;\n  let bottomCorner;\n  if (northCap) {\n    bottomCorner = height - 1;\n  } else {\n    const topRightCorner = width - 1;\n    indices[index++] = topRightCorner;\n    indices[index++] = topRightCorner + length;\n    bottomCorner = width + height - 2;\n  }\n  indices[index++] = bottomCorner;\n  indices[index++] = bottomCorner + length;\n  if (!southCap) {\n    const bottomLeftCorner = width + bottomCorner - 1;\n    indices[index++] = bottomLeftCorner;\n    indices[index] = bottomLeftCorner + length;\n  }\n  geo.indices = indices;\n  return geo;\n}\n\n/**\n * A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.\n *\n * @alias RectangleOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the rectangle lies.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\n * @param {number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\n *\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>rectangle.south</code>.\n *\n * @see RectangleOutlineGeometry#createGeometry\n *\n * @example\n * const rectangle = new Cesium.RectangleOutlineGeometry({\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * const geometry = Cesium.RectangleOutlineGeometry.createGeometry(rectangle);\n */\nfunction RectangleOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const rectangle = options.rectangle;\n  const granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  const rotation = defaultValue(options.rotation, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required.\");\n  }\n  Rectangle._validate(rectangle);\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\"options.rectangle.north must be greater than options.rectangle.south\");\n  }\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n  this._rectangle = Rectangle.clone(rectangle);\n  this._granularity = granularity;\n  this._ellipsoid = ellipsoid;\n  this._surfaceHeight = Math.max(height, extrudedHeight);\n  this._rotation = rotation;\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createRectangleOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nRectangleOutlineGeometry.packedLength = Rectangle.packedLength + Ellipsoid.packedLength + 5;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {RectangleOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nRectangleOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Rectangle.pack(value._rectangle, array, startingIndex);\n  startingIndex += Rectangle.packedLength;\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._surfaceHeight;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n  return array;\n};\nconst scratchRectangle = new Rectangle();\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchOptions = {\n  rectangle: scratchRectangle,\n  ellipsoid: scratchEllipsoid,\n  granularity: undefined,\n  height: undefined,\n  rotation: undefined,\n  extrudedHeight: undefined,\n  offsetAttribute: undefined\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {RectangleOutlineGeometry} [result] The object into which to store the result.\n * @returns {RectangleOutlineGeometry} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nRectangleOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  const rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n  startingIndex += Rectangle.packedLength;\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n  const granularity = array[startingIndex++];\n  const height = array[startingIndex++];\n  const rotation = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n  if (!defined(result)) {\n    scratchOptions.granularity = granularity;\n    scratchOptions.height = height;\n    scratchOptions.rotation = rotation;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new RectangleOutlineGeometry(scratchOptions);\n  }\n  result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._surfaceHeight = height;\n  result._rotation = rotation;\n  result._extrudedHeight = extrudedHeight;\n  result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n  return result;\n};\nconst nwScratch = new Cartographic();\n/**\n * Computes the geometric representation of an outline of a rectangle, including its vertices, indices, and a bounding sphere.\n *\n * @param {RectangleOutlineGeometry} rectangleGeometry A description of the rectangle outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n *\n * @exception {DeveloperError} Rotated rectangle is invalid.\n */\nRectangleOutlineGeometry.createGeometry = function (rectangleGeometry) {\n  const rectangle = rectangleGeometry._rectangle;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n  const computedOptions = RectangleGeometryLibrary.computeOptions(rectangle, rectangleGeometry._granularity, rectangleGeometry._rotation, 0, rectangleScratch, nwScratch);\n  let geometry;\n  let boundingSphere;\n  if (CesiumMath.equalsEpsilon(rectangle.north, rectangle.south, CesiumMath.EPSILON10) || CesiumMath.equalsEpsilon(rectangle.east, rectangle.west, CesiumMath.EPSILON10)) {\n    return undefined;\n  }\n  const surfaceHeight = rectangleGeometry._surfaceHeight;\n  const extrudedHeight = rectangleGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(surfaceHeight, extrudedHeight, 0, CesiumMath.EPSILON2);\n  let offsetValue;\n  if (extrude) {\n    geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      const size = geometry.attributes.position.values.length / 3;\n      let offsetAttribute = new Uint8Array(size);\n      if (rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n        offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n      } else {\n        offsetValue = rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n        offsetAttribute = offsetAttribute.fill(offsetValue);\n      }\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: offsetAttribute\n      });\n    }\n    const topBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight, topBoundingSphere);\n    const bottomBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, extrudedHeight, bottomBoundingSphere);\n    boundingSphere = BoundingSphere.union(topBS, bottomBS);\n  } else {\n    geometry = constructRectangle(rectangleGeometry, computedOptions);\n    geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometry.attributes.position.values, surfaceHeight, ellipsoid, false);\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      const length = geometry.attributes.position.values.length;\n      offsetValue = rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset\n      });\n    }\n    boundingSphere = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight);\n  }\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: rectangleGeometry._offsetAttribute\n  });\n};\nexport default RectangleOutlineGeometry;","map":{"version":3,"names":["BoundingSphere","Cartesian3","Cartographic","ComponentDatatype","defaultValue","defined","DeveloperError","Ellipsoid","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","IndexDatatype","CesiumMath","PolygonPipeline","PrimitiveType","Rectangle","RectangleGeometryLibrary","bottomBoundingSphere","topBoundingSphere","positionScratch","rectangleScratch","constructRectangle","geometry","computedOptions","ellipsoid","_ellipsoid","height","width","northCap","southCap","rowHeight","widthMultiplier","size","corners","positions","Float64Array","posIndex","row","col","position","computePosition","x","y","z","indicesSize","length","indices","createTypedArray","index","i","geo","attributes","primitiveType","LINES","componentDatatype","DOUBLE","componentsPerAttribute","values","constructExtrudedRectangle","rectangleGeometry","maxHeight","_surfaceHeight","minHeight","_extrudedHeight","topPositions","scaleToGeodeticHeight","set","bottomPositions","bottomCorner","topRightCorner","bottomLeftCorner","RectangleOutlineGeometry","options","EMPTY_OBJECT","rectangle","granularity","RADIANS_PER_DEGREE","default","rotation","_validate","north","south","extrudedHeight","_rectangle","clone","_granularity","Math","max","_rotation","min","_offsetAttribute","offsetAttribute","_workerName","packedLength","pack","value","array","startingIndex","scratchRectangle","scratchEllipsoid","UNIT_SPHERE","scratchOptions","undefined","unpack","result","nwScratch","createGeometry","computeOptions","boundingSphere","equalsEpsilon","EPSILON10","east","west","surfaceHeight","extrude","EPSILON2","offsetValue","Uint8Array","TOP","fill","NONE","applyOffset","UNSIGNED_BYTE","topBS","fromRectangle3D","bottomBS","union"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/RectangleOutlineGeometry.js"],"sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport RectangleGeometryLibrary from \"./RectangleGeometryLibrary.js\";\n\nconst bottomBoundingSphere = new BoundingSphere();\nconst topBoundingSphere = new BoundingSphere();\nconst positionScratch = new Cartesian3();\nconst rectangleScratch = new Rectangle();\n\nfunction constructRectangle(geometry, computedOptions) {\n  const ellipsoid = geometry._ellipsoid;\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n  const northCap = computedOptions.northCap;\n  const southCap = computedOptions.southCap;\n\n  let rowHeight = height;\n  let widthMultiplier = 2;\n  let size = 0;\n  let corners = 4;\n  if (northCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    size += 1;\n    corners -= 2;\n  }\n  if (southCap) {\n    widthMultiplier -= 1;\n    rowHeight -= 1;\n    size += 1;\n    corners -= 2;\n  }\n  size += widthMultiplier * width + 2 * rowHeight - corners;\n\n  const positions = new Float64Array(size * 3);\n\n  let posIndex = 0;\n  let row = 0;\n  let col;\n  const position = positionScratch;\n  if (northCap) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      false,\n      row,\n      0,\n      position,\n    );\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  } else {\n    for (col = 0; col < width; col++) {\n      RectangleGeometryLibrary.computePosition(\n        computedOptions,\n        ellipsoid,\n        false,\n        row,\n        col,\n        position,\n      );\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n    }\n  }\n\n  col = width - 1;\n  for (row = 1; row < height; row++) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      false,\n      row,\n      col,\n      position,\n    );\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  }\n\n  row = height - 1;\n  if (!southCap) {\n    // if southCap is true, we dont need to add any more points because the south pole point was added by the iteration above\n    for (col = width - 2; col >= 0; col--) {\n      RectangleGeometryLibrary.computePosition(\n        computedOptions,\n        ellipsoid,\n        false,\n        row,\n        col,\n        position,\n      );\n      positions[posIndex++] = position.x;\n      positions[posIndex++] = position.y;\n      positions[posIndex++] = position.z;\n    }\n  }\n\n  col = 0;\n  for (row = height - 2; row > 0; row--) {\n    RectangleGeometryLibrary.computePosition(\n      computedOptions,\n      ellipsoid,\n      false,\n      row,\n      col,\n      position,\n    );\n    positions[posIndex++] = position.x;\n    positions[posIndex++] = position.y;\n    positions[posIndex++] = position.z;\n  }\n\n  const indicesSize = (positions.length / 3) * 2;\n  const indices = IndexDatatype.createTypedArray(\n    positions.length / 3,\n    indicesSize,\n  );\n\n  let index = 0;\n  for (let i = 0; i < positions.length / 3 - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n  indices[index++] = positions.length / 3 - 1;\n  indices[index++] = 0;\n\n  const geo = new Geometry({\n    attributes: new GeometryAttributes(),\n    primitiveType: PrimitiveType.LINES,\n  });\n\n  geo.attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n  geo.indices = indices;\n\n  return geo;\n}\n\nfunction constructExtrudedRectangle(rectangleGeometry, computedOptions) {\n  const maxHeight = rectangleGeometry._surfaceHeight;\n  const minHeight = rectangleGeometry._extrudedHeight;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n  const geo = constructRectangle(rectangleGeometry, computedOptions);\n\n  const height = computedOptions.height;\n  const width = computedOptions.width;\n\n  const topPositions = PolygonPipeline.scaleToGeodeticHeight(\n    geo.attributes.position.values,\n    maxHeight,\n    ellipsoid,\n    false,\n  );\n  let length = topPositions.length;\n  const positions = new Float64Array(length * 2);\n  positions.set(topPositions);\n  const bottomPositions = PolygonPipeline.scaleToGeodeticHeight(\n    geo.attributes.position.values,\n    minHeight,\n    ellipsoid,\n  );\n  positions.set(bottomPositions, length);\n  geo.attributes.position.values = positions;\n\n  const northCap = computedOptions.northCap;\n  const southCap = computedOptions.southCap;\n  let corners = 4;\n  if (northCap) {\n    corners -= 1;\n  }\n  if (southCap) {\n    corners -= 1;\n  }\n\n  const indicesSize = (positions.length / 3 + corners) * 2;\n  const indices = IndexDatatype.createTypedArray(\n    positions.length / 3,\n    indicesSize,\n  );\n  length = positions.length / 6;\n  let index = 0;\n  for (let i = 0; i < length - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n    indices[index++] = i + length;\n    indices[index++] = i + length + 1;\n  }\n  indices[index++] = length - 1;\n  indices[index++] = 0;\n  indices[index++] = length + length - 1;\n  indices[index++] = length;\n\n  indices[index++] = 0;\n  indices[index++] = length;\n\n  let bottomCorner;\n  if (northCap) {\n    bottomCorner = height - 1;\n  } else {\n    const topRightCorner = width - 1;\n    indices[index++] = topRightCorner;\n    indices[index++] = topRightCorner + length;\n    bottomCorner = width + height - 2;\n  }\n\n  indices[index++] = bottomCorner;\n  indices[index++] = bottomCorner + length;\n\n  if (!southCap) {\n    const bottomLeftCorner = width + bottomCorner - 1;\n    indices[index++] = bottomLeftCorner;\n    indices[index] = bottomLeftCorner + length;\n  }\n\n  geo.indices = indices;\n\n  return geo;\n}\n\n/**\n * A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.\n *\n * @alias RectangleOutlineGeometry\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.default] The ellipsoid on which the rectangle lies.\n * @param {number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.\n * @param {number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n * @param {number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.\n *\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>rectangle.south</code>.\n *\n * @see RectangleOutlineGeometry#createGeometry\n *\n * @example\n * const rectangle = new Cesium.RectangleOutlineGeometry({\n *   ellipsoid : Cesium.Ellipsoid.WGS84,\n *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n *   height : 10000.0\n * });\n * const geometry = Cesium.RectangleOutlineGeometry.createGeometry(rectangle);\n */\nfunction RectangleOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const rectangle = options.rectangle;\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE,\n  );\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.default);\n  const rotation = defaultValue(options.rotation, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required.\");\n  }\n  Rectangle._validate(rectangle);\n  if (rectangle.north < rectangle.south) {\n    throw new DeveloperError(\n      \"options.rectangle.north must be greater than options.rectangle.south\",\n    );\n  }\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._rectangle = Rectangle.clone(rectangle);\n  this._granularity = granularity;\n  this._ellipsoid = ellipsoid;\n  this._surfaceHeight = Math.max(height, extrudedHeight);\n  this._rotation = rotation;\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createRectangleOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {number}\n */\nRectangleOutlineGeometry.packedLength =\n  Rectangle.packedLength + Ellipsoid.packedLength + 5;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {RectangleOutlineGeometry} value The value to pack.\n * @param {number[]} array The array to pack into.\n * @param {number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {number[]} The array that was packed into\n */\nRectangleOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Rectangle.pack(value._rectangle, array, startingIndex);\n  startingIndex += Rectangle.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._surfaceHeight;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchRectangle = new Rectangle();\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchOptions = {\n  rectangle: scratchRectangle,\n  ellipsoid: scratchEllipsoid,\n  granularity: undefined,\n  height: undefined,\n  rotation: undefined,\n  extrudedHeight: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {number[]} array The packed array.\n * @param {number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {RectangleOutlineGeometry} [result] The object into which to store the result.\n * @returns {RectangleOutlineGeometry} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nRectangleOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n  startingIndex += Rectangle.packedLength;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const granularity = array[startingIndex++];\n  const height = array[startingIndex++];\n  const rotation = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.granularity = granularity;\n    scratchOptions.height = height;\n    scratchOptions.rotation = rotation;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new RectangleOutlineGeometry(scratchOptions);\n  }\n\n  result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._surfaceHeight = height;\n  result._rotation = rotation;\n  result._extrudedHeight = extrudedHeight;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\nconst nwScratch = new Cartographic();\n/**\n * Computes the geometric representation of an outline of a rectangle, including its vertices, indices, and a bounding sphere.\n *\n * @param {RectangleOutlineGeometry} rectangleGeometry A description of the rectangle outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n *\n * @exception {DeveloperError} Rotated rectangle is invalid.\n */\nRectangleOutlineGeometry.createGeometry = function (rectangleGeometry) {\n  const rectangle = rectangleGeometry._rectangle;\n  const ellipsoid = rectangleGeometry._ellipsoid;\n  const computedOptions = RectangleGeometryLibrary.computeOptions(\n    rectangle,\n    rectangleGeometry._granularity,\n    rectangleGeometry._rotation,\n    0,\n    rectangleScratch,\n    nwScratch,\n  );\n\n  let geometry;\n  let boundingSphere;\n\n  if (\n    CesiumMath.equalsEpsilon(\n      rectangle.north,\n      rectangle.south,\n      CesiumMath.EPSILON10,\n    ) ||\n    CesiumMath.equalsEpsilon(\n      rectangle.east,\n      rectangle.west,\n      CesiumMath.EPSILON10,\n    )\n  ) {\n    return undefined;\n  }\n\n  const surfaceHeight = rectangleGeometry._surfaceHeight;\n  const extrudedHeight = rectangleGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    surfaceHeight,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2,\n  );\n  let offsetValue;\n  if (extrude) {\n    geometry = constructExtrudedRectangle(rectangleGeometry, computedOptions);\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      const size = geometry.attributes.position.values.length / 3;\n      let offsetAttribute = new Uint8Array(size);\n      if (rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n        offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\n      } else {\n        offsetValue =\n          rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n            ? 0\n            : 1;\n        offsetAttribute = offsetAttribute.fill(offsetValue);\n      }\n\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: offsetAttribute,\n      });\n    }\n    const topBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight,\n      topBoundingSphere,\n    );\n    const bottomBS = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      extrudedHeight,\n      bottomBoundingSphere,\n    );\n    boundingSphere = BoundingSphere.union(topBS, bottomBS);\n  } else {\n    geometry = constructRectangle(rectangleGeometry, computedOptions);\n    geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      geometry.attributes.position.values,\n      surfaceHeight,\n      ellipsoid,\n      false,\n    );\n\n    if (defined(rectangleGeometry._offsetAttribute)) {\n      const length = geometry.attributes.position.values.length;\n      offsetValue =\n        rectangleGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n\n    boundingSphere = BoundingSphere.fromRectangle3D(\n      rectangle,\n      ellipsoid,\n      surfaceHeight,\n    );\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: rectangleGeometry._offsetAttribute,\n  });\n};\nexport default RectangleOutlineGeometry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}