{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defined from \"../Core/defined.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Plane from \"../Core/Plane.js\";\nimport CoplanarPolygonOutlineGeometry from \"../Core/CoplanarPolygonOutlineGeometry.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport S2Cell from \"../Core/S2Cell.js\";\nlet centerCartographicScratch = new Cartographic();\n/**\n * A tile bounding volume specified as an S2 cell token with minimum and maximum heights.\n * The bounding volume is a k DOP. A k-DOP is the Boolean intersection of extents along k directions.\n *\n * @alias TileBoundingS2Cell\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {string} options.token The token of the S2 cell.\n * @param {number} [options.minimumHeight=0.0] The minimum height of the bounding volume.\n * @param {number} [options.maximumHeight=0.0] The maximum height of the bounding volume.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n * @param {boolean} [options.computeBoundingVolumes=true] True to compute the {@link TileBoundingS2Cell#boundingVolume} and\n *                  {@link TileBoundingS2Cell#boundingSphere}. If false, these properties will be undefined.\n *\n * @private\n */\nfunction TileBoundingS2Cell(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.string(\"options.token\", options.token);\n  //>>includeEnd('debug');\n\n  const s2Cell = S2Cell.fromToken(options.token);\n  const minimumHeight = defaultValue(options.minimumHeight, 0.0);\n  const maximumHeight = defaultValue(options.maximumHeight, 0.0);\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this.s2Cell = s2Cell;\n  this.minimumHeight = minimumHeight;\n  this.maximumHeight = maximumHeight;\n  this.ellipsoid = ellipsoid;\n  const boundingPlanes = computeBoundingPlanes(s2Cell, minimumHeight, maximumHeight, ellipsoid);\n  this._boundingPlanes = boundingPlanes;\n\n  // Pre-compute vertices to speed up the plane intersection test.\n  const vertices = computeVertices(boundingPlanes);\n  this._vertices = vertices;\n\n  // Pre-compute edge normals to speed up the point-polygon distance check in distanceToCamera.\n  this._edgeNormals = new Array(6);\n  this._edgeNormals[0] = computeEdgeNormals(boundingPlanes[0], vertices.slice(0, 4));\n  let i;\n  // Based on the way the edge normals are computed, the edge normals all point away from the \"face\"\n  // of the polyhedron they surround, except the plane for the top plane. Therefore, we negate the normals\n  // for the top plane.\n  for (i = 0; i < 4; i++) {\n    this._edgeNormals[0][i] = Cartesian3.negate(this._edgeNormals[0][i], this._edgeNormals[0][i]);\n  }\n  this._edgeNormals[1] = computeEdgeNormals(boundingPlanes[1], vertices.slice(4, 8));\n  for (i = 0; i < 4; i++) {\n    // For each plane, iterate through the vertices in CCW order.\n    this._edgeNormals[2 + i] = computeEdgeNormals(boundingPlanes[2 + i], [vertices[i % 4], vertices[(i + 1) % 4], vertices[4 + (i + 1) % 4], vertices[4 + i]]);\n  }\n  this._planeVertices = [this._vertices.slice(0, 4), this._vertices.slice(4, 8)];\n  for (i = 0; i < 4; i++) {\n    this._planeVertices.push([this._vertices[i % 4], this._vertices[(i + 1) % 4], this._vertices[4 + (i + 1) % 4], this._vertices[4 + i]]);\n  }\n  const center = s2Cell.getCenter();\n  centerCartographicScratch = ellipsoid.cartesianToCartographic(center, centerCartographicScratch);\n  centerCartographicScratch.height = (maximumHeight + minimumHeight) / 2;\n  this.center = ellipsoid.cartographicToCartesian(centerCartographicScratch, center);\n  this._boundingSphere = BoundingSphere.fromPoints(vertices);\n}\nconst centerGeodeticNormalScratch = new Cartesian3();\nconst topCartographicScratch = new Cartographic();\nconst topScratch = new Cartesian3();\nconst vertexCartographicScratch = new Cartographic();\nconst vertexScratch = new Cartesian3();\nconst vertexGeodeticNormalScratch = new Cartesian3();\nconst sideNormalScratch = new Cartesian3();\nconst sideScratch = new Cartesian3();\n/**\n * Computes bounding planes of the kDOP.\n * @private\n */\nfunction computeBoundingPlanes(s2Cell, minimumHeight, maximumHeight, ellipsoid) {\n  const planes = new Array(6);\n  const centerPoint = s2Cell.getCenter();\n\n  // Compute top plane.\n  // - Get geodetic surface normal at the center of the S2 cell.\n  // - Get center point at maximum height of bounding volume.\n  // - Create top plane from surface normal and top point.\n  const centerSurfaceNormal = ellipsoid.geodeticSurfaceNormal(centerPoint, centerGeodeticNormalScratch);\n  const topCartographic = ellipsoid.cartesianToCartographic(centerPoint, topCartographicScratch);\n  topCartographic.height = maximumHeight;\n  const top = ellipsoid.cartographicToCartesian(topCartographic, topScratch);\n  const topPlane = Plane.fromPointNormal(top, centerSurfaceNormal);\n  planes[0] = topPlane;\n\n  // Compute bottom plane.\n  // - Iterate through bottom vertices\n  //   - Get distance from vertex to top plane\n  // - Find longest distance from vertex to top plane\n  // - Translate top plane by the distance\n  let maxDistance = 0;\n  let i;\n  const vertices = [];\n  let vertex, vertexCartographic;\n  for (i = 0; i < 4; i++) {\n    vertex = s2Cell.getVertex(i);\n    vertices[i] = vertex;\n    vertexCartographic = ellipsoid.cartesianToCartographic(vertex, vertexCartographicScratch);\n    vertexCartographic.height = minimumHeight;\n    const distance = Plane.getPointDistance(topPlane, ellipsoid.cartographicToCartesian(vertexCartographic, vertexScratch));\n    if (distance < maxDistance) {\n      maxDistance = distance;\n    }\n  }\n  const bottomPlane = Plane.clone(topPlane);\n  // Negate the normal of the bottom plane since we want all normals to point \"outwards\".\n  bottomPlane.normal = Cartesian3.negate(bottomPlane.normal, bottomPlane.normal);\n  bottomPlane.distance = bottomPlane.distance * -1 + maxDistance;\n  planes[1] = bottomPlane;\n\n  // Compute side planes.\n  // - Iterate through vertices (in CCW order, by default)\n  //   - Get a vertex and another vertex adjacent to it.\n  //   - Compute geodetic surface normal at one vertex.\n  //   - Compute vector between vertices.\n  //   - Compute normal of side plane. (cross product of top dir and side dir)\n  for (i = 0; i < 4; i++) {\n    vertex = vertices[i];\n    const adjacentVertex = vertices[(i + 1) % 4];\n    const geodeticNormal = ellipsoid.geodeticSurfaceNormal(vertex, vertexGeodeticNormalScratch);\n    const side = Cartesian3.subtract(adjacentVertex, vertex, sideScratch);\n    let sideNormal = Cartesian3.cross(side, geodeticNormal, sideNormalScratch);\n    sideNormal = Cartesian3.normalize(sideNormal, sideNormal);\n    planes[2 + i] = Plane.fromPointNormal(vertex, sideNormal);\n  }\n  return planes;\n}\nlet n0Scratch = new Cartesian3();\nlet n1Scratch = new Cartesian3();\nlet n2Scratch = new Cartesian3();\nlet x0Scratch = new Cartesian3();\nlet x1Scratch = new Cartesian3();\nlet x2Scratch = new Cartesian3();\nconst t0Scratch = new Cartesian3();\nconst t1Scratch = new Cartesian3();\nconst t2Scratch = new Cartesian3();\nlet f0Scratch = new Cartesian3();\nlet f1Scratch = new Cartesian3();\nlet f2Scratch = new Cartesian3();\nlet sScratch = new Cartesian3();\nconst matrixScratch = new Matrix3();\n/**\n * Computes intersection of 3 planes.\n * @private\n */\nfunction computeIntersection(p0, p1, p2) {\n  n0Scratch = p0.normal;\n  n1Scratch = p1.normal;\n  n2Scratch = p2.normal;\n  x0Scratch = Cartesian3.multiplyByScalar(p0.normal, -p0.distance, x0Scratch);\n  x1Scratch = Cartesian3.multiplyByScalar(p1.normal, -p1.distance, x1Scratch);\n  x2Scratch = Cartesian3.multiplyByScalar(p2.normal, -p2.distance, x2Scratch);\n  f0Scratch = Cartesian3.multiplyByScalar(Cartesian3.cross(n1Scratch, n2Scratch, t0Scratch), Cartesian3.dot(x0Scratch, n0Scratch), f0Scratch);\n  f1Scratch = Cartesian3.multiplyByScalar(Cartesian3.cross(n2Scratch, n0Scratch, t1Scratch), Cartesian3.dot(x1Scratch, n1Scratch), f1Scratch);\n  f2Scratch = Cartesian3.multiplyByScalar(Cartesian3.cross(n0Scratch, n1Scratch, t2Scratch), Cartesian3.dot(x2Scratch, n2Scratch), f2Scratch);\n  matrixScratch[0] = n0Scratch.x;\n  matrixScratch[1] = n1Scratch.x;\n  matrixScratch[2] = n2Scratch.x;\n  matrixScratch[3] = n0Scratch.y;\n  matrixScratch[4] = n1Scratch.y;\n  matrixScratch[5] = n2Scratch.y;\n  matrixScratch[6] = n0Scratch.z;\n  matrixScratch[7] = n1Scratch.z;\n  matrixScratch[8] = n2Scratch.z;\n  const determinant = Matrix3.determinant(matrixScratch);\n  sScratch = Cartesian3.add(f0Scratch, f1Scratch, sScratch);\n  sScratch = Cartesian3.add(sScratch, f2Scratch, sScratch);\n  return new Cartesian3(sScratch.x / determinant, sScratch.y / determinant, sScratch.z / determinant);\n}\n/**\n * Compute the vertices of the kDOP.\n * @private\n */\nfunction computeVertices(boundingPlanes) {\n  const vertices = new Array(8);\n  for (let i = 0; i < 4; i++) {\n    // Vertices on the top plane.\n    vertices[i] = computeIntersection(boundingPlanes[0], boundingPlanes[2 + (i + 3) % 4], boundingPlanes[2 + i % 4]);\n    // Vertices on the bottom plane.\n    vertices[i + 4] = computeIntersection(boundingPlanes[1], boundingPlanes[2 + (i + 3) % 4], boundingPlanes[2 + i % 4]);\n  }\n  return vertices;\n}\nlet edgeScratch = new Cartesian3();\nlet edgeNormalScratch = new Cartesian3();\n/**\n * Compute edge normals on a plane.\n * @private\n */\nfunction computeEdgeNormals(plane, vertices) {\n  const edgeNormals = [];\n  for (let i = 0; i < 4; i++) {\n    edgeScratch = Cartesian3.subtract(vertices[(i + 1) % 4], vertices[i], edgeScratch);\n    edgeNormalScratch = Cartesian3.cross(plane.normal, edgeScratch, edgeNormalScratch);\n    edgeNormalScratch = Cartesian3.normalize(edgeNormalScratch, edgeNormalScratch);\n    edgeNormals[i] = Cartesian3.clone(edgeNormalScratch);\n  }\n  return edgeNormals;\n}\nObject.defineProperties(TileBoundingS2Cell.prototype, {\n  /**\n   * The underlying bounding volume.\n   *\n   * @memberof TileBoundingS2Cell.prototype\n   *\n   * @type {object}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function () {\n      return this;\n    }\n  },\n  /**\n   * The underlying bounding sphere.\n   *\n   * @memberof TileBoundingS2Cell.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    }\n  }\n});\nconst facePointScratch = new Cartesian3();\n/**\n * The distance to point check for this kDOP involves checking the signed distance of the point to each bounding\n * plane. A plane qualifies for a distance check if the point being tested against is in the half-space in the direction\n * of the normal i.e. if the signed distance of the point from the plane is greater than 0.\n *\n * There are 4 possible cases for a point if it is outside the polyhedron:\n *\n *   \\     X     /     X \\           /       \\           /       \\           /\n * ---\\---------/---   ---\\---------/---   ---X---------/---   ---\\---------/---\n *     \\       /           \\       /           \\       /           \\       /\n *   ---\\-----/---       ---\\-----/---       ---\\-----/---       ---\\-----/---\n *       \\   /               \\   /               \\   /               \\   /\n *                                                                    \\ /\n *                                                                     \\\n *                                                                    / \\\n *                                                                   / X \\\n *\n *         I                  II                  III                 IV\n *\n * Case I: There is only one plane selected.\n * In this case, we project the point onto the plane and do a point polygon distance check to find the closest point on the polygon.\n * The point may lie inside the \"face\" of the polygon or outside. If it is outside, we need to determine which edges to test against.\n *\n * Case II: There are two planes selected.\n * In this case, the point will lie somewhere on the line created at the intersection of the selected planes or one of the planes.\n *\n * Case III: There are three planes selected.\n * In this case, the point will lie on the vertex, at the intersection of the selected planes.\n *\n * Case IV: There are more than three planes selected.\n * Since we are on an ellipsoid, this will only happen in the bottom plane, which is what we will use for the distance test.\n */\nTileBoundingS2Cell.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  const point = frameState.camera.positionWC;\n  const selectedPlaneIndices = [];\n  const vertices = [];\n  let edgeNormals;\n  if (Plane.getPointDistance(this._boundingPlanes[0], point) > 0) {\n    selectedPlaneIndices.push(0);\n    vertices.push(this._planeVertices[0]);\n    edgeNormals = this._edgeNormals[0];\n  } else if (Plane.getPointDistance(this._boundingPlanes[1], point) > 0) {\n    selectedPlaneIndices.push(1);\n    vertices.push(this._planeVertices[1]);\n    edgeNormals = this._edgeNormals[1];\n  }\n  let i;\n  let sidePlaneIndex;\n  for (i = 0; i < 4; i++) {\n    sidePlaneIndex = 2 + i;\n    if (Plane.getPointDistance(this._boundingPlanes[sidePlaneIndex], point) > 0) {\n      selectedPlaneIndices.push(sidePlaneIndex);\n      // Store vertices in CCW order.\n      vertices.push(this._planeVertices[sidePlaneIndex]);\n      edgeNormals = this._edgeNormals[sidePlaneIndex];\n    }\n  }\n\n  // Check if inside all planes.\n  if (selectedPlaneIndices.length === 0) {\n    return 0.0;\n  }\n\n  // We use the skip variable when the side plane indices are non-consecutive.\n  let facePoint;\n  let selectedPlane;\n  if (selectedPlaneIndices.length === 1) {\n    // Handles Case I\n    selectedPlane = this._boundingPlanes[selectedPlaneIndices[0]];\n    facePoint = closestPointPolygon(Plane.projectPointOntoPlane(selectedPlane, point, facePointScratch), vertices[0], selectedPlane, edgeNormals);\n    return Cartesian3.distance(facePoint, point);\n  } else if (selectedPlaneIndices.length === 2) {\n    // Handles Case II\n    // Since we are on the ellipsoid, the dihedral angle between a top plane and a side plane\n    // will always be acute, so we can do a faster check there.\n    if (selectedPlaneIndices[0] === 0) {\n      const edge = [this._vertices[4 * selectedPlaneIndices[0] + (selectedPlaneIndices[1] - 2)], this._vertices[4 * selectedPlaneIndices[0] + (selectedPlaneIndices[1] - 2 + 1) % 4]];\n      facePoint = closestPointLineSegment(point, edge[0], edge[1]);\n      return Cartesian3.distance(facePoint, point);\n    }\n    let minimumDistance = Number.MAX_VALUE;\n    let distance;\n    for (i = 0; i < 2; i++) {\n      selectedPlane = this._boundingPlanes[selectedPlaneIndices[i]];\n      facePoint = closestPointPolygon(Plane.projectPointOntoPlane(selectedPlane, point, facePointScratch), vertices[i], selectedPlane, this._edgeNormals[selectedPlaneIndices[i]]);\n      distance = Cartesian3.distanceSquared(facePoint, point);\n      if (distance < minimumDistance) {\n        minimumDistance = distance;\n      }\n    }\n    return Math.sqrt(minimumDistance);\n  } else if (selectedPlaneIndices.length > 3) {\n    // Handles Case IV\n    facePoint = closestPointPolygon(Plane.projectPointOntoPlane(this._boundingPlanes[1], point, facePointScratch), this._planeVertices[1], this._boundingPlanes[1], this._edgeNormals[1]);\n    return Cartesian3.distance(facePoint, point);\n  }\n\n  // Handles Case III\n  const skip = selectedPlaneIndices[1] === 2 && selectedPlaneIndices[2] === 5 ? 0 : 1;\n\n  // Vertex is on top plane.\n  if (selectedPlaneIndices[0] === 0) {\n    return Cartesian3.distance(point, this._vertices[(selectedPlaneIndices[1] - 2 + skip) % 4]);\n  }\n\n  // Vertex is on bottom plane.\n  return Cartesian3.distance(point, this._vertices[4 + (selectedPlaneIndices[1] - 2 + skip) % 4]);\n};\nconst dScratch = new Cartesian3();\nconst pL0Scratch = new Cartesian3();\n/**\n * Finds point on a line segment closest to a given point.\n * @private\n */\nfunction closestPointLineSegment(p, l0, l1) {\n  const d = Cartesian3.subtract(l1, l0, dScratch);\n  const pL0 = Cartesian3.subtract(p, l0, pL0Scratch);\n  let t = Cartesian3.dot(d, pL0);\n  if (t <= 0) {\n    return l0;\n  }\n  const dMag = Cartesian3.dot(d, d);\n  if (t >= dMag) {\n    return l1;\n  }\n  t = t / dMag;\n  return new Cartesian3((1 - t) * l0.x + t * l1.x, (1 - t) * l0.y + t * l1.y, (1 - t) * l0.z + t * l1.z);\n}\nconst edgePlaneScratch = new Plane(Cartesian3.UNIT_X, 0.0);\n/**\n * Finds closes point on the polygon, created by the given vertices, from\n * a point. The test point and the polygon are all on the same plane.\n * @private\n */\nfunction closestPointPolygon(p, vertices, plane, edgeNormals) {\n  let minDistance = Number.MAX_VALUE;\n  let distance;\n  let closestPoint;\n  let closestPointOnEdge;\n  for (let i = 0; i < vertices.length; i++) {\n    const edgePlane = Plane.fromPointNormal(vertices[i], edgeNormals[i], edgePlaneScratch);\n    const edgePlaneDistance = Plane.getPointDistance(edgePlane, p);\n\n    // Skip checking against the edge if the point is not in the half-space that the\n    // edgePlane's normal points towards i.e. if the edgePlane is facing away from the point.\n    if (edgePlaneDistance < 0) {\n      continue;\n    }\n    closestPointOnEdge = closestPointLineSegment(p, vertices[i], vertices[(i + 1) % 4]);\n    distance = Cartesian3.distance(p, closestPointOnEdge);\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestPoint = closestPointOnEdge;\n    }\n  }\n  if (!defined(closestPoint)) {\n    return p;\n  }\n  return closestPoint;\n}\n\n/**\n * Determines which side of a plane this volume is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire volume is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire volume is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the volume\n *                      intersects the plane.\n */\nTileBoundingS2Cell.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  let plusCount = 0;\n  let negCount = 0;\n  for (let i = 0; i < this._vertices.length; i++) {\n    const distanceToPlane = Cartesian3.dot(plane.normal, this._vertices[i]) + plane.distance;\n    if (distanceToPlane < 0) {\n      negCount++;\n    } else {\n      plusCount++;\n    }\n  }\n  if (plusCount === this._vertices.length) {\n    return Intersect.INSIDE;\n  } else if (negCount === this._vertices.length) {\n    return Intersect.OUTSIDE;\n  }\n  return Intersect.INTERSECTING;\n};\n\n/**\n * Creates a debug primitive that shows the outline of the tile bounding\n * volume.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n */\nTileBoundingS2Cell.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color);\n  //>>includeEnd('debug');\n\n  const modelMatrix = new Matrix4.clone(Matrix4.IDENTITY);\n  const topPlanePolygon = new CoplanarPolygonOutlineGeometry({\n    polygonHierarchy: {\n      positions: this._planeVertices[0]\n    }\n  });\n  const topPlaneGeometry = CoplanarPolygonOutlineGeometry.createGeometry(topPlanePolygon);\n  const topPlaneInstance = new GeometryInstance({\n    geometry: topPlaneGeometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color)\n    }\n  });\n  const bottomPlanePolygon = new CoplanarPolygonOutlineGeometry({\n    polygonHierarchy: {\n      positions: this._planeVertices[1]\n    }\n  });\n  const bottomPlaneGeometry = CoplanarPolygonOutlineGeometry.createGeometry(bottomPlanePolygon);\n  const bottomPlaneInstance = new GeometryInstance({\n    geometry: bottomPlaneGeometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color)\n    }\n  });\n  const sideInstances = [];\n  for (let i = 0; i < 4; i++) {\n    const sidePlanePolygon = new CoplanarPolygonOutlineGeometry({\n      polygonHierarchy: {\n        positions: this._planeVertices[2 + i]\n      }\n    });\n    const sidePlaneGeometry = CoplanarPolygonOutlineGeometry.createGeometry(sidePlanePolygon);\n    sideInstances[i] = new GeometryInstance({\n      geometry: sidePlaneGeometry,\n      id: \"outline\",\n      modelMatrix: modelMatrix,\n      attributes: {\n        color: ColorGeometryInstanceAttribute.fromColor(color)\n      }\n    });\n  }\n  return new Primitive({\n    geometryInstances: [sideInstances[0], sideInstances[1], sideInstances[2], sideInstances[3], bottomPlaneInstance, topPlaneInstance],\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true\n    }),\n    asynchronous: false\n  });\n};\nexport default TileBoundingS2Cell;","map":{"version":3,"names":["Cartesian3","defined","Cartographic","Ellipsoid","Intersect","Matrix3","Plane","CoplanarPolygonOutlineGeometry","BoundingSphere","Check","ColorGeometryInstanceAttribute","defaultValue","GeometryInstance","Matrix4","PerInstanceColorAppearance","Primitive","S2Cell","centerCartographicScratch","TileBoundingS2Cell","options","typeOf","object","string","token","s2Cell","fromToken","minimumHeight","maximumHeight","ellipsoid","WGS84","boundingPlanes","computeBoundingPlanes","_boundingPlanes","vertices","computeVertices","_vertices","_edgeNormals","Array","computeEdgeNormals","slice","i","negate","_planeVertices","push","center","getCenter","cartesianToCartographic","height","cartographicToCartesian","_boundingSphere","fromPoints","centerGeodeticNormalScratch","topCartographicScratch","topScratch","vertexCartographicScratch","vertexScratch","vertexGeodeticNormalScratch","sideNormalScratch","sideScratch","planes","centerPoint","centerSurfaceNormal","geodeticSurfaceNormal","topCartographic","top","topPlane","fromPointNormal","maxDistance","vertex","vertexCartographic","getVertex","distance","getPointDistance","bottomPlane","clone","normal","adjacentVertex","geodeticNormal","side","subtract","sideNormal","cross","normalize","n0Scratch","n1Scratch","n2Scratch","x0Scratch","x1Scratch","x2Scratch","t0Scratch","t1Scratch","t2Scratch","f0Scratch","f1Scratch","f2Scratch","sScratch","matrixScratch","computeIntersection","p0","p1","p2","multiplyByScalar","dot","x","y","z","determinant","add","edgeScratch","edgeNormalScratch","plane","edgeNormals","Object","defineProperties","prototype","boundingVolume","get","boundingSphere","facePointScratch","distanceToCamera","frameState","point","camera","positionWC","selectedPlaneIndices","sidePlaneIndex","length","facePoint","selectedPlane","closestPointPolygon","projectPointOntoPlane","edge","closestPointLineSegment","minimumDistance","Number","MAX_VALUE","distanceSquared","Math","sqrt","skip","dScratch","pL0Scratch","p","l0","l1","d","pL0","t","dMag","edgePlaneScratch","UNIT_X","minDistance","closestPoint","closestPointOnEdge","edgePlane","edgePlaneDistance","intersectPlane","plusCount","negCount","distanceToPlane","INSIDE","OUTSIDE","INTERSECTING","createDebugVolume","color","modelMatrix","IDENTITY","topPlanePolygon","polygonHierarchy","positions","topPlaneGeometry","createGeometry","topPlaneInstance","geometry","id","attributes","fromColor","bottomPlanePolygon","bottomPlaneGeometry","bottomPlaneInstance","sideInstances","sidePlanePolygon","sidePlaneGeometry","geometryInstances","appearance","translucent","flat","asynchronous"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Scene/TileBoundingS2Cell.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defined from \"../Core/defined.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Plane from \"../Core/Plane.js\";\nimport CoplanarPolygonOutlineGeometry from \"../Core/CoplanarPolygonOutlineGeometry.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport S2Cell from \"../Core/S2Cell.js\";\nlet centerCartographicScratch = new Cartographic();\n/**\n * A tile bounding volume specified as an S2 cell token with minimum and maximum heights.\n * The bounding volume is a k DOP. A k-DOP is the Boolean intersection of extents along k directions.\n *\n * @alias TileBoundingS2Cell\n * @constructor\n *\n * @param {object} options Object with the following properties:\n * @param {string} options.token The token of the S2 cell.\n * @param {number} [options.minimumHeight=0.0] The minimum height of the bounding volume.\n * @param {number} [options.maximumHeight=0.0] The maximum height of the bounding volume.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n * @param {boolean} [options.computeBoundingVolumes=true] True to compute the {@link TileBoundingS2Cell#boundingVolume} and\n *                  {@link TileBoundingS2Cell#boundingSphere}. If false, these properties will be undefined.\n *\n * @private\n */\nfunction TileBoundingS2Cell(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.string(\"options.token\", options.token);\n  //>>includeEnd('debug');\n\n  const s2Cell = S2Cell.fromToken(options.token);\n  const minimumHeight = defaultValue(options.minimumHeight, 0.0);\n  const maximumHeight = defaultValue(options.maximumHeight, 0.0);\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n  this.s2Cell = s2Cell;\n  this.minimumHeight = minimumHeight;\n  this.maximumHeight = maximumHeight;\n  this.ellipsoid = ellipsoid;\n\n  const boundingPlanes = computeBoundingPlanes(\n    s2Cell,\n    minimumHeight,\n    maximumHeight,\n    ellipsoid,\n  );\n  this._boundingPlanes = boundingPlanes;\n\n  // Pre-compute vertices to speed up the plane intersection test.\n  const vertices = computeVertices(boundingPlanes);\n  this._vertices = vertices;\n\n  // Pre-compute edge normals to speed up the point-polygon distance check in distanceToCamera.\n  this._edgeNormals = new Array(6);\n\n  this._edgeNormals[0] = computeEdgeNormals(\n    boundingPlanes[0],\n    vertices.slice(0, 4),\n  );\n  let i;\n  // Based on the way the edge normals are computed, the edge normals all point away from the \"face\"\n  // of the polyhedron they surround, except the plane for the top plane. Therefore, we negate the normals\n  // for the top plane.\n  for (i = 0; i < 4; i++) {\n    this._edgeNormals[0][i] = Cartesian3.negate(\n      this._edgeNormals[0][i],\n      this._edgeNormals[0][i],\n    );\n  }\n\n  this._edgeNormals[1] = computeEdgeNormals(\n    boundingPlanes[1],\n    vertices.slice(4, 8),\n  );\n  for (i = 0; i < 4; i++) {\n    // For each plane, iterate through the vertices in CCW order.\n    this._edgeNormals[2 + i] = computeEdgeNormals(boundingPlanes[2 + i], [\n      vertices[i % 4],\n      vertices[(i + 1) % 4],\n      vertices[4 + ((i + 1) % 4)],\n      vertices[4 + i],\n    ]);\n  }\n\n  this._planeVertices = [\n    this._vertices.slice(0, 4),\n    this._vertices.slice(4, 8),\n  ];\n  for (i = 0; i < 4; i++) {\n    this._planeVertices.push([\n      this._vertices[i % 4],\n      this._vertices[(i + 1) % 4],\n      this._vertices[4 + ((i + 1) % 4)],\n      this._vertices[4 + i],\n    ]);\n  }\n\n  const center = s2Cell.getCenter();\n  centerCartographicScratch = ellipsoid.cartesianToCartographic(\n    center,\n    centerCartographicScratch,\n  );\n  centerCartographicScratch.height = (maximumHeight + minimumHeight) / 2;\n  this.center = ellipsoid.cartographicToCartesian(\n    centerCartographicScratch,\n    center,\n  );\n\n  this._boundingSphere = BoundingSphere.fromPoints(vertices);\n}\n\nconst centerGeodeticNormalScratch = new Cartesian3();\nconst topCartographicScratch = new Cartographic();\nconst topScratch = new Cartesian3();\nconst vertexCartographicScratch = new Cartographic();\nconst vertexScratch = new Cartesian3();\nconst vertexGeodeticNormalScratch = new Cartesian3();\nconst sideNormalScratch = new Cartesian3();\nconst sideScratch = new Cartesian3();\n/**\n * Computes bounding planes of the kDOP.\n * @private\n */\nfunction computeBoundingPlanes(\n  s2Cell,\n  minimumHeight,\n  maximumHeight,\n  ellipsoid,\n) {\n  const planes = new Array(6);\n  const centerPoint = s2Cell.getCenter();\n\n  // Compute top plane.\n  // - Get geodetic surface normal at the center of the S2 cell.\n  // - Get center point at maximum height of bounding volume.\n  // - Create top plane from surface normal and top point.\n  const centerSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n    centerPoint,\n    centerGeodeticNormalScratch,\n  );\n  const topCartographic = ellipsoid.cartesianToCartographic(\n    centerPoint,\n    topCartographicScratch,\n  );\n  topCartographic.height = maximumHeight;\n  const top = ellipsoid.cartographicToCartesian(topCartographic, topScratch);\n  const topPlane = Plane.fromPointNormal(top, centerSurfaceNormal);\n  planes[0] = topPlane;\n\n  // Compute bottom plane.\n  // - Iterate through bottom vertices\n  //   - Get distance from vertex to top plane\n  // - Find longest distance from vertex to top plane\n  // - Translate top plane by the distance\n  let maxDistance = 0;\n  let i;\n  const vertices = [];\n  let vertex, vertexCartographic;\n  for (i = 0; i < 4; i++) {\n    vertex = s2Cell.getVertex(i);\n    vertices[i] = vertex;\n    vertexCartographic = ellipsoid.cartesianToCartographic(\n      vertex,\n      vertexCartographicScratch,\n    );\n    vertexCartographic.height = minimumHeight;\n    const distance = Plane.getPointDistance(\n      topPlane,\n      ellipsoid.cartographicToCartesian(vertexCartographic, vertexScratch),\n    );\n    if (distance < maxDistance) {\n      maxDistance = distance;\n    }\n  }\n  const bottomPlane = Plane.clone(topPlane);\n  // Negate the normal of the bottom plane since we want all normals to point \"outwards\".\n  bottomPlane.normal = Cartesian3.negate(\n    bottomPlane.normal,\n    bottomPlane.normal,\n  );\n  bottomPlane.distance = bottomPlane.distance * -1 + maxDistance;\n  planes[1] = bottomPlane;\n\n  // Compute side planes.\n  // - Iterate through vertices (in CCW order, by default)\n  //   - Get a vertex and another vertex adjacent to it.\n  //   - Compute geodetic surface normal at one vertex.\n  //   - Compute vector between vertices.\n  //   - Compute normal of side plane. (cross product of top dir and side dir)\n  for (i = 0; i < 4; i++) {\n    vertex = vertices[i];\n    const adjacentVertex = vertices[(i + 1) % 4];\n    const geodeticNormal = ellipsoid.geodeticSurfaceNormal(\n      vertex,\n      vertexGeodeticNormalScratch,\n    );\n    const side = Cartesian3.subtract(adjacentVertex, vertex, sideScratch);\n    let sideNormal = Cartesian3.cross(side, geodeticNormal, sideNormalScratch);\n    sideNormal = Cartesian3.normalize(sideNormal, sideNormal);\n    planes[2 + i] = Plane.fromPointNormal(vertex, sideNormal);\n  }\n\n  return planes;\n}\n\nlet n0Scratch = new Cartesian3();\nlet n1Scratch = new Cartesian3();\nlet n2Scratch = new Cartesian3();\nlet x0Scratch = new Cartesian3();\nlet x1Scratch = new Cartesian3();\nlet x2Scratch = new Cartesian3();\nconst t0Scratch = new Cartesian3();\nconst t1Scratch = new Cartesian3();\nconst t2Scratch = new Cartesian3();\nlet f0Scratch = new Cartesian3();\nlet f1Scratch = new Cartesian3();\nlet f2Scratch = new Cartesian3();\nlet sScratch = new Cartesian3();\nconst matrixScratch = new Matrix3();\n/**\n * Computes intersection of 3 planes.\n * @private\n */\nfunction computeIntersection(p0, p1, p2) {\n  n0Scratch = p0.normal;\n  n1Scratch = p1.normal;\n  n2Scratch = p2.normal;\n\n  x0Scratch = Cartesian3.multiplyByScalar(p0.normal, -p0.distance, x0Scratch);\n  x1Scratch = Cartesian3.multiplyByScalar(p1.normal, -p1.distance, x1Scratch);\n  x2Scratch = Cartesian3.multiplyByScalar(p2.normal, -p2.distance, x2Scratch);\n\n  f0Scratch = Cartesian3.multiplyByScalar(\n    Cartesian3.cross(n1Scratch, n2Scratch, t0Scratch),\n    Cartesian3.dot(x0Scratch, n0Scratch),\n    f0Scratch,\n  );\n  f1Scratch = Cartesian3.multiplyByScalar(\n    Cartesian3.cross(n2Scratch, n0Scratch, t1Scratch),\n    Cartesian3.dot(x1Scratch, n1Scratch),\n    f1Scratch,\n  );\n  f2Scratch = Cartesian3.multiplyByScalar(\n    Cartesian3.cross(n0Scratch, n1Scratch, t2Scratch),\n    Cartesian3.dot(x2Scratch, n2Scratch),\n    f2Scratch,\n  );\n\n  matrixScratch[0] = n0Scratch.x;\n  matrixScratch[1] = n1Scratch.x;\n  matrixScratch[2] = n2Scratch.x;\n  matrixScratch[3] = n0Scratch.y;\n  matrixScratch[4] = n1Scratch.y;\n  matrixScratch[5] = n2Scratch.y;\n  matrixScratch[6] = n0Scratch.z;\n  matrixScratch[7] = n1Scratch.z;\n  matrixScratch[8] = n2Scratch.z;\n  const determinant = Matrix3.determinant(matrixScratch);\n  sScratch = Cartesian3.add(f0Scratch, f1Scratch, sScratch);\n  sScratch = Cartesian3.add(sScratch, f2Scratch, sScratch);\n  return new Cartesian3(\n    sScratch.x / determinant,\n    sScratch.y / determinant,\n    sScratch.z / determinant,\n  );\n}\n/**\n * Compute the vertices of the kDOP.\n * @private\n */\nfunction computeVertices(boundingPlanes) {\n  const vertices = new Array(8);\n  for (let i = 0; i < 4; i++) {\n    // Vertices on the top plane.\n    vertices[i] = computeIntersection(\n      boundingPlanes[0],\n      boundingPlanes[2 + ((i + 3) % 4)],\n      boundingPlanes[2 + (i % 4)],\n    );\n    // Vertices on the bottom plane.\n    vertices[i + 4] = computeIntersection(\n      boundingPlanes[1],\n      boundingPlanes[2 + ((i + 3) % 4)],\n      boundingPlanes[2 + (i % 4)],\n    );\n  }\n  return vertices;\n}\n\nlet edgeScratch = new Cartesian3();\nlet edgeNormalScratch = new Cartesian3();\n/**\n * Compute edge normals on a plane.\n * @private\n */\nfunction computeEdgeNormals(plane, vertices) {\n  const edgeNormals = [];\n  for (let i = 0; i < 4; i++) {\n    edgeScratch = Cartesian3.subtract(\n      vertices[(i + 1) % 4],\n      vertices[i],\n      edgeScratch,\n    );\n    edgeNormalScratch = Cartesian3.cross(\n      plane.normal,\n      edgeScratch,\n      edgeNormalScratch,\n    );\n    edgeNormalScratch = Cartesian3.normalize(\n      edgeNormalScratch,\n      edgeNormalScratch,\n    );\n    edgeNormals[i] = Cartesian3.clone(edgeNormalScratch);\n  }\n  return edgeNormals;\n}\n\nObject.defineProperties(TileBoundingS2Cell.prototype, {\n  /**\n   * The underlying bounding volume.\n   *\n   * @memberof TileBoundingS2Cell.prototype\n   *\n   * @type {object}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function () {\n      return this;\n    },\n  },\n  /**\n   * The underlying bounding sphere.\n   *\n   * @memberof TileBoundingS2Cell.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n});\n\nconst facePointScratch = new Cartesian3();\n/**\n * The distance to point check for this kDOP involves checking the signed distance of the point to each bounding\n * plane. A plane qualifies for a distance check if the point being tested against is in the half-space in the direction\n * of the normal i.e. if the signed distance of the point from the plane is greater than 0.\n *\n * There are 4 possible cases for a point if it is outside the polyhedron:\n *\n *   \\     X     /     X \\           /       \\           /       \\           /\n * ---\\---------/---   ---\\---------/---   ---X---------/---   ---\\---------/---\n *     \\       /           \\       /           \\       /           \\       /\n *   ---\\-----/---       ---\\-----/---       ---\\-----/---       ---\\-----/---\n *       \\   /               \\   /               \\   /               \\   /\n *                                                                    \\ /\n *                                                                     \\\n *                                                                    / \\\n *                                                                   / X \\\n *\n *         I                  II                  III                 IV\n *\n * Case I: There is only one plane selected.\n * In this case, we project the point onto the plane and do a point polygon distance check to find the closest point on the polygon.\n * The point may lie inside the \"face\" of the polygon or outside. If it is outside, we need to determine which edges to test against.\n *\n * Case II: There are two planes selected.\n * In this case, the point will lie somewhere on the line created at the intersection of the selected planes or one of the planes.\n *\n * Case III: There are three planes selected.\n * In this case, the point will lie on the vertex, at the intersection of the selected planes.\n *\n * Case IV: There are more than three planes selected.\n * Since we are on an ellipsoid, this will only happen in the bottom plane, which is what we will use for the distance test.\n */\nTileBoundingS2Cell.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  const point = frameState.camera.positionWC;\n\n  const selectedPlaneIndices = [];\n  const vertices = [];\n  let edgeNormals;\n\n  if (Plane.getPointDistance(this._boundingPlanes[0], point) > 0) {\n    selectedPlaneIndices.push(0);\n    vertices.push(this._planeVertices[0]);\n    edgeNormals = this._edgeNormals[0];\n  } else if (Plane.getPointDistance(this._boundingPlanes[1], point) > 0) {\n    selectedPlaneIndices.push(1);\n    vertices.push(this._planeVertices[1]);\n    edgeNormals = this._edgeNormals[1];\n  }\n\n  let i;\n  let sidePlaneIndex;\n  for (i = 0; i < 4; i++) {\n    sidePlaneIndex = 2 + i;\n    if (\n      Plane.getPointDistance(this._boundingPlanes[sidePlaneIndex], point) > 0\n    ) {\n      selectedPlaneIndices.push(sidePlaneIndex);\n      // Store vertices in CCW order.\n      vertices.push(this._planeVertices[sidePlaneIndex]);\n      edgeNormals = this._edgeNormals[sidePlaneIndex];\n    }\n  }\n\n  // Check if inside all planes.\n  if (selectedPlaneIndices.length === 0) {\n    return 0.0;\n  }\n\n  // We use the skip variable when the side plane indices are non-consecutive.\n  let facePoint;\n  let selectedPlane;\n  if (selectedPlaneIndices.length === 1) {\n    // Handles Case I\n    selectedPlane = this._boundingPlanes[selectedPlaneIndices[0]];\n    facePoint = closestPointPolygon(\n      Plane.projectPointOntoPlane(selectedPlane, point, facePointScratch),\n      vertices[0],\n      selectedPlane,\n      edgeNormals,\n    );\n\n    return Cartesian3.distance(facePoint, point);\n  } else if (selectedPlaneIndices.length === 2) {\n    // Handles Case II\n    // Since we are on the ellipsoid, the dihedral angle between a top plane and a side plane\n    // will always be acute, so we can do a faster check there.\n    if (selectedPlaneIndices[0] === 0) {\n      const edge = [\n        this._vertices[\n          4 * selectedPlaneIndices[0] + (selectedPlaneIndices[1] - 2)\n        ],\n        this._vertices[\n          4 * selectedPlaneIndices[0] + ((selectedPlaneIndices[1] - 2 + 1) % 4)\n        ],\n      ];\n      facePoint = closestPointLineSegment(point, edge[0], edge[1]);\n      return Cartesian3.distance(facePoint, point);\n    }\n    let minimumDistance = Number.MAX_VALUE;\n    let distance;\n    for (i = 0; i < 2; i++) {\n      selectedPlane = this._boundingPlanes[selectedPlaneIndices[i]];\n      facePoint = closestPointPolygon(\n        Plane.projectPointOntoPlane(selectedPlane, point, facePointScratch),\n        vertices[i],\n        selectedPlane,\n        this._edgeNormals[selectedPlaneIndices[i]],\n      );\n\n      distance = Cartesian3.distanceSquared(facePoint, point);\n      if (distance < minimumDistance) {\n        minimumDistance = distance;\n      }\n    }\n    return Math.sqrt(minimumDistance);\n  } else if (selectedPlaneIndices.length > 3) {\n    // Handles Case IV\n    facePoint = closestPointPolygon(\n      Plane.projectPointOntoPlane(\n        this._boundingPlanes[1],\n        point,\n        facePointScratch,\n      ),\n      this._planeVertices[1],\n      this._boundingPlanes[1],\n      this._edgeNormals[1],\n    );\n    return Cartesian3.distance(facePoint, point);\n  }\n\n  // Handles Case III\n  const skip =\n    selectedPlaneIndices[1] === 2 && selectedPlaneIndices[2] === 5 ? 0 : 1;\n\n  // Vertex is on top plane.\n  if (selectedPlaneIndices[0] === 0) {\n    return Cartesian3.distance(\n      point,\n      this._vertices[(selectedPlaneIndices[1] - 2 + skip) % 4],\n    );\n  }\n\n  // Vertex is on bottom plane.\n  return Cartesian3.distance(\n    point,\n    this._vertices[4 + ((selectedPlaneIndices[1] - 2 + skip) % 4)],\n  );\n};\n\nconst dScratch = new Cartesian3();\nconst pL0Scratch = new Cartesian3();\n/**\n * Finds point on a line segment closest to a given point.\n * @private\n */\nfunction closestPointLineSegment(p, l0, l1) {\n  const d = Cartesian3.subtract(l1, l0, dScratch);\n  const pL0 = Cartesian3.subtract(p, l0, pL0Scratch);\n  let t = Cartesian3.dot(d, pL0);\n\n  if (t <= 0) {\n    return l0;\n  }\n\n  const dMag = Cartesian3.dot(d, d);\n  if (t >= dMag) {\n    return l1;\n  }\n\n  t = t / dMag;\n  return new Cartesian3(\n    (1 - t) * l0.x + t * l1.x,\n    (1 - t) * l0.y + t * l1.y,\n    (1 - t) * l0.z + t * l1.z,\n  );\n}\n\nconst edgePlaneScratch = new Plane(Cartesian3.UNIT_X, 0.0);\n/**\n * Finds closes point on the polygon, created by the given vertices, from\n * a point. The test point and the polygon are all on the same plane.\n * @private\n */\nfunction closestPointPolygon(p, vertices, plane, edgeNormals) {\n  let minDistance = Number.MAX_VALUE;\n  let distance;\n  let closestPoint;\n  let closestPointOnEdge;\n\n  for (let i = 0; i < vertices.length; i++) {\n    const edgePlane = Plane.fromPointNormal(\n      vertices[i],\n      edgeNormals[i],\n      edgePlaneScratch,\n    );\n    const edgePlaneDistance = Plane.getPointDistance(edgePlane, p);\n\n    // Skip checking against the edge if the point is not in the half-space that the\n    // edgePlane's normal points towards i.e. if the edgePlane is facing away from the point.\n    if (edgePlaneDistance < 0) {\n      continue;\n    }\n\n    closestPointOnEdge = closestPointLineSegment(\n      p,\n      vertices[i],\n      vertices[(i + 1) % 4],\n    );\n\n    distance = Cartesian3.distance(p, closestPointOnEdge);\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestPoint = closestPointOnEdge;\n    }\n  }\n\n  if (!defined(closestPoint)) {\n    return p;\n  }\n  return closestPoint;\n}\n\n/**\n * Determines which side of a plane this volume is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire volume is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire volume is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the volume\n *                      intersects the plane.\n */\nTileBoundingS2Cell.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  let plusCount = 0;\n  let negCount = 0;\n  for (let i = 0; i < this._vertices.length; i++) {\n    const distanceToPlane =\n      Cartesian3.dot(plane.normal, this._vertices[i]) + plane.distance;\n    if (distanceToPlane < 0) {\n      negCount++;\n    } else {\n      plusCount++;\n    }\n  }\n\n  if (plusCount === this._vertices.length) {\n    return Intersect.INSIDE;\n  } else if (negCount === this._vertices.length) {\n    return Intersect.OUTSIDE;\n  }\n  return Intersect.INTERSECTING;\n};\n\n/**\n * Creates a debug primitive that shows the outline of the tile bounding\n * volume.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n */\nTileBoundingS2Cell.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color);\n  //>>includeEnd('debug');\n\n  const modelMatrix = new Matrix4.clone(Matrix4.IDENTITY);\n  const topPlanePolygon = new CoplanarPolygonOutlineGeometry({\n    polygonHierarchy: {\n      positions: this._planeVertices[0],\n    },\n  });\n  const topPlaneGeometry =\n    CoplanarPolygonOutlineGeometry.createGeometry(topPlanePolygon);\n  const topPlaneInstance = new GeometryInstance({\n    geometry: topPlaneGeometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  const bottomPlanePolygon = new CoplanarPolygonOutlineGeometry({\n    polygonHierarchy: {\n      positions: this._planeVertices[1],\n    },\n  });\n  const bottomPlaneGeometry =\n    CoplanarPolygonOutlineGeometry.createGeometry(bottomPlanePolygon);\n  const bottomPlaneInstance = new GeometryInstance({\n    geometry: bottomPlaneGeometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  const sideInstances = [];\n  for (let i = 0; i < 4; i++) {\n    const sidePlanePolygon = new CoplanarPolygonOutlineGeometry({\n      polygonHierarchy: {\n        positions: this._planeVertices[2 + i],\n      },\n    });\n    const sidePlaneGeometry =\n      CoplanarPolygonOutlineGeometry.createGeometry(sidePlanePolygon);\n    sideInstances[i] = new GeometryInstance({\n      geometry: sidePlaneGeometry,\n      id: \"outline\",\n      modelMatrix: modelMatrix,\n      attributes: {\n        color: ColorGeometryInstanceAttribute.fromColor(color),\n      },\n    });\n  }\n\n  return new Primitive({\n    geometryInstances: [\n      sideInstances[0],\n      sideInstances[1],\n      sideInstances[2],\n      sideInstances[3],\n      bottomPlaneInstance,\n      topPlaneInstance,\n    ],\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true,\n    }),\n    asynchronous: false,\n  });\n};\n\nexport default TileBoundingS2Cell;\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,uBAAuB;AAC9C,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,8BAA8B,MAAM,2CAA2C;AACtF,OAAOC,cAAc,MAAM,2BAA2B;AACtD,OAAOC,KAAK,MAAM,kBAAkB;AACpC,OAAOC,8BAA8B,MAAM,2CAA2C;AACtF,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,gBAAgB,MAAM,6BAA6B;AAC1D,OAAOC,OAAO,MAAM,oBAAoB;AACxC,OAAOC,0BAA0B,MAAM,iCAAiC;AACxE,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,MAAM,MAAM,mBAAmB;AACtC,IAAIC,yBAAyB,GAAG,IAAIf,YAAY,CAAC,CAAC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASgB,kBAAkBA,CAACC,OAAO,EAAE;EACnC;EACAV,KAAK,CAACW,MAAM,CAACC,MAAM,CAAC,SAAS,EAAEF,OAAO,CAAC;EACvCV,KAAK,CAACW,MAAM,CAACE,MAAM,CAAC,eAAe,EAAEH,OAAO,CAACI,KAAK,CAAC;EACnD;;EAEA,MAAMC,MAAM,GAAGR,MAAM,CAACS,SAAS,CAACN,OAAO,CAACI,KAAK,CAAC;EAC9C,MAAMG,aAAa,GAAGf,YAAY,CAACQ,OAAO,CAACO,aAAa,EAAE,GAAG,CAAC;EAC9D,MAAMC,aAAa,GAAGhB,YAAY,CAACQ,OAAO,CAACQ,aAAa,EAAE,GAAG,CAAC;EAC9D,MAAMC,SAAS,GAAGjB,YAAY,CAACQ,OAAO,CAACS,SAAS,EAAEzB,SAAS,CAAC0B,KAAK,CAAC;EAElE,IAAI,CAACL,MAAM,GAAGA,MAAM;EACpB,IAAI,CAACE,aAAa,GAAGA,aAAa;EAClC,IAAI,CAACC,aAAa,GAAGA,aAAa;EAClC,IAAI,CAACC,SAAS,GAAGA,SAAS;EAE1B,MAAME,cAAc,GAAGC,qBAAqB,CAC1CP,MAAM,EACNE,aAAa,EACbC,aAAa,EACbC,SACF,CAAC;EACD,IAAI,CAACI,eAAe,GAAGF,cAAc;;EAErC;EACA,MAAMG,QAAQ,GAAGC,eAAe,CAACJ,cAAc,CAAC;EAChD,IAAI,CAACK,SAAS,GAAGF,QAAQ;;EAEzB;EACA,IAAI,CAACG,YAAY,GAAG,IAAIC,KAAK,CAAC,CAAC,CAAC;EAEhC,IAAI,CAACD,YAAY,CAAC,CAAC,CAAC,GAAGE,kBAAkB,CACvCR,cAAc,CAAC,CAAC,CAAC,EACjBG,QAAQ,CAACM,KAAK,CAAC,CAAC,EAAE,CAAC,CACrB,CAAC;EACD,IAAIC,CAAC;EACL;EACA;EACA;EACA,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IACtB,IAAI,CAACJ,YAAY,CAAC,CAAC,CAAC,CAACI,CAAC,CAAC,GAAGxC,UAAU,CAACyC,MAAM,CACzC,IAAI,CAACL,YAAY,CAAC,CAAC,CAAC,CAACI,CAAC,CAAC,EACvB,IAAI,CAACJ,YAAY,CAAC,CAAC,CAAC,CAACI,CAAC,CACxB,CAAC;EACH;EAEA,IAAI,CAACJ,YAAY,CAAC,CAAC,CAAC,GAAGE,kBAAkB,CACvCR,cAAc,CAAC,CAAC,CAAC,EACjBG,QAAQ,CAACM,KAAK,CAAC,CAAC,EAAE,CAAC,CACrB,CAAC;EACD,KAAKC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IACtB;IACA,IAAI,CAACJ,YAAY,CAAC,CAAC,GAAGI,CAAC,CAAC,GAAGF,kBAAkB,CAACR,cAAc,CAAC,CAAC,GAAGU,CAAC,CAAC,EAAE,CACnEP,QAAQ,CAACO,CAAC,GAAG,CAAC,CAAC,EACfP,QAAQ,CAAC,CAACO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EACrBP,QAAQ,CAAC,CAAC,GAAI,CAACO,CAAC,GAAG,CAAC,IAAI,CAAE,CAAC,EAC3BP,QAAQ,CAAC,CAAC,GAAGO,CAAC,CAAC,CAChB,CAAC;EACJ;EAEA,IAAI,CAACE,cAAc,GAAG,CACpB,IAAI,CAACP,SAAS,CAACI,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAC1B,IAAI,CAACJ,SAAS,CAACI,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAC3B;EACD,KAAKC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IACtB,IAAI,CAACE,cAAc,CAACC,IAAI,CAAC,CACvB,IAAI,CAACR,SAAS,CAACK,CAAC,GAAG,CAAC,CAAC,EACrB,IAAI,CAACL,SAAS,CAAC,CAACK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAC3B,IAAI,CAACL,SAAS,CAAC,CAAC,GAAI,CAACK,CAAC,GAAG,CAAC,IAAI,CAAE,CAAC,EACjC,IAAI,CAACL,SAAS,CAAC,CAAC,GAAGK,CAAC,CAAC,CACtB,CAAC;EACJ;EAEA,MAAMI,MAAM,GAAGpB,MAAM,CAACqB,SAAS,CAAC,CAAC;EACjC5B,yBAAyB,GAAGW,SAAS,CAACkB,uBAAuB,CAC3DF,MAAM,EACN3B,yBACF,CAAC;EACDA,yBAAyB,CAAC8B,MAAM,GAAG,CAACpB,aAAa,GAAGD,aAAa,IAAI,CAAC;EACtE,IAAI,CAACkB,MAAM,GAAGhB,SAAS,CAACoB,uBAAuB,CAC7C/B,yBAAyB,EACzB2B,MACF,CAAC;EAED,IAAI,CAACK,eAAe,GAAGzC,cAAc,CAAC0C,UAAU,CAACjB,QAAQ,CAAC;AAC5D;AAEA,MAAMkB,2BAA2B,GAAG,IAAInD,UAAU,CAAC,CAAC;AACpD,MAAMoD,sBAAsB,GAAG,IAAIlD,YAAY,CAAC,CAAC;AACjD,MAAMmD,UAAU,GAAG,IAAIrD,UAAU,CAAC,CAAC;AACnC,MAAMsD,yBAAyB,GAAG,IAAIpD,YAAY,CAAC,CAAC;AACpD,MAAMqD,aAAa,GAAG,IAAIvD,UAAU,CAAC,CAAC;AACtC,MAAMwD,2BAA2B,GAAG,IAAIxD,UAAU,CAAC,CAAC;AACpD,MAAMyD,iBAAiB,GAAG,IAAIzD,UAAU,CAAC,CAAC;AAC1C,MAAM0D,WAAW,GAAG,IAAI1D,UAAU,CAAC,CAAC;AACpC;AACA;AACA;AACA;AACA,SAAS+B,qBAAqBA,CAC5BP,MAAM,EACNE,aAAa,EACbC,aAAa,EACbC,SAAS,EACT;EACA,MAAM+B,MAAM,GAAG,IAAItB,KAAK,CAAC,CAAC,CAAC;EAC3B,MAAMuB,WAAW,GAAGpC,MAAM,CAACqB,SAAS,CAAC,CAAC;;EAEtC;EACA;EACA;EACA;EACA,MAAMgB,mBAAmB,GAAGjC,SAAS,CAACkC,qBAAqB,CACzDF,WAAW,EACXT,2BACF,CAAC;EACD,MAAMY,eAAe,GAAGnC,SAAS,CAACkB,uBAAuB,CACvDc,WAAW,EACXR,sBACF,CAAC;EACDW,eAAe,CAAChB,MAAM,GAAGpB,aAAa;EACtC,MAAMqC,GAAG,GAAGpC,SAAS,CAACoB,uBAAuB,CAACe,eAAe,EAAEV,UAAU,CAAC;EAC1E,MAAMY,QAAQ,GAAG3D,KAAK,CAAC4D,eAAe,CAACF,GAAG,EAAEH,mBAAmB,CAAC;EAChEF,MAAM,CAAC,CAAC,CAAC,GAAGM,QAAQ;;EAEpB;EACA;EACA;EACA;EACA;EACA,IAAIE,WAAW,GAAG,CAAC;EACnB,IAAI3B,CAAC;EACL,MAAMP,QAAQ,GAAG,EAAE;EACnB,IAAImC,MAAM,EAAEC,kBAAkB;EAC9B,KAAK7B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IACtB4B,MAAM,GAAG5C,MAAM,CAAC8C,SAAS,CAAC9B,CAAC,CAAC;IAC5BP,QAAQ,CAACO,CAAC,CAAC,GAAG4B,MAAM;IACpBC,kBAAkB,GAAGzC,SAAS,CAACkB,uBAAuB,CACpDsB,MAAM,EACNd,yBACF,CAAC;IACDe,kBAAkB,CAACtB,MAAM,GAAGrB,aAAa;IACzC,MAAM6C,QAAQ,GAAGjE,KAAK,CAACkE,gBAAgB,CACrCP,QAAQ,EACRrC,SAAS,CAACoB,uBAAuB,CAACqB,kBAAkB,EAAEd,aAAa,CACrE,CAAC;IACD,IAAIgB,QAAQ,GAAGJ,WAAW,EAAE;MAC1BA,WAAW,GAAGI,QAAQ;IACxB;EACF;EACA,MAAME,WAAW,GAAGnE,KAAK,CAACoE,KAAK,CAACT,QAAQ,CAAC;EACzC;EACAQ,WAAW,CAACE,MAAM,GAAG3E,UAAU,CAACyC,MAAM,CACpCgC,WAAW,CAACE,MAAM,EAClBF,WAAW,CAACE,MACd,CAAC;EACDF,WAAW,CAACF,QAAQ,GAAGE,WAAW,CAACF,QAAQ,GAAG,CAAC,CAAC,GAAGJ,WAAW;EAC9DR,MAAM,CAAC,CAAC,CAAC,GAAGc,WAAW;;EAEvB;EACA;EACA;EACA;EACA;EACA;EACA,KAAKjC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IACtB4B,MAAM,GAAGnC,QAAQ,CAACO,CAAC,CAAC;IACpB,MAAMoC,cAAc,GAAG3C,QAAQ,CAAC,CAACO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAC5C,MAAMqC,cAAc,GAAGjD,SAAS,CAACkC,qBAAqB,CACpDM,MAAM,EACNZ,2BACF,CAAC;IACD,MAAMsB,IAAI,GAAG9E,UAAU,CAAC+E,QAAQ,CAACH,cAAc,EAAER,MAAM,EAAEV,WAAW,CAAC;IACrE,IAAIsB,UAAU,GAAGhF,UAAU,CAACiF,KAAK,CAACH,IAAI,EAAED,cAAc,EAAEpB,iBAAiB,CAAC;IAC1EuB,UAAU,GAAGhF,UAAU,CAACkF,SAAS,CAACF,UAAU,EAAEA,UAAU,CAAC;IACzDrB,MAAM,CAAC,CAAC,GAAGnB,CAAC,CAAC,GAAGlC,KAAK,CAAC4D,eAAe,CAACE,MAAM,EAAEY,UAAU,CAAC;EAC3D;EAEA,OAAOrB,MAAM;AACf;AAEA,IAAIwB,SAAS,GAAG,IAAInF,UAAU,CAAC,CAAC;AAChC,IAAIoF,SAAS,GAAG,IAAIpF,UAAU,CAAC,CAAC;AAChC,IAAIqF,SAAS,GAAG,IAAIrF,UAAU,CAAC,CAAC;AAChC,IAAIsF,SAAS,GAAG,IAAItF,UAAU,CAAC,CAAC;AAChC,IAAIuF,SAAS,GAAG,IAAIvF,UAAU,CAAC,CAAC;AAChC,IAAIwF,SAAS,GAAG,IAAIxF,UAAU,CAAC,CAAC;AAChC,MAAMyF,SAAS,GAAG,IAAIzF,UAAU,CAAC,CAAC;AAClC,MAAM0F,SAAS,GAAG,IAAI1F,UAAU,CAAC,CAAC;AAClC,MAAM2F,SAAS,GAAG,IAAI3F,UAAU,CAAC,CAAC;AAClC,IAAI4F,SAAS,GAAG,IAAI5F,UAAU,CAAC,CAAC;AAChC,IAAI6F,SAAS,GAAG,IAAI7F,UAAU,CAAC,CAAC;AAChC,IAAI8F,SAAS,GAAG,IAAI9F,UAAU,CAAC,CAAC;AAChC,IAAI+F,QAAQ,GAAG,IAAI/F,UAAU,CAAC,CAAC;AAC/B,MAAMgG,aAAa,GAAG,IAAI3F,OAAO,CAAC,CAAC;AACnC;AACA;AACA;AACA;AACA,SAAS4F,mBAAmBA,CAACC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAE;EACvCjB,SAAS,GAAGe,EAAE,CAACvB,MAAM;EACrBS,SAAS,GAAGe,EAAE,CAACxB,MAAM;EACrBU,SAAS,GAAGe,EAAE,CAACzB,MAAM;EAErBW,SAAS,GAAGtF,UAAU,CAACqG,gBAAgB,CAACH,EAAE,CAACvB,MAAM,EAAE,CAACuB,EAAE,CAAC3B,QAAQ,EAAEe,SAAS,CAAC;EAC3EC,SAAS,GAAGvF,UAAU,CAACqG,gBAAgB,CAACF,EAAE,CAACxB,MAAM,EAAE,CAACwB,EAAE,CAAC5B,QAAQ,EAAEgB,SAAS,CAAC;EAC3EC,SAAS,GAAGxF,UAAU,CAACqG,gBAAgB,CAACD,EAAE,CAACzB,MAAM,EAAE,CAACyB,EAAE,CAAC7B,QAAQ,EAAEiB,SAAS,CAAC;EAE3EI,SAAS,GAAG5F,UAAU,CAACqG,gBAAgB,CACrCrG,UAAU,CAACiF,KAAK,CAACG,SAAS,EAAEC,SAAS,EAAEI,SAAS,CAAC,EACjDzF,UAAU,CAACsG,GAAG,CAAChB,SAAS,EAAEH,SAAS,CAAC,EACpCS,SACF,CAAC;EACDC,SAAS,GAAG7F,UAAU,CAACqG,gBAAgB,CACrCrG,UAAU,CAACiF,KAAK,CAACI,SAAS,EAAEF,SAAS,EAAEO,SAAS,CAAC,EACjD1F,UAAU,CAACsG,GAAG,CAACf,SAAS,EAAEH,SAAS,CAAC,EACpCS,SACF,CAAC;EACDC,SAAS,GAAG9F,UAAU,CAACqG,gBAAgB,CACrCrG,UAAU,CAACiF,KAAK,CAACE,SAAS,EAAEC,SAAS,EAAEO,SAAS,CAAC,EACjD3F,UAAU,CAACsG,GAAG,CAACd,SAAS,EAAEH,SAAS,CAAC,EACpCS,SACF,CAAC;EAEDE,aAAa,CAAC,CAAC,CAAC,GAAGb,SAAS,CAACoB,CAAC;EAC9BP,aAAa,CAAC,CAAC,CAAC,GAAGZ,SAAS,CAACmB,CAAC;EAC9BP,aAAa,CAAC,CAAC,CAAC,GAAGX,SAAS,CAACkB,CAAC;EAC9BP,aAAa,CAAC,CAAC,CAAC,GAAGb,SAAS,CAACqB,CAAC;EAC9BR,aAAa,CAAC,CAAC,CAAC,GAAGZ,SAAS,CAACoB,CAAC;EAC9BR,aAAa,CAAC,CAAC,CAAC,GAAGX,SAAS,CAACmB,CAAC;EAC9BR,aAAa,CAAC,CAAC,CAAC,GAAGb,SAAS,CAACsB,CAAC;EAC9BT,aAAa,CAAC,CAAC,CAAC,GAAGZ,SAAS,CAACqB,CAAC;EAC9BT,aAAa,CAAC,CAAC,CAAC,GAAGX,SAAS,CAACoB,CAAC;EAC9B,MAAMC,WAAW,GAAGrG,OAAO,CAACqG,WAAW,CAACV,aAAa,CAAC;EACtDD,QAAQ,GAAG/F,UAAU,CAAC2G,GAAG,CAACf,SAAS,EAAEC,SAAS,EAAEE,QAAQ,CAAC;EACzDA,QAAQ,GAAG/F,UAAU,CAAC2G,GAAG,CAACZ,QAAQ,EAAED,SAAS,EAAEC,QAAQ,CAAC;EACxD,OAAO,IAAI/F,UAAU,CACnB+F,QAAQ,CAACQ,CAAC,GAAGG,WAAW,EACxBX,QAAQ,CAACS,CAAC,GAAGE,WAAW,EACxBX,QAAQ,CAACU,CAAC,GAAGC,WACf,CAAC;AACH;AACA;AACA;AACA;AACA;AACA,SAASxE,eAAeA,CAACJ,cAAc,EAAE;EACvC,MAAMG,QAAQ,GAAG,IAAII,KAAK,CAAC,CAAC,CAAC;EAC7B,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC1B;IACAP,QAAQ,CAACO,CAAC,CAAC,GAAGyD,mBAAmB,CAC/BnE,cAAc,CAAC,CAAC,CAAC,EACjBA,cAAc,CAAC,CAAC,GAAI,CAACU,CAAC,GAAG,CAAC,IAAI,CAAE,CAAC,EACjCV,cAAc,CAAC,CAAC,GAAIU,CAAC,GAAG,CAAE,CAC5B,CAAC;IACD;IACAP,QAAQ,CAACO,CAAC,GAAG,CAAC,CAAC,GAAGyD,mBAAmB,CACnCnE,cAAc,CAAC,CAAC,CAAC,EACjBA,cAAc,CAAC,CAAC,GAAI,CAACU,CAAC,GAAG,CAAC,IAAI,CAAE,CAAC,EACjCV,cAAc,CAAC,CAAC,GAAIU,CAAC,GAAG,CAAE,CAC5B,CAAC;EACH;EACA,OAAOP,QAAQ;AACjB;AAEA,IAAI2E,WAAW,GAAG,IAAI5G,UAAU,CAAC,CAAC;AAClC,IAAI6G,iBAAiB,GAAG,IAAI7G,UAAU,CAAC,CAAC;AACxC;AACA;AACA;AACA;AACA,SAASsC,kBAAkBA,CAACwE,KAAK,EAAE7E,QAAQ,EAAE;EAC3C,MAAM8E,WAAW,GAAG,EAAE;EACtB,KAAK,IAAIvE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC1BoE,WAAW,GAAG5G,UAAU,CAAC+E,QAAQ,CAC/B9C,QAAQ,CAAC,CAACO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EACrBP,QAAQ,CAACO,CAAC,CAAC,EACXoE,WACF,CAAC;IACDC,iBAAiB,GAAG7G,UAAU,CAACiF,KAAK,CAClC6B,KAAK,CAACnC,MAAM,EACZiC,WAAW,EACXC,iBACF,CAAC;IACDA,iBAAiB,GAAG7G,UAAU,CAACkF,SAAS,CACtC2B,iBAAiB,EACjBA,iBACF,CAAC;IACDE,WAAW,CAACvE,CAAC,CAAC,GAAGxC,UAAU,CAAC0E,KAAK,CAACmC,iBAAiB,CAAC;EACtD;EACA,OAAOE,WAAW;AACpB;AAEAC,MAAM,CAACC,gBAAgB,CAAC/F,kBAAkB,CAACgG,SAAS,EAAE;EACpD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,cAAc,EAAE;IACdC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI;IACb;EACF,CAAC;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,cAAc,EAAE;IACdD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACf,OAAO,IAAI,CAACnE,eAAe;IAC7B;EACF;AACF,CAAC,CAAC;AAEF,MAAMqE,gBAAgB,GAAG,IAAItH,UAAU,CAAC,CAAC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAkB,kBAAkB,CAACgG,SAAS,CAACK,gBAAgB,GAAG,UAAUC,UAAU,EAAE;EACpE;EACA/G,KAAK,CAACR,OAAO,CAAC,YAAY,EAAEuH,UAAU,CAAC;EACvC;;EAEA,MAAMC,KAAK,GAAGD,UAAU,CAACE,MAAM,CAACC,UAAU;EAE1C,MAAMC,oBAAoB,GAAG,EAAE;EAC/B,MAAM3F,QAAQ,GAAG,EAAE;EACnB,IAAI8E,WAAW;EAEf,IAAIzG,KAAK,CAACkE,gBAAgB,CAAC,IAAI,CAACxC,eAAe,CAAC,CAAC,CAAC,EAAEyF,KAAK,CAAC,GAAG,CAAC,EAAE;IAC9DG,oBAAoB,CAACjF,IAAI,CAAC,CAAC,CAAC;IAC5BV,QAAQ,CAACU,IAAI,CAAC,IAAI,CAACD,cAAc,CAAC,CAAC,CAAC,CAAC;IACrCqE,WAAW,GAAG,IAAI,CAAC3E,YAAY,CAAC,CAAC,CAAC;EACpC,CAAC,MAAM,IAAI9B,KAAK,CAACkE,gBAAgB,CAAC,IAAI,CAACxC,eAAe,CAAC,CAAC,CAAC,EAAEyF,KAAK,CAAC,GAAG,CAAC,EAAE;IACrEG,oBAAoB,CAACjF,IAAI,CAAC,CAAC,CAAC;IAC5BV,QAAQ,CAACU,IAAI,CAAC,IAAI,CAACD,cAAc,CAAC,CAAC,CAAC,CAAC;IACrCqE,WAAW,GAAG,IAAI,CAAC3E,YAAY,CAAC,CAAC,CAAC;EACpC;EAEA,IAAII,CAAC;EACL,IAAIqF,cAAc;EAClB,KAAKrF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IACtBqF,cAAc,GAAG,CAAC,GAAGrF,CAAC;IACtB,IACElC,KAAK,CAACkE,gBAAgB,CAAC,IAAI,CAACxC,eAAe,CAAC6F,cAAc,CAAC,EAAEJ,KAAK,CAAC,GAAG,CAAC,EACvE;MACAG,oBAAoB,CAACjF,IAAI,CAACkF,cAAc,CAAC;MACzC;MACA5F,QAAQ,CAACU,IAAI,CAAC,IAAI,CAACD,cAAc,CAACmF,cAAc,CAAC,CAAC;MAClDd,WAAW,GAAG,IAAI,CAAC3E,YAAY,CAACyF,cAAc,CAAC;IACjD;EACF;;EAEA;EACA,IAAID,oBAAoB,CAACE,MAAM,KAAK,CAAC,EAAE;IACrC,OAAO,GAAG;EACZ;;EAEA;EACA,IAAIC,SAAS;EACb,IAAIC,aAAa;EACjB,IAAIJ,oBAAoB,CAACE,MAAM,KAAK,CAAC,EAAE;IACrC;IACAE,aAAa,GAAG,IAAI,CAAChG,eAAe,CAAC4F,oBAAoB,CAAC,CAAC,CAAC,CAAC;IAC7DG,SAAS,GAAGE,mBAAmB,CAC7B3H,KAAK,CAAC4H,qBAAqB,CAACF,aAAa,EAAEP,KAAK,EAAEH,gBAAgB,CAAC,EACnErF,QAAQ,CAAC,CAAC,CAAC,EACX+F,aAAa,EACbjB,WACF,CAAC;IAED,OAAO/G,UAAU,CAACuE,QAAQ,CAACwD,SAAS,EAAEN,KAAK,CAAC;EAC9C,CAAC,MAAM,IAAIG,oBAAoB,CAACE,MAAM,KAAK,CAAC,EAAE;IAC5C;IACA;IACA;IACA,IAAIF,oBAAoB,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;MACjC,MAAMO,IAAI,GAAG,CACX,IAAI,CAAChG,SAAS,CACZ,CAAC,GAAGyF,oBAAoB,CAAC,CAAC,CAAC,IAAIA,oBAAoB,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAC5D,EACD,IAAI,CAACzF,SAAS,CACZ,CAAC,GAAGyF,oBAAoB,CAAC,CAAC,CAAC,GAAI,CAACA,oBAAoB,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAE,CACtE,CACF;MACDG,SAAS,GAAGK,uBAAuB,CAACX,KAAK,EAAEU,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC;MAC5D,OAAOnI,UAAU,CAACuE,QAAQ,CAACwD,SAAS,EAAEN,KAAK,CAAC;IAC9C;IACA,IAAIY,eAAe,GAAGC,MAAM,CAACC,SAAS;IACtC,IAAIhE,QAAQ;IACZ,KAAK/B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MACtBwF,aAAa,GAAG,IAAI,CAAChG,eAAe,CAAC4F,oBAAoB,CAACpF,CAAC,CAAC,CAAC;MAC7DuF,SAAS,GAAGE,mBAAmB,CAC7B3H,KAAK,CAAC4H,qBAAqB,CAACF,aAAa,EAAEP,KAAK,EAAEH,gBAAgB,CAAC,EACnErF,QAAQ,CAACO,CAAC,CAAC,EACXwF,aAAa,EACb,IAAI,CAAC5F,YAAY,CAACwF,oBAAoB,CAACpF,CAAC,CAAC,CAC3C,CAAC;MAED+B,QAAQ,GAAGvE,UAAU,CAACwI,eAAe,CAACT,SAAS,EAAEN,KAAK,CAAC;MACvD,IAAIlD,QAAQ,GAAG8D,eAAe,EAAE;QAC9BA,eAAe,GAAG9D,QAAQ;MAC5B;IACF;IACA,OAAOkE,IAAI,CAACC,IAAI,CAACL,eAAe,CAAC;EACnC,CAAC,MAAM,IAAIT,oBAAoB,CAACE,MAAM,GAAG,CAAC,EAAE;IAC1C;IACAC,SAAS,GAAGE,mBAAmB,CAC7B3H,KAAK,CAAC4H,qBAAqB,CACzB,IAAI,CAAClG,eAAe,CAAC,CAAC,CAAC,EACvByF,KAAK,EACLH,gBACF,CAAC,EACD,IAAI,CAAC5E,cAAc,CAAC,CAAC,CAAC,EACtB,IAAI,CAACV,eAAe,CAAC,CAAC,CAAC,EACvB,IAAI,CAACI,YAAY,CAAC,CAAC,CACrB,CAAC;IACD,OAAOpC,UAAU,CAACuE,QAAQ,CAACwD,SAAS,EAAEN,KAAK,CAAC;EAC9C;;EAEA;EACA,MAAMkB,IAAI,GACRf,oBAAoB,CAAC,CAAC,CAAC,KAAK,CAAC,IAAIA,oBAAoB,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;;EAExE;EACA,IAAIA,oBAAoB,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;IACjC,OAAO5H,UAAU,CAACuE,QAAQ,CACxBkD,KAAK,EACL,IAAI,CAACtF,SAAS,CAAC,CAACyF,oBAAoB,CAAC,CAAC,CAAC,GAAG,CAAC,GAAGe,IAAI,IAAI,CAAC,CACzD,CAAC;EACH;;EAEA;EACA,OAAO3I,UAAU,CAACuE,QAAQ,CACxBkD,KAAK,EACL,IAAI,CAACtF,SAAS,CAAC,CAAC,GAAI,CAACyF,oBAAoB,CAAC,CAAC,CAAC,GAAG,CAAC,GAAGe,IAAI,IAAI,CAAE,CAC/D,CAAC;AACH,CAAC;AAED,MAAMC,QAAQ,GAAG,IAAI5I,UAAU,CAAC,CAAC;AACjC,MAAM6I,UAAU,GAAG,IAAI7I,UAAU,CAAC,CAAC;AACnC;AACA;AACA;AACA;AACA,SAASoI,uBAAuBA,CAACU,CAAC,EAAEC,EAAE,EAAEC,EAAE,EAAE;EAC1C,MAAMC,CAAC,GAAGjJ,UAAU,CAAC+E,QAAQ,CAACiE,EAAE,EAAED,EAAE,EAAEH,QAAQ,CAAC;EAC/C,MAAMM,GAAG,GAAGlJ,UAAU,CAAC+E,QAAQ,CAAC+D,CAAC,EAAEC,EAAE,EAAEF,UAAU,CAAC;EAClD,IAAIM,CAAC,GAAGnJ,UAAU,CAACsG,GAAG,CAAC2C,CAAC,EAAEC,GAAG,CAAC;EAE9B,IAAIC,CAAC,IAAI,CAAC,EAAE;IACV,OAAOJ,EAAE;EACX;EAEA,MAAMK,IAAI,GAAGpJ,UAAU,CAACsG,GAAG,CAAC2C,CAAC,EAAEA,CAAC,CAAC;EACjC,IAAIE,CAAC,IAAIC,IAAI,EAAE;IACb,OAAOJ,EAAE;EACX;EAEAG,CAAC,GAAGA,CAAC,GAAGC,IAAI;EACZ,OAAO,IAAIpJ,UAAU,CACnB,CAAC,CAAC,GAAGmJ,CAAC,IAAIJ,EAAE,CAACxC,CAAC,GAAG4C,CAAC,GAAGH,EAAE,CAACzC,CAAC,EACzB,CAAC,CAAC,GAAG4C,CAAC,IAAIJ,EAAE,CAACvC,CAAC,GAAG2C,CAAC,GAAGH,EAAE,CAACxC,CAAC,EACzB,CAAC,CAAC,GAAG2C,CAAC,IAAIJ,EAAE,CAACtC,CAAC,GAAG0C,CAAC,GAAGH,EAAE,CAACvC,CAC1B,CAAC;AACH;AAEA,MAAM4C,gBAAgB,GAAG,IAAI/I,KAAK,CAACN,UAAU,CAACsJ,MAAM,EAAE,GAAG,CAAC;AAC1D;AACA;AACA;AACA;AACA;AACA,SAASrB,mBAAmBA,CAACa,CAAC,EAAE7G,QAAQ,EAAE6E,KAAK,EAAEC,WAAW,EAAE;EAC5D,IAAIwC,WAAW,GAAGjB,MAAM,CAACC,SAAS;EAClC,IAAIhE,QAAQ;EACZ,IAAIiF,YAAY;EAChB,IAAIC,kBAAkB;EAEtB,KAAK,IAAIjH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,QAAQ,CAAC6F,MAAM,EAAEtF,CAAC,EAAE,EAAE;IACxC,MAAMkH,SAAS,GAAGpJ,KAAK,CAAC4D,eAAe,CACrCjC,QAAQ,CAACO,CAAC,CAAC,EACXuE,WAAW,CAACvE,CAAC,CAAC,EACd6G,gBACF,CAAC;IACD,MAAMM,iBAAiB,GAAGrJ,KAAK,CAACkE,gBAAgB,CAACkF,SAAS,EAAEZ,CAAC,CAAC;;IAE9D;IACA;IACA,IAAIa,iBAAiB,GAAG,CAAC,EAAE;MACzB;IACF;IAEAF,kBAAkB,GAAGrB,uBAAuB,CAC1CU,CAAC,EACD7G,QAAQ,CAACO,CAAC,CAAC,EACXP,QAAQ,CAAC,CAACO,CAAC,GAAG,CAAC,IAAI,CAAC,CACtB,CAAC;IAED+B,QAAQ,GAAGvE,UAAU,CAACuE,QAAQ,CAACuE,CAAC,EAAEW,kBAAkB,CAAC;IACrD,IAAIlF,QAAQ,GAAGgF,WAAW,EAAE;MAC1BA,WAAW,GAAGhF,QAAQ;MACtBiF,YAAY,GAAGC,kBAAkB;IACnC;EACF;EAEA,IAAI,CAACxJ,OAAO,CAACuJ,YAAY,CAAC,EAAE;IAC1B,OAAOV,CAAC;EACV;EACA,OAAOU,YAAY;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAtI,kBAAkB,CAACgG,SAAS,CAAC0C,cAAc,GAAG,UAAU9C,KAAK,EAAE;EAC7D;EACArG,KAAK,CAACR,OAAO,CAAC,OAAO,EAAE6G,KAAK,CAAC;EAC7B;;EAEA,IAAI+C,SAAS,GAAG,CAAC;EACjB,IAAIC,QAAQ,GAAG,CAAC;EAChB,KAAK,IAAItH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACL,SAAS,CAAC2F,MAAM,EAAEtF,CAAC,EAAE,EAAE;IAC9C,MAAMuH,eAAe,GACnB/J,UAAU,CAACsG,GAAG,CAACQ,KAAK,CAACnC,MAAM,EAAE,IAAI,CAACxC,SAAS,CAACK,CAAC,CAAC,CAAC,GAAGsE,KAAK,CAACvC,QAAQ;IAClE,IAAIwF,eAAe,GAAG,CAAC,EAAE;MACvBD,QAAQ,EAAE;IACZ,CAAC,MAAM;MACLD,SAAS,EAAE;IACb;EACF;EAEA,IAAIA,SAAS,KAAK,IAAI,CAAC1H,SAAS,CAAC2F,MAAM,EAAE;IACvC,OAAO1H,SAAS,CAAC4J,MAAM;EACzB,CAAC,MAAM,IAAIF,QAAQ,KAAK,IAAI,CAAC3H,SAAS,CAAC2F,MAAM,EAAE;IAC7C,OAAO1H,SAAS,CAAC6J,OAAO;EAC1B;EACA,OAAO7J,SAAS,CAAC8J,YAAY;AAC/B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAhJ,kBAAkB,CAACgG,SAAS,CAACiD,iBAAiB,GAAG,UAAUC,KAAK,EAAE;EAChE;EACA3J,KAAK,CAACR,OAAO,CAAC,OAAO,EAAEmK,KAAK,CAAC;EAC7B;;EAEA,MAAMC,WAAW,GAAG,IAAIxJ,OAAO,CAAC6D,KAAK,CAAC7D,OAAO,CAACyJ,QAAQ,CAAC;EACvD,MAAMC,eAAe,GAAG,IAAIhK,8BAA8B,CAAC;IACzDiK,gBAAgB,EAAE;MAChBC,SAAS,EAAE,IAAI,CAAC/H,cAAc,CAAC,CAAC;IAClC;EACF,CAAC,CAAC;EACF,MAAMgI,gBAAgB,GACpBnK,8BAA8B,CAACoK,cAAc,CAACJ,eAAe,CAAC;EAChE,MAAMK,gBAAgB,GAAG,IAAIhK,gBAAgB,CAAC;IAC5CiK,QAAQ,EAAEH,gBAAgB;IAC1BI,EAAE,EAAE,SAAS;IACbT,WAAW,EAAEA,WAAW;IACxBU,UAAU,EAAE;MACVX,KAAK,EAAE1J,8BAA8B,CAACsK,SAAS,CAACZ,KAAK;IACvD;EACF,CAAC,CAAC;EAEF,MAAMa,kBAAkB,GAAG,IAAI1K,8BAA8B,CAAC;IAC5DiK,gBAAgB,EAAE;MAChBC,SAAS,EAAE,IAAI,CAAC/H,cAAc,CAAC,CAAC;IAClC;EACF,CAAC,CAAC;EACF,MAAMwI,mBAAmB,GACvB3K,8BAA8B,CAACoK,cAAc,CAACM,kBAAkB,CAAC;EACnE,MAAME,mBAAmB,GAAG,IAAIvK,gBAAgB,CAAC;IAC/CiK,QAAQ,EAAEK,mBAAmB;IAC7BJ,EAAE,EAAE,SAAS;IACbT,WAAW,EAAEA,WAAW;IACxBU,UAAU,EAAE;MACVX,KAAK,EAAE1J,8BAA8B,CAACsK,SAAS,CAACZ,KAAK;IACvD;EACF,CAAC,CAAC;EAEF,MAAMgB,aAAa,GAAG,EAAE;EACxB,KAAK,IAAI5I,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC1B,MAAM6I,gBAAgB,GAAG,IAAI9K,8BAA8B,CAAC;MAC1DiK,gBAAgB,EAAE;QAChBC,SAAS,EAAE,IAAI,CAAC/H,cAAc,CAAC,CAAC,GAAGF,CAAC;MACtC;IACF,CAAC,CAAC;IACF,MAAM8I,iBAAiB,GACrB/K,8BAA8B,CAACoK,cAAc,CAACU,gBAAgB,CAAC;IACjED,aAAa,CAAC5I,CAAC,CAAC,GAAG,IAAI5B,gBAAgB,CAAC;MACtCiK,QAAQ,EAAES,iBAAiB;MAC3BR,EAAE,EAAE,SAAS;MACbT,WAAW,EAAEA,WAAW;MACxBU,UAAU,EAAE;QACVX,KAAK,EAAE1J,8BAA8B,CAACsK,SAAS,CAACZ,KAAK;MACvD;IACF,CAAC,CAAC;EACJ;EAEA,OAAO,IAAIrJ,SAAS,CAAC;IACnBwK,iBAAiB,EAAE,CACjBH,aAAa,CAAC,CAAC,CAAC,EAChBA,aAAa,CAAC,CAAC,CAAC,EAChBA,aAAa,CAAC,CAAC,CAAC,EAChBA,aAAa,CAAC,CAAC,CAAC,EAChBD,mBAAmB,EACnBP,gBAAgB,CACjB;IACDY,UAAU,EAAE,IAAI1K,0BAA0B,CAAC;MACzC2K,WAAW,EAAE,KAAK;MAClBC,IAAI,EAAE;IACR,CAAC,CAAC;IACFC,YAAY,EAAE;EAChB,CAAC,CAAC;AACJ,CAAC;AAED,eAAezK,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}