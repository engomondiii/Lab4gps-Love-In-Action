{"ast":null,"code":"import Uri from \"urijs\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defer from \"./defer.js\";\nimport defined from \"./defined.js\";\nimport Event from \"./Event.js\";\nimport Heap from \"./Heap.js\";\nimport isBlobUri from \"./isBlobUri.js\";\nimport isDataUri from \"./isDataUri.js\";\nimport RequestState from \"./RequestState.js\";\nfunction sortRequests(a, b) {\n  return a.priority - b.priority;\n}\nconst statistics = {\n  numberOfAttemptedRequests: 0,\n  numberOfActiveRequests: 0,\n  numberOfCancelledRequests: 0,\n  numberOfCancelledActiveRequests: 0,\n  numberOfFailedRequests: 0,\n  numberOfActiveRequestsEver: 0,\n  lastNumberOfActiveRequests: 0\n};\nlet priorityHeapLength = 20;\nconst requestHeap = new Heap({\n  comparator: sortRequests\n});\nrequestHeap.maximumLength = priorityHeapLength;\nrequestHeap.reserve(priorityHeapLength);\nconst activeRequests = [];\nlet numberOfActiveRequestsByServer = {};\nconst pageUri = typeof document !== \"undefined\" ? new Uri(document.location.href) : new Uri();\nconst requestCompletedEvent = new Event();\n\n/**\n * The request scheduler is used to track and constrain the number of active requests in order to prioritize incoming requests. The ability\n * to retain control over the number of requests in CesiumJS is important because due to events such as changes in the camera position,\n * a lot of new requests may be generated and a lot of in-flight requests may become redundant. The request scheduler manually constrains the\n * number of requests so that newer requests wait in a shorter queue and don't have to compete for bandwidth with requests that have expired.\n *\n * @namespace RequestScheduler\n *\n */\nfunction RequestScheduler() {}\n\n/**\n * The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.\n * @type {number}\n * @default 50\n */\nRequestScheduler.maximumRequests = 50;\n\n/**\n * The maximum number of simultaneous active requests per server. Un-throttled requests or servers specifically\n * listed in {@link requestsByServer} do not observe this limit.\n * @type {number}\n * @default 18\n */\nRequestScheduler.maximumRequestsPerServer = 18;\n\n/**\n * A per server key list of overrides to use for throttling instead of <code>maximumRequestsPerServer</code>.\n * Useful when streaming data from a known HTTP/2 or HTTP/3 server.\n * @type {object}\n *\n * @example\n * RequestScheduler.requestsByServer[\"myserver.com:443\"] = 18;\n *\n * @example\n * RequestScheduler.requestsByServer = {\n *   \"api.cesium.com:443\": 18,\n *   \"assets.cesium.com:443\": 18,\n * };\n */\nRequestScheduler.requestsByServer = {};\n\n/**\n * Specifies if the request scheduler should throttle incoming requests, or let the browser queue requests under its control.\n * @type {boolean}\n * @default true\n */\nRequestScheduler.throttleRequests = true;\n\n/**\n * When true, log statistics to the console every frame\n * @type {boolean}\n * @default false\n * @private\n */\nRequestScheduler.debugShowStatistics = false;\n\n/**\n * An event that's raised when a request is completed.  Event handlers are passed\n * the error object if the request fails.\n *\n * @type {Event}\n * @default Event()\n * @private\n */\nRequestScheduler.requestCompletedEvent = requestCompletedEvent;\nObject.defineProperties(RequestScheduler, {\n  /**\n   * Returns the statistics used by the request scheduler.\n   *\n   * @memberof RequestScheduler\n   *\n   * @type {object}\n   * @readonly\n   * @private\n   */\n  statistics: {\n    get: function () {\n      return statistics;\n    }\n  },\n  /**\n   * The maximum size of the priority heap. This limits the number of requests that are sorted by priority. Only applies to requests that are not yet active.\n   *\n   * @memberof RequestScheduler\n   *\n   * @type {number}\n   * @default 20\n   * @private\n   */\n  priorityHeapLength: {\n    get: function () {\n      return priorityHeapLength;\n    },\n    set: function (value) {\n      // If the new length shrinks the heap, need to cancel some of the requests.\n      // Since this value is not intended to be tweaked regularly it is fine to just cancel the high priority requests.\n      if (value < priorityHeapLength) {\n        while (requestHeap.length > value) {\n          const request = requestHeap.pop();\n          cancelRequest(request);\n        }\n      }\n      priorityHeapLength = value;\n      requestHeap.maximumLength = value;\n      requestHeap.reserve(value);\n    }\n  }\n});\nfunction updatePriority(request) {\n  if (defined(request.priorityFunction)) {\n    request.priority = request.priorityFunction();\n  }\n}\n\n/**\n * Check if there are open slots for a particular server key. If desiredRequests is greater than 1, this checks if the queue has room for scheduling multiple requests.\n * @param {string} serverKey The server key returned by {@link RequestScheduler.getServerKey}.\n * @param {number} [desiredRequests=1] How many requests the caller plans to request\n * @return {boolean} True if there are enough open slots for <code>desiredRequests</code> more requests.\n * @private\n */\nRequestScheduler.serverHasOpenSlots = function (serverKey, desiredRequests) {\n  desiredRequests = defaultValue(desiredRequests, 1);\n  const maxRequests = defaultValue(RequestScheduler.requestsByServer[serverKey], RequestScheduler.maximumRequestsPerServer);\n  const hasOpenSlotsServer = numberOfActiveRequestsByServer[serverKey] + desiredRequests <= maxRequests;\n  return hasOpenSlotsServer;\n};\n\n/**\n * Check if the priority heap has open slots, regardless of which server they\n * are from. This is used in {@link Multiple3DTileContent} for determining when\n * all requests can be scheduled\n * @param {number} desiredRequests The number of requests the caller intends to make\n * @return {boolean} <code>true</code> if the heap has enough available slots to meet the desiredRequests. <code>false</code> otherwise.\n *\n * @private\n */\nRequestScheduler.heapHasOpenSlots = function (desiredRequests) {\n  const hasOpenSlotsHeap = requestHeap.length + desiredRequests <= priorityHeapLength;\n  return hasOpenSlotsHeap;\n};\nfunction issueRequest(request) {\n  if (request.state === RequestState.UNISSUED) {\n    request.state = RequestState.ISSUED;\n    request.deferred = defer();\n  }\n  return request.deferred.promise;\n}\nfunction getRequestReceivedFunction(request) {\n  return function (results) {\n    if (request.state === RequestState.CANCELLED) {\n      // If the data request comes back but the request is cancelled, ignore it.\n      return;\n    }\n    // explicitly set to undefined to ensure GC of request response data. See #8843\n    const deferred = request.deferred;\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    requestCompletedEvent.raiseEvent();\n    request.state = RequestState.RECEIVED;\n    request.deferred = undefined;\n    deferred.resolve(results);\n  };\n}\nfunction getRequestFailedFunction(request) {\n  return function (error) {\n    if (request.state === RequestState.CANCELLED) {\n      // If the data request comes back but the request is cancelled, ignore it.\n      return;\n    }\n    ++statistics.numberOfFailedRequests;\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    requestCompletedEvent.raiseEvent(error);\n    request.state = RequestState.FAILED;\n    request.deferred.reject(error);\n  };\n}\nfunction startRequest(request) {\n  const promise = issueRequest(request);\n  request.state = RequestState.ACTIVE;\n  activeRequests.push(request);\n  ++statistics.numberOfActiveRequests;\n  ++statistics.numberOfActiveRequestsEver;\n  ++numberOfActiveRequestsByServer[request.serverKey];\n  request.requestFunction().then(getRequestReceivedFunction(request)).catch(getRequestFailedFunction(request));\n  return promise;\n}\nfunction cancelRequest(request) {\n  const active = request.state === RequestState.ACTIVE;\n  request.state = RequestState.CANCELLED;\n  ++statistics.numberOfCancelledRequests;\n  // check that deferred has not been cleared since cancelRequest can be called\n  // on a finished request, e.g. by clearForSpecs during tests\n  if (defined(request.deferred)) {\n    const deferred = request.deferred;\n    request.deferred = undefined;\n    deferred.reject();\n  }\n  if (active) {\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    ++statistics.numberOfCancelledActiveRequests;\n  }\n  if (defined(request.cancelFunction)) {\n    request.cancelFunction();\n  }\n}\n\n/**\n * Sort requests by priority and start requests.\n * @private\n */\nRequestScheduler.update = function () {\n  let i;\n  let request;\n\n  // Loop over all active requests. Cancelled, failed, or received requests are removed from the array to make room for new requests.\n  let removeCount = 0;\n  const activeLength = activeRequests.length;\n  for (i = 0; i < activeLength; ++i) {\n    request = activeRequests[i];\n    if (request.cancelled) {\n      // Request was explicitly cancelled\n      cancelRequest(request);\n    }\n    if (request.state !== RequestState.ACTIVE) {\n      // Request is no longer active, remove from array\n      ++removeCount;\n      continue;\n    }\n    if (removeCount > 0) {\n      // Shift back to fill in vacated slots from completed requests\n      activeRequests[i - removeCount] = request;\n    }\n  }\n  activeRequests.length -= removeCount;\n\n  // Update priority of issued requests and resort the heap\n  const issuedRequests = requestHeap.internalArray;\n  const issuedLength = requestHeap.length;\n  for (i = 0; i < issuedLength; ++i) {\n    updatePriority(issuedRequests[i]);\n  }\n  requestHeap.resort();\n\n  // Get the number of open slots and fill with the highest priority requests.\n  // Un-throttled requests are automatically added to activeRequests, so activeRequests.length may exceed maximumRequests\n  const openSlots = Math.max(RequestScheduler.maximumRequests - activeRequests.length, 0);\n  let filledSlots = 0;\n  while (filledSlots < openSlots && requestHeap.length > 0) {\n    // Loop until all open slots are filled or the heap becomes empty\n    request = requestHeap.pop();\n    if (request.cancelled) {\n      // Request was explicitly cancelled\n      cancelRequest(request);\n      continue;\n    }\n    if (request.throttleByServer && !RequestScheduler.serverHasOpenSlots(request.serverKey)) {\n      // Open slots are available, but the request is throttled by its server. Cancel and try again later.\n      cancelRequest(request);\n      continue;\n    }\n    startRequest(request);\n    ++filledSlots;\n  }\n  updateStatistics();\n};\n\n/**\n * Get the server key from a given url.\n *\n * @param {string} url The url.\n * @returns {string} The server key.\n * @private\n */\nRequestScheduler.getServerKey = function (url) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"url\", url);\n  //>>includeEnd('debug');\n\n  let uri = new Uri(url);\n  if (uri.scheme() === \"\") {\n    uri = uri.absoluteTo(pageUri);\n    uri.normalize();\n  }\n  let serverKey = uri.authority();\n  if (!/:/.test(serverKey)) {\n    // If the authority does not contain a port number, add port 443 for https or port 80 for http\n    serverKey = `${serverKey}:${uri.scheme() === \"https\" ? \"443\" : \"80\"}`;\n  }\n  const length = numberOfActiveRequestsByServer[serverKey];\n  if (!defined(length)) {\n    numberOfActiveRequestsByServer[serverKey] = 0;\n  }\n  return serverKey;\n};\n\n/**\n * Issue a request. If request.throttle is false, the request is sent immediately. Otherwise the request will be\n * queued and sorted by priority before being sent.\n *\n * @param {Request} request The request object.\n *\n * @returns {Promise|undefined} A Promise for the requested data, or undefined if this request does not have high enough priority to be issued.\n *\n * @private\n */\nRequestScheduler.request = function (request) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"request\", request);\n  Check.typeOf.string(\"request.url\", request.url);\n  Check.typeOf.func(\"request.requestFunction\", request.requestFunction);\n  //>>includeEnd('debug');\n\n  if (isDataUri(request.url) || isBlobUri(request.url)) {\n    requestCompletedEvent.raiseEvent();\n    request.state = RequestState.RECEIVED;\n    return request.requestFunction();\n  }\n  ++statistics.numberOfAttemptedRequests;\n  if (!defined(request.serverKey)) {\n    request.serverKey = RequestScheduler.getServerKey(request.url);\n  }\n  if (RequestScheduler.throttleRequests && request.throttleByServer && !RequestScheduler.serverHasOpenSlots(request.serverKey)) {\n    // Server is saturated. Try again later.\n    return undefined;\n  }\n  if (!RequestScheduler.throttleRequests || !request.throttle) {\n    return startRequest(request);\n  }\n  if (activeRequests.length >= RequestScheduler.maximumRequests) {\n    // Active requests are saturated. Try again later.\n    return undefined;\n  }\n\n  // Insert into the priority heap and see if a request was bumped off. If this request is the lowest\n  // priority it will be returned.\n  updatePriority(request);\n  const removedRequest = requestHeap.insert(request);\n  if (defined(removedRequest)) {\n    if (removedRequest === request) {\n      // Request does not have high enough priority to be issued\n      return undefined;\n    }\n    // A previously issued request has been bumped off the priority heap, so cancel it\n    cancelRequest(removedRequest);\n  }\n  return issueRequest(request);\n};\nfunction updateStatistics() {\n  if (!RequestScheduler.debugShowStatistics) {\n    return;\n  }\n  if (statistics.numberOfActiveRequests === 0 && statistics.lastNumberOfActiveRequests > 0) {\n    if (statistics.numberOfAttemptedRequests > 0) {\n      console.log(`Number of attempted requests: ${statistics.numberOfAttemptedRequests}`);\n      statistics.numberOfAttemptedRequests = 0;\n    }\n    if (statistics.numberOfCancelledRequests > 0) {\n      console.log(`Number of cancelled requests: ${statistics.numberOfCancelledRequests}`);\n      statistics.numberOfCancelledRequests = 0;\n    }\n    if (statistics.numberOfCancelledActiveRequests > 0) {\n      console.log(`Number of cancelled active requests: ${statistics.numberOfCancelledActiveRequests}`);\n      statistics.numberOfCancelledActiveRequests = 0;\n    }\n    if (statistics.numberOfFailedRequests > 0) {\n      console.log(`Number of failed requests: ${statistics.numberOfFailedRequests}`);\n      statistics.numberOfFailedRequests = 0;\n    }\n  }\n  statistics.lastNumberOfActiveRequests = statistics.numberOfActiveRequests;\n}\n\n/**\n * For testing only. Clears any requests that may not have completed from previous tests.\n *\n * @private\n */\nRequestScheduler.clearForSpecs = function () {\n  while (requestHeap.length > 0) {\n    const request = requestHeap.pop();\n    cancelRequest(request);\n  }\n  const length = activeRequests.length;\n  for (let i = 0; i < length; ++i) {\n    cancelRequest(activeRequests[i]);\n  }\n  activeRequests.length = 0;\n  numberOfActiveRequestsByServer = {};\n\n  // Clear stats\n  statistics.numberOfAttemptedRequests = 0;\n  statistics.numberOfActiveRequests = 0;\n  statistics.numberOfCancelledRequests = 0;\n  statistics.numberOfCancelledActiveRequests = 0;\n  statistics.numberOfFailedRequests = 0;\n  statistics.numberOfActiveRequestsEver = 0;\n  statistics.lastNumberOfActiveRequests = 0;\n};\n\n/**\n * For testing only.\n *\n * @private\n */\nRequestScheduler.numberOfActiveRequestsByServer = function (serverKey) {\n  return numberOfActiveRequestsByServer[serverKey];\n};\n\n/**\n * For testing only.\n *\n * @private\n */\nRequestScheduler.requestHeap = requestHeap;\nexport default RequestScheduler;","map":{"version":3,"names":["Uri","Check","defaultValue","defer","defined","Event","Heap","isBlobUri","isDataUri","RequestState","sortRequests","a","b","priority","statistics","numberOfAttemptedRequests","numberOfActiveRequests","numberOfCancelledRequests","numberOfCancelledActiveRequests","numberOfFailedRequests","numberOfActiveRequestsEver","lastNumberOfActiveRequests","priorityHeapLength","requestHeap","comparator","maximumLength","reserve","activeRequests","numberOfActiveRequestsByServer","pageUri","document","location","href","requestCompletedEvent","RequestScheduler","maximumRequests","maximumRequestsPerServer","requestsByServer","throttleRequests","debugShowStatistics","Object","defineProperties","get","set","value","length","request","pop","cancelRequest","updatePriority","priorityFunction","serverHasOpenSlots","serverKey","desiredRequests","maxRequests","hasOpenSlotsServer","heapHasOpenSlots","hasOpenSlotsHeap","issueRequest","state","UNISSUED","ISSUED","deferred","promise","getRequestReceivedFunction","results","CANCELLED","raiseEvent","RECEIVED","undefined","resolve","getRequestFailedFunction","error","FAILED","reject","startRequest","ACTIVE","push","requestFunction","then","catch","active","cancelFunction","update","i","removeCount","activeLength","cancelled","issuedRequests","internalArray","issuedLength","resort","openSlots","Math","max","filledSlots","throttleByServer","updateStatistics","getServerKey","url","typeOf","string","uri","scheme","absoluteTo","normalize","authority","test","object","func","throttle","removedRequest","insert","console","log","clearForSpecs"],"sources":["/Users/mac/Desktop/IWL_Fresh_Start/Lab4gps-Love-In-Action/node_modules/@cesium/engine/Source/Core/RequestScheduler.js"],"sourcesContent":["import Uri from \"urijs\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defer from \"./defer.js\";\nimport defined from \"./defined.js\";\nimport Event from \"./Event.js\";\nimport Heap from \"./Heap.js\";\nimport isBlobUri from \"./isBlobUri.js\";\nimport isDataUri from \"./isDataUri.js\";\nimport RequestState from \"./RequestState.js\";\n\nfunction sortRequests(a, b) {\n  return a.priority - b.priority;\n}\n\nconst statistics = {\n  numberOfAttemptedRequests: 0,\n  numberOfActiveRequests: 0,\n  numberOfCancelledRequests: 0,\n  numberOfCancelledActiveRequests: 0,\n  numberOfFailedRequests: 0,\n  numberOfActiveRequestsEver: 0,\n  lastNumberOfActiveRequests: 0,\n};\n\nlet priorityHeapLength = 20;\nconst requestHeap = new Heap({\n  comparator: sortRequests,\n});\nrequestHeap.maximumLength = priorityHeapLength;\nrequestHeap.reserve(priorityHeapLength);\n\nconst activeRequests = [];\nlet numberOfActiveRequestsByServer = {};\n\nconst pageUri =\n  typeof document !== \"undefined\" ? new Uri(document.location.href) : new Uri();\n\nconst requestCompletedEvent = new Event();\n\n/**\n * The request scheduler is used to track and constrain the number of active requests in order to prioritize incoming requests. The ability\n * to retain control over the number of requests in CesiumJS is important because due to events such as changes in the camera position,\n * a lot of new requests may be generated and a lot of in-flight requests may become redundant. The request scheduler manually constrains the\n * number of requests so that newer requests wait in a shorter queue and don't have to compete for bandwidth with requests that have expired.\n *\n * @namespace RequestScheduler\n *\n */\nfunction RequestScheduler() {}\n\n/**\n * The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.\n * @type {number}\n * @default 50\n */\nRequestScheduler.maximumRequests = 50;\n\n/**\n * The maximum number of simultaneous active requests per server. Un-throttled requests or servers specifically\n * listed in {@link requestsByServer} do not observe this limit.\n * @type {number}\n * @default 18\n */\nRequestScheduler.maximumRequestsPerServer = 18;\n\n/**\n * A per server key list of overrides to use for throttling instead of <code>maximumRequestsPerServer</code>.\n * Useful when streaming data from a known HTTP/2 or HTTP/3 server.\n * @type {object}\n *\n * @example\n * RequestScheduler.requestsByServer[\"myserver.com:443\"] = 18;\n *\n * @example\n * RequestScheduler.requestsByServer = {\n *   \"api.cesium.com:443\": 18,\n *   \"assets.cesium.com:443\": 18,\n * };\n */\nRequestScheduler.requestsByServer = {};\n\n/**\n * Specifies if the request scheduler should throttle incoming requests, or let the browser queue requests under its control.\n * @type {boolean}\n * @default true\n */\nRequestScheduler.throttleRequests = true;\n\n/**\n * When true, log statistics to the console every frame\n * @type {boolean}\n * @default false\n * @private\n */\nRequestScheduler.debugShowStatistics = false;\n\n/**\n * An event that's raised when a request is completed.  Event handlers are passed\n * the error object if the request fails.\n *\n * @type {Event}\n * @default Event()\n * @private\n */\nRequestScheduler.requestCompletedEvent = requestCompletedEvent;\n\nObject.defineProperties(RequestScheduler, {\n  /**\n   * Returns the statistics used by the request scheduler.\n   *\n   * @memberof RequestScheduler\n   *\n   * @type {object}\n   * @readonly\n   * @private\n   */\n  statistics: {\n    get: function () {\n      return statistics;\n    },\n  },\n\n  /**\n   * The maximum size of the priority heap. This limits the number of requests that are sorted by priority. Only applies to requests that are not yet active.\n   *\n   * @memberof RequestScheduler\n   *\n   * @type {number}\n   * @default 20\n   * @private\n   */\n  priorityHeapLength: {\n    get: function () {\n      return priorityHeapLength;\n    },\n    set: function (value) {\n      // If the new length shrinks the heap, need to cancel some of the requests.\n      // Since this value is not intended to be tweaked regularly it is fine to just cancel the high priority requests.\n      if (value < priorityHeapLength) {\n        while (requestHeap.length > value) {\n          const request = requestHeap.pop();\n          cancelRequest(request);\n        }\n      }\n      priorityHeapLength = value;\n      requestHeap.maximumLength = value;\n      requestHeap.reserve(value);\n    },\n  },\n});\n\nfunction updatePriority(request) {\n  if (defined(request.priorityFunction)) {\n    request.priority = request.priorityFunction();\n  }\n}\n\n/**\n * Check if there are open slots for a particular server key. If desiredRequests is greater than 1, this checks if the queue has room for scheduling multiple requests.\n * @param {string} serverKey The server key returned by {@link RequestScheduler.getServerKey}.\n * @param {number} [desiredRequests=1] How many requests the caller plans to request\n * @return {boolean} True if there are enough open slots for <code>desiredRequests</code> more requests.\n * @private\n */\nRequestScheduler.serverHasOpenSlots = function (serverKey, desiredRequests) {\n  desiredRequests = defaultValue(desiredRequests, 1);\n\n  const maxRequests = defaultValue(\n    RequestScheduler.requestsByServer[serverKey],\n    RequestScheduler.maximumRequestsPerServer,\n  );\n  const hasOpenSlotsServer =\n    numberOfActiveRequestsByServer[serverKey] + desiredRequests <= maxRequests;\n\n  return hasOpenSlotsServer;\n};\n\n/**\n * Check if the priority heap has open slots, regardless of which server they\n * are from. This is used in {@link Multiple3DTileContent} for determining when\n * all requests can be scheduled\n * @param {number} desiredRequests The number of requests the caller intends to make\n * @return {boolean} <code>true</code> if the heap has enough available slots to meet the desiredRequests. <code>false</code> otherwise.\n *\n * @private\n */\nRequestScheduler.heapHasOpenSlots = function (desiredRequests) {\n  const hasOpenSlotsHeap =\n    requestHeap.length + desiredRequests <= priorityHeapLength;\n  return hasOpenSlotsHeap;\n};\n\nfunction issueRequest(request) {\n  if (request.state === RequestState.UNISSUED) {\n    request.state = RequestState.ISSUED;\n    request.deferred = defer();\n  }\n  return request.deferred.promise;\n}\n\nfunction getRequestReceivedFunction(request) {\n  return function (results) {\n    if (request.state === RequestState.CANCELLED) {\n      // If the data request comes back but the request is cancelled, ignore it.\n      return;\n    }\n    // explicitly set to undefined to ensure GC of request response data. See #8843\n    const deferred = request.deferred;\n\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    requestCompletedEvent.raiseEvent();\n    request.state = RequestState.RECEIVED;\n    request.deferred = undefined;\n\n    deferred.resolve(results);\n  };\n}\n\nfunction getRequestFailedFunction(request) {\n  return function (error) {\n    if (request.state === RequestState.CANCELLED) {\n      // If the data request comes back but the request is cancelled, ignore it.\n      return;\n    }\n    ++statistics.numberOfFailedRequests;\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    requestCompletedEvent.raiseEvent(error);\n    request.state = RequestState.FAILED;\n    request.deferred.reject(error);\n  };\n}\n\nfunction startRequest(request) {\n  const promise = issueRequest(request);\n  request.state = RequestState.ACTIVE;\n  activeRequests.push(request);\n  ++statistics.numberOfActiveRequests;\n  ++statistics.numberOfActiveRequestsEver;\n  ++numberOfActiveRequestsByServer[request.serverKey];\n  request\n    .requestFunction()\n    .then(getRequestReceivedFunction(request))\n    .catch(getRequestFailedFunction(request));\n  return promise;\n}\n\nfunction cancelRequest(request) {\n  const active = request.state === RequestState.ACTIVE;\n  request.state = RequestState.CANCELLED;\n  ++statistics.numberOfCancelledRequests;\n  // check that deferred has not been cleared since cancelRequest can be called\n  // on a finished request, e.g. by clearForSpecs during tests\n  if (defined(request.deferred)) {\n    const deferred = request.deferred;\n    request.deferred = undefined;\n    deferred.reject();\n  }\n\n  if (active) {\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    ++statistics.numberOfCancelledActiveRequests;\n  }\n\n  if (defined(request.cancelFunction)) {\n    request.cancelFunction();\n  }\n}\n\n/**\n * Sort requests by priority and start requests.\n * @private\n */\nRequestScheduler.update = function () {\n  let i;\n  let request;\n\n  // Loop over all active requests. Cancelled, failed, or received requests are removed from the array to make room for new requests.\n  let removeCount = 0;\n  const activeLength = activeRequests.length;\n  for (i = 0; i < activeLength; ++i) {\n    request = activeRequests[i];\n    if (request.cancelled) {\n      // Request was explicitly cancelled\n      cancelRequest(request);\n    }\n    if (request.state !== RequestState.ACTIVE) {\n      // Request is no longer active, remove from array\n      ++removeCount;\n      continue;\n    }\n    if (removeCount > 0) {\n      // Shift back to fill in vacated slots from completed requests\n      activeRequests[i - removeCount] = request;\n    }\n  }\n  activeRequests.length -= removeCount;\n\n  // Update priority of issued requests and resort the heap\n  const issuedRequests = requestHeap.internalArray;\n  const issuedLength = requestHeap.length;\n  for (i = 0; i < issuedLength; ++i) {\n    updatePriority(issuedRequests[i]);\n  }\n  requestHeap.resort();\n\n  // Get the number of open slots and fill with the highest priority requests.\n  // Un-throttled requests are automatically added to activeRequests, so activeRequests.length may exceed maximumRequests\n  const openSlots = Math.max(\n    RequestScheduler.maximumRequests - activeRequests.length,\n    0,\n  );\n  let filledSlots = 0;\n  while (filledSlots < openSlots && requestHeap.length > 0) {\n    // Loop until all open slots are filled or the heap becomes empty\n    request = requestHeap.pop();\n    if (request.cancelled) {\n      // Request was explicitly cancelled\n      cancelRequest(request);\n      continue;\n    }\n\n    if (\n      request.throttleByServer &&\n      !RequestScheduler.serverHasOpenSlots(request.serverKey)\n    ) {\n      // Open slots are available, but the request is throttled by its server. Cancel and try again later.\n      cancelRequest(request);\n      continue;\n    }\n\n    startRequest(request);\n    ++filledSlots;\n  }\n\n  updateStatistics();\n};\n\n/**\n * Get the server key from a given url.\n *\n * @param {string} url The url.\n * @returns {string} The server key.\n * @private\n */\nRequestScheduler.getServerKey = function (url) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"url\", url);\n  //>>includeEnd('debug');\n\n  let uri = new Uri(url);\n  if (uri.scheme() === \"\") {\n    uri = uri.absoluteTo(pageUri);\n    uri.normalize();\n  }\n\n  let serverKey = uri.authority();\n  if (!/:/.test(serverKey)) {\n    // If the authority does not contain a port number, add port 443 for https or port 80 for http\n    serverKey = `${serverKey}:${uri.scheme() === \"https\" ? \"443\" : \"80\"}`;\n  }\n\n  const length = numberOfActiveRequestsByServer[serverKey];\n  if (!defined(length)) {\n    numberOfActiveRequestsByServer[serverKey] = 0;\n  }\n\n  return serverKey;\n};\n\n/**\n * Issue a request. If request.throttle is false, the request is sent immediately. Otherwise the request will be\n * queued and sorted by priority before being sent.\n *\n * @param {Request} request The request object.\n *\n * @returns {Promise|undefined} A Promise for the requested data, or undefined if this request does not have high enough priority to be issued.\n *\n * @private\n */\nRequestScheduler.request = function (request) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"request\", request);\n  Check.typeOf.string(\"request.url\", request.url);\n  Check.typeOf.func(\"request.requestFunction\", request.requestFunction);\n  //>>includeEnd('debug');\n\n  if (isDataUri(request.url) || isBlobUri(request.url)) {\n    requestCompletedEvent.raiseEvent();\n    request.state = RequestState.RECEIVED;\n    return request.requestFunction();\n  }\n\n  ++statistics.numberOfAttemptedRequests;\n\n  if (!defined(request.serverKey)) {\n    request.serverKey = RequestScheduler.getServerKey(request.url);\n  }\n\n  if (\n    RequestScheduler.throttleRequests &&\n    request.throttleByServer &&\n    !RequestScheduler.serverHasOpenSlots(request.serverKey)\n  ) {\n    // Server is saturated. Try again later.\n    return undefined;\n  }\n\n  if (!RequestScheduler.throttleRequests || !request.throttle) {\n    return startRequest(request);\n  }\n\n  if (activeRequests.length >= RequestScheduler.maximumRequests) {\n    // Active requests are saturated. Try again later.\n    return undefined;\n  }\n\n  // Insert into the priority heap and see if a request was bumped off. If this request is the lowest\n  // priority it will be returned.\n  updatePriority(request);\n  const removedRequest = requestHeap.insert(request);\n\n  if (defined(removedRequest)) {\n    if (removedRequest === request) {\n      // Request does not have high enough priority to be issued\n      return undefined;\n    }\n    // A previously issued request has been bumped off the priority heap, so cancel it\n    cancelRequest(removedRequest);\n  }\n\n  return issueRequest(request);\n};\n\nfunction updateStatistics() {\n  if (!RequestScheduler.debugShowStatistics) {\n    return;\n  }\n\n  if (\n    statistics.numberOfActiveRequests === 0 &&\n    statistics.lastNumberOfActiveRequests > 0\n  ) {\n    if (statistics.numberOfAttemptedRequests > 0) {\n      console.log(\n        `Number of attempted requests: ${statistics.numberOfAttemptedRequests}`,\n      );\n      statistics.numberOfAttemptedRequests = 0;\n    }\n\n    if (statistics.numberOfCancelledRequests > 0) {\n      console.log(\n        `Number of cancelled requests: ${statistics.numberOfCancelledRequests}`,\n      );\n      statistics.numberOfCancelledRequests = 0;\n    }\n\n    if (statistics.numberOfCancelledActiveRequests > 0) {\n      console.log(\n        `Number of cancelled active requests: ${statistics.numberOfCancelledActiveRequests}`,\n      );\n      statistics.numberOfCancelledActiveRequests = 0;\n    }\n\n    if (statistics.numberOfFailedRequests > 0) {\n      console.log(\n        `Number of failed requests: ${statistics.numberOfFailedRequests}`,\n      );\n      statistics.numberOfFailedRequests = 0;\n    }\n  }\n\n  statistics.lastNumberOfActiveRequests = statistics.numberOfActiveRequests;\n}\n\n/**\n * For testing only. Clears any requests that may not have completed from previous tests.\n *\n * @private\n */\nRequestScheduler.clearForSpecs = function () {\n  while (requestHeap.length > 0) {\n    const request = requestHeap.pop();\n    cancelRequest(request);\n  }\n  const length = activeRequests.length;\n  for (let i = 0; i < length; ++i) {\n    cancelRequest(activeRequests[i]);\n  }\n  activeRequests.length = 0;\n  numberOfActiveRequestsByServer = {};\n\n  // Clear stats\n  statistics.numberOfAttemptedRequests = 0;\n  statistics.numberOfActiveRequests = 0;\n  statistics.numberOfCancelledRequests = 0;\n  statistics.numberOfCancelledActiveRequests = 0;\n  statistics.numberOfFailedRequests = 0;\n  statistics.numberOfActiveRequestsEver = 0;\n  statistics.lastNumberOfActiveRequests = 0;\n};\n\n/**\n * For testing only.\n *\n * @private\n */\nRequestScheduler.numberOfActiveRequestsByServer = function (serverKey) {\n  return numberOfActiveRequestsByServer[serverKey];\n};\n\n/**\n * For testing only.\n *\n * @private\n */\nRequestScheduler.requestHeap = requestHeap;\nexport default RequestScheduler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}